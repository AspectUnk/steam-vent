// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `networkbasetypes.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgVector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVector {
    // message fields
    // @@protoc_insertion_point(field:CMsgVector.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.z)
    pub z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.w)
    pub w: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVector.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVector {
    fn default() -> &'a CMsgVector {
        <CMsgVector as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgVector {
    pub fn new() -> CMsgVector {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    // optional float w = 4;

    pub fn w(&self) -> f32 {
        self.w.unwrap_or(0.)
    }

    pub fn clear_w(&mut self) {
        self.w = ::std::option::Option::None;
    }

    pub fn has_w(&self) -> bool {
        self.w.is_some()
    }

    // Param is passed by value, moved
    pub fn set_w(&mut self, v: f32) {
        self.w = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgVector {
    const NAME: &'static str = "CMsgVector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.w = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.w {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.w {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVector {
        CMsgVector::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.w = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVector {
        static instance: CMsgVector = CMsgVector {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            w: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgVector2D)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVector2D {
    // message fields
    // @@protoc_insertion_point(field:CMsgVector2D.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector2D.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVector2D.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVector2D {
    fn default() -> &'a CMsgVector2D {
        <CMsgVector2D as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgVector2D {
    pub fn new() -> CMsgVector2D {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgVector2D {
    const NAME: &'static str = "CMsgVector2D";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVector2D {
        CMsgVector2D::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVector2D {
        static instance: CMsgVector2D = CMsgVector2D {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQAngle {
    // message fields
    // @@protoc_insertion_point(field:CMsgQAngle.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQAngle.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQAngle.z)
    pub z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQAngle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQAngle {
    fn default() -> &'a CMsgQAngle {
        <CMsgQAngle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQAngle {
    pub fn new() -> CMsgQAngle {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQAngle {
    const NAME: &'static str = "CMsgQAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQAngle {
        CMsgQAngle::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQAngle {
        static instance: CMsgQAngle = CMsgQAngle {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQuaternion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuaternion {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuaternion.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuaternion.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuaternion.z)
    pub z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuaternion.w)
    pub w: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuaternion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuaternion {
    fn default() -> &'a CMsgQuaternion {
        <CMsgQuaternion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuaternion {
    pub fn new() -> CMsgQuaternion {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    // optional float w = 4;

    pub fn w(&self) -> f32 {
        self.w.unwrap_or(0.)
    }

    pub fn clear_w(&mut self) {
        self.w = ::std::option::Option::None;
    }

    pub fn has_w(&self) -> bool {
        self.w.is_some()
    }

    // Param is passed by value, moved
    pub fn set_w(&mut self, v: f32) {
        self.w = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuaternion {
    const NAME: &'static str = "CMsgQuaternion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.w = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.w {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.w {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuaternion {
        CMsgQuaternion::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.w = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuaternion {
        static instance: CMsgQuaternion = CMsgQuaternion {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            w: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTransform)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTransform {
    // message fields
    // @@protoc_insertion_point(field:CMsgTransform.position)
    pub position: ::steam_vent_proto_common::protobuf::MessageField<CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTransform.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransform.orientation)
    pub orientation: ::steam_vent_proto_common::protobuf::MessageField<CMsgQuaternion>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTransform.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTransform {
    fn default() -> &'a CMsgTransform {
        <CMsgTransform as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTransform {
    pub fn new() -> CMsgTransform {
        ::std::default::Default::default()
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTransform {
    const NAME: &'static str = "CMsgTransform";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.orientation)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.orientation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.orientation.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTransform {
        CMsgTransform::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.scale = ::std::option::Option::None;
        self.orientation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTransform {
        static instance: CMsgTransform = CMsgTransform {
            position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            orientation: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRGBA)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRGBA {
    // message fields
    // @@protoc_insertion_point(field:CMsgRGBA.r)
    pub r: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.g)
    pub g: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.b)
    pub b: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.a)
    pub a: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRGBA.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRGBA {
    fn default() -> &'a CMsgRGBA {
        <CMsgRGBA as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRGBA {
    pub fn new() -> CMsgRGBA {
        ::std::default::Default::default()
    }

    // optional int32 r = 1;

    pub fn r(&self) -> i32 {
        self.r.unwrap_or(0)
    }

    pub fn clear_r(&mut self) {
        self.r = ::std::option::Option::None;
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: i32) {
        self.r = ::std::option::Option::Some(v);
    }

    // optional int32 g = 2;

    pub fn g(&self) -> i32 {
        self.g.unwrap_or(0)
    }

    pub fn clear_g(&mut self) {
        self.g = ::std::option::Option::None;
    }

    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: i32) {
        self.g = ::std::option::Option::Some(v);
    }

    // optional int32 b = 3;

    pub fn b(&self) -> i32 {
        self.b.unwrap_or(0)
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: i32) {
        self.b = ::std::option::Option::Some(v);
    }

    // optional int32 a = 4;

    pub fn a(&self) -> i32 {
        self.a.unwrap_or(0)
    }

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: i32) {
        self.a = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRGBA {
    const NAME: &'static str = "CMsgRGBA";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.r = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.g = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.b = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.a = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.g {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.b {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.a {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.r {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.g {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.b {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.a {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRGBA {
        CMsgRGBA::new()
    }

    fn clear(&mut self) {
        self.r = ::std::option::Option::None;
        self.g = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.a = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRGBA {
        static instance: CMsgRGBA = CMsgRGBA {
            r: ::std::option::Option::None,
            g: ::std::option::Option::None,
            b: ::std::option::Option::None,
            a: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.userid)
    pub userid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.fakeplayer)
    pub fakeplayer: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.ishltv)
    pub ishltv: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerInfo {
    fn default() -> &'a CMsgPlayerInfo {
        <CMsgPlayerInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerInfo {
    pub fn new() -> CMsgPlayerInfo {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 xuid = 2;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 userid = 3;

    pub fn userid(&self) -> i32 {
        self.userid.unwrap_or(0)
    }

    pub fn clear_userid(&mut self) {
        self.userid = ::std::option::Option::None;
    }

    pub fn has_userid(&self) -> bool {
        self.userid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userid(&mut self, v: i32) {
        self.userid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool fakeplayer = 5;

    pub fn fakeplayer(&self) -> bool {
        self.fakeplayer.unwrap_or(false)
    }

    pub fn clear_fakeplayer(&mut self) {
        self.fakeplayer = ::std::option::Option::None;
    }

    pub fn has_fakeplayer(&self) -> bool {
        self.fakeplayer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fakeplayer(&mut self, v: bool) {
        self.fakeplayer = ::std::option::Option::Some(v);
    }

    // optional bool ishltv = 6;

    pub fn ishltv(&self) -> bool {
        self.ishltv.unwrap_or(false)
    }

    pub fn clear_ishltv(&mut self) {
        self.ishltv = ::std::option::Option::None;
    }

    pub fn has_ishltv(&self) -> bool {
        self.ishltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ishltv(&mut self, v: bool) {
        self.ishltv = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerInfo {
    const NAME: &'static str = "CMsgPlayerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.userid = ::std::option::Option::Some(is.read_int32()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.fakeplayer = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.ishltv = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.userid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.fakeplayer {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ishltv {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.userid {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.fakeplayer {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.ishltv {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerInfo {
        CMsgPlayerInfo::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.userid = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.fakeplayer = ::std::option::Option::None;
        self.ishltv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerInfo {
        static instance: CMsgPlayerInfo = CMsgPlayerInfo {
            name: ::std::option::Option::None,
            xuid: ::std::option::Option::None,
            userid: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            fakeplayer: ::std::option::Option::None,
            ishltv: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEntityMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMsg {
    // message fields
    // @@protoc_insertion_point(field:CEntityMsg.target_entity)
    pub target_entity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMsg {
    fn default() -> &'a CEntityMsg {
        <CEntityMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEntityMsg {
    pub fn new() -> CEntityMsg {
        ::std::default::Default::default()
    }

    // optional uint32 target_entity = 1;

    pub fn target_entity(&self) -> u32 {
        self.target_entity.unwrap_or(16777215u32)
    }

    pub fn clear_target_entity(&mut self) {
        self.target_entity = ::std::option::Option::None;
    }

    pub fn has_target_entity(&self) -> bool {
        self.target_entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entity(&mut self, v: u32) {
        self.target_entity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEntityMsg {
    const NAME: &'static str = "CEntityMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entity {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMsg {
        CEntityMsg::new()
    }

    fn clear(&mut self) {
        self.target_entity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMsg {
        static instance: CEntityMsg = CEntityMsg {
            target_entity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsg_CVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg_CVars {
    // message fields
    // @@protoc_insertion_point(field:CMsg_CVars.cvars)
    pub cvars: ::std::vec::Vec<cmsg_cvars::CVar>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg_CVars.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg_CVars {
    fn default() -> &'a CMsg_CVars {
        <CMsg_CVars as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsg_CVars {
    pub fn new() -> CMsg_CVars {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsg_CVars {
    const NAME: &'static str = "CMsg_CVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cvars.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cvars {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.cvars {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg_CVars {
        CMsg_CVars::new()
    }

    fn clear(&mut self) {
        self.cvars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg_CVars {
        static instance: CMsg_CVars = CMsg_CVars {
            cvars: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsg_CVars`
pub mod cmsg_cvars {
    // @@protoc_insertion_point(message:CMsg_CVars.CVar)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CVar {
        // message fields
        // @@protoc_insertion_point(field:CMsg_CVars.CVar.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsg_CVars.CVar.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg_CVars.CVar.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CVar {
        fn default() -> &'a CVar {
            <CVar as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CVar {
        pub fn new() -> CVar {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CVar {
        const NAME: &'static str = "CVar";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CVar {
            CVar::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CVar {
            static instance: CVar = CVar {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CNETMsg_NOP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_NOP {
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_NOP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_NOP {
    fn default() -> &'a CNETMsg_NOP {
        <CNETMsg_NOP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_NOP {
    pub fn new() -> CNETMsg_NOP {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_NOP {
    const NAME: &'static str = "CNETMsg_NOP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_NOP {
        CNETMsg_NOP::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_NOP {
        static instance: CNETMsg_NOP = CNETMsg_NOP {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_SplitScreenUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SplitScreenUser {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SplitScreenUser.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SplitScreenUser.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SplitScreenUser {
    fn default() -> &'a CNETMsg_SplitScreenUser {
        <CNETMsg_SplitScreenUser as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SplitScreenUser {
    pub fn new() -> CNETMsg_SplitScreenUser {
        ::std::default::Default::default()
    }

    // optional int32 slot = 1;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SplitScreenUser {
    const NAME: &'static str = "CNETMsg_SplitScreenUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.slot {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SplitScreenUser {
        CNETMsg_SplitScreenUser::new()
    }

    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SplitScreenUser {
        static instance: CNETMsg_SplitScreenUser = CNETMsg_SplitScreenUser {
            slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_Tick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_Tick {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_Tick.tick)
    pub tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_frametime)
    pub host_frametime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_frametime_std_deviation)
    pub host_frametime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_computationtime)
    pub host_computationtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_computationtime_std_deviation)
    pub host_computationtime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_framestarttime_std_deviation)
    pub host_framestarttime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_loss)
    pub host_loss: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_unfiltered_frametime)
    pub host_unfiltered_frametime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.hltv_replay_flags)
    pub hltv_replay_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.expected_long_tick)
    pub expected_long_tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.expected_long_tick_reason)
    pub expected_long_tick_reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_Tick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_Tick {
    fn default() -> &'a CNETMsg_Tick {
        <CNETMsg_Tick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_Tick {
    pub fn new() -> CNETMsg_Tick {
        ::std::default::Default::default()
    }

    // optional uint32 tick = 1;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional uint32 host_frametime = 2;

    pub fn host_frametime(&self) -> u32 {
        self.host_frametime.unwrap_or(0)
    }

    pub fn clear_host_frametime(&mut self) {
        self.host_frametime = ::std::option::Option::None;
    }

    pub fn has_host_frametime(&self) -> bool {
        self.host_frametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_frametime(&mut self, v: u32) {
        self.host_frametime = ::std::option::Option::Some(v);
    }

    // optional uint32 host_frametime_std_deviation = 3;

    pub fn host_frametime_std_deviation(&self) -> u32 {
        self.host_frametime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_frametime_std_deviation(&mut self) {
        self.host_frametime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_frametime_std_deviation(&self) -> bool {
        self.host_frametime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_frametime_std_deviation(&mut self, v: u32) {
        self.host_frametime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 host_computationtime = 4;

    pub fn host_computationtime(&self) -> u32 {
        self.host_computationtime.unwrap_or(0)
    }

    pub fn clear_host_computationtime(&mut self) {
        self.host_computationtime = ::std::option::Option::None;
    }

    pub fn has_host_computationtime(&self) -> bool {
        self.host_computationtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_computationtime(&mut self, v: u32) {
        self.host_computationtime = ::std::option::Option::Some(v);
    }

    // optional uint32 host_computationtime_std_deviation = 5;

    pub fn host_computationtime_std_deviation(&self) -> u32 {
        self.host_computationtime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_computationtime_std_deviation(&mut self) {
        self.host_computationtime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_computationtime_std_deviation(&self) -> bool {
        self.host_computationtime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_computationtime_std_deviation(&mut self, v: u32) {
        self.host_computationtime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 host_framestarttime_std_deviation = 6;

    pub fn host_framestarttime_std_deviation(&self) -> u32 {
        self.host_framestarttime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_framestarttime_std_deviation(&mut self) {
        self.host_framestarttime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_framestarttime_std_deviation(&self) -> bool {
        self.host_framestarttime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_framestarttime_std_deviation(&mut self, v: u32) {
        self.host_framestarttime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 host_loss = 7;

    pub fn host_loss(&self) -> u32 {
        self.host_loss.unwrap_or(0)
    }

    pub fn clear_host_loss(&mut self) {
        self.host_loss = ::std::option::Option::None;
    }

    pub fn has_host_loss(&self) -> bool {
        self.host_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_loss(&mut self, v: u32) {
        self.host_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 host_unfiltered_frametime = 8;

    pub fn host_unfiltered_frametime(&self) -> u32 {
        self.host_unfiltered_frametime.unwrap_or(0)
    }

    pub fn clear_host_unfiltered_frametime(&mut self) {
        self.host_unfiltered_frametime = ::std::option::Option::None;
    }

    pub fn has_host_unfiltered_frametime(&self) -> bool {
        self.host_unfiltered_frametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_unfiltered_frametime(&mut self, v: u32) {
        self.host_unfiltered_frametime = ::std::option::Option::Some(v);
    }

    // optional uint32 hltv_replay_flags = 9;

    pub fn hltv_replay_flags(&self) -> u32 {
        self.hltv_replay_flags.unwrap_or(0)
    }

    pub fn clear_hltv_replay_flags(&mut self) {
        self.hltv_replay_flags = ::std::option::Option::None;
    }

    pub fn has_hltv_replay_flags(&self) -> bool {
        self.hltv_replay_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_replay_flags(&mut self, v: u32) {
        self.hltv_replay_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 expected_long_tick = 10;

    pub fn expected_long_tick(&self) -> u32 {
        self.expected_long_tick.unwrap_or(0)
    }

    pub fn clear_expected_long_tick(&mut self) {
        self.expected_long_tick = ::std::option::Option::None;
    }

    pub fn has_expected_long_tick(&self) -> bool {
        self.expected_long_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_long_tick(&mut self, v: u32) {
        self.expected_long_tick = ::std::option::Option::Some(v);
    }

    // optional string expected_long_tick_reason = 11;

    pub fn expected_long_tick_reason(&self) -> &str {
        match self.expected_long_tick_reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_expected_long_tick_reason(&mut self) {
        self.expected_long_tick_reason = ::std::option::Option::None;
    }

    pub fn has_expected_long_tick_reason(&self) -> bool {
        self.expected_long_tick_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_long_tick_reason(&mut self, v: ::std::string::String) {
        self.expected_long_tick_reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expected_long_tick_reason(&mut self) -> &mut ::std::string::String {
        if self.expected_long_tick_reason.is_none() {
            self.expected_long_tick_reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.expected_long_tick_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_expected_long_tick_reason(&mut self) -> ::std::string::String {
        self.expected_long_tick_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_Tick {
    const NAME: &'static str = "CNETMsg_Tick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.host_frametime = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.host_frametime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.host_computationtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.host_computationtime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.host_framestarttime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.host_loss = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.host_unfiltered_frametime = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.hltv_replay_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.expected_long_tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.expected_long_tick_reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.host_frametime {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.host_frametime_std_deviation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.host_computationtime {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.host_computationtime_std_deviation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.host_framestarttime_std_deviation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.host_loss {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.host_unfiltered_frametime {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.hltv_replay_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.expected_long_tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.expected_long_tick_reason.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.host_frametime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.host_frametime_std_deviation {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.host_computationtime {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.host_computationtime_std_deviation {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.host_framestarttime_std_deviation {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.host_loss {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.host_unfiltered_frametime {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.hltv_replay_flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.expected_long_tick {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.expected_long_tick_reason.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_Tick {
        CNETMsg_Tick::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.host_frametime = ::std::option::Option::None;
        self.host_frametime_std_deviation = ::std::option::Option::None;
        self.host_computationtime = ::std::option::Option::None;
        self.host_computationtime_std_deviation = ::std::option::Option::None;
        self.host_framestarttime_std_deviation = ::std::option::Option::None;
        self.host_loss = ::std::option::Option::None;
        self.host_unfiltered_frametime = ::std::option::Option::None;
        self.hltv_replay_flags = ::std::option::Option::None;
        self.expected_long_tick = ::std::option::Option::None;
        self.expected_long_tick_reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_Tick {
        static instance: CNETMsg_Tick = CNETMsg_Tick {
            tick: ::std::option::Option::None,
            host_frametime: ::std::option::Option::None,
            host_frametime_std_deviation: ::std::option::Option::None,
            host_computationtime: ::std::option::Option::None,
            host_computationtime_std_deviation: ::std::option::Option::None,
            host_framestarttime_std_deviation: ::std::option::Option::None,
            host_loss: ::std::option::Option::None,
            host_unfiltered_frametime: ::std::option::Option::None,
            hltv_replay_flags: ::std::option::Option::None,
            expected_long_tick: ::std::option::Option::None,
            expected_long_tick_reason: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_StringCmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_StringCmd {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_StringCmd.command)
    pub command: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_StringCmd.prediction_sync)
    pub prediction_sync: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_StringCmd.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_StringCmd {
    fn default() -> &'a CNETMsg_StringCmd {
        <CNETMsg_StringCmd as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_StringCmd {
    pub fn new() -> CNETMsg_StringCmd {
        ::std::default::Default::default()
    }

    // optional string command = 1;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 prediction_sync = 2;

    pub fn prediction_sync(&self) -> u32 {
        self.prediction_sync.unwrap_or(0)
    }

    pub fn clear_prediction_sync(&mut self) {
        self.prediction_sync = ::std::option::Option::None;
    }

    pub fn has_prediction_sync(&self) -> bool {
        self.prediction_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_sync(&mut self, v: u32) {
        self.prediction_sync = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_StringCmd {
    const NAME: &'static str = "CNETMsg_StringCmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.prediction_sync = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.prediction_sync {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.command.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.prediction_sync {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_StringCmd {
        CNETMsg_StringCmd::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.prediction_sync = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_StringCmd {
        static instance: CNETMsg_StringCmd = CNETMsg_StringCmd {
            command: ::std::option::Option::None,
            prediction_sync: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_SetConVar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SetConVar {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SetConVar.convars)
    pub convars: ::steam_vent_proto_common::protobuf::MessageField<CMsg_CVars>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SetConVar.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SetConVar {
    fn default() -> &'a CNETMsg_SetConVar {
        <CNETMsg_SetConVar as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SetConVar {
    pub fn new() -> CNETMsg_SetConVar {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SetConVar {
    const NAME: &'static str = "CNETMsg_SetConVar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.convars)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.convars.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.convars.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SetConVar {
        CNETMsg_SetConVar::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SetConVar {
        static instance: CNETMsg_SetConVar = CNETMsg_SetConVar {
            convars: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_SignonState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SignonState {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SignonState.signon_state)
    pub signon_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<SignonState_t>>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.spawn_count)
    pub spawn_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.num_server_players)
    pub num_server_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.players_networkids)
    pub players_networkids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.addons)
    pub addons: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SignonState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SignonState {
    fn default() -> &'a CNETMsg_SignonState {
        <CNETMsg_SignonState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SignonState {
    pub fn new() -> CNETMsg_SignonState {
        ::std::default::Default::default()
    }

    // optional .SignonState_t signon_state = 1;

    pub fn signon_state(&self) -> SignonState_t {
        match self.signon_state {
            Some(e) => e.enum_value_or(SignonState_t::SIGNONSTATE_NONE),
            None => SignonState_t::SIGNONSTATE_NONE,
        }
    }

    pub fn clear_signon_state(&mut self) {
        self.signon_state = ::std::option::Option::None;
    }

    pub fn has_signon_state(&self) -> bool {
        self.signon_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signon_state(&mut self, v: SignonState_t) {
        self.signon_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 spawn_count = 2;

    pub fn spawn_count(&self) -> u32 {
        self.spawn_count.unwrap_or(0)
    }

    pub fn clear_spawn_count(&mut self) {
        self.spawn_count = ::std::option::Option::None;
    }

    pub fn has_spawn_count(&self) -> bool {
        self.spawn_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_count(&mut self, v: u32) {
        self.spawn_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_server_players = 3;

    pub fn num_server_players(&self) -> u32 {
        self.num_server_players.unwrap_or(0)
    }

    pub fn clear_num_server_players(&mut self) {
        self.num_server_players = ::std::option::Option::None;
    }

    pub fn has_num_server_players(&self) -> bool {
        self.num_server_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_server_players(&mut self, v: u32) {
        self.num_server_players = ::std::option::Option::Some(v);
    }

    // optional string map_name = 5;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string addons = 6;

    pub fn addons(&self) -> &str {
        match self.addons.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_addons(&mut self) {
        self.addons = ::std::option::Option::None;
    }

    pub fn has_addons(&self) -> bool {
        self.addons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addons(&mut self, v: ::std::string::String) {
        self.addons = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addons(&mut self) -> &mut ::std::string::String {
        if self.addons.is_none() {
            self.addons = ::std::option::Option::Some(::std::string::String::new());
        }
        self.addons.as_mut().unwrap()
    }

    // Take field
    pub fn take_addons(&mut self) -> ::std::string::String {
        self.addons.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SignonState {
    const NAME: &'static str = "CNETMsg_SignonState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.signon_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.spawn_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_server_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.players_networkids.push(is.read_string()?);
                },
                42 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.addons = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signon_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.spawn_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_server_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.players_networkids {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.addons.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.signon_state {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.spawn_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_server_players {
            os.write_uint32(3, v)?;
        }
        for v in &self.players_networkids {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.addons.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SignonState {
        CNETMsg_SignonState::new()
    }

    fn clear(&mut self) {
        self.signon_state = ::std::option::Option::None;
        self.spawn_count = ::std::option::Option::None;
        self.num_server_players = ::std::option::Option::None;
        self.players_networkids.clear();
        self.map_name = ::std::option::Option::None;
        self.addons = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SignonState {
        static instance: CNETMsg_SignonState = CNETMsg_SignonState {
            signon_state: ::std::option::Option::None,
            spawn_count: ::std::option::Option::None,
            num_server_players: ::std::option::Option::None,
            players_networkids: ::std::vec::Vec::new(),
            map_name: ::std::option::Option::None,
            addons: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_GameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GameEvent {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.eventid)
    pub eventid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.keys)
    pub keys: ::std::vec::Vec<csvcmsg_game_event::Key_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameEvent {
    fn default() -> &'a CSVCMsg_GameEvent {
        <CSVCMsg_GameEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameEvent {
    pub fn new() -> CSVCMsg_GameEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 eventid = 2;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_GameEvent {
    const NAME: &'static str = "CSVCMsg_GameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eventid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eventid {
            os.write_int32(2, v)?;
        }
        for v in &self.keys {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameEvent {
        CSVCMsg_GameEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.eventid = ::std::option::Option::None;
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameEvent {
        static instance: CSVCMsg_GameEvent = CSVCMsg_GameEvent {
            event_name: ::std::option::Option::None,
            eventid: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSVCMsg_GameEvent`
pub mod csvcmsg_game_event {
    // @@protoc_insertion_point(message:CSVCMsg_GameEvent.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_string)
        pub val_string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_float)
        pub val_float: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_long)
        pub val_long: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_short)
        pub val_short: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_byte)
        pub val_byte: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_bool)
        pub val_bool: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_uint64)
        pub val_uint64: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEvent.key_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string val_string = 2;

        pub fn val_string(&self) -> &str {
            match self.val_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_val_string(&mut self) {
            self.val_string = ::std::option::Option::None;
        }

        pub fn has_val_string(&self) -> bool {
            self.val_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_string(&mut self, v: ::std::string::String) {
            self.val_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
            if self.val_string.is_none() {
                self.val_string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.val_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_string(&mut self) -> ::std::string::String {
            self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float val_float = 3;

        pub fn val_float(&self) -> f32 {
            self.val_float.unwrap_or(0.)
        }

        pub fn clear_val_float(&mut self) {
            self.val_float = ::std::option::Option::None;
        }

        pub fn has_val_float(&self) -> bool {
            self.val_float.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_float(&mut self, v: f32) {
            self.val_float = ::std::option::Option::Some(v);
        }

        // optional int32 val_long = 4;

        pub fn val_long(&self) -> i32 {
            self.val_long.unwrap_or(0)
        }

        pub fn clear_val_long(&mut self) {
            self.val_long = ::std::option::Option::None;
        }

        pub fn has_val_long(&self) -> bool {
            self.val_long.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_long(&mut self, v: i32) {
            self.val_long = ::std::option::Option::Some(v);
        }

        // optional int32 val_short = 5;

        pub fn val_short(&self) -> i32 {
            self.val_short.unwrap_or(0)
        }

        pub fn clear_val_short(&mut self) {
            self.val_short = ::std::option::Option::None;
        }

        pub fn has_val_short(&self) -> bool {
            self.val_short.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_short(&mut self, v: i32) {
            self.val_short = ::std::option::Option::Some(v);
        }

        // optional int32 val_byte = 6;

        pub fn val_byte(&self) -> i32 {
            self.val_byte.unwrap_or(0)
        }

        pub fn clear_val_byte(&mut self) {
            self.val_byte = ::std::option::Option::None;
        }

        pub fn has_val_byte(&self) -> bool {
            self.val_byte.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_byte(&mut self, v: i32) {
            self.val_byte = ::std::option::Option::Some(v);
        }

        // optional bool val_bool = 7;

        pub fn val_bool(&self) -> bool {
            self.val_bool.unwrap_or(false)
        }

        pub fn clear_val_bool(&mut self) {
            self.val_bool = ::std::option::Option::None;
        }

        pub fn has_val_bool(&self) -> bool {
            self.val_bool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_bool(&mut self, v: bool) {
            self.val_bool = ::std::option::Option::Some(v);
        }

        // optional uint64 val_uint64 = 8;

        pub fn val_uint64(&self) -> u64 {
            self.val_uint64.unwrap_or(0)
        }

        pub fn clear_val_uint64(&mut self) {
            self.val_uint64 = ::std::option::Option::None;
        }

        pub fn has_val_uint64(&self) -> bool {
            self.val_uint64.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_uint64(&mut self, v: u64) {
            self.val_uint64 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.val_string = ::std::option::Option::Some(is.read_string()?);
                    },
                    29 => {
                        self.val_float = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.val_long = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.val_short = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.val_byte = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.val_bool = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.val_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.val_string.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.val_float {
                my_size += 1 + 4;
            }
            if let Some(v) = self.val_long {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.val_short {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.val_byte {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.val_bool {
                my_size += 1 + 1;
            }
            if let Some(v) = self.val_uint64 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.val_string.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.val_float {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.val_long {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.val_short {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.val_byte {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.val_bool {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.val_uint64 {
                os.write_uint64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.val_string = ::std::option::Option::None;
            self.val_float = ::std::option::Option::None;
            self.val_long = ::std::option::Option::None;
            self.val_short = ::std::option::Option::None;
            self.val_byte = ::std::option::Option::None;
            self.val_bool = ::std::option::Option::None;
            self.val_uint64 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                val_string: ::std::option::Option::None,
                val_float: ::std::option::Option::None,
                val_long: ::std::option::Option::None,
                val_short: ::std::option::Option::None,
                val_byte: ::std::option::Option::None,
                val_bool: ::std::option::Option::None,
                val_uint64: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsgList_GameEvents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsgList_GameEvents {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsgList_GameEvents.events)
    pub events: ::std::vec::Vec<csvcmsg_list_game_events::Event_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsgList_GameEvents.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsgList_GameEvents {
    fn default() -> &'a CSVCMsgList_GameEvents {
        <CSVCMsgList_GameEvents as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsgList_GameEvents {
    pub fn new() -> CSVCMsgList_GameEvents {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsgList_GameEvents {
    const NAME: &'static str = "CSVCMsgList_GameEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsgList_GameEvents {
        CSVCMsgList_GameEvents::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsgList_GameEvents {
        static instance: CSVCMsgList_GameEvents = CSVCMsgList_GameEvents {
            events: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSVCMsgList_GameEvents`
pub mod csvcmsg_list_game_events {
    // @@protoc_insertion_point(message:CSVCMsgList_GameEvents.event_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Event_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsgList_GameEvents.event_t.tick)
        pub tick: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsgList_GameEvents.event_t.event)
        pub event: ::steam_vent_proto_common::protobuf::MessageField<super::CSVCMsg_GameEvent>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsgList_GameEvents.event_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Event_t {
        fn default() -> &'a Event_t {
            <Event_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Event_t {
        pub fn new() -> Event_t {
            ::std::default::Default::default()
        }

        // optional int32 tick = 1;

        pub fn tick(&self) -> i32 {
            self.tick.unwrap_or(0)
        }

        pub fn clear_tick(&mut self) {
            self.tick = ::std::option::Option::None;
        }

        pub fn has_tick(&self) -> bool {
            self.tick.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tick(&mut self, v: i32) {
            self.tick = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Event_t {
        const NAME: &'static str = "event_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tick = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tick {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.event.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.tick {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.event.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Event_t {
            Event_t::new()
        }

        fn clear(&mut self) {
            self.tick = ::std::option::Option::None;
            self.event.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Event_t {
            static instance: Event_t = Event_t {
                tick: ::std::option::Option::None,
                event: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_Load)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_Load {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.worldname)
    pub worldname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.entitylumpname)
    pub entitylumpname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.entityfiltername)
    pub entityfiltername: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngroupownerhandle)
    pub spawngroupownerhandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.world_offset_pos)
    pub world_offset_pos: ::steam_vent_proto_common::protobuf::MessageField<CMsgVector>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.world_offset_angle)
    pub world_offset_angle: ::steam_vent_proto_common::protobuf::MessageField<CMsgQAngle>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngroupmanifest)
    pub spawngroupmanifest: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.tickcount)
    pub tickcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.manifestincomplete)
    pub manifestincomplete: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.localnamefixup)
    pub localnamefixup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.parentnamefixup)
    pub parentnamefixup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.manifestloadpriority)
    pub manifestloadpriority: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.worldgroupid)
    pub worldgroupid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.creationsequence)
    pub creationsequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.savegamefilename)
    pub savegamefilename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngroupparenthandle)
    pub spawngroupparenthandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.leveltransition)
    pub leveltransition: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.worldgroupname)
    pub worldgroupname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_Load.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_Load {
    fn default() -> &'a CNETMsg_SpawnGroup_Load {
        <CNETMsg_SpawnGroup_Load as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_Load {
    pub fn new() -> CNETMsg_SpawnGroup_Load {
        ::std::default::Default::default()
    }

    // optional string worldname = 1;

    pub fn worldname(&self) -> &str {
        match self.worldname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_worldname(&mut self) {
        self.worldname = ::std::option::Option::None;
    }

    pub fn has_worldname(&self) -> bool {
        self.worldname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldname(&mut self, v: ::std::string::String) {
        self.worldname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worldname(&mut self) -> &mut ::std::string::String {
        if self.worldname.is_none() {
            self.worldname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.worldname.as_mut().unwrap()
    }

    // Take field
    pub fn take_worldname(&mut self) -> ::std::string::String {
        self.worldname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string entitylumpname = 2;

    pub fn entitylumpname(&self) -> &str {
        match self.entitylumpname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entitylumpname(&mut self) {
        self.entitylumpname = ::std::option::Option::None;
    }

    pub fn has_entitylumpname(&self) -> bool {
        self.entitylumpname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entitylumpname(&mut self, v: ::std::string::String) {
        self.entitylumpname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entitylumpname(&mut self) -> &mut ::std::string::String {
        if self.entitylumpname.is_none() {
            self.entitylumpname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entitylumpname.as_mut().unwrap()
    }

    // Take field
    pub fn take_entitylumpname(&mut self) -> ::std::string::String {
        self.entitylumpname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string entityfiltername = 3;

    pub fn entityfiltername(&self) -> &str {
        match self.entityfiltername.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entityfiltername(&mut self) {
        self.entityfiltername = ::std::option::Option::None;
    }

    pub fn has_entityfiltername(&self) -> bool {
        self.entityfiltername.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityfiltername(&mut self, v: ::std::string::String) {
        self.entityfiltername = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityfiltername(&mut self) -> &mut ::std::string::String {
        if self.entityfiltername.is_none() {
            self.entityfiltername = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entityfiltername.as_mut().unwrap()
    }

    // Take field
    pub fn take_entityfiltername(&mut self) -> ::std::string::String {
        self.entityfiltername.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 spawngrouphandle = 4;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional uint32 spawngroupownerhandle = 5;

    pub fn spawngroupownerhandle(&self) -> u32 {
        self.spawngroupownerhandle.unwrap_or(0)
    }

    pub fn clear_spawngroupownerhandle(&mut self) {
        self.spawngroupownerhandle = ::std::option::Option::None;
    }

    pub fn has_spawngroupownerhandle(&self) -> bool {
        self.spawngroupownerhandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupownerhandle(&mut self, v: u32) {
        self.spawngroupownerhandle = ::std::option::Option::Some(v);
    }

    // optional bytes spawngroupmanifest = 8;

    pub fn spawngroupmanifest(&self) -> &[u8] {
        match self.spawngroupmanifest.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spawngroupmanifest(&mut self) {
        self.spawngroupmanifest = ::std::option::Option::None;
    }

    pub fn has_spawngroupmanifest(&self) -> bool {
        self.spawngroupmanifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupmanifest(&mut self, v: ::std::vec::Vec<u8>) {
        self.spawngroupmanifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spawngroupmanifest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spawngroupmanifest.is_none() {
            self.spawngroupmanifest = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.spawngroupmanifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_spawngroupmanifest(&mut self) -> ::std::vec::Vec<u8> {
        self.spawngroupmanifest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 flags = 9;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional int32 tickcount = 10;

    pub fn tickcount(&self) -> i32 {
        self.tickcount.unwrap_or(0)
    }

    pub fn clear_tickcount(&mut self) {
        self.tickcount = ::std::option::Option::None;
    }

    pub fn has_tickcount(&self) -> bool {
        self.tickcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tickcount(&mut self, v: i32) {
        self.tickcount = ::std::option::Option::Some(v);
    }

    // optional bool manifestincomplete = 11;

    pub fn manifestincomplete(&self) -> bool {
        self.manifestincomplete.unwrap_or(false)
    }

    pub fn clear_manifestincomplete(&mut self) {
        self.manifestincomplete = ::std::option::Option::None;
    }

    pub fn has_manifestincomplete(&self) -> bool {
        self.manifestincomplete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifestincomplete(&mut self, v: bool) {
        self.manifestincomplete = ::std::option::Option::Some(v);
    }

    // optional string localnamefixup = 12;

    pub fn localnamefixup(&self) -> &str {
        match self.localnamefixup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localnamefixup(&mut self) {
        self.localnamefixup = ::std::option::Option::None;
    }

    pub fn has_localnamefixup(&self) -> bool {
        self.localnamefixup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localnamefixup(&mut self, v: ::std::string::String) {
        self.localnamefixup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localnamefixup(&mut self) -> &mut ::std::string::String {
        if self.localnamefixup.is_none() {
            self.localnamefixup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localnamefixup.as_mut().unwrap()
    }

    // Take field
    pub fn take_localnamefixup(&mut self) -> ::std::string::String {
        self.localnamefixup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parentnamefixup = 13;

    pub fn parentnamefixup(&self) -> &str {
        match self.parentnamefixup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parentnamefixup(&mut self) {
        self.parentnamefixup = ::std::option::Option::None;
    }

    pub fn has_parentnamefixup(&self) -> bool {
        self.parentnamefixup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentnamefixup(&mut self, v: ::std::string::String) {
        self.parentnamefixup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentnamefixup(&mut self) -> &mut ::std::string::String {
        if self.parentnamefixup.is_none() {
            self.parentnamefixup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parentnamefixup.as_mut().unwrap()
    }

    // Take field
    pub fn take_parentnamefixup(&mut self) -> ::std::string::String {
        self.parentnamefixup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 manifestloadpriority = 14;

    pub fn manifestloadpriority(&self) -> i32 {
        self.manifestloadpriority.unwrap_or(0)
    }

    pub fn clear_manifestloadpriority(&mut self) {
        self.manifestloadpriority = ::std::option::Option::None;
    }

    pub fn has_manifestloadpriority(&self) -> bool {
        self.manifestloadpriority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifestloadpriority(&mut self, v: i32) {
        self.manifestloadpriority = ::std::option::Option::Some(v);
    }

    // optional uint32 worldgroupid = 15;

    pub fn worldgroupid(&self) -> u32 {
        self.worldgroupid.unwrap_or(0)
    }

    pub fn clear_worldgroupid(&mut self) {
        self.worldgroupid = ::std::option::Option::None;
    }

    pub fn has_worldgroupid(&self) -> bool {
        self.worldgroupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldgroupid(&mut self, v: u32) {
        self.worldgroupid = ::std::option::Option::Some(v);
    }

    // optional uint32 creationsequence = 16;

    pub fn creationsequence(&self) -> u32 {
        self.creationsequence.unwrap_or(0)
    }

    pub fn clear_creationsequence(&mut self) {
        self.creationsequence = ::std::option::Option::None;
    }

    pub fn has_creationsequence(&self) -> bool {
        self.creationsequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationsequence(&mut self, v: u32) {
        self.creationsequence = ::std::option::Option::Some(v);
    }

    // optional string savegamefilename = 17;

    pub fn savegamefilename(&self) -> &str {
        match self.savegamefilename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_savegamefilename(&mut self) {
        self.savegamefilename = ::std::option::Option::None;
    }

    pub fn has_savegamefilename(&self) -> bool {
        self.savegamefilename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_savegamefilename(&mut self, v: ::std::string::String) {
        self.savegamefilename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_savegamefilename(&mut self) -> &mut ::std::string::String {
        if self.savegamefilename.is_none() {
            self.savegamefilename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.savegamefilename.as_mut().unwrap()
    }

    // Take field
    pub fn take_savegamefilename(&mut self) -> ::std::string::String {
        self.savegamefilename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 spawngroupparenthandle = 18;

    pub fn spawngroupparenthandle(&self) -> u32 {
        self.spawngroupparenthandle.unwrap_or(0)
    }

    pub fn clear_spawngroupparenthandle(&mut self) {
        self.spawngroupparenthandle = ::std::option::Option::None;
    }

    pub fn has_spawngroupparenthandle(&self) -> bool {
        self.spawngroupparenthandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupparenthandle(&mut self, v: u32) {
        self.spawngroupparenthandle = ::std::option::Option::Some(v);
    }

    // optional bool leveltransition = 19;

    pub fn leveltransition(&self) -> bool {
        self.leveltransition.unwrap_or(false)
    }

    pub fn clear_leveltransition(&mut self) {
        self.leveltransition = ::std::option::Option::None;
    }

    pub fn has_leveltransition(&self) -> bool {
        self.leveltransition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leveltransition(&mut self, v: bool) {
        self.leveltransition = ::std::option::Option::Some(v);
    }

    // optional string worldgroupname = 20;

    pub fn worldgroupname(&self) -> &str {
        match self.worldgroupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_worldgroupname(&mut self) {
        self.worldgroupname = ::std::option::Option::None;
    }

    pub fn has_worldgroupname(&self) -> bool {
        self.worldgroupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldgroupname(&mut self, v: ::std::string::String) {
        self.worldgroupname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worldgroupname(&mut self) -> &mut ::std::string::String {
        if self.worldgroupname.is_none() {
            self.worldgroupname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.worldgroupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_worldgroupname(&mut self) -> ::std::string::String {
        self.worldgroupname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SpawnGroup_Load {
    const NAME: &'static str = "CNETMsg_SpawnGroup_Load";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.worldname = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.entitylumpname = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.entityfiltername = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.spawngroupownerhandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.world_offset_pos)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.world_offset_angle)?;
                },
                66 => {
                    self.spawngroupmanifest = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.tickcount = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.manifestincomplete = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.localnamefixup = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.parentnamefixup = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.manifestloadpriority = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.worldgroupid = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.creationsequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                138 => {
                    self.savegamefilename = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.spawngroupparenthandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.leveltransition = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.worldgroupname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.worldname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.entitylumpname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.entityfiltername.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.spawngrouphandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.spawngroupownerhandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.world_offset_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.world_offset_angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.tickcount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.manifestincomplete {
            my_size += 1 + 1;
        }
        if let Some(v) = self.localnamefixup.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.parentnamefixup.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.manifestloadpriority {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.worldgroupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.creationsequence {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.savegamefilename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.spawngroupparenthandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.leveltransition {
            my_size += 2 + 1;
        }
        if let Some(v) = self.worldgroupname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(20, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.worldname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.entitylumpname.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.entityfiltername.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spawngroupownerhandle {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.world_offset_pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.world_offset_angle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.tickcount {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.manifestincomplete {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.localnamefixup.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.parentnamefixup.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.manifestloadpriority {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.worldgroupid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.creationsequence {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.savegamefilename.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.spawngroupparenthandle {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.leveltransition {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.worldgroupname.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_Load {
        CNETMsg_SpawnGroup_Load::new()
    }

    fn clear(&mut self) {
        self.worldname = ::std::option::Option::None;
        self.entitylumpname = ::std::option::Option::None;
        self.entityfiltername = ::std::option::Option::None;
        self.spawngrouphandle = ::std::option::Option::None;
        self.spawngroupownerhandle = ::std::option::Option::None;
        self.world_offset_pos.clear();
        self.world_offset_angle.clear();
        self.spawngroupmanifest = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.tickcount = ::std::option::Option::None;
        self.manifestincomplete = ::std::option::Option::None;
        self.localnamefixup = ::std::option::Option::None;
        self.parentnamefixup = ::std::option::Option::None;
        self.manifestloadpriority = ::std::option::Option::None;
        self.worldgroupid = ::std::option::Option::None;
        self.creationsequence = ::std::option::Option::None;
        self.savegamefilename = ::std::option::Option::None;
        self.spawngroupparenthandle = ::std::option::Option::None;
        self.leveltransition = ::std::option::Option::None;
        self.worldgroupname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_Load {
        static instance: CNETMsg_SpawnGroup_Load = CNETMsg_SpawnGroup_Load {
            worldname: ::std::option::Option::None,
            entitylumpname: ::std::option::Option::None,
            entityfiltername: ::std::option::Option::None,
            spawngrouphandle: ::std::option::Option::None,
            spawngroupownerhandle: ::std::option::Option::None,
            world_offset_pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            world_offset_angle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            spawngroupmanifest: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            tickcount: ::std::option::Option::None,
            manifestincomplete: ::std::option::Option::None,
            localnamefixup: ::std::option::Option::None,
            parentnamefixup: ::std::option::Option::None,
            manifestloadpriority: ::std::option::Option::None,
            worldgroupid: ::std::option::Option::None,
            creationsequence: ::std::option::Option::None,
            savegamefilename: ::std::option::Option::None,
            spawngroupparenthandle: ::std::option::Option::None,
            leveltransition: ::std::option::Option::None,
            worldgroupname: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_ManifestUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_ManifestUpdate {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_ManifestUpdate.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_ManifestUpdate.spawngroupmanifest)
    pub spawngroupmanifest: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_ManifestUpdate.manifestincomplete)
    pub manifestincomplete: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_ManifestUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_ManifestUpdate {
    fn default() -> &'a CNETMsg_SpawnGroup_ManifestUpdate {
        <CNETMsg_SpawnGroup_ManifestUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_ManifestUpdate {
    pub fn new() -> CNETMsg_SpawnGroup_ManifestUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional bytes spawngroupmanifest = 2;

    pub fn spawngroupmanifest(&self) -> &[u8] {
        match self.spawngroupmanifest.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spawngroupmanifest(&mut self) {
        self.spawngroupmanifest = ::std::option::Option::None;
    }

    pub fn has_spawngroupmanifest(&self) -> bool {
        self.spawngroupmanifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupmanifest(&mut self, v: ::std::vec::Vec<u8>) {
        self.spawngroupmanifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spawngroupmanifest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spawngroupmanifest.is_none() {
            self.spawngroupmanifest = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.spawngroupmanifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_spawngroupmanifest(&mut self) -> ::std::vec::Vec<u8> {
        self.spawngroupmanifest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool manifestincomplete = 3;

    pub fn manifestincomplete(&self) -> bool {
        self.manifestincomplete.unwrap_or(false)
    }

    pub fn clear_manifestincomplete(&mut self) {
        self.manifestincomplete = ::std::option::Option::None;
    }

    pub fn has_manifestincomplete(&self) -> bool {
        self.manifestincomplete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifestincomplete(&mut self, v: bool) {
        self.manifestincomplete = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SpawnGroup_ManifestUpdate {
    const NAME: &'static str = "CNETMsg_SpawnGroup_ManifestUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.spawngroupmanifest = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.manifestincomplete = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.manifestincomplete {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.manifestincomplete {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_ManifestUpdate {
        CNETMsg_SpawnGroup_ManifestUpdate::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.spawngroupmanifest = ::std::option::Option::None;
        self.manifestincomplete = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_ManifestUpdate {
        static instance: CNETMsg_SpawnGroup_ManifestUpdate = CNETMsg_SpawnGroup_ManifestUpdate {
            spawngrouphandle: ::std::option::Option::None,
            spawngroupmanifest: ::std::option::Option::None,
            manifestincomplete: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_SetCreationTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_SetCreationTick {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_SetCreationTick.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_SetCreationTick.tickcount)
    pub tickcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_SetCreationTick.creationsequence)
    pub creationsequence: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_SetCreationTick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_SetCreationTick {
    fn default() -> &'a CNETMsg_SpawnGroup_SetCreationTick {
        <CNETMsg_SpawnGroup_SetCreationTick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_SetCreationTick {
    pub fn new() -> CNETMsg_SpawnGroup_SetCreationTick {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional int32 tickcount = 2;

    pub fn tickcount(&self) -> i32 {
        self.tickcount.unwrap_or(0)
    }

    pub fn clear_tickcount(&mut self) {
        self.tickcount = ::std::option::Option::None;
    }

    pub fn has_tickcount(&self) -> bool {
        self.tickcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tickcount(&mut self, v: i32) {
        self.tickcount = ::std::option::Option::Some(v);
    }

    // optional uint32 creationsequence = 3;

    pub fn creationsequence(&self) -> u32 {
        self.creationsequence.unwrap_or(0)
    }

    pub fn clear_creationsequence(&mut self) {
        self.creationsequence = ::std::option::Option::None;
    }

    pub fn has_creationsequence(&self) -> bool {
        self.creationsequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationsequence(&mut self, v: u32) {
        self.creationsequence = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SpawnGroup_SetCreationTick {
    const NAME: &'static str = "CNETMsg_SpawnGroup_SetCreationTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tickcount = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.creationsequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tickcount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.creationsequence {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tickcount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.creationsequence {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_SetCreationTick {
        CNETMsg_SpawnGroup_SetCreationTick::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.tickcount = ::std::option::Option::None;
        self.creationsequence = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_SetCreationTick {
        static instance: CNETMsg_SpawnGroup_SetCreationTick = CNETMsg_SpawnGroup_SetCreationTick {
            spawngrouphandle: ::std::option::Option::None,
            tickcount: ::std::option::Option::None,
            creationsequence: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_Unload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_Unload {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Unload.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Unload.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Unload.tickcount)
    pub tickcount: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_Unload.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_Unload {
    fn default() -> &'a CNETMsg_SpawnGroup_Unload {
        <CNETMsg_SpawnGroup_Unload as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_Unload {
    pub fn new() -> CNETMsg_SpawnGroup_Unload {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional int32 tickcount = 3;

    pub fn tickcount(&self) -> i32 {
        self.tickcount.unwrap_or(0)
    }

    pub fn clear_tickcount(&mut self) {
        self.tickcount = ::std::option::Option::None;
    }

    pub fn has_tickcount(&self) -> bool {
        self.tickcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tickcount(&mut self, v: i32) {
        self.tickcount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SpawnGroup_Unload {
    const NAME: &'static str = "CNETMsg_SpawnGroup_Unload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tickcount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tickcount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tickcount {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_Unload {
        CNETMsg_SpawnGroup_Unload::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.tickcount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_Unload {
        static instance: CNETMsg_SpawnGroup_Unload = CNETMsg_SpawnGroup_Unload {
            spawngrouphandle: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            tickcount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_LoadCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_LoadCompleted {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_LoadCompleted.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_LoadCompleted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_LoadCompleted {
    fn default() -> &'a CNETMsg_SpawnGroup_LoadCompleted {
        <CNETMsg_SpawnGroup_LoadCompleted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_LoadCompleted {
    pub fn new() -> CNETMsg_SpawnGroup_LoadCompleted {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_SpawnGroup_LoadCompleted {
    const NAME: &'static str = "CNETMsg_SpawnGroup_LoadCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_LoadCompleted {
        CNETMsg_SpawnGroup_LoadCompleted::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_LoadCompleted {
        static instance: CNETMsg_SpawnGroup_LoadCompleted = CNETMsg_SpawnGroup_LoadCompleted {
            spawngrouphandle: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_GameSessionConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GameSessionConfiguration {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_multiplayer)
    pub is_multiplayer: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_loadsavegame)
    pub is_loadsavegame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_background_map)
    pub is_background_map: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_headless)
    pub is_headless: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.min_client_limit)
    pub min_client_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.max_client_limit)
    pub max_client_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.max_clients)
    pub max_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.tick_interval)
    pub tick_interval: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.savegamename)
    pub savegamename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.s1_mapname)
    pub s1_mapname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.gamemode)
    pub gamemode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.server_ip_address)
    pub server_ip_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_localonly)
    pub is_localonly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.no_steam_server)
    pub no_steam_server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_transition)
    pub is_transition: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.previouslevel)
    pub previouslevel: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.landmarkname)
    pub landmarkname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameSessionConfiguration.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameSessionConfiguration {
    fn default() -> &'a CSVCMsg_GameSessionConfiguration {
        <CSVCMsg_GameSessionConfiguration as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameSessionConfiguration {
    pub fn new() -> CSVCMsg_GameSessionConfiguration {
        ::std::default::Default::default()
    }

    // optional bool is_multiplayer = 1;

    pub fn is_multiplayer(&self) -> bool {
        self.is_multiplayer.unwrap_or(false)
    }

    pub fn clear_is_multiplayer(&mut self) {
        self.is_multiplayer = ::std::option::Option::None;
    }

    pub fn has_is_multiplayer(&self) -> bool {
        self.is_multiplayer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_multiplayer(&mut self, v: bool) {
        self.is_multiplayer = ::std::option::Option::Some(v);
    }

    // optional bool is_loadsavegame = 2;

    pub fn is_loadsavegame(&self) -> bool {
        self.is_loadsavegame.unwrap_or(false)
    }

    pub fn clear_is_loadsavegame(&mut self) {
        self.is_loadsavegame = ::std::option::Option::None;
    }

    pub fn has_is_loadsavegame(&self) -> bool {
        self.is_loadsavegame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_loadsavegame(&mut self, v: bool) {
        self.is_loadsavegame = ::std::option::Option::Some(v);
    }

    // optional bool is_background_map = 3;

    pub fn is_background_map(&self) -> bool {
        self.is_background_map.unwrap_or(false)
    }

    pub fn clear_is_background_map(&mut self) {
        self.is_background_map = ::std::option::Option::None;
    }

    pub fn has_is_background_map(&self) -> bool {
        self.is_background_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_background_map(&mut self, v: bool) {
        self.is_background_map = ::std::option::Option::Some(v);
    }

    // optional bool is_headless = 4;

    pub fn is_headless(&self) -> bool {
        self.is_headless.unwrap_or(false)
    }

    pub fn clear_is_headless(&mut self) {
        self.is_headless = ::std::option::Option::None;
    }

    pub fn has_is_headless(&self) -> bool {
        self.is_headless.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_headless(&mut self, v: bool) {
        self.is_headless = ::std::option::Option::Some(v);
    }

    // optional uint32 min_client_limit = 5;

    pub fn min_client_limit(&self) -> u32 {
        self.min_client_limit.unwrap_or(0)
    }

    pub fn clear_min_client_limit(&mut self) {
        self.min_client_limit = ::std::option::Option::None;
    }

    pub fn has_min_client_limit(&self) -> bool {
        self.min_client_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_client_limit(&mut self, v: u32) {
        self.min_client_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 max_client_limit = 6;

    pub fn max_client_limit(&self) -> u32 {
        self.max_client_limit.unwrap_or(0)
    }

    pub fn clear_max_client_limit(&mut self) {
        self.max_client_limit = ::std::option::Option::None;
    }

    pub fn has_max_client_limit(&self) -> bool {
        self.max_client_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_client_limit(&mut self, v: u32) {
        self.max_client_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 max_clients = 7;

    pub fn max_clients(&self) -> u32 {
        self.max_clients.unwrap_or(0)
    }

    pub fn clear_max_clients(&mut self) {
        self.max_clients = ::std::option::Option::None;
    }

    pub fn has_max_clients(&self) -> bool {
        self.max_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_clients(&mut self, v: u32) {
        self.max_clients = ::std::option::Option::Some(v);
    }

    // optional fixed32 tick_interval = 8;

    pub fn tick_interval(&self) -> u32 {
        self.tick_interval.unwrap_or(0)
    }

    pub fn clear_tick_interval(&mut self) {
        self.tick_interval = ::std::option::Option::None;
    }

    pub fn has_tick_interval(&self) -> bool {
        self.tick_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_interval(&mut self, v: u32) {
        self.tick_interval = ::std::option::Option::Some(v);
    }

    // optional string hostname = 9;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string savegamename = 10;

    pub fn savegamename(&self) -> &str {
        match self.savegamename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_savegamename(&mut self) {
        self.savegamename = ::std::option::Option::None;
    }

    pub fn has_savegamename(&self) -> bool {
        self.savegamename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_savegamename(&mut self, v: ::std::string::String) {
        self.savegamename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_savegamename(&mut self) -> &mut ::std::string::String {
        if self.savegamename.is_none() {
            self.savegamename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.savegamename.as_mut().unwrap()
    }

    // Take field
    pub fn take_savegamename(&mut self) -> ::std::string::String {
        self.savegamename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string s1_mapname = 11;

    pub fn s1_mapname(&self) -> &str {
        match self.s1_mapname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_s1_mapname(&mut self) {
        self.s1_mapname = ::std::option::Option::None;
    }

    pub fn has_s1_mapname(&self) -> bool {
        self.s1_mapname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s1_mapname(&mut self, v: ::std::string::String) {
        self.s1_mapname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s1_mapname(&mut self) -> &mut ::std::string::String {
        if self.s1_mapname.is_none() {
            self.s1_mapname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.s1_mapname.as_mut().unwrap()
    }

    // Take field
    pub fn take_s1_mapname(&mut self) -> ::std::string::String {
        self.s1_mapname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string gamemode = 12;

    pub fn gamemode(&self) -> &str {
        match self.gamemode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamemode(&mut self) {
        self.gamemode = ::std::option::Option::None;
    }

    pub fn has_gamemode(&self) -> bool {
        self.gamemode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamemode(&mut self, v: ::std::string::String) {
        self.gamemode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamemode(&mut self) -> &mut ::std::string::String {
        if self.gamemode.is_none() {
            self.gamemode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gamemode.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamemode(&mut self) -> ::std::string::String {
        self.gamemode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_ip_address = 13;

    pub fn server_ip_address(&self) -> &str {
        match self.server_ip_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_ip_address(&mut self) {
        self.server_ip_address = ::std::option::Option::None;
    }

    pub fn has_server_ip_address(&self) -> bool {
        self.server_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip_address(&mut self, v: ::std::string::String) {
        self.server_ip_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_ip_address(&mut self) -> &mut ::std::string::String {
        if self.server_ip_address.is_none() {
            self.server_ip_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_ip_address(&mut self) -> ::std::string::String {
        self.server_ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 14;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_localonly = 15;

    pub fn is_localonly(&self) -> bool {
        self.is_localonly.unwrap_or(false)
    }

    pub fn clear_is_localonly(&mut self) {
        self.is_localonly = ::std::option::Option::None;
    }

    pub fn has_is_localonly(&self) -> bool {
        self.is_localonly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_localonly(&mut self, v: bool) {
        self.is_localonly = ::std::option::Option::Some(v);
    }

    // optional bool no_steam_server = 19;

    pub fn no_steam_server(&self) -> bool {
        self.no_steam_server.unwrap_or(false)
    }

    pub fn clear_no_steam_server(&mut self) {
        self.no_steam_server = ::std::option::Option::None;
    }

    pub fn has_no_steam_server(&self) -> bool {
        self.no_steam_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_steam_server(&mut self, v: bool) {
        self.no_steam_server = ::std::option::Option::Some(v);
    }

    // optional bool is_transition = 16;

    pub fn is_transition(&self) -> bool {
        self.is_transition.unwrap_or(false)
    }

    pub fn clear_is_transition(&mut self) {
        self.is_transition = ::std::option::Option::None;
    }

    pub fn has_is_transition(&self) -> bool {
        self.is_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_transition(&mut self, v: bool) {
        self.is_transition = ::std::option::Option::Some(v);
    }

    // optional string previouslevel = 17;

    pub fn previouslevel(&self) -> &str {
        match self.previouslevel.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_previouslevel(&mut self) {
        self.previouslevel = ::std::option::Option::None;
    }

    pub fn has_previouslevel(&self) -> bool {
        self.previouslevel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previouslevel(&mut self, v: ::std::string::String) {
        self.previouslevel = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previouslevel(&mut self) -> &mut ::std::string::String {
        if self.previouslevel.is_none() {
            self.previouslevel = ::std::option::Option::Some(::std::string::String::new());
        }
        self.previouslevel.as_mut().unwrap()
    }

    // Take field
    pub fn take_previouslevel(&mut self) -> ::std::string::String {
        self.previouslevel.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string landmarkname = 18;

    pub fn landmarkname(&self) -> &str {
        match self.landmarkname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_landmarkname(&mut self) {
        self.landmarkname = ::std::option::Option::None;
    }

    pub fn has_landmarkname(&self) -> bool {
        self.landmarkname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_landmarkname(&mut self, v: ::std::string::String) {
        self.landmarkname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_landmarkname(&mut self) -> &mut ::std::string::String {
        if self.landmarkname.is_none() {
            self.landmarkname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.landmarkname.as_mut().unwrap()
    }

    // Take field
    pub fn take_landmarkname(&mut self) -> ::std::string::String {
        self.landmarkname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_GameSessionConfiguration {
    const NAME: &'static str = "CSVCMsg_GameSessionConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_multiplayer = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_loadsavegame = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.is_background_map = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_headless = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.min_client_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.max_client_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.max_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.tick_interval = ::std::option::Option::Some(is.read_fixed32()?);
                },
                74 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.savegamename = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.s1_mapname = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.gamemode = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.server_ip_address = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                120 => {
                    self.is_localonly = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.no_steam_server = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.is_transition = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.previouslevel = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.landmarkname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_multiplayer {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_loadsavegame {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_background_map {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_headless {
            my_size += 1 + 1;
        }
        if let Some(v) = self.min_client_limit {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.max_client_limit {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.max_clients {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.tick_interval {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.savegamename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.s1_mapname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.gamemode.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.server_ip_address.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.is_localonly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_steam_server {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_transition {
            my_size += 2 + 1;
        }
        if let Some(v) = self.previouslevel.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.landmarkname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(18, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.is_multiplayer {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_loadsavegame {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.is_background_map {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_headless {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.min_client_limit {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.max_client_limit {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_clients {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.tick_interval {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.savegamename.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.s1_mapname.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.gamemode.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.server_ip_address.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.is_localonly {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.no_steam_server {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.is_transition {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.previouslevel.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.landmarkname.as_ref() {
            os.write_string(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameSessionConfiguration {
        CSVCMsg_GameSessionConfiguration::new()
    }

    fn clear(&mut self) {
        self.is_multiplayer = ::std::option::Option::None;
        self.is_loadsavegame = ::std::option::Option::None;
        self.is_background_map = ::std::option::Option::None;
        self.is_headless = ::std::option::Option::None;
        self.min_client_limit = ::std::option::Option::None;
        self.max_client_limit = ::std::option::Option::None;
        self.max_clients = ::std::option::Option::None;
        self.tick_interval = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.savegamename = ::std::option::Option::None;
        self.s1_mapname = ::std::option::Option::None;
        self.gamemode = ::std::option::Option::None;
        self.server_ip_address = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.is_localonly = ::std::option::Option::None;
        self.no_steam_server = ::std::option::Option::None;
        self.is_transition = ::std::option::Option::None;
        self.previouslevel = ::std::option::Option::None;
        self.landmarkname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameSessionConfiguration {
        static instance: CSVCMsg_GameSessionConfiguration = CSVCMsg_GameSessionConfiguration {
            is_multiplayer: ::std::option::Option::None,
            is_loadsavegame: ::std::option::Option::None,
            is_background_map: ::std::option::Option::None,
            is_headless: ::std::option::Option::None,
            min_client_limit: ::std::option::Option::None,
            max_client_limit: ::std::option::Option::None,
            max_clients: ::std::option::Option::None,
            tick_interval: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            savegamename: ::std::option::Option::None,
            s1_mapname: ::std::option::Option::None,
            gamemode: ::std::option::Option::None,
            server_ip_address: ::std::option::Option::None,
            data: ::std::option::Option::None,
            is_localonly: ::std::option::Option::None,
            no_steam_server: ::std::option::Option::None,
            is_transition: ::std::option::Option::None,
            previouslevel: ::std::option::Option::None,
            landmarkname: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CNETMsg_DebugOverlay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_DebugOverlay {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.etype)
    pub etype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.vectors)
    pub vectors: ::std::vec::Vec<CMsgVector>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.colors)
    pub colors: ::std::vec::Vec<CMsgRGBA>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.dimensions)
    pub dimensions: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.times)
    pub times: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.bools)
    pub bools: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.uint64s)
    pub uint64s: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_DebugOverlay.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_DebugOverlay {
    fn default() -> &'a CNETMsg_DebugOverlay {
        <CNETMsg_DebugOverlay as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_DebugOverlay {
    pub fn new() -> CNETMsg_DebugOverlay {
        ::std::default::Default::default()
    }

    // optional int32 etype = 1;

    pub fn etype(&self) -> i32 {
        self.etype.unwrap_or(0)
    }

    pub fn clear_etype(&mut self) {
        self.etype = ::std::option::Option::None;
    }

    pub fn has_etype(&self) -> bool {
        self.etype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_etype(&mut self, v: i32) {
        self.etype = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CNETMsg_DebugOverlay {
    const NAME: &'static str = "CNETMsg_DebugOverlay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.etype = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.vectors.push(is.read_message()?);
                },
                26 => {
                    self.colors.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_float_into(&mut self.dimensions)?;
                },
                37 => {
                    self.dimensions.push(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_float_into(&mut self.times)?;
                },
                45 => {
                    self.times.push(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_bool_into(&mut self.bools)?;
                },
                48 => {
                    self.bools.push(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_uint64_into(&mut self.uint64s)?;
                },
                56 => {
                    self.uint64s.push(is.read_uint64()?);
                },
                66 => {
                    self.strings.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.etype {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.vectors {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 5 * self.dimensions.len() as u64;
        my_size += 5 * self.times.len() as u64;
        my_size += 2 * self.bools.len() as u64;
        for value in &self.uint64s {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, *value);
        };
        for value in &self.strings {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.etype {
            os.write_int32(1, v)?;
        }
        for v in &self.vectors {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.colors {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.dimensions {
            os.write_float(4, *v)?;
        };
        for v in &self.times {
            os.write_float(5, *v)?;
        };
        for v in &self.bools {
            os.write_bool(6, *v)?;
        };
        for v in &self.uint64s {
            os.write_uint64(7, *v)?;
        };
        for v in &self.strings {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_DebugOverlay {
        CNETMsg_DebugOverlay::new()
    }

    fn clear(&mut self) {
        self.etype = ::std::option::Option::None;
        self.vectors.clear();
        self.colors.clear();
        self.dimensions.clear();
        self.times.clear();
        self.bools.clear();
        self.uint64s.clear();
        self.strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_DebugOverlay {
        static instance: CNETMsg_DebugOverlay = CNETMsg_DebugOverlay {
            etype: ::std::option::Option::None,
            vectors: ::std::vec::Vec::new(),
            colors: ::std::vec::Vec::new(),
            dimensions: ::std::vec::Vec::new(),
            times: ::std::vec::Vec::new(),
            bools: ::std::vec::Vec::new(),
            uint64s: ::std::vec::Vec::new(),
            strings: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SignonState_t)
pub enum SignonState_t {
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_NONE)
    SIGNONSTATE_NONE = 0,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_CHALLENGE)
    SIGNONSTATE_CHALLENGE = 1,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_CONNECTED)
    SIGNONSTATE_CONNECTED = 2,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_NEW)
    SIGNONSTATE_NEW = 3,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_PRESPAWN)
    SIGNONSTATE_PRESPAWN = 4,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_SPAWN)
    SIGNONSTATE_SPAWN = 5,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_FULL)
    SIGNONSTATE_FULL = 6,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_CHANGELEVEL)
    SIGNONSTATE_CHANGELEVEL = 7,
}

impl ::steam_vent_proto_common::protobuf::Enum for SignonState_t {
    const NAME: &'static str = "SignonState_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SignonState_t> {
        match value {
            0 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NONE),
            1 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHALLENGE),
            2 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CONNECTED),
            3 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NEW),
            4 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_PRESPAWN),
            5 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_SPAWN),
            6 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_FULL),
            7 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHANGELEVEL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SignonState_t> {
        match str {
            "SIGNONSTATE_NONE" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NONE),
            "SIGNONSTATE_CHALLENGE" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHALLENGE),
            "SIGNONSTATE_CONNECTED" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CONNECTED),
            "SIGNONSTATE_NEW" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NEW),
            "SIGNONSTATE_PRESPAWN" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_PRESPAWN),
            "SIGNONSTATE_SPAWN" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_SPAWN),
            "SIGNONSTATE_FULL" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_FULL),
            "SIGNONSTATE_CHANGELEVEL" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHANGELEVEL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SignonState_t] = &[
        SignonState_t::SIGNONSTATE_NONE,
        SignonState_t::SIGNONSTATE_CHALLENGE,
        SignonState_t::SIGNONSTATE_CONNECTED,
        SignonState_t::SIGNONSTATE_NEW,
        SignonState_t::SIGNONSTATE_PRESPAWN,
        SignonState_t::SIGNONSTATE_SPAWN,
        SignonState_t::SIGNONSTATE_FULL,
        SignonState_t::SIGNONSTATE_CHANGELEVEL,
    ];
}

impl ::std::default::Default for SignonState_t {
    fn default() -> Self {
        SignonState_t::SIGNONSTATE_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:NET_Messages)
pub enum NET_Messages {
    // @@protoc_insertion_point(enum_value:NET_Messages.net_NOP)
    net_NOP = 0,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_Disconnect_Legacy)
    net_Disconnect_Legacy = 1,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SplitScreenUser)
    net_SplitScreenUser = 3,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_Tick)
    net_Tick = 4,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_StringCmd)
    net_StringCmd = 5,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SetConVar)
    net_SetConVar = 6,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SignonState)
    net_SignonState = 7,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_Load)
    net_SpawnGroup_Load = 8,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_ManifestUpdate)
    net_SpawnGroup_ManifestUpdate = 9,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_SetCreationTick)
    net_SpawnGroup_SetCreationTick = 11,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_Unload)
    net_SpawnGroup_Unload = 12,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_LoadCompleted)
    net_SpawnGroup_LoadCompleted = 13,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_DebugOverlay)
    net_DebugOverlay = 15,
}

impl ::steam_vent_proto_common::protobuf::Enum for NET_Messages {
    const NAME: &'static str = "NET_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NET_Messages> {
        match value {
            0 => ::std::option::Option::Some(NET_Messages::net_NOP),
            1 => ::std::option::Option::Some(NET_Messages::net_Disconnect_Legacy),
            3 => ::std::option::Option::Some(NET_Messages::net_SplitScreenUser),
            4 => ::std::option::Option::Some(NET_Messages::net_Tick),
            5 => ::std::option::Option::Some(NET_Messages::net_StringCmd),
            6 => ::std::option::Option::Some(NET_Messages::net_SetConVar),
            7 => ::std::option::Option::Some(NET_Messages::net_SignonState),
            8 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Load),
            9 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_ManifestUpdate),
            11 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_SetCreationTick),
            12 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Unload),
            13 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_LoadCompleted),
            15 => ::std::option::Option::Some(NET_Messages::net_DebugOverlay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NET_Messages> {
        match str {
            "net_NOP" => ::std::option::Option::Some(NET_Messages::net_NOP),
            "net_Disconnect_Legacy" => ::std::option::Option::Some(NET_Messages::net_Disconnect_Legacy),
            "net_SplitScreenUser" => ::std::option::Option::Some(NET_Messages::net_SplitScreenUser),
            "net_Tick" => ::std::option::Option::Some(NET_Messages::net_Tick),
            "net_StringCmd" => ::std::option::Option::Some(NET_Messages::net_StringCmd),
            "net_SetConVar" => ::std::option::Option::Some(NET_Messages::net_SetConVar),
            "net_SignonState" => ::std::option::Option::Some(NET_Messages::net_SignonState),
            "net_SpawnGroup_Load" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Load),
            "net_SpawnGroup_ManifestUpdate" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_ManifestUpdate),
            "net_SpawnGroup_SetCreationTick" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_SetCreationTick),
            "net_SpawnGroup_Unload" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Unload),
            "net_SpawnGroup_LoadCompleted" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_LoadCompleted),
            "net_DebugOverlay" => ::std::option::Option::Some(NET_Messages::net_DebugOverlay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NET_Messages] = &[
        NET_Messages::net_NOP,
        NET_Messages::net_Disconnect_Legacy,
        NET_Messages::net_SplitScreenUser,
        NET_Messages::net_Tick,
        NET_Messages::net_StringCmd,
        NET_Messages::net_SetConVar,
        NET_Messages::net_SignonState,
        NET_Messages::net_SpawnGroup_Load,
        NET_Messages::net_SpawnGroup_ManifestUpdate,
        NET_Messages::net_SpawnGroup_SetCreationTick,
        NET_Messages::net_SpawnGroup_Unload,
        NET_Messages::net_SpawnGroup_LoadCompleted,
        NET_Messages::net_DebugOverlay,
    ];
}

impl ::std::default::Default for NET_Messages {
    fn default() -> Self {
        NET_Messages::net_NOP
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SpawnGroupFlags_t)
pub enum SpawnGroupFlags_t {
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE)
    SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE = 1,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_DONT_SPAWN_ENTITIES)
    SPAWN_GROUP_DONT_SPAWN_ENTITIES = 2,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_SYNCHRONOUS_SPAWN)
    SPAWN_GROUP_SYNCHRONOUS_SPAWN = 4,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP)
    SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP = 8,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES)
    SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES = 16,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_BLOCK_UNTIL_LOADED)
    SPAWN_GROUP_BLOCK_UNTIL_LOADED = 64,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_LOAD_STREAMING_DATA)
    SPAWN_GROUP_LOAD_STREAMING_DATA = 128,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_CREATE_NEW_SCENE_WORLD)
    SPAWN_GROUP_CREATE_NEW_SCENE_WORLD = 256,
}

impl ::steam_vent_proto_common::protobuf::Enum for SpawnGroupFlags_t {
    const NAME: &'static str = "SpawnGroupFlags_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpawnGroupFlags_t> {
        match value {
            1 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE),
            2 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_DONT_SPAWN_ENTITIES),
            4 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_SYNCHRONOUS_SPAWN),
            8 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP),
            16 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES),
            64 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_BLOCK_UNTIL_LOADED),
            128 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_STREAMING_DATA),
            256 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_NEW_SCENE_WORLD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SpawnGroupFlags_t> {
        match str {
            "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE),
            "SPAWN_GROUP_DONT_SPAWN_ENTITIES" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_DONT_SPAWN_ENTITIES),
            "SPAWN_GROUP_SYNCHRONOUS_SPAWN" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_SYNCHRONOUS_SPAWN),
            "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP),
            "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES),
            "SPAWN_GROUP_BLOCK_UNTIL_LOADED" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_BLOCK_UNTIL_LOADED),
            "SPAWN_GROUP_LOAD_STREAMING_DATA" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_STREAMING_DATA),
            "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_NEW_SCENE_WORLD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SpawnGroupFlags_t] = &[
        SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE,
        SpawnGroupFlags_t::SPAWN_GROUP_DONT_SPAWN_ENTITIES,
        SpawnGroupFlags_t::SPAWN_GROUP_SYNCHRONOUS_SPAWN,
        SpawnGroupFlags_t::SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP,
        SpawnGroupFlags_t::SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES,
        SpawnGroupFlags_t::SPAWN_GROUP_BLOCK_UNTIL_LOADED,
        SpawnGroupFlags_t::SPAWN_GROUP_LOAD_STREAMING_DATA,
        SpawnGroupFlags_t::SPAWN_GROUP_CREATE_NEW_SCENE_WORLD,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SpawnGroupFlags_t {
    fn default() -> Self {
        SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::network_connection::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgVector {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgVector2D {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQAngle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuaternion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTransform {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRGBA {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CEntityMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsg_CVars {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_NOP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SplitScreenUser {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_Tick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_StringCmd {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SetConVar {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SignonState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_GameEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsgList_GameEvents {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SpawnGroup_Load {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SpawnGroup_ManifestUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SpawnGroup_SetCreationTick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SpawnGroup_Unload {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_SpawnGroup_LoadCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_GameSessionConfiguration {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CNETMsg_DebugOverlay {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
