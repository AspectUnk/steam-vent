// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `te.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgTEArmorRicochet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEArmorRicochet {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEArmorRicochet.pos)
    pub pos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEArmorRicochet.dir)
    pub dir: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEArmorRicochet.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEArmorRicochet {
    fn default() -> &'a CMsgTEArmorRicochet {
        <CMsgTEArmorRicochet as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEArmorRicochet {
    pub fn new() -> CMsgTEArmorRicochet {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEArmorRicochet {
    const NAME: &'static str = "CMsgTEArmorRicochet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dir)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dir.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEArmorRicochet {
        CMsgTEArmorRicochet::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.dir.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEArmorRicochet {
        static instance: CMsgTEArmorRicochet = CMsgTEArmorRicochet {
            pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dir: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBaseBeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBaseBeam {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.modelindex)
    pub modelindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.haloindex)
    pub haloindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.startframe)
    pub startframe: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.life)
    pub life: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.endwidth)
    pub endwidth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.fadelength)
    pub fadelength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.amplitude)
    pub amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.speed)
    pub speed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBaseBeam.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBaseBeam {
    fn default() -> &'a CMsgTEBaseBeam {
        <CMsgTEBaseBeam as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBaseBeam {
    pub fn new() -> CMsgTEBaseBeam {
        ::std::default::Default::default()
    }

    // optional fixed64 modelindex = 1;

    pub fn modelindex(&self) -> u64 {
        self.modelindex.unwrap_or(0)
    }

    pub fn clear_modelindex(&mut self) {
        self.modelindex = ::std::option::Option::None;
    }

    pub fn has_modelindex(&self) -> bool {
        self.modelindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modelindex(&mut self, v: u64) {
        self.modelindex = ::std::option::Option::Some(v);
    }

    // optional fixed64 haloindex = 2;

    pub fn haloindex(&self) -> u64 {
        self.haloindex.unwrap_or(0)
    }

    pub fn clear_haloindex(&mut self) {
        self.haloindex = ::std::option::Option::None;
    }

    pub fn has_haloindex(&self) -> bool {
        self.haloindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_haloindex(&mut self, v: u64) {
        self.haloindex = ::std::option::Option::Some(v);
    }

    // optional uint32 startframe = 3;

    pub fn startframe(&self) -> u32 {
        self.startframe.unwrap_or(0)
    }

    pub fn clear_startframe(&mut self) {
        self.startframe = ::std::option::Option::None;
    }

    pub fn has_startframe(&self) -> bool {
        self.startframe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startframe(&mut self, v: u32) {
        self.startframe = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate = 4;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional float life = 5;

    pub fn life(&self) -> f32 {
        self.life.unwrap_or(0.)
    }

    pub fn clear_life(&mut self) {
        self.life = ::std::option::Option::None;
    }

    pub fn has_life(&self) -> bool {
        self.life.is_some()
    }

    // Param is passed by value, moved
    pub fn set_life(&mut self, v: f32) {
        self.life = ::std::option::Option::Some(v);
    }

    // optional float width = 6;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float endwidth = 7;

    pub fn endwidth(&self) -> f32 {
        self.endwidth.unwrap_or(0.)
    }

    pub fn clear_endwidth(&mut self) {
        self.endwidth = ::std::option::Option::None;
    }

    pub fn has_endwidth(&self) -> bool {
        self.endwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endwidth(&mut self, v: f32) {
        self.endwidth = ::std::option::Option::Some(v);
    }

    // optional uint32 fadelength = 8;

    pub fn fadelength(&self) -> u32 {
        self.fadelength.unwrap_or(0)
    }

    pub fn clear_fadelength(&mut self) {
        self.fadelength = ::std::option::Option::None;
    }

    pub fn has_fadelength(&self) -> bool {
        self.fadelength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fadelength(&mut self, v: u32) {
        self.fadelength = ::std::option::Option::Some(v);
    }

    // optional float amplitude = 9;

    pub fn amplitude(&self) -> f32 {
        self.amplitude.unwrap_or(0.)
    }

    pub fn clear_amplitude(&mut self) {
        self.amplitude = ::std::option::Option::None;
    }

    pub fn has_amplitude(&self) -> bool {
        self.amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amplitude(&mut self, v: f32) {
        self.amplitude = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 10;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 speed = 11;

    pub fn speed(&self) -> u32 {
        self.speed.unwrap_or(0)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: u32) {
        self.speed = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 12;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBaseBeam {
    const NAME: &'static str = "CMsgTEBaseBeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.modelindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.haloindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.startframe = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.life = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.endwidth = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.fadelength = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                88 => {
                    self.speed = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modelindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.haloindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.startframe {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.framerate {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.life {
            my_size += 1 + 4;
        }
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.endwidth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fadelength {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.modelindex {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.haloindex {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.startframe {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.life {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.width {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.endwidth {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.fadelength {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.amplitude {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.speed {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBaseBeam {
        CMsgTEBaseBeam::new()
    }

    fn clear(&mut self) {
        self.modelindex = ::std::option::Option::None;
        self.haloindex = ::std::option::Option::None;
        self.startframe = ::std::option::Option::None;
        self.framerate = ::std::option::Option::None;
        self.life = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.endwidth = ::std::option::Option::None;
        self.fadelength = ::std::option::Option::None;
        self.amplitude = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBaseBeam {
        static instance: CMsgTEBaseBeam = CMsgTEBaseBeam {
            modelindex: ::std::option::Option::None,
            haloindex: ::std::option::Option::None,
            startframe: ::std::option::Option::None,
            framerate: ::std::option::Option::None,
            life: ::std::option::Option::None,
            width: ::std::option::Option::None,
            endwidth: ::std::option::Option::None,
            fadelength: ::std::option::Option::None,
            amplitude: ::std::option::Option::None,
            color: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBeamEntPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamEntPoint {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.base)
    pub base: ::steam_vent_proto_common::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.startentity)
    pub startentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.endentity)
    pub endentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.start)
    pub start: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.end)
    pub end: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamEntPoint.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamEntPoint {
    fn default() -> &'a CMsgTEBeamEntPoint {
        <CMsgTEBeamEntPoint as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamEntPoint {
    pub fn new() -> CMsgTEBeamEntPoint {
        ::std::default::Default::default()
    }

    // optional uint32 startentity = 2;

    pub fn startentity(&self) -> u32 {
        self.startentity.unwrap_or(0)
    }

    pub fn clear_startentity(&mut self) {
        self.startentity = ::std::option::Option::None;
    }

    pub fn has_startentity(&self) -> bool {
        self.startentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startentity(&mut self, v: u32) {
        self.startentity = ::std::option::Option::Some(v);
    }

    // optional uint32 endentity = 3;

    pub fn endentity(&self) -> u32 {
        self.endentity.unwrap_or(0)
    }

    pub fn clear_endentity(&mut self) {
        self.endentity = ::std::option::Option::None;
    }

    pub fn has_endentity(&self) -> bool {
        self.endentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endentity(&mut self, v: u32) {
        self.endentity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBeamEntPoint {
    const NAME: &'static str = "CMsgTEBeamEntPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.startentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.endentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startentity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.endentity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.startentity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.endentity {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamEntPoint {
        CMsgTEBeamEntPoint::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.startentity = ::std::option::Option::None;
        self.endentity = ::std::option::Option::None;
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamEntPoint {
        static instance: CMsgTEBeamEntPoint = CMsgTEBeamEntPoint {
            base: ::steam_vent_proto_common::protobuf::MessageField::none(),
            startentity: ::std::option::Option::None,
            endentity: ::std::option::Option::None,
            start: ::steam_vent_proto_common::protobuf::MessageField::none(),
            end: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBeamEnts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamEnts {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamEnts.base)
    pub base: ::steam_vent_proto_common::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamEnts.startentity)
    pub startentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamEnts.endentity)
    pub endentity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamEnts.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamEnts {
    fn default() -> &'a CMsgTEBeamEnts {
        <CMsgTEBeamEnts as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamEnts {
    pub fn new() -> CMsgTEBeamEnts {
        ::std::default::Default::default()
    }

    // optional uint32 startentity = 2;

    pub fn startentity(&self) -> u32 {
        self.startentity.unwrap_or(0)
    }

    pub fn clear_startentity(&mut self) {
        self.startentity = ::std::option::Option::None;
    }

    pub fn has_startentity(&self) -> bool {
        self.startentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startentity(&mut self, v: u32) {
        self.startentity = ::std::option::Option::Some(v);
    }

    // optional uint32 endentity = 3;

    pub fn endentity(&self) -> u32 {
        self.endentity.unwrap_or(0)
    }

    pub fn clear_endentity(&mut self) {
        self.endentity = ::std::option::Option::None;
    }

    pub fn has_endentity(&self) -> bool {
        self.endentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endentity(&mut self, v: u32) {
        self.endentity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBeamEnts {
    const NAME: &'static str = "CMsgTEBeamEnts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.startentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.endentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startentity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.endentity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.startentity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.endentity {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamEnts {
        CMsgTEBeamEnts::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.startentity = ::std::option::Option::None;
        self.endentity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamEnts {
        static instance: CMsgTEBeamEnts = CMsgTEBeamEnts {
            base: ::steam_vent_proto_common::protobuf::MessageField::none(),
            startentity: ::std::option::Option::None,
            endentity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBeamPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamPoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamPoints.base)
    pub base: ::steam_vent_proto_common::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamPoints.start)
    pub start: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBeamPoints.end)
    pub end: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamPoints.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamPoints {
    fn default() -> &'a CMsgTEBeamPoints {
        <CMsgTEBeamPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamPoints {
    pub fn new() -> CMsgTEBeamPoints {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBeamPoints {
    const NAME: &'static str = "CMsgTEBeamPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamPoints {
        CMsgTEBeamPoints::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamPoints {
        static instance: CMsgTEBeamPoints = CMsgTEBeamPoints {
            base: ::steam_vent_proto_common::protobuf::MessageField::none(),
            start: ::steam_vent_proto_common::protobuf::MessageField::none(),
            end: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBeamRing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamRing {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamRing.base)
    pub base: ::steam_vent_proto_common::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamRing.startentity)
    pub startentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamRing.endentity)
    pub endentity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamRing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamRing {
    fn default() -> &'a CMsgTEBeamRing {
        <CMsgTEBeamRing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamRing {
    pub fn new() -> CMsgTEBeamRing {
        ::std::default::Default::default()
    }

    // optional uint32 startentity = 2;

    pub fn startentity(&self) -> u32 {
        self.startentity.unwrap_or(0)
    }

    pub fn clear_startentity(&mut self) {
        self.startentity = ::std::option::Option::None;
    }

    pub fn has_startentity(&self) -> bool {
        self.startentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startentity(&mut self, v: u32) {
        self.startentity = ::std::option::Option::Some(v);
    }

    // optional uint32 endentity = 3;

    pub fn endentity(&self) -> u32 {
        self.endentity.unwrap_or(0)
    }

    pub fn clear_endentity(&mut self) {
        self.endentity = ::std::option::Option::None;
    }

    pub fn has_endentity(&self) -> bool {
        self.endentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endentity(&mut self, v: u32) {
        self.endentity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBeamRing {
    const NAME: &'static str = "CMsgTEBeamRing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.startentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.endentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startentity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.endentity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.startentity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.endentity {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamRing {
        CMsgTEBeamRing::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.startentity = ::std::option::Option::None;
        self.endentity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamRing {
        static instance: CMsgTEBeamRing = CMsgTEBeamRing {
            base: ::steam_vent_proto_common::protobuf::MessageField::none(),
            startentity: ::std::option::Option::None,
            endentity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBSPDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBSPDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.normal)
    pub normal: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.saxis)
    pub saxis: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.entity)
    pub entity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBSPDecal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBSPDecal {
    fn default() -> &'a CMsgTEBSPDecal {
        <CMsgTEBSPDecal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBSPDecal {
    pub fn new() -> CMsgTEBSPDecal {
        ::std::default::Default::default()
    }

    // optional int32 entity = 4;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional uint32 index = 5;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBSPDecal {
    const NAME: &'static str = "CMsgTEBSPDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.saxis)?;
                },
                32 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.saxis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.saxis.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.entity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBSPDecal {
        CMsgTEBSPDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.normal.clear();
        self.saxis.clear();
        self.entity = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBSPDecal {
        static instance: CMsgTEBSPDecal = CMsgTEBSPDecal {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            normal: ::steam_vent_proto_common::protobuf::MessageField::none(),
            saxis: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entity: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBubbles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBubbles {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBubbles.mins)
    pub mins: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.maxs)
    pub maxs: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.height)
    pub height: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.speed)
    pub speed: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBubbles.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBubbles {
    fn default() -> &'a CMsgTEBubbles {
        <CMsgTEBubbles as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBubbles {
    pub fn new() -> CMsgTEBubbles {
        ::std::default::Default::default()
    }

    // optional float height = 3;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 4;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional float speed = 5;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBubbles {
    const NAME: &'static str = "CMsgTEBubbles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.mins)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.maxs)?;
                },
                29 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mins.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mins.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxs.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.height {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBubbles {
        CMsgTEBubbles::new()
    }

    fn clear(&mut self) {
        self.mins.clear();
        self.maxs.clear();
        self.height = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBubbles {
        static instance: CMsgTEBubbles = CMsgTEBubbles {
            mins: ::steam_vent_proto_common::protobuf::MessageField::none(),
            maxs: ::steam_vent_proto_common::protobuf::MessageField::none(),
            height: ::std::option::Option::None,
            count: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBubbleTrail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBubbleTrail {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.mins)
    pub mins: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.maxs)
    pub maxs: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.waterz)
    pub waterz: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.speed)
    pub speed: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBubbleTrail.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBubbleTrail {
    fn default() -> &'a CMsgTEBubbleTrail {
        <CMsgTEBubbleTrail as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBubbleTrail {
    pub fn new() -> CMsgTEBubbleTrail {
        ::std::default::Default::default()
    }

    // optional float waterz = 3;

    pub fn waterz(&self) -> f32 {
        self.waterz.unwrap_or(0.)
    }

    pub fn clear_waterz(&mut self) {
        self.waterz = ::std::option::Option::None;
    }

    pub fn has_waterz(&self) -> bool {
        self.waterz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_waterz(&mut self, v: f32) {
        self.waterz = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 4;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional float speed = 5;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBubbleTrail {
    const NAME: &'static str = "CMsgTEBubbleTrail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.mins)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.maxs)?;
                },
                29 => {
                    self.waterz = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mins.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.waterz {
            my_size += 1 + 4;
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mins.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxs.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.waterz {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBubbleTrail {
        CMsgTEBubbleTrail::new()
    }

    fn clear(&mut self) {
        self.mins.clear();
        self.maxs.clear();
        self.waterz = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBubbleTrail {
        static instance: CMsgTEBubbleTrail = CMsgTEBubbleTrail {
            mins: ::steam_vent_proto_common::protobuf::MessageField::none(),
            maxs: ::steam_vent_proto_common::protobuf::MessageField::none(),
            waterz: ::std::option::Option::None,
            count: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEDecal.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEDecal.start)
    pub start: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEDecal.entity)
    pub entity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEDecal.hitbox)
    pub hitbox: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEDecal.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEDecal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEDecal {
    fn default() -> &'a CMsgTEDecal {
        <CMsgTEDecal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEDecal {
    pub fn new() -> CMsgTEDecal {
        ::std::default::Default::default()
    }

    // optional int32 entity = 3;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional uint32 hitbox = 4;

    pub fn hitbox(&self) -> u32 {
        self.hitbox.unwrap_or(0)
    }

    pub fn clear_hitbox(&mut self) {
        self.hitbox = ::std::option::Option::None;
    }

    pub fn has_hitbox(&self) -> bool {
        self.hitbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hitbox(&mut self, v: u32) {
        self.hitbox = ::std::option::Option::Some(v);
    }

    // optional uint32 index = 5;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEDecal {
    const NAME: &'static str = "CMsgTEDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                24 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.hitbox = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.hitbox {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.entity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hitbox {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEDecal {
        CMsgTEDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.start.clear();
        self.entity = ::std::option::Option::None;
        self.hitbox = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEDecal {
        static instance: CMsgTEDecal = CMsgTEDecal {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            start: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entity: ::std::option::Option::None,
            hitbox: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEffectData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEffectData {
    // message fields
    // @@protoc_insertion_point(field:CMsgEffectData.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgEffectData.start)
    pub start: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgEffectData.normal)
    pub normal: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgEffectData.angles)
    pub angles: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgEffectData.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.otherentity)
    pub otherentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEffectData.magnitude)
    pub magnitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEffectData.radius)
    pub radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEffectData.surfaceprop)
    pub surfaceprop: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.effectindex)
    pub effectindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgEffectData.damagetype)
    pub damagetype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.material)
    pub material: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.hitbox)
    pub hitbox: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.attachmentindex)
    pub attachmentindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgEffectData.effectname)
    pub effectname: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.attachmentname)
    pub attachmentname: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEffectData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEffectData {
    fn default() -> &'a CMsgEffectData {
        <CMsgEffectData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgEffectData {
    pub fn new() -> CMsgEffectData {
        ::std::default::Default::default()
    }

    // optional fixed32 entity = 5;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(16777215u32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional fixed32 otherentity = 6;

    pub fn otherentity(&self) -> u32 {
        self.otherentity.unwrap_or(16777215u32)
    }

    pub fn clear_otherentity(&mut self) {
        self.otherentity = ::std::option::Option::None;
    }

    pub fn has_otherentity(&self) -> bool {
        self.otherentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otherentity(&mut self, v: u32) {
        self.otherentity = ::std::option::Option::Some(v);
    }

    // optional float scale = 7;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float magnitude = 8;

    pub fn magnitude(&self) -> f32 {
        self.magnitude.unwrap_or(0.)
    }

    pub fn clear_magnitude(&mut self) {
        self.magnitude = ::std::option::Option::None;
    }

    pub fn has_magnitude(&self) -> bool {
        self.magnitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magnitude(&mut self, v: f32) {
        self.magnitude = ::std::option::Option::Some(v);
    }

    // optional float radius = 9;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional fixed32 surfaceprop = 10;

    pub fn surfaceprop(&self) -> u32 {
        self.surfaceprop.unwrap_or(0)
    }

    pub fn clear_surfaceprop(&mut self) {
        self.surfaceprop = ::std::option::Option::None;
    }

    pub fn has_surfaceprop(&self) -> bool {
        self.surfaceprop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surfaceprop(&mut self, v: u32) {
        self.surfaceprop = ::std::option::Option::Some(v);
    }

    // optional fixed64 effectindex = 11;

    pub fn effectindex(&self) -> u64 {
        self.effectindex.unwrap_or(0)
    }

    pub fn clear_effectindex(&mut self) {
        self.effectindex = ::std::option::Option::None;
    }

    pub fn has_effectindex(&self) -> bool {
        self.effectindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effectindex(&mut self, v: u64) {
        self.effectindex = ::std::option::Option::Some(v);
    }

    // optional uint32 damagetype = 12;

    pub fn damagetype(&self) -> u32 {
        self.damagetype.unwrap_or(0)
    }

    pub fn clear_damagetype(&mut self) {
        self.damagetype = ::std::option::Option::None;
    }

    pub fn has_damagetype(&self) -> bool {
        self.damagetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damagetype(&mut self, v: u32) {
        self.damagetype = ::std::option::Option::Some(v);
    }

    // optional uint32 material = 13;

    pub fn material(&self) -> u32 {
        self.material.unwrap_or(0)
    }

    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: u32) {
        self.material = ::std::option::Option::Some(v);
    }

    // optional uint32 hitbox = 14;

    pub fn hitbox(&self) -> u32 {
        self.hitbox.unwrap_or(0)
    }

    pub fn clear_hitbox(&mut self) {
        self.hitbox = ::std::option::Option::None;
    }

    pub fn has_hitbox(&self) -> bool {
        self.hitbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hitbox(&mut self, v: u32) {
        self.hitbox = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 15;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 16;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional int32 attachmentindex = 17;

    pub fn attachmentindex(&self) -> i32 {
        self.attachmentindex.unwrap_or(0)
    }

    pub fn clear_attachmentindex(&mut self) {
        self.attachmentindex = ::std::option::Option::None;
    }

    pub fn has_attachmentindex(&self) -> bool {
        self.attachmentindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentindex(&mut self, v: i32) {
        self.attachmentindex = ::std::option::Option::Some(v);
    }

    // optional uint32 effectname = 18;

    pub fn effectname(&self) -> u32 {
        self.effectname.unwrap_or(0)
    }

    pub fn clear_effectname(&mut self) {
        self.effectname = ::std::option::Option::None;
    }

    pub fn has_effectname(&self) -> bool {
        self.effectname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effectname(&mut self, v: u32) {
        self.effectname = ::std::option::Option::Some(v);
    }

    // optional uint32 attachmentname = 19;

    pub fn attachmentname(&self) -> u32 {
        self.attachmentname.unwrap_or(0)
    }

    pub fn clear_attachmentname(&mut self) {
        self.attachmentname = ::std::option::Option::None;
    }

    pub fn has_attachmentname(&self) -> bool {
        self.attachmentname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentname(&mut self, v: u32) {
        self.attachmentname = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgEffectData {
    const NAME: &'static str = "CMsgEffectData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                45 => {
                    self.entity = ::std::option::Option::Some(is.read_fixed32()?);
                },
                53 => {
                    self.otherentity = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.magnitude = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.surfaceprop = ::std::option::Option::Some(is.read_fixed32()?);
                },
                89 => {
                    self.effectindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                96 => {
                    self.damagetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.material = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.hitbox = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.attachmentindex = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.effectname = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.attachmentname = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity {
            my_size += 1 + 4;
        }
        if let Some(v) = self.otherentity {
            my_size += 1 + 4;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.magnitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.surfaceprop {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effectindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.damagetype {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.material {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.hitbox {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.attachmentindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.effectname {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.attachmentname {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.entity {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.otherentity {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.magnitude {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.surfaceprop {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.effectindex {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.damagetype {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.material {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.hitbox {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.attachmentindex {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.effectname {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.attachmentname {
            os.write_uint32(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEffectData {
        CMsgEffectData::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.start.clear();
        self.normal.clear();
        self.angles.clear();
        self.entity = ::std::option::Option::None;
        self.otherentity = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.magnitude = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.surfaceprop = ::std::option::Option::None;
        self.effectindex = ::std::option::Option::None;
        self.damagetype = ::std::option::Option::None;
        self.material = ::std::option::Option::None;
        self.hitbox = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.attachmentindex = ::std::option::Option::None;
        self.effectname = ::std::option::Option::None;
        self.attachmentname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEffectData {
        static instance: CMsgEffectData = CMsgEffectData {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            start: ::steam_vent_proto_common::protobuf::MessageField::none(),
            normal: ::steam_vent_proto_common::protobuf::MessageField::none(),
            angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entity: ::std::option::Option::None,
            otherentity: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            magnitude: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            surfaceprop: ::std::option::Option::None,
            effectindex: ::std::option::Option::None,
            damagetype: ::std::option::Option::None,
            material: ::std::option::Option::None,
            hitbox: ::std::option::Option::None,
            color: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            attachmentindex: ::std::option::Option::None,
            effectname: ::std::option::Option::None,
            attachmentname: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEEffectDispatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEEffectDispatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEEffectDispatch.effectdata)
    pub effectdata: ::steam_vent_proto_common::protobuf::MessageField<CMsgEffectData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEEffectDispatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEEffectDispatch {
    fn default() -> &'a CMsgTEEffectDispatch {
        <CMsgTEEffectDispatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEEffectDispatch {
    pub fn new() -> CMsgTEEffectDispatch {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEEffectDispatch {
    const NAME: &'static str = "CMsgTEEffectDispatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.effectdata)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.effectdata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.effectdata.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEEffectDispatch {
        CMsgTEEffectDispatch::new()
    }

    fn clear(&mut self) {
        self.effectdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEEffectDispatch {
        static instance: CMsgTEEffectDispatch = CMsgTEEffectDispatch {
            effectdata: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEEnergySplash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEEnergySplash {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEEnergySplash.pos)
    pub pos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEEnergySplash.dir)
    pub dir: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEEnergySplash.explosive)
    pub explosive: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEEnergySplash.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEEnergySplash {
    fn default() -> &'a CMsgTEEnergySplash {
        <CMsgTEEnergySplash as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEEnergySplash {
    pub fn new() -> CMsgTEEnergySplash {
        ::std::default::Default::default()
    }

    // optional bool explosive = 3;

    pub fn explosive(&self) -> bool {
        self.explosive.unwrap_or(false)
    }

    pub fn clear_explosive(&mut self) {
        self.explosive = ::std::option::Option::None;
    }

    pub fn has_explosive(&self) -> bool {
        self.explosive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explosive(&mut self, v: bool) {
        self.explosive = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEEnergySplash {
    const NAME: &'static str = "CMsgTEEnergySplash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dir)?;
                },
                24 => {
                    self.explosive = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.explosive {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dir.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.explosive {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEEnergySplash {
        CMsgTEEnergySplash::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.dir.clear();
        self.explosive = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEEnergySplash {
        static instance: CMsgTEEnergySplash = CMsgTEEnergySplash {
            pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dir: ::steam_vent_proto_common::protobuf::MessageField::none(),
            explosive: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEFizz)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEFizz {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEFizz.entity)
    pub entity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEFizz.density)
    pub density: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEFizz.current)
    pub current: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEFizz.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEFizz {
    fn default() -> &'a CMsgTEFizz {
        <CMsgTEFizz as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEFizz {
    pub fn new() -> CMsgTEFizz {
        ::std::default::Default::default()
    }

    // optional int32 entity = 1;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional uint32 density = 2;

    pub fn density(&self) -> u32 {
        self.density.unwrap_or(0)
    }

    pub fn clear_density(&mut self) {
        self.density = ::std::option::Option::None;
    }

    pub fn has_density(&self) -> bool {
        self.density.is_some()
    }

    // Param is passed by value, moved
    pub fn set_density(&mut self, v: u32) {
        self.density = ::std::option::Option::Some(v);
    }

    // optional int32 current = 3;

    pub fn current(&self) -> i32 {
        self.current.unwrap_or(0)
    }

    pub fn clear_current(&mut self) {
        self.current = ::std::option::Option::None;
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: i32) {
        self.current = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEFizz {
    const NAME: &'static str = "CMsgTEFizz";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.density = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.current = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.density {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.current {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.density {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.current {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEFizz {
        CMsgTEFizz::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.density = ::std::option::Option::None;
        self.current = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEFizz {
        static instance: CMsgTEFizz = CMsgTEFizz {
            entity: ::std::option::Option::None,
            density: ::std::option::Option::None,
            current: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEShatterSurface)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEShatterSurface {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.angles)
    pub angles: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.force)
    pub force: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.forcepos)
    pub forcepos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.height)
    pub height: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.shardsize)
    pub shardsize: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.surfacetype)
    pub surfacetype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.frontcolor)
    pub frontcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.backcolor)
    pub backcolor: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEShatterSurface.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEShatterSurface {
    fn default() -> &'a CMsgTEShatterSurface {
        <CMsgTEShatterSurface as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEShatterSurface {
    pub fn new() -> CMsgTEShatterSurface {
        ::std::default::Default::default()
    }

    // optional float width = 5;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float height = 6;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional float shardsize = 7;

    pub fn shardsize(&self) -> f32 {
        self.shardsize.unwrap_or(0.)
    }

    pub fn clear_shardsize(&mut self) {
        self.shardsize = ::std::option::Option::None;
    }

    pub fn has_shardsize(&self) -> bool {
        self.shardsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shardsize(&mut self, v: f32) {
        self.shardsize = ::std::option::Option::Some(v);
    }

    // optional uint32 surfacetype = 8;

    pub fn surfacetype(&self) -> u32 {
        self.surfacetype.unwrap_or(0)
    }

    pub fn clear_surfacetype(&mut self) {
        self.surfacetype = ::std::option::Option::None;
    }

    pub fn has_surfacetype(&self) -> bool {
        self.surfacetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surfacetype(&mut self, v: u32) {
        self.surfacetype = ::std::option::Option::Some(v);
    }

    // optional fixed32 frontcolor = 9;

    pub fn frontcolor(&self) -> u32 {
        self.frontcolor.unwrap_or(0)
    }

    pub fn clear_frontcolor(&mut self) {
        self.frontcolor = ::std::option::Option::None;
    }

    pub fn has_frontcolor(&self) -> bool {
        self.frontcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frontcolor(&mut self, v: u32) {
        self.frontcolor = ::std::option::Option::Some(v);
    }

    // optional fixed32 backcolor = 10;

    pub fn backcolor(&self) -> u32 {
        self.backcolor.unwrap_or(0)
    }

    pub fn clear_backcolor(&mut self) {
        self.backcolor = ::std::option::Option::None;
    }

    pub fn has_backcolor(&self) -> bool {
        self.backcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backcolor(&mut self, v: u32) {
        self.backcolor = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEShatterSurface {
    const NAME: &'static str = "CMsgTEShatterSurface";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.force)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.forcepos)?;
                },
                45 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.shardsize = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.surfacetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.frontcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                85 => {
                    self.backcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.force.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.forcepos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shardsize {
            my_size += 1 + 4;
        }
        if let Some(v) = self.surfacetype {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.frontcolor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.backcolor {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.force.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.forcepos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.width {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.shardsize {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.surfacetype {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.frontcolor {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.backcolor {
            os.write_fixed32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEShatterSurface {
        CMsgTEShatterSurface::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.angles.clear();
        self.force.clear();
        self.forcepos.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.shardsize = ::std::option::Option::None;
        self.surfacetype = ::std::option::Option::None;
        self.frontcolor = ::std::option::Option::None;
        self.backcolor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEShatterSurface {
        static instance: CMsgTEShatterSurface = CMsgTEShatterSurface {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
            force: ::steam_vent_proto_common::protobuf::MessageField::none(),
            forcepos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            shardsize: ::std::option::Option::None,
            surfacetype: ::std::option::Option::None,
            frontcolor: ::std::option::Option::None,
            backcolor: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEGlowSprite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEGlowSprite {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.life)
    pub life: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.brightness)
    pub brightness: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEGlowSprite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEGlowSprite {
    fn default() -> &'a CMsgTEGlowSprite {
        <CMsgTEGlowSprite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEGlowSprite {
    pub fn new() -> CMsgTEGlowSprite {
        ::std::default::Default::default()
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float life = 3;

    pub fn life(&self) -> f32 {
        self.life.unwrap_or(0.)
    }

    pub fn clear_life(&mut self) {
        self.life = ::std::option::Option::None;
    }

    pub fn has_life(&self) -> bool {
        self.life.is_some()
    }

    // Param is passed by value, moved
    pub fn set_life(&mut self, v: f32) {
        self.life = ::std::option::Option::Some(v);
    }

    // optional uint32 brightness = 4;

    pub fn brightness(&self) -> u32 {
        self.brightness.unwrap_or(0)
    }

    pub fn clear_brightness(&mut self) {
        self.brightness = ::std::option::Option::None;
    }

    pub fn has_brightness(&self) -> bool {
        self.brightness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: u32) {
        self.brightness = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEGlowSprite {
    const NAME: &'static str = "CMsgTEGlowSprite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.life = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.brightness = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.life {
            my_size += 1 + 4;
        }
        if let Some(v) = self.brightness {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.life {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.brightness {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEGlowSprite {
        CMsgTEGlowSprite::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.scale = ::std::option::Option::None;
        self.life = ::std::option::Option::None;
        self.brightness = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEGlowSprite {
        static instance: CMsgTEGlowSprite = CMsgTEGlowSprite {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            life: ::std::option::Option::None,
            brightness: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEImpact)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEImpact {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEImpact.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEImpact.normal)
    pub normal: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEImpact.type)
    pub type_: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEImpact.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEImpact {
    fn default() -> &'a CMsgTEImpact {
        <CMsgTEImpact as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEImpact {
    pub fn new() -> CMsgTEImpact {
        ::std::default::Default::default()
    }

    // optional uint32 type = 3;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEImpact {
    const NAME: &'static str = "CMsgTEImpact";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEImpact {
        CMsgTEImpact::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.normal.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEImpact {
        static instance: CMsgTEImpact = CMsgTEImpact {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            normal: ::steam_vent_proto_common::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEMuzzleFlash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEMuzzleFlash {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.angles)
    pub angles: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.type)
    pub type_: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEMuzzleFlash.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEMuzzleFlash {
    fn default() -> &'a CMsgTEMuzzleFlash {
        <CMsgTEMuzzleFlash as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEMuzzleFlash {
    pub fn new() -> CMsgTEMuzzleFlash {
        ::std::default::Default::default()
    }

    // optional float scale = 3;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 4;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEMuzzleFlash {
    const NAME: &'static str = "CMsgTEMuzzleFlash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                29 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEMuzzleFlash {
        CMsgTEMuzzleFlash::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.angles.clear();
        self.scale = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEMuzzleFlash {
        static instance: CMsgTEMuzzleFlash = CMsgTEMuzzleFlash {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEBloodStream)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBloodStream {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBloodStream.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBloodStream.direction)
    pub direction: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBloodStream.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBloodStream.amount)
    pub amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBloodStream.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBloodStream {
    fn default() -> &'a CMsgTEBloodStream {
        <CMsgTEBloodStream as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBloodStream {
    pub fn new() -> CMsgTEBloodStream {
        ::std::default::Default::default()
    }

    // optional fixed32 color = 3;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 amount = 4;

    pub fn amount(&self) -> u32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u32) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEBloodStream {
    const NAME: &'static str = "CMsgTEBloodStream";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                29 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBloodStream {
        CMsgTEBloodStream::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.direction.clear();
        self.color = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBloodStream {
        static instance: CMsgTEBloodStream = CMsgTEBloodStream {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            direction: ::steam_vent_proto_common::protobuf::MessageField::none(),
            color: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEExplosion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEExplosion {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEExplosion.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.normal)
    pub normal: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.materialtype)
    pub materialtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.radius)
    pub radius: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.magnitude)
    pub magnitude: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.affect_ragdolls)
    pub affect_ragdolls: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.effect_name)
    pub effect_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.explosion_type)
    pub explosion_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEExplosion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEExplosion {
    fn default() -> &'a CMsgTEExplosion {
        <CMsgTEExplosion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEExplosion {
    pub fn new() -> CMsgTEExplosion {
        ::std::default::Default::default()
    }

    // optional uint32 framerate = 2;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 3;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 materialtype = 5;

    pub fn materialtype(&self) -> u32 {
        self.materialtype.unwrap_or(0)
    }

    pub fn clear_materialtype(&mut self) {
        self.materialtype = ::std::option::Option::None;
    }

    pub fn has_materialtype(&self) -> bool {
        self.materialtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_materialtype(&mut self, v: u32) {
        self.materialtype = ::std::option::Option::Some(v);
    }

    // optional uint32 radius = 6;

    pub fn radius(&self) -> u32 {
        self.radius.unwrap_or(0)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: u32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional uint32 magnitude = 7;

    pub fn magnitude(&self) -> u32 {
        self.magnitude.unwrap_or(0)
    }

    pub fn clear_magnitude(&mut self) {
        self.magnitude = ::std::option::Option::None;
    }

    pub fn has_magnitude(&self) -> bool {
        self.magnitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magnitude(&mut self, v: u32) {
        self.magnitude = ::std::option::Option::Some(v);
    }

    // optional float scale = 8;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional bool affect_ragdolls = 9;

    pub fn affect_ragdolls(&self) -> bool {
        self.affect_ragdolls.unwrap_or(false)
    }

    pub fn clear_affect_ragdolls(&mut self) {
        self.affect_ragdolls = ::std::option::Option::None;
    }

    pub fn has_affect_ragdolls(&self) -> bool {
        self.affect_ragdolls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affect_ragdolls(&mut self, v: bool) {
        self.affect_ragdolls = ::std::option::Option::Some(v);
    }

    // optional string effect_name = 10;

    pub fn effect_name(&self) -> &str {
        match self.effect_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_effect_name(&mut self) {
        self.effect_name = ::std::option::Option::None;
    }

    pub fn has_effect_name(&self) -> bool {
        self.effect_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_name(&mut self, v: ::std::string::String) {
        self.effect_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect_name(&mut self) -> &mut ::std::string::String {
        if self.effect_name.is_none() {
            self.effect_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.effect_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect_name(&mut self) -> ::std::string::String {
        self.effect_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 explosion_type = 11;

    pub fn explosion_type(&self) -> u32 {
        self.explosion_type.unwrap_or(0)
    }

    pub fn clear_explosion_type(&mut self) {
        self.explosion_type = ::std::option::Option::None;
    }

    pub fn has_explosion_type(&self) -> bool {
        self.explosion_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explosion_type(&mut self, v: u32) {
        self.explosion_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEExplosion {
    const NAME: &'static str = "CMsgTEExplosion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                40 => {
                    self.materialtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.radius = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.magnitude = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.affect_ragdolls = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.effect_name = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.explosion_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.framerate {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.materialtype {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.radius {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.magnitude {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.affect_ragdolls {
            my_size += 1 + 1;
        }
        if let Some(v) = self.effect_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.explosion_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.materialtype {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.radius {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.magnitude {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.affect_ragdolls {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.effect_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.explosion_type {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEExplosion {
        CMsgTEExplosion::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.framerate = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.normal.clear();
        self.materialtype = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.magnitude = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.affect_ragdolls = ::std::option::Option::None;
        self.effect_name = ::std::option::Option::None;
        self.explosion_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEExplosion {
        static instance: CMsgTEExplosion = CMsgTEExplosion {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            framerate: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            normal: ::steam_vent_proto_common::protobuf::MessageField::none(),
            materialtype: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            magnitude: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            affect_ragdolls: ::std::option::Option::None,
            effect_name: ::std::option::Option::None,
            explosion_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEDust)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEDust {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEDust.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEDust.size)
    pub size: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEDust.speed)
    pub speed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEDust.direction)
    pub direction: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEDust.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEDust {
    fn default() -> &'a CMsgTEDust {
        <CMsgTEDust as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEDust {
    pub fn new() -> CMsgTEDust {
        ::std::default::Default::default()
    }

    // optional float size = 2;

    pub fn size(&self) -> f32 {
        self.size.unwrap_or(0.)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: f32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional float speed = 3;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEDust {
    const NAME: &'static str = "CMsgTEDust";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                21 => {
                    self.size = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += 1 + 4;
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.size {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEDust {
        CMsgTEDust::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.size = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.direction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEDust {
        static instance: CMsgTEDust = CMsgTEDust {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            size: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            direction: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTELargeFunnel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTELargeFunnel {
    // message fields
    // @@protoc_insertion_point(field:CMsgTELargeFunnel.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTELargeFunnel.reversed)
    pub reversed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTELargeFunnel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTELargeFunnel {
    fn default() -> &'a CMsgTELargeFunnel {
        <CMsgTELargeFunnel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTELargeFunnel {
    pub fn new() -> CMsgTELargeFunnel {
        ::std::default::Default::default()
    }

    // optional uint32 reversed = 2;

    pub fn reversed(&self) -> u32 {
        self.reversed.unwrap_or(0)
    }

    pub fn clear_reversed(&mut self) {
        self.reversed = ::std::option::Option::None;
    }

    pub fn has_reversed(&self) -> bool {
        self.reversed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reversed(&mut self, v: u32) {
        self.reversed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTELargeFunnel {
    const NAME: &'static str = "CMsgTELargeFunnel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.reversed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reversed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.reversed {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTELargeFunnel {
        CMsgTELargeFunnel::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.reversed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTELargeFunnel {
        static instance: CMsgTELargeFunnel = CMsgTELargeFunnel {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            reversed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTESparks)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTESparks {
    // message fields
    // @@protoc_insertion_point(field:CMsgTESparks.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTESparks.magnitude)
    pub magnitude: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTESparks.length)
    pub length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTESparks.direction)
    pub direction: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTESparks.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTESparks {
    fn default() -> &'a CMsgTESparks {
        <CMsgTESparks as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTESparks {
    pub fn new() -> CMsgTESparks {
        ::std::default::Default::default()
    }

    // optional uint32 magnitude = 2;

    pub fn magnitude(&self) -> u32 {
        self.magnitude.unwrap_or(0)
    }

    pub fn clear_magnitude(&mut self) {
        self.magnitude = ::std::option::Option::None;
    }

    pub fn has_magnitude(&self) -> bool {
        self.magnitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magnitude(&mut self, v: u32) {
        self.magnitude = ::std::option::Option::Some(v);
    }

    // optional uint32 length = 3;

    pub fn length(&self) -> u32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTESparks {
    const NAME: &'static str = "CMsgTESparks";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.magnitude = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.length = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.magnitude {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.length {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.magnitude {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTESparks {
        CMsgTESparks::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.magnitude = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.direction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTESparks {
        static instance: CMsgTESparks = CMsgTESparks {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            magnitude: ::std::option::Option::None,
            length: ::std::option::Option::None,
            direction: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEPhysicsProp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEPhysicsProp {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.velocity)
    pub velocity: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.angles)
    pub angles: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.skin)
    pub skin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.effects)
    pub effects: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.modelindex)
    pub modelindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.unused_breakmodelsnottomake)
    pub unused_breakmodelsnottomake: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.dmgpos)
    pub dmgpos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.dmgdir)
    pub dmgdir: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.dmgtype)
    pub dmgtype: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEPhysicsProp.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEPhysicsProp {
    fn default() -> &'a CMsgTEPhysicsProp {
        <CMsgTEPhysicsProp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEPhysicsProp {
    pub fn new() -> CMsgTEPhysicsProp {
        ::std::default::Default::default()
    }

    // optional fixed32 skin = 4;

    pub fn skin(&self) -> u32 {
        self.skin.unwrap_or(0)
    }

    pub fn clear_skin(&mut self) {
        self.skin = ::std::option::Option::None;
    }

    pub fn has_skin(&self) -> bool {
        self.skin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skin(&mut self, v: u32) {
        self.skin = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 effects = 6;

    pub fn effects(&self) -> u32 {
        self.effects.unwrap_or(0)
    }

    pub fn clear_effects(&mut self) {
        self.effects = ::std::option::Option::None;
    }

    pub fn has_effects(&self) -> bool {
        self.effects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: u32) {
        self.effects = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 7;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional fixed64 modelindex = 8;

    pub fn modelindex(&self) -> u64 {
        self.modelindex.unwrap_or(0)
    }

    pub fn clear_modelindex(&mut self) {
        self.modelindex = ::std::option::Option::None;
    }

    pub fn has_modelindex(&self) -> bool {
        self.modelindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modelindex(&mut self, v: u64) {
        self.modelindex = ::std::option::Option::Some(v);
    }

    // optional uint32 unused_breakmodelsnottomake = 9;

    pub fn unused_breakmodelsnottomake(&self) -> u32 {
        self.unused_breakmodelsnottomake.unwrap_or(0)
    }

    pub fn clear_unused_breakmodelsnottomake(&mut self) {
        self.unused_breakmodelsnottomake = ::std::option::Option::None;
    }

    pub fn has_unused_breakmodelsnottomake(&self) -> bool {
        self.unused_breakmodelsnottomake.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused_breakmodelsnottomake(&mut self, v: u32) {
        self.unused_breakmodelsnottomake = ::std::option::Option::Some(v);
    }

    // optional float scale = 10;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional int32 dmgtype = 13;

    pub fn dmgtype(&self) -> i32 {
        self.dmgtype.unwrap_or(0)
    }

    pub fn clear_dmgtype(&mut self) {
        self.dmgtype = ::std::option::Option::None;
    }

    pub fn has_dmgtype(&self) -> bool {
        self.dmgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmgtype(&mut self, v: i32) {
        self.dmgtype = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEPhysicsProp {
    const NAME: &'static str = "CMsgTEPhysicsProp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.velocity)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                37 => {
                    self.skin = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.effects = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                65 => {
                    self.modelindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                72 => {
                    self.unused_breakmodelsnottomake = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dmgpos)?;
                },
                98 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dmgdir)?;
                },
                104 => {
                    self.dmgtype = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.skin {
            my_size += 1 + 4;
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.effects {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.modelindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unused_breakmodelsnottomake {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.dmgpos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dmgdir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dmgtype {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.velocity.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.skin {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.effects {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.modelindex {
            os.write_fixed64(8, v)?;
        }
        if let Some(v) = self.unused_breakmodelsnottomake {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.dmgpos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.dmgdir.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.dmgtype {
            os.write_int32(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEPhysicsProp {
        CMsgTEPhysicsProp::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.velocity.clear();
        self.angles.clear();
        self.skin = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.effects = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.modelindex = ::std::option::Option::None;
        self.unused_breakmodelsnottomake = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.dmgpos.clear();
        self.dmgdir.clear();
        self.dmgtype = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEPhysicsProp {
        static instance: CMsgTEPhysicsProp = CMsgTEPhysicsProp {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            velocity: ::steam_vent_proto_common::protobuf::MessageField::none(),
            angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
            skin: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            effects: ::std::option::Option::None,
            color: ::std::option::Option::None,
            modelindex: ::std::option::Option::None,
            unused_breakmodelsnottomake: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            dmgpos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dmgdir: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dmgtype: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEPlayerDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEPlayerDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEPlayerDecal.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPlayerDecal.player)
    pub player: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEPlayerDecal.entity)
    pub entity: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEPlayerDecal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEPlayerDecal {
    fn default() -> &'a CMsgTEPlayerDecal {
        <CMsgTEPlayerDecal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEPlayerDecal {
    pub fn new() -> CMsgTEPlayerDecal {
        ::std::default::Default::default()
    }

    // optional int32 player = 2;

    pub fn player(&self) -> i32 {
        self.player.unwrap_or(-1i32)
    }

    pub fn clear_player(&mut self) {
        self.player = ::std::option::Option::None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = ::std::option::Option::Some(v);
    }

    // optional int32 entity = 3;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEPlayerDecal {
    const NAME: &'static str = "CMsgTEPlayerDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.player = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.player {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEPlayerDecal {
        CMsgTEPlayerDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.player = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEPlayerDecal {
        static instance: CMsgTEPlayerDecal = CMsgTEPlayerDecal {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player: ::std::option::Option::None,
            entity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEProjectedDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEProjectedDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.angles)
    pub angles: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.distance)
    pub distance: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEProjectedDecal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEProjectedDecal {
    fn default() -> &'a CMsgTEProjectedDecal {
        <CMsgTEProjectedDecal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEProjectedDecal {
    pub fn new() -> CMsgTEProjectedDecal {
        ::std::default::Default::default()
    }

    // optional uint32 index = 3;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional float distance = 4;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEProjectedDecal {
    const NAME: &'static str = "CMsgTEProjectedDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                24 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEProjectedDecal {
        CMsgTEProjectedDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.angles.clear();
        self.index = ::std::option::Option::None;
        self.distance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEProjectedDecal {
        static instance: CMsgTEProjectedDecal = CMsgTEProjectedDecal {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
            index: ::std::option::Option::None,
            distance: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTESmoke)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTESmoke {
    // message fields
    // @@protoc_insertion_point(field:CMsgTESmoke.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTESmoke.scale)
    pub scale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTESmoke.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTESmoke {
    fn default() -> &'a CMsgTESmoke {
        <CMsgTESmoke as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTESmoke {
    pub fn new() -> CMsgTESmoke {
        ::std::default::Default::default()
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTESmoke {
    const NAME: &'static str = "CMsgTESmoke";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTESmoke {
        CMsgTESmoke::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTESmoke {
        static instance: CMsgTESmoke = CMsgTESmoke {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTEWorldDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEWorldDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEWorldDecal.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEWorldDecal.normal)
    pub normal: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEWorldDecal.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEWorldDecal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEWorldDecal {
    fn default() -> &'a CMsgTEWorldDecal {
        <CMsgTEWorldDecal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTEWorldDecal {
    pub fn new() -> CMsgTEWorldDecal {
        ::std::default::Default::default()
    }

    // optional uint32 index = 3;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTEWorldDecal {
    const NAME: &'static str = "CMsgTEWorldDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                24 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEWorldDecal {
        CMsgTEWorldDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.normal.clear();
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEWorldDecal {
        static instance: CMsgTEWorldDecal = CMsgTEWorldDecal {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            normal: ::steam_vent_proto_common::protobuf::MessageField::none(),
            index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETEProtobufIds)
pub enum ETEProtobufIds {
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_EffectDispatchId)
    TE_EffectDispatchId = 400,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ArmorRicochetId)
    TE_ArmorRicochetId = 401,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamEntPointId)
    TE_BeamEntPointId = 402,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamEntsId)
    TE_BeamEntsId = 403,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamPointsId)
    TE_BeamPointsId = 404,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamRingId)
    TE_BeamRingId = 405,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BSPDecalId)
    TE_BSPDecalId = 407,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BubblesId)
    TE_BubblesId = 408,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BubbleTrailId)
    TE_BubbleTrailId = 409,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_DecalId)
    TE_DecalId = 410,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_WorldDecalId)
    TE_WorldDecalId = 411,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_EnergySplashId)
    TE_EnergySplashId = 412,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_FizzId)
    TE_FizzId = 413,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ShatterSurfaceId)
    TE_ShatterSurfaceId = 414,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_GlowSpriteId)
    TE_GlowSpriteId = 415,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ImpactId)
    TE_ImpactId = 416,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_MuzzleFlashId)
    TE_MuzzleFlashId = 417,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BloodStreamId)
    TE_BloodStreamId = 418,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ExplosionId)
    TE_ExplosionId = 419,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_DustId)
    TE_DustId = 420,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_LargeFunnelId)
    TE_LargeFunnelId = 421,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_SparksId)
    TE_SparksId = 422,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_PhysicsPropId)
    TE_PhysicsPropId = 423,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_PlayerDecalId)
    TE_PlayerDecalId = 424,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ProjectedDecalId)
    TE_ProjectedDecalId = 425,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_SmokeId)
    TE_SmokeId = 426,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETEProtobufIds {
    const NAME: &'static str = "ETEProtobufIds";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETEProtobufIds> {
        match value {
            400 => ::std::option::Option::Some(ETEProtobufIds::TE_EffectDispatchId),
            401 => ::std::option::Option::Some(ETEProtobufIds::TE_ArmorRicochetId),
            402 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntPointId),
            403 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntsId),
            404 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamPointsId),
            405 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamRingId),
            407 => ::std::option::Option::Some(ETEProtobufIds::TE_BSPDecalId),
            408 => ::std::option::Option::Some(ETEProtobufIds::TE_BubblesId),
            409 => ::std::option::Option::Some(ETEProtobufIds::TE_BubbleTrailId),
            410 => ::std::option::Option::Some(ETEProtobufIds::TE_DecalId),
            411 => ::std::option::Option::Some(ETEProtobufIds::TE_WorldDecalId),
            412 => ::std::option::Option::Some(ETEProtobufIds::TE_EnergySplashId),
            413 => ::std::option::Option::Some(ETEProtobufIds::TE_FizzId),
            414 => ::std::option::Option::Some(ETEProtobufIds::TE_ShatterSurfaceId),
            415 => ::std::option::Option::Some(ETEProtobufIds::TE_GlowSpriteId),
            416 => ::std::option::Option::Some(ETEProtobufIds::TE_ImpactId),
            417 => ::std::option::Option::Some(ETEProtobufIds::TE_MuzzleFlashId),
            418 => ::std::option::Option::Some(ETEProtobufIds::TE_BloodStreamId),
            419 => ::std::option::Option::Some(ETEProtobufIds::TE_ExplosionId),
            420 => ::std::option::Option::Some(ETEProtobufIds::TE_DustId),
            421 => ::std::option::Option::Some(ETEProtobufIds::TE_LargeFunnelId),
            422 => ::std::option::Option::Some(ETEProtobufIds::TE_SparksId),
            423 => ::std::option::Option::Some(ETEProtobufIds::TE_PhysicsPropId),
            424 => ::std::option::Option::Some(ETEProtobufIds::TE_PlayerDecalId),
            425 => ::std::option::Option::Some(ETEProtobufIds::TE_ProjectedDecalId),
            426 => ::std::option::Option::Some(ETEProtobufIds::TE_SmokeId),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETEProtobufIds> {
        match str {
            "TE_EffectDispatchId" => ::std::option::Option::Some(ETEProtobufIds::TE_EffectDispatchId),
            "TE_ArmorRicochetId" => ::std::option::Option::Some(ETEProtobufIds::TE_ArmorRicochetId),
            "TE_BeamEntPointId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntPointId),
            "TE_BeamEntsId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntsId),
            "TE_BeamPointsId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamPointsId),
            "TE_BeamRingId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamRingId),
            "TE_BSPDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_BSPDecalId),
            "TE_BubblesId" => ::std::option::Option::Some(ETEProtobufIds::TE_BubblesId),
            "TE_BubbleTrailId" => ::std::option::Option::Some(ETEProtobufIds::TE_BubbleTrailId),
            "TE_DecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_DecalId),
            "TE_WorldDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_WorldDecalId),
            "TE_EnergySplashId" => ::std::option::Option::Some(ETEProtobufIds::TE_EnergySplashId),
            "TE_FizzId" => ::std::option::Option::Some(ETEProtobufIds::TE_FizzId),
            "TE_ShatterSurfaceId" => ::std::option::Option::Some(ETEProtobufIds::TE_ShatterSurfaceId),
            "TE_GlowSpriteId" => ::std::option::Option::Some(ETEProtobufIds::TE_GlowSpriteId),
            "TE_ImpactId" => ::std::option::Option::Some(ETEProtobufIds::TE_ImpactId),
            "TE_MuzzleFlashId" => ::std::option::Option::Some(ETEProtobufIds::TE_MuzzleFlashId),
            "TE_BloodStreamId" => ::std::option::Option::Some(ETEProtobufIds::TE_BloodStreamId),
            "TE_ExplosionId" => ::std::option::Option::Some(ETEProtobufIds::TE_ExplosionId),
            "TE_DustId" => ::std::option::Option::Some(ETEProtobufIds::TE_DustId),
            "TE_LargeFunnelId" => ::std::option::Option::Some(ETEProtobufIds::TE_LargeFunnelId),
            "TE_SparksId" => ::std::option::Option::Some(ETEProtobufIds::TE_SparksId),
            "TE_PhysicsPropId" => ::std::option::Option::Some(ETEProtobufIds::TE_PhysicsPropId),
            "TE_PlayerDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_PlayerDecalId),
            "TE_ProjectedDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_ProjectedDecalId),
            "TE_SmokeId" => ::std::option::Option::Some(ETEProtobufIds::TE_SmokeId),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETEProtobufIds] = &[
        ETEProtobufIds::TE_EffectDispatchId,
        ETEProtobufIds::TE_ArmorRicochetId,
        ETEProtobufIds::TE_BeamEntPointId,
        ETEProtobufIds::TE_BeamEntsId,
        ETEProtobufIds::TE_BeamPointsId,
        ETEProtobufIds::TE_BeamRingId,
        ETEProtobufIds::TE_BSPDecalId,
        ETEProtobufIds::TE_BubblesId,
        ETEProtobufIds::TE_BubbleTrailId,
        ETEProtobufIds::TE_DecalId,
        ETEProtobufIds::TE_WorldDecalId,
        ETEProtobufIds::TE_EnergySplashId,
        ETEProtobufIds::TE_FizzId,
        ETEProtobufIds::TE_ShatterSurfaceId,
        ETEProtobufIds::TE_GlowSpriteId,
        ETEProtobufIds::TE_ImpactId,
        ETEProtobufIds::TE_MuzzleFlashId,
        ETEProtobufIds::TE_BloodStreamId,
        ETEProtobufIds::TE_ExplosionId,
        ETEProtobufIds::TE_DustId,
        ETEProtobufIds::TE_LargeFunnelId,
        ETEProtobufIds::TE_SparksId,
        ETEProtobufIds::TE_PhysicsPropId,
        ETEProtobufIds::TE_PlayerDecalId,
        ETEProtobufIds::TE_ProjectedDecalId,
        ETEProtobufIds::TE_SmokeId,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETEProtobufIds {
    fn default() -> Self {
        ETEProtobufIds::TE_EffectDispatchId
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::networkbasetypes::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgTEArmorRicochet {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBaseBeam {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBeamEntPoint {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBeamEnts {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBeamPoints {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBeamRing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBSPDecal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBubbles {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBubbleTrail {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEDecal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgEffectData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEEffectDispatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEEnergySplash {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEFizz {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEShatterSurface {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEGlowSprite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEImpact {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEMuzzleFlash {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEBloodStream {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEExplosion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEDust {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTELargeFunnel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTESparks {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEPhysicsProp {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEPlayerDecal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEProjectedDecal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTESmoke {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTEWorldDecal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
