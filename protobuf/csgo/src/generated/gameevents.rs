// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gameevents.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgVDebugGameSessionIDEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVDebugGameSessionIDEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgVDebugGameSessionIDEvent.clientid)
    pub clientid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgVDebugGameSessionIDEvent.gamesessionid)
    pub gamesessionid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVDebugGameSessionIDEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVDebugGameSessionIDEvent {
    fn default() -> &'a CMsgVDebugGameSessionIDEvent {
        <CMsgVDebugGameSessionIDEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgVDebugGameSessionIDEvent {
    pub fn new() -> CMsgVDebugGameSessionIDEvent {
        ::std::default::Default::default()
    }

    // optional int32 clientid = 1;

    pub fn clientid(&self) -> i32 {
        self.clientid.unwrap_or(0)
    }

    pub fn clear_clientid(&mut self) {
        self.clientid = ::std::option::Option::None;
    }

    pub fn has_clientid(&self) -> bool {
        self.clientid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientid(&mut self, v: i32) {
        self.clientid = ::std::option::Option::Some(v);
    }

    // optional string gamesessionid = 2;

    pub fn gamesessionid(&self) -> &str {
        match self.gamesessionid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamesessionid(&mut self) {
        self.gamesessionid = ::std::option::Option::None;
    }

    pub fn has_gamesessionid(&self) -> bool {
        self.gamesessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamesessionid(&mut self, v: ::std::string::String) {
        self.gamesessionid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamesessionid(&mut self) -> &mut ::std::string::String {
        if self.gamesessionid.is_none() {
            self.gamesessionid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gamesessionid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamesessionid(&mut self) -> ::std::string::String {
        self.gamesessionid.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgVDebugGameSessionIDEvent {
    const NAME: &'static str = "CMsgVDebugGameSessionIDEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clientid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.gamesessionid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clientid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gamesessionid.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clientid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gamesessionid.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVDebugGameSessionIDEvent {
        CMsgVDebugGameSessionIDEvent::new()
    }

    fn clear(&mut self) {
        self.clientid = ::std::option::Option::None;
        self.gamesessionid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVDebugGameSessionIDEvent {
        static instance: CMsgVDebugGameSessionIDEvent = CMsgVDebugGameSessionIDEvent {
            clientid: ::std::option::Option::None,
            gamesessionid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlaceDecalEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlaceDecalEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.position)
    pub position: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.normal)
    pub normal: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.saxis)
    pub saxis: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.decalmaterialindex)
    pub decalmaterialindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.height)
    pub height: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.depth)
    pub depth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.entityhandleindex)
    pub entityhandleindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.skeletoninstancehash)
    pub skeletoninstancehash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.boneindex)
    pub boneindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.translucenthit)
    pub translucenthit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.is_adjacent)
    pub is_adjacent: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlaceDecalEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlaceDecalEvent {
    fn default() -> &'a CMsgPlaceDecalEvent {
        <CMsgPlaceDecalEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlaceDecalEvent {
    pub fn new() -> CMsgPlaceDecalEvent {
        ::std::default::Default::default()
    }

    // optional uint32 decalmaterialindex = 4;

    pub fn decalmaterialindex(&self) -> u32 {
        self.decalmaterialindex.unwrap_or(0)
    }

    pub fn clear_decalmaterialindex(&mut self) {
        self.decalmaterialindex = ::std::option::Option::None;
    }

    pub fn has_decalmaterialindex(&self) -> bool {
        self.decalmaterialindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decalmaterialindex(&mut self, v: u32) {
        self.decalmaterialindex = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 6;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional float width = 7;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float height = 8;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional float depth = 9;

    pub fn depth(&self) -> f32 {
        self.depth.unwrap_or(0.)
    }

    pub fn clear_depth(&mut self) {
        self.depth = ::std::option::Option::None;
    }

    pub fn has_depth(&self) -> bool {
        self.depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depth(&mut self, v: f32) {
        self.depth = ::std::option::Option::Some(v);
    }

    // optional uint32 entityhandleindex = 10;

    pub fn entityhandleindex(&self) -> u32 {
        self.entityhandleindex.unwrap_or(0)
    }

    pub fn clear_entityhandleindex(&mut self) {
        self.entityhandleindex = ::std::option::Option::None;
    }

    pub fn has_entityhandleindex(&self) -> bool {
        self.entityhandleindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityhandleindex(&mut self, v: u32) {
        self.entityhandleindex = ::std::option::Option::Some(v);
    }

    // optional fixed32 skeletoninstancehash = 11;

    pub fn skeletoninstancehash(&self) -> u32 {
        self.skeletoninstancehash.unwrap_or(0)
    }

    pub fn clear_skeletoninstancehash(&mut self) {
        self.skeletoninstancehash = ::std::option::Option::None;
    }

    pub fn has_skeletoninstancehash(&self) -> bool {
        self.skeletoninstancehash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skeletoninstancehash(&mut self, v: u32) {
        self.skeletoninstancehash = ::std::option::Option::Some(v);
    }

    // optional int32 boneindex = 12;

    pub fn boneindex(&self) -> i32 {
        self.boneindex.unwrap_or(0)
    }

    pub fn clear_boneindex(&mut self) {
        self.boneindex = ::std::option::Option::None;
    }

    pub fn has_boneindex(&self) -> bool {
        self.boneindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boneindex(&mut self, v: i32) {
        self.boneindex = ::std::option::Option::Some(v);
    }

    // optional bool translucenthit = 13;

    pub fn translucenthit(&self) -> bool {
        self.translucenthit.unwrap_or(false)
    }

    pub fn clear_translucenthit(&mut self) {
        self.translucenthit = ::std::option::Option::None;
    }

    pub fn has_translucenthit(&self) -> bool {
        self.translucenthit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translucenthit(&mut self, v: bool) {
        self.translucenthit = ::std::option::Option::Some(v);
    }

    // optional bool is_adjacent = 14;

    pub fn is_adjacent(&self) -> bool {
        self.is_adjacent.unwrap_or(false)
    }

    pub fn clear_is_adjacent(&mut self) {
        self.is_adjacent = ::std::option::Option::None;
    }

    pub fn has_is_adjacent(&self) -> bool {
        self.is_adjacent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_adjacent(&mut self, v: bool) {
        self.is_adjacent = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlaceDecalEvent {
    const NAME: &'static str = "CMsgPlaceDecalEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.saxis)?;
                },
                32 => {
                    self.decalmaterialindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.depth = ::std::option::Option::Some(is.read_float()?);
                },
                80 => {
                    self.entityhandleindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                93 => {
                    self.skeletoninstancehash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                96 => {
                    self.boneindex = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.translucenthit = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_adjacent = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.saxis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.decalmaterialindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        if let Some(v) = self.depth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.entityhandleindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.skeletoninstancehash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.boneindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.translucenthit {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_adjacent {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.saxis.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.decalmaterialindex {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.width {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.height {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.depth {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.entityhandleindex {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.skeletoninstancehash {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.boneindex {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.translucenthit {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_adjacent {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlaceDecalEvent {
        CMsgPlaceDecalEvent::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.normal.clear();
        self.saxis.clear();
        self.decalmaterialindex = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.depth = ::std::option::Option::None;
        self.entityhandleindex = ::std::option::Option::None;
        self.skeletoninstancehash = ::std::option::Option::None;
        self.boneindex = ::std::option::Option::None;
        self.translucenthit = ::std::option::Option::None;
        self.is_adjacent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlaceDecalEvent {
        static instance: CMsgPlaceDecalEvent = CMsgPlaceDecalEvent {
            position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            normal: ::steam_vent_proto_common::protobuf::MessageField::none(),
            saxis: ::steam_vent_proto_common::protobuf::MessageField::none(),
            decalmaterialindex: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            color: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            depth: ::std::option::Option::None,
            entityhandleindex: ::std::option::Option::None,
            skeletoninstancehash: ::std::option::Option::None,
            boneindex: ::std::option::Option::None,
            translucenthit: ::std::option::Option::None,
            is_adjacent: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClearWorldDecalsEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearWorldDecalsEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearWorldDecalsEvent.flagstoclear)
    pub flagstoclear: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearWorldDecalsEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearWorldDecalsEvent {
    fn default() -> &'a CMsgClearWorldDecalsEvent {
        <CMsgClearWorldDecalsEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClearWorldDecalsEvent {
    pub fn new() -> CMsgClearWorldDecalsEvent {
        ::std::default::Default::default()
    }

    // optional uint32 flagstoclear = 1;

    pub fn flagstoclear(&self) -> u32 {
        self.flagstoclear.unwrap_or(0)
    }

    pub fn clear_flagstoclear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
    }

    pub fn has_flagstoclear(&self) -> bool {
        self.flagstoclear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagstoclear(&mut self, v: u32) {
        self.flagstoclear = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClearWorldDecalsEvent {
    const NAME: &'static str = "CMsgClearWorldDecalsEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flagstoclear = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flagstoclear {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.flagstoclear {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearWorldDecalsEvent {
        CMsgClearWorldDecalsEvent::new()
    }

    fn clear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearWorldDecalsEvent {
        static instance: CMsgClearWorldDecalsEvent = CMsgClearWorldDecalsEvent {
            flagstoclear: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClearEntityDecalsEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearEntityDecalsEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearEntityDecalsEvent.flagstoclear)
    pub flagstoclear: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearEntityDecalsEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearEntityDecalsEvent {
    fn default() -> &'a CMsgClearEntityDecalsEvent {
        <CMsgClearEntityDecalsEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClearEntityDecalsEvent {
    pub fn new() -> CMsgClearEntityDecalsEvent {
        ::std::default::Default::default()
    }

    // optional uint32 flagstoclear = 1;

    pub fn flagstoclear(&self) -> u32 {
        self.flagstoclear.unwrap_or(0)
    }

    pub fn clear_flagstoclear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
    }

    pub fn has_flagstoclear(&self) -> bool {
        self.flagstoclear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagstoclear(&mut self, v: u32) {
        self.flagstoclear = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClearEntityDecalsEvent {
    const NAME: &'static str = "CMsgClearEntityDecalsEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flagstoclear = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flagstoclear {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.flagstoclear {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearEntityDecalsEvent {
        CMsgClearEntityDecalsEvent::new()
    }

    fn clear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearEntityDecalsEvent {
        static instance: CMsgClearEntityDecalsEvent = CMsgClearEntityDecalsEvent {
            flagstoclear: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClearDecalsForSkeletonInstanceEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearDecalsForSkeletonInstanceEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearDecalsForSkeletonInstanceEvent.flagstoclear)
    pub flagstoclear: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClearDecalsForSkeletonInstanceEvent.entityhandleindex)
    pub entityhandleindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClearDecalsForSkeletonInstanceEvent.skeletoninstancehash)
    pub skeletoninstancehash: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearDecalsForSkeletonInstanceEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearDecalsForSkeletonInstanceEvent {
    fn default() -> &'a CMsgClearDecalsForSkeletonInstanceEvent {
        <CMsgClearDecalsForSkeletonInstanceEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClearDecalsForSkeletonInstanceEvent {
    pub fn new() -> CMsgClearDecalsForSkeletonInstanceEvent {
        ::std::default::Default::default()
    }

    // optional uint32 flagstoclear = 1;

    pub fn flagstoclear(&self) -> u32 {
        self.flagstoclear.unwrap_or(0)
    }

    pub fn clear_flagstoclear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
    }

    pub fn has_flagstoclear(&self) -> bool {
        self.flagstoclear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagstoclear(&mut self, v: u32) {
        self.flagstoclear = ::std::option::Option::Some(v);
    }

    // optional uint32 entityhandleindex = 2;

    pub fn entityhandleindex(&self) -> u32 {
        self.entityhandleindex.unwrap_or(0)
    }

    pub fn clear_entityhandleindex(&mut self) {
        self.entityhandleindex = ::std::option::Option::None;
    }

    pub fn has_entityhandleindex(&self) -> bool {
        self.entityhandleindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityhandleindex(&mut self, v: u32) {
        self.entityhandleindex = ::std::option::Option::Some(v);
    }

    // optional uint32 skeletoninstancehash = 3;

    pub fn skeletoninstancehash(&self) -> u32 {
        self.skeletoninstancehash.unwrap_or(0)
    }

    pub fn clear_skeletoninstancehash(&mut self) {
        self.skeletoninstancehash = ::std::option::Option::None;
    }

    pub fn has_skeletoninstancehash(&self) -> bool {
        self.skeletoninstancehash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skeletoninstancehash(&mut self, v: u32) {
        self.skeletoninstancehash = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClearDecalsForSkeletonInstanceEvent {
    const NAME: &'static str = "CMsgClearDecalsForSkeletonInstanceEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flagstoclear = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.entityhandleindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.skeletoninstancehash = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flagstoclear {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.entityhandleindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.skeletoninstancehash {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.flagstoclear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.entityhandleindex {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.skeletoninstancehash {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearDecalsForSkeletonInstanceEvent {
        CMsgClearDecalsForSkeletonInstanceEvent::new()
    }

    fn clear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
        self.entityhandleindex = ::std::option::Option::None;
        self.skeletoninstancehash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearDecalsForSkeletonInstanceEvent {
        static instance: CMsgClearDecalsForSkeletonInstanceEvent = CMsgClearDecalsForSkeletonInstanceEvent {
            flagstoclear: ::std::option::Option::None,
            entityhandleindex: ::std::option::Option::None,
            skeletoninstancehash: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSource1LegacyGameEventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource1LegacyGameEventList {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptors)
    pub descriptors: ::std::vec::Vec<cmsg_source1legacy_game_event_list::Descriptor_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEventList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource1LegacyGameEventList {
    fn default() -> &'a CMsgSource1LegacyGameEventList {
        <CMsgSource1LegacyGameEventList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSource1LegacyGameEventList {
    pub fn new() -> CMsgSource1LegacyGameEventList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSource1LegacyGameEventList {
    const NAME: &'static str = "CMsgSource1LegacyGameEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.descriptors {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource1LegacyGameEventList {
        CMsgSource1LegacyGameEventList::new()
    }

    fn clear(&mut self) {
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource1LegacyGameEventList {
        static instance: CMsgSource1LegacyGameEventList = CMsgSource1LegacyGameEventList {
            descriptors: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSource1LegacyGameEventList`
pub mod cmsg_source1legacy_game_event_list {
    // @@protoc_insertion_point(message:CMsgSource1LegacyGameEventList.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.key_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEventList.key_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSource1LegacyGameEventList.descriptor_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Descriptor_t {
        // message fields
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptor_t.eventid)
        pub eventid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptor_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptor_t.keys)
        pub keys: ::std::vec::Vec<Key_t>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEventList.descriptor_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Descriptor_t {
        fn default() -> &'a Descriptor_t {
            <Descriptor_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Descriptor_t {
        pub fn new() -> Descriptor_t {
            ::std::default::Default::default()
        }

        // optional int32 eventid = 1;

        pub fn eventid(&self) -> i32 {
            self.eventid.unwrap_or(0)
        }

        pub fn clear_eventid(&mut self) {
            self.eventid = ::std::option::Option::None;
        }

        pub fn has_eventid(&self) -> bool {
            self.eventid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eventid(&mut self, v: i32) {
            self.eventid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Descriptor_t {
        const NAME: &'static str = "descriptor_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eventid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.keys.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eventid {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            for value in &self.keys {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.eventid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.keys {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Descriptor_t {
            Descriptor_t::new()
        }

        fn clear(&mut self) {
            self.eventid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.keys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Descriptor_t {
            static instance: Descriptor_t = Descriptor_t {
                eventid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                keys: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSource1LegacyListenEvents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource1LegacyListenEvents {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource1LegacyListenEvents.playerslot)
    pub playerslot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyListenEvents.eventarraybits)
    pub eventarraybits: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource1LegacyListenEvents.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource1LegacyListenEvents {
    fn default() -> &'a CMsgSource1LegacyListenEvents {
        <CMsgSource1LegacyListenEvents as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSource1LegacyListenEvents {
    pub fn new() -> CMsgSource1LegacyListenEvents {
        ::std::default::Default::default()
    }

    // optional int32 playerslot = 1;

    pub fn playerslot(&self) -> i32 {
        self.playerslot.unwrap_or(0)
    }

    pub fn clear_playerslot(&mut self) {
        self.playerslot = ::std::option::Option::None;
    }

    pub fn has_playerslot(&self) -> bool {
        self.playerslot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerslot(&mut self, v: i32) {
        self.playerslot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSource1LegacyListenEvents {
    const NAME: &'static str = "CMsgSource1LegacyListenEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.playerslot = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.eventarraybits)?;
                },
                16 => {
                    self.eventarraybits.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playerslot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.eventarraybits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.playerslot {
            os.write_int32(1, v)?;
        }
        for v in &self.eventarraybits {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource1LegacyListenEvents {
        CMsgSource1LegacyListenEvents::new()
    }

    fn clear(&mut self) {
        self.playerslot = ::std::option::Option::None;
        self.eventarraybits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource1LegacyListenEvents {
        static instance: CMsgSource1LegacyListenEvents = CMsgSource1LegacyListenEvents {
            playerslot: ::std::option::Option::None,
            eventarraybits: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSource1LegacyGameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource1LegacyGameEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.eventid)
    pub eventid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.keys)
    pub keys: ::std::vec::Vec<cmsg_source1legacy_game_event::Key_t>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.server_tick)
    pub server_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource1LegacyGameEvent {
    fn default() -> &'a CMsgSource1LegacyGameEvent {
        <CMsgSource1LegacyGameEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSource1LegacyGameEvent {
    pub fn new() -> CMsgSource1LegacyGameEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 eventid = 2;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional int32 server_tick = 4;

    pub fn server_tick(&self) -> i32 {
        self.server_tick.unwrap_or(0)
    }

    pub fn clear_server_tick(&mut self) {
        self.server_tick = ::std::option::Option::None;
    }

    pub fn has_server_tick(&self) -> bool {
        self.server_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tick(&mut self, v: i32) {
        self.server_tick = ::std::option::Option::Some(v);
    }

    // optional int32 passthrough = 5;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSource1LegacyGameEvent {
    const NAME: &'static str = "CMsgSource1LegacyGameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.keys.push(is.read_message()?);
                },
                32 => {
                    self.server_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eventid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eventid {
            os.write_int32(2, v)?;
        }
        for v in &self.keys {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.server_tick {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource1LegacyGameEvent {
        CMsgSource1LegacyGameEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.eventid = ::std::option::Option::None;
        self.keys.clear();
        self.server_tick = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource1LegacyGameEvent {
        static instance: CMsgSource1LegacyGameEvent = CMsgSource1LegacyGameEvent {
            event_name: ::std::option::Option::None,
            eventid: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            server_tick: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSource1LegacyGameEvent`
pub mod cmsg_source1legacy_game_event {
    // @@protoc_insertion_point(message:CMsgSource1LegacyGameEvent.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_string)
        pub val_string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_float)
        pub val_float: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_long)
        pub val_long: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_short)
        pub val_short: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_byte)
        pub val_byte: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_bool)
        pub val_bool: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_uint64)
        pub val_uint64: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEvent.key_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string val_string = 2;

        pub fn val_string(&self) -> &str {
            match self.val_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_val_string(&mut self) {
            self.val_string = ::std::option::Option::None;
        }

        pub fn has_val_string(&self) -> bool {
            self.val_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_string(&mut self, v: ::std::string::String) {
            self.val_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
            if self.val_string.is_none() {
                self.val_string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.val_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_string(&mut self) -> ::std::string::String {
            self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float val_float = 3;

        pub fn val_float(&self) -> f32 {
            self.val_float.unwrap_or(0.)
        }

        pub fn clear_val_float(&mut self) {
            self.val_float = ::std::option::Option::None;
        }

        pub fn has_val_float(&self) -> bool {
            self.val_float.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_float(&mut self, v: f32) {
            self.val_float = ::std::option::Option::Some(v);
        }

        // optional int32 val_long = 4;

        pub fn val_long(&self) -> i32 {
            self.val_long.unwrap_or(0)
        }

        pub fn clear_val_long(&mut self) {
            self.val_long = ::std::option::Option::None;
        }

        pub fn has_val_long(&self) -> bool {
            self.val_long.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_long(&mut self, v: i32) {
            self.val_long = ::std::option::Option::Some(v);
        }

        // optional int32 val_short = 5;

        pub fn val_short(&self) -> i32 {
            self.val_short.unwrap_or(0)
        }

        pub fn clear_val_short(&mut self) {
            self.val_short = ::std::option::Option::None;
        }

        pub fn has_val_short(&self) -> bool {
            self.val_short.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_short(&mut self, v: i32) {
            self.val_short = ::std::option::Option::Some(v);
        }

        // optional int32 val_byte = 6;

        pub fn val_byte(&self) -> i32 {
            self.val_byte.unwrap_or(0)
        }

        pub fn clear_val_byte(&mut self) {
            self.val_byte = ::std::option::Option::None;
        }

        pub fn has_val_byte(&self) -> bool {
            self.val_byte.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_byte(&mut self, v: i32) {
            self.val_byte = ::std::option::Option::Some(v);
        }

        // optional bool val_bool = 7;

        pub fn val_bool(&self) -> bool {
            self.val_bool.unwrap_or(false)
        }

        pub fn clear_val_bool(&mut self) {
            self.val_bool = ::std::option::Option::None;
        }

        pub fn has_val_bool(&self) -> bool {
            self.val_bool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_bool(&mut self, v: bool) {
            self.val_bool = ::std::option::Option::Some(v);
        }

        // optional uint64 val_uint64 = 8;

        pub fn val_uint64(&self) -> u64 {
            self.val_uint64.unwrap_or(0)
        }

        pub fn clear_val_uint64(&mut self) {
            self.val_uint64 = ::std::option::Option::None;
        }

        pub fn has_val_uint64(&self) -> bool {
            self.val_uint64.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_uint64(&mut self, v: u64) {
            self.val_uint64 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.val_string = ::std::option::Option::Some(is.read_string()?);
                    },
                    29 => {
                        self.val_float = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.val_long = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.val_short = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.val_byte = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.val_bool = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.val_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.val_string.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.val_float {
                my_size += 1 + 4;
            }
            if let Some(v) = self.val_long {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.val_short {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.val_byte {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.val_bool {
                my_size += 1 + 1;
            }
            if let Some(v) = self.val_uint64 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.val_string.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.val_float {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.val_long {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.val_short {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.val_byte {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.val_bool {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.val_uint64 {
                os.write_uint64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.val_string = ::std::option::Option::None;
            self.val_float = ::std::option::Option::None;
            self.val_long = ::std::option::Option::None;
            self.val_short = ::std::option::Option::None;
            self.val_byte = ::std::option::Option::None;
            self.val_bool = ::std::option::Option::None;
            self.val_uint64 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                val_string: ::std::option::Option::None,
                val_float: ::std::option::Option::None,
                val_long: ::std::option::Option::None,
                val_short: ::std::option::Option::None,
                val_byte: ::std::option::Option::None,
                val_bool: ::std::option::Option::None,
                val_uint64: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSosStartSoundEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosStartSoundEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.soundevent_guid)
    pub soundevent_guid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.soundevent_hash)
    pub soundevent_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.source_entity_index)
    pub source_entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.seed)
    pub seed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.packed_params)
    pub packed_params: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.start_time)
    pub start_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosStartSoundEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosStartSoundEvent {
    fn default() -> &'a CMsgSosStartSoundEvent {
        <CMsgSosStartSoundEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSosStartSoundEvent {
    pub fn new() -> CMsgSosStartSoundEvent {
        ::std::default::Default::default()
    }

    // optional int32 soundevent_guid = 1;

    pub fn soundevent_guid(&self) -> i32 {
        self.soundevent_guid.unwrap_or(0)
    }

    pub fn clear_soundevent_guid(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
    }

    pub fn has_soundevent_guid(&self) -> bool {
        self.soundevent_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_guid(&mut self, v: i32) {
        self.soundevent_guid = ::std::option::Option::Some(v);
    }

    // optional fixed32 soundevent_hash = 2;

    pub fn soundevent_hash(&self) -> u32 {
        self.soundevent_hash.unwrap_or(0)
    }

    pub fn clear_soundevent_hash(&mut self) {
        self.soundevent_hash = ::std::option::Option::None;
    }

    pub fn has_soundevent_hash(&self) -> bool {
        self.soundevent_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_hash(&mut self, v: u32) {
        self.soundevent_hash = ::std::option::Option::Some(v);
    }

    // optional int32 source_entity_index = 3;

    pub fn source_entity_index(&self) -> i32 {
        self.source_entity_index.unwrap_or(-1i32)
    }

    pub fn clear_source_entity_index(&mut self) {
        self.source_entity_index = ::std::option::Option::None;
    }

    pub fn has_source_entity_index(&self) -> bool {
        self.source_entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_entity_index(&mut self, v: i32) {
        self.source_entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 seed = 4;

    pub fn seed(&self) -> i32 {
        self.seed.unwrap_or(0)
    }

    pub fn clear_seed(&mut self) {
        self.seed = ::std::option::Option::None;
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: i32) {
        self.seed = ::std::option::Option::Some(v);
    }

    // optional bytes packed_params = 5;

    pub fn packed_params(&self) -> &[u8] {
        match self.packed_params.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_packed_params(&mut self) {
        self.packed_params = ::std::option::Option::None;
    }

    pub fn has_packed_params(&self) -> bool {
        self.packed_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed_params(&mut self, v: ::std::vec::Vec<u8>) {
        self.packed_params = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packed_params(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packed_params.is_none() {
            self.packed_params = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.packed_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_packed_params(&mut self) -> ::std::vec::Vec<u8> {
        self.packed_params.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional float start_time = 6;

    pub fn start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSosStartSoundEvent {
    const NAME: &'static str = "CMsgSosStartSoundEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soundevent_guid = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.soundevent_hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.source_entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.seed = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.packed_params = ::std::option::Option::Some(is.read_bytes()?);
                },
                53 => {
                    self.start_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_guid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.soundevent_hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.seed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.packed_params.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soundevent_guid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.soundevent_hash {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.source_entity_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.seed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.packed_params.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosStartSoundEvent {
        CMsgSosStartSoundEvent::new()
    }

    fn clear(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
        self.soundevent_hash = ::std::option::Option::None;
        self.source_entity_index = ::std::option::Option::None;
        self.seed = ::std::option::Option::None;
        self.packed_params = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosStartSoundEvent {
        static instance: CMsgSosStartSoundEvent = CMsgSosStartSoundEvent {
            soundevent_guid: ::std::option::Option::None,
            soundevent_hash: ::std::option::Option::None,
            source_entity_index: ::std::option::Option::None,
            seed: ::std::option::Option::None,
            packed_params: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSosStopSoundEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosStopSoundEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosStopSoundEvent.soundevent_guid)
    pub soundevent_guid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosStopSoundEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosStopSoundEvent {
    fn default() -> &'a CMsgSosStopSoundEvent {
        <CMsgSosStopSoundEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSosStopSoundEvent {
    pub fn new() -> CMsgSosStopSoundEvent {
        ::std::default::Default::default()
    }

    // optional int32 soundevent_guid = 1;

    pub fn soundevent_guid(&self) -> i32 {
        self.soundevent_guid.unwrap_or(0)
    }

    pub fn clear_soundevent_guid(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
    }

    pub fn has_soundevent_guid(&self) -> bool {
        self.soundevent_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_guid(&mut self, v: i32) {
        self.soundevent_guid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSosStopSoundEvent {
    const NAME: &'static str = "CMsgSosStopSoundEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soundevent_guid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_guid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soundevent_guid {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosStopSoundEvent {
        CMsgSosStopSoundEvent::new()
    }

    fn clear(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosStopSoundEvent {
        static instance: CMsgSosStopSoundEvent = CMsgSosStopSoundEvent {
            soundevent_guid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSosStopSoundEventHash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosStopSoundEventHash {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosStopSoundEventHash.soundevent_hash)
    pub soundevent_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSosStopSoundEventHash.source_entity_index)
    pub source_entity_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosStopSoundEventHash.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosStopSoundEventHash {
    fn default() -> &'a CMsgSosStopSoundEventHash {
        <CMsgSosStopSoundEventHash as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSosStopSoundEventHash {
    pub fn new() -> CMsgSosStopSoundEventHash {
        ::std::default::Default::default()
    }

    // optional fixed32 soundevent_hash = 1;

    pub fn soundevent_hash(&self) -> u32 {
        self.soundevent_hash.unwrap_or(0)
    }

    pub fn clear_soundevent_hash(&mut self) {
        self.soundevent_hash = ::std::option::Option::None;
    }

    pub fn has_soundevent_hash(&self) -> bool {
        self.soundevent_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_hash(&mut self, v: u32) {
        self.soundevent_hash = ::std::option::Option::Some(v);
    }

    // optional int32 source_entity_index = 2;

    pub fn source_entity_index(&self) -> i32 {
        self.source_entity_index.unwrap_or(-1i32)
    }

    pub fn clear_source_entity_index(&mut self) {
        self.source_entity_index = ::std::option::Option::None;
    }

    pub fn has_source_entity_index(&self) -> bool {
        self.source_entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_entity_index(&mut self, v: i32) {
        self.source_entity_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSosStopSoundEventHash {
    const NAME: &'static str = "CMsgSosStopSoundEventHash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.soundevent_hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.source_entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soundevent_hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.source_entity_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosStopSoundEventHash {
        CMsgSosStopSoundEventHash::new()
    }

    fn clear(&mut self) {
        self.soundevent_hash = ::std::option::Option::None;
        self.source_entity_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosStopSoundEventHash {
        static instance: CMsgSosStopSoundEventHash = CMsgSosStopSoundEventHash {
            soundevent_hash: ::std::option::Option::None,
            source_entity_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSosSetSoundEventParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosSetSoundEventParams {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosSetSoundEventParams.soundevent_guid)
    pub soundevent_guid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosSetSoundEventParams.packed_params)
    pub packed_params: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosSetSoundEventParams.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosSetSoundEventParams {
    fn default() -> &'a CMsgSosSetSoundEventParams {
        <CMsgSosSetSoundEventParams as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSosSetSoundEventParams {
    pub fn new() -> CMsgSosSetSoundEventParams {
        ::std::default::Default::default()
    }

    // optional int32 soundevent_guid = 1;

    pub fn soundevent_guid(&self) -> i32 {
        self.soundevent_guid.unwrap_or(0)
    }

    pub fn clear_soundevent_guid(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
    }

    pub fn has_soundevent_guid(&self) -> bool {
        self.soundevent_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_guid(&mut self, v: i32) {
        self.soundevent_guid = ::std::option::Option::Some(v);
    }

    // optional bytes packed_params = 5;

    pub fn packed_params(&self) -> &[u8] {
        match self.packed_params.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_packed_params(&mut self) {
        self.packed_params = ::std::option::Option::None;
    }

    pub fn has_packed_params(&self) -> bool {
        self.packed_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed_params(&mut self, v: ::std::vec::Vec<u8>) {
        self.packed_params = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packed_params(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packed_params.is_none() {
            self.packed_params = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.packed_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_packed_params(&mut self) -> ::std::vec::Vec<u8> {
        self.packed_params.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSosSetSoundEventParams {
    const NAME: &'static str = "CMsgSosSetSoundEventParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soundevent_guid = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.packed_params = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_guid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.packed_params.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soundevent_guid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.packed_params.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosSetSoundEventParams {
        CMsgSosSetSoundEventParams::new()
    }

    fn clear(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
        self.packed_params = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosSetSoundEventParams {
        static instance: CMsgSosSetSoundEventParams = CMsgSosSetSoundEventParams {
            soundevent_guid: ::std::option::Option::None,
            packed_params: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSosSetLibraryStackFields)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosSetLibraryStackFields {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosSetLibraryStackFields.stack_hash)
    pub stack_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSosSetLibraryStackFields.packed_fields)
    pub packed_fields: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosSetLibraryStackFields.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosSetLibraryStackFields {
    fn default() -> &'a CMsgSosSetLibraryStackFields {
        <CMsgSosSetLibraryStackFields as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSosSetLibraryStackFields {
    pub fn new() -> CMsgSosSetLibraryStackFields {
        ::std::default::Default::default()
    }

    // optional fixed32 stack_hash = 1;

    pub fn stack_hash(&self) -> u32 {
        self.stack_hash.unwrap_or(0)
    }

    pub fn clear_stack_hash(&mut self) {
        self.stack_hash = ::std::option::Option::None;
    }

    pub fn has_stack_hash(&self) -> bool {
        self.stack_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_hash(&mut self, v: u32) {
        self.stack_hash = ::std::option::Option::Some(v);
    }

    // optional bytes packed_fields = 5;

    pub fn packed_fields(&self) -> &[u8] {
        match self.packed_fields.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_packed_fields(&mut self) {
        self.packed_fields = ::std::option::Option::None;
    }

    pub fn has_packed_fields(&self) -> bool {
        self.packed_fields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed_fields(&mut self, v: ::std::vec::Vec<u8>) {
        self.packed_fields = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packed_fields(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packed_fields.is_none() {
            self.packed_fields = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.packed_fields.as_mut().unwrap()
    }

    // Take field
    pub fn take_packed_fields(&mut self) -> ::std::vec::Vec<u8> {
        self.packed_fields.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSosSetLibraryStackFields {
    const NAME: &'static str = "CMsgSosSetLibraryStackFields";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.stack_hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                42 => {
                    self.packed_fields = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stack_hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.packed_fields.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.stack_hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.packed_fields.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosSetLibraryStackFields {
        CMsgSosSetLibraryStackFields::new()
    }

    fn clear(&mut self) {
        self.stack_hash = ::std::option::Option::None;
        self.packed_fields = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosSetLibraryStackFields {
        static instance: CMsgSosSetLibraryStackFields = CMsgSosSetLibraryStackFields {
            stack_hash: ::std::option::Option::None,
            packed_fields: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBaseGameEvents)
pub enum EBaseGameEvents {
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_VDebugGameSessionIDEvent)
    GE_VDebugGameSessionIDEvent = 200,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_PlaceDecalEvent)
    GE_PlaceDecalEvent = 201,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_ClearWorldDecalsEvent)
    GE_ClearWorldDecalsEvent = 202,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_ClearEntityDecalsEvent)
    GE_ClearEntityDecalsEvent = 203,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_ClearDecalsForSkeletonInstanceEvent)
    GE_ClearDecalsForSkeletonInstanceEvent = 204,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_Source1LegacyGameEventList)
    GE_Source1LegacyGameEventList = 205,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_Source1LegacyListenEvents)
    GE_Source1LegacyListenEvents = 206,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_Source1LegacyGameEvent)
    GE_Source1LegacyGameEvent = 207,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosStartSoundEvent)
    GE_SosStartSoundEvent = 208,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosStopSoundEvent)
    GE_SosStopSoundEvent = 209,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosSetSoundEventParams)
    GE_SosSetSoundEventParams = 210,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosSetLibraryStackFields)
    GE_SosSetLibraryStackFields = 211,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosStopSoundEventHash)
    GE_SosStopSoundEventHash = 212,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBaseGameEvents {
    const NAME: &'static str = "EBaseGameEvents";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBaseGameEvents> {
        match value {
            200 => ::std::option::Option::Some(EBaseGameEvents::GE_VDebugGameSessionIDEvent),
            201 => ::std::option::Option::Some(EBaseGameEvents::GE_PlaceDecalEvent),
            202 => ::std::option::Option::Some(EBaseGameEvents::GE_ClearWorldDecalsEvent),
            203 => ::std::option::Option::Some(EBaseGameEvents::GE_ClearEntityDecalsEvent),
            204 => ::std::option::Option::Some(EBaseGameEvents::GE_ClearDecalsForSkeletonInstanceEvent),
            205 => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEventList),
            206 => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyListenEvents),
            207 => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEvent),
            208 => ::std::option::Option::Some(EBaseGameEvents::GE_SosStartSoundEvent),
            209 => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEvent),
            210 => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetSoundEventParams),
            211 => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetLibraryStackFields),
            212 => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEventHash),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBaseGameEvents> {
        match str {
            "GE_VDebugGameSessionIDEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_VDebugGameSessionIDEvent),
            "GE_PlaceDecalEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_PlaceDecalEvent),
            "GE_ClearWorldDecalsEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_ClearWorldDecalsEvent),
            "GE_ClearEntityDecalsEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_ClearEntityDecalsEvent),
            "GE_ClearDecalsForSkeletonInstanceEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_ClearDecalsForSkeletonInstanceEvent),
            "GE_Source1LegacyGameEventList" => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEventList),
            "GE_Source1LegacyListenEvents" => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyListenEvents),
            "GE_Source1LegacyGameEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEvent),
            "GE_SosStartSoundEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_SosStartSoundEvent),
            "GE_SosStopSoundEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEvent),
            "GE_SosSetSoundEventParams" => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetSoundEventParams),
            "GE_SosSetLibraryStackFields" => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetLibraryStackFields),
            "GE_SosStopSoundEventHash" => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEventHash),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBaseGameEvents] = &[
        EBaseGameEvents::GE_VDebugGameSessionIDEvent,
        EBaseGameEvents::GE_PlaceDecalEvent,
        EBaseGameEvents::GE_ClearWorldDecalsEvent,
        EBaseGameEvents::GE_ClearEntityDecalsEvent,
        EBaseGameEvents::GE_ClearDecalsForSkeletonInstanceEvent,
        EBaseGameEvents::GE_Source1LegacyGameEventList,
        EBaseGameEvents::GE_Source1LegacyListenEvents,
        EBaseGameEvents::GE_Source1LegacyGameEvent,
        EBaseGameEvents::GE_SosStartSoundEvent,
        EBaseGameEvents::GE_SosStopSoundEvent,
        EBaseGameEvents::GE_SosSetSoundEventParams,
        EBaseGameEvents::GE_SosSetLibraryStackFields,
        EBaseGameEvents::GE_SosStopSoundEventHash,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBaseGameEvents {
    fn default() -> Self {
        EBaseGameEvents::GE_VDebugGameSessionIDEvent
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::networkbasetypes::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgVDebugGameSessionIDEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlaceDecalEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClearWorldDecalsEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClearEntityDecalsEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClearDecalsForSkeletonInstanceEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSource1LegacyGameEventList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSource1LegacyListenEvents {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSource1LegacyGameEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSosStartSoundEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSosStopSoundEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSosStopSoundEventHash {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSosSetSoundEventParams {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSosSetLibraryStackFields {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
