// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `fatdemo.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:MLDict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLDict {
    // message fields
    // @@protoc_insertion_point(field:MLDict.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLDict.val_string)
    pub val_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLDict.val_int)
    pub val_int: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLDict.val_float)
    pub val_float: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLDict.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLDict {
    fn default() -> &'a MLDict {
        <MLDict as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLDict {
    pub fn new() -> MLDict {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string val_string = 2;

    pub fn val_string(&self) -> &str {
        match self.val_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_val_string(&mut self) {
        self.val_string = ::std::option::Option::None;
    }

    pub fn has_val_string(&self) -> bool {
        self.val_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_string(&mut self, v: ::std::string::String) {
        self.val_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
        if self.val_string.is_none() {
            self.val_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.val_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_val_string(&mut self) -> ::std::string::String {
        self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 val_int = 3;

    pub fn val_int(&self) -> i32 {
        self.val_int.unwrap_or(0)
    }

    pub fn clear_val_int(&mut self) {
        self.val_int = ::std::option::Option::None;
    }

    pub fn has_val_int(&self) -> bool {
        self.val_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_int(&mut self, v: i32) {
        self.val_int = ::std::option::Option::Some(v);
    }

    // optional float val_float = 4;

    pub fn val_float(&self) -> f32 {
        self.val_float.unwrap_or(0.)
    }

    pub fn clear_val_float(&mut self) {
        self.val_float = ::std::option::Option::None;
    }

    pub fn has_val_float(&self) -> bool {
        self.val_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_float(&mut self, v: f32) {
        self.val_float = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLDict {
    const NAME: &'static str = "MLDict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.val_string = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.val_int = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.val_float = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.val_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.val_int {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.val_float {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.val_string.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.val_int {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.val_float {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLDict {
        MLDict::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.val_string = ::std::option::Option::None;
        self.val_int = ::std::option::Option::None;
        self.val_float = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLDict {
        static instance: MLDict = MLDict {
            key: ::std::option::Option::None,
            val_string: ::std::option::Option::None,
            val_int: ::std::option::Option::None,
            val_float: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLEvent {
    // message fields
    // @@protoc_insertion_point(field:MLEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLEvent.data)
    pub data: ::std::vec::Vec<MLDict>,
    // special fields
    // @@protoc_insertion_point(special_field:MLEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLEvent {
    fn default() -> &'a MLEvent {
        <MLEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLEvent {
    pub fn new() -> MLEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLEvent {
    const NAME: &'static str = "MLEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLEvent {
        MLEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLEvent {
        static instance: MLEvent = MLEvent {
            event_name: ::std::option::Option::None,
            data: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLMatchState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLMatchState {
    // message fields
    // @@protoc_insertion_point(field:MLMatchState.game_mode)
    pub game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLMatchState.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLMatchState.round)
    pub round: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLMatchState.score_ct)
    pub score_ct: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLMatchState.score_t)
    pub score_t: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLMatchState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLMatchState {
    fn default() -> &'a MLMatchState {
        <MLMatchState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLMatchState {
    pub fn new() -> MLMatchState {
        ::std::default::Default::default()
    }

    // optional string game_mode = 1;

    pub fn game_mode(&self) -> &str {
        match self.game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: ::std::string::String) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mode(&mut self) -> &mut ::std::string::String {
        if self.game_mode.is_none() {
            self.game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mode(&mut self) -> ::std::string::String {
        self.game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string phase = 2;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 round = 3;

    pub fn round(&self) -> i32 {
        self.round.unwrap_or(0)
    }

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional int32 score_ct = 4;

    pub fn score_ct(&self) -> i32 {
        self.score_ct.unwrap_or(0)
    }

    pub fn clear_score_ct(&mut self) {
        self.score_ct = ::std::option::Option::None;
    }

    pub fn has_score_ct(&self) -> bool {
        self.score_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_ct(&mut self, v: i32) {
        self.score_ct = ::std::option::Option::Some(v);
    }

    // optional int32 score_t = 5;

    pub fn score_t(&self) -> i32 {
        self.score_t.unwrap_or(0)
    }

    pub fn clear_score_t(&mut self) {
        self.score_t = ::std::option::Option::None;
    }

    pub fn has_score_t(&self) -> bool {
        self.score_t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_t(&mut self, v: i32) {
        self.score_t = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLMatchState {
    const NAME: &'static str = "MLMatchState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.round = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.score_ct = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.score_t = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_mode.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.phase.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.round {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.score_ct {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.score_t {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_mode.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.phase.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.round {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.score_ct {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.score_t {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLMatchState {
        MLMatchState::new()
    }

    fn clear(&mut self) {
        self.game_mode = ::std::option::Option::None;
        self.phase = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.score_ct = ::std::option::Option::None;
        self.score_t = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLMatchState {
        static instance: MLMatchState = MLMatchState {
            game_mode: ::std::option::Option::None,
            phase: ::std::option::Option::None,
            round: ::std::option::Option::None,
            score_ct: ::std::option::Option::None,
            score_t: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLRoundState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLRoundState {
    // message fields
    // @@protoc_insertion_point(field:MLRoundState.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLRoundState.win_team)
    pub win_team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETeam>>,
    // @@protoc_insertion_point(field:MLRoundState.bomb_state)
    pub bomb_state: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MLRoundState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLRoundState {
    fn default() -> &'a MLRoundState {
        <MLRoundState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLRoundState {
    pub fn new() -> MLRoundState {
        ::std::default::Default::default()
    }

    // optional string phase = 1;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ETeam win_team = 2;

    pub fn win_team(&self) -> ETeam {
        match self.win_team {
            Some(e) => e.enum_value_or(ETeam::ET_Unknown),
            None => ETeam::ET_Unknown,
        }
    }

    pub fn clear_win_team(&mut self) {
        self.win_team = ::std::option::Option::None;
    }

    pub fn has_win_team(&self) -> bool {
        self.win_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_team(&mut self, v: ETeam) {
        self.win_team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string bomb_state = 3;

    pub fn bomb_state(&self) -> &str {
        match self.bomb_state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bomb_state(&mut self) {
        self.bomb_state = ::std::option::Option::None;
    }

    pub fn has_bomb_state(&self) -> bool {
        self.bomb_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bomb_state(&mut self, v: ::std::string::String) {
        self.bomb_state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bomb_state(&mut self) -> &mut ::std::string::String {
        if self.bomb_state.is_none() {
            self.bomb_state = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bomb_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_bomb_state(&mut self) -> ::std::string::String {
        self.bomb_state.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLRoundState {
    const NAME: &'static str = "MLRoundState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.win_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.bomb_state = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.win_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.bomb_state.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.phase.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.win_team {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bomb_state.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLRoundState {
        MLRoundState::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.win_team = ::std::option::Option::None;
        self.bomb_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLRoundState {
        static instance: MLRoundState = MLRoundState {
            phase: ::std::option::Option::None,
            win_team: ::std::option::Option::None,
            bomb_state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLWeaponState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLWeaponState {
    // message fields
    // @@protoc_insertion_point(field:MLWeaponState.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLWeaponState.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EWeaponType>>,
    // @@protoc_insertion_point(field:MLWeaponState.ammo_clip)
    pub ammo_clip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.ammo_clip_max)
    pub ammo_clip_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.ammo_reserve)
    pub ammo_reserve: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.state)
    pub state: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLWeaponState.recoil_index)
    pub recoil_index: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLWeaponState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLWeaponState {
    fn default() -> &'a MLWeaponState {
        <MLWeaponState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLWeaponState {
    pub fn new() -> MLWeaponState {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EWeaponType type = 3;

    pub fn type_(&self) -> EWeaponType {
        match self.type_ {
            Some(e) => e.enum_value_or(EWeaponType::EWT_Knife),
            None => EWeaponType::EWT_Knife,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EWeaponType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 ammo_clip = 4;

    pub fn ammo_clip(&self) -> i32 {
        self.ammo_clip.unwrap_or(0)
    }

    pub fn clear_ammo_clip(&mut self) {
        self.ammo_clip = ::std::option::Option::None;
    }

    pub fn has_ammo_clip(&self) -> bool {
        self.ammo_clip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_clip(&mut self, v: i32) {
        self.ammo_clip = ::std::option::Option::Some(v);
    }

    // optional int32 ammo_clip_max = 5;

    pub fn ammo_clip_max(&self) -> i32 {
        self.ammo_clip_max.unwrap_or(0)
    }

    pub fn clear_ammo_clip_max(&mut self) {
        self.ammo_clip_max = ::std::option::Option::None;
    }

    pub fn has_ammo_clip_max(&self) -> bool {
        self.ammo_clip_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_clip_max(&mut self, v: i32) {
        self.ammo_clip_max = ::std::option::Option::Some(v);
    }

    // optional int32 ammo_reserve = 6;

    pub fn ammo_reserve(&self) -> i32 {
        self.ammo_reserve.unwrap_or(0)
    }

    pub fn clear_ammo_reserve(&mut self) {
        self.ammo_reserve = ::std::option::Option::None;
    }

    pub fn has_ammo_reserve(&self) -> bool {
        self.ammo_reserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_reserve(&mut self, v: i32) {
        self.ammo_reserve = ::std::option::Option::Some(v);
    }

    // optional string state = 7;

    pub fn state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        if self.state.is_none() {
            self.state = ::std::option::Option::Some(::std::string::String::new());
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        self.state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float recoil_index = 8;

    pub fn recoil_index(&self) -> f32 {
        self.recoil_index.unwrap_or(0.)
    }

    pub fn clear_recoil_index(&mut self) {
        self.recoil_index = ::std::option::Option::None;
    }

    pub fn has_recoil_index(&self) -> bool {
        self.recoil_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recoil_index(&mut self, v: f32) {
        self.recoil_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLWeaponState {
    const NAME: &'static str = "MLWeaponState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.ammo_clip = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.ammo_clip_max = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.ammo_reserve = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.state = ::std::option::Option::Some(is.read_string()?);
                },
                69 => {
                    self.recoil_index = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.ammo_clip {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.ammo_clip_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.ammo_reserve {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.state.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.recoil_index {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ammo_clip {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ammo_clip_max {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ammo_reserve {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.recoil_index {
            os.write_float(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLWeaponState {
        MLWeaponState::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.ammo_clip = ::std::option::Option::None;
        self.ammo_clip_max = ::std::option::Option::None;
        self.ammo_reserve = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.recoil_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLWeaponState {
        static instance: MLWeaponState = MLWeaponState {
            index: ::std::option::Option::None,
            name: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            ammo_clip: ::std::option::Option::None,
            ammo_clip_max: ::std::option::Option::None,
            ammo_reserve: ::std::option::Option::None,
            state: ::std::option::Option::None,
            recoil_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLPlayerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLPlayerState {
    // message fields
    // @@protoc_insertion_point(field:MLPlayerState.account_id)
    pub account_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLPlayerState.clan)
    pub clan: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLPlayerState.team)
    pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETeam>>,
    // @@protoc_insertion_point(field:MLPlayerState.abspos)
    pub abspos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:MLPlayerState.eyeangle)
    pub eyeangle: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:MLPlayerState.eyeangle_fwd)
    pub eyeangle_fwd: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:MLPlayerState.health)
    pub health: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.armor)
    pub armor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.flashed)
    pub flashed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MLPlayerState.smoked)
    pub smoked: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MLPlayerState.money)
    pub money: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.round_kills)
    pub round_kills: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.round_killhs)
    pub round_killhs: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.burning)
    pub burning: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MLPlayerState.helmet)
    pub helmet: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MLPlayerState.defuse_kit)
    pub defuse_kit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MLPlayerState.weapons)
    pub weapons: ::std::vec::Vec<MLWeaponState>,
    // special fields
    // @@protoc_insertion_point(special_field:MLPlayerState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLPlayerState {
    fn default() -> &'a MLPlayerState {
        <MLPlayerState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLPlayerState {
    pub fn new() -> MLPlayerState {
        ::std::default::Default::default()
    }

    // optional int32 account_id = 1;

    pub fn account_id(&self) -> i32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: i32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 2;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 entindex = 3;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string clan = 5;

    pub fn clan(&self) -> &str {
        match self.clan.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clan(&mut self) {
        self.clan = ::std::option::Option::None;
    }

    pub fn has_clan(&self) -> bool {
        self.clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan(&mut self, v: ::std::string::String) {
        self.clan = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clan(&mut self) -> &mut ::std::string::String {
        if self.clan.is_none() {
            self.clan = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clan.as_mut().unwrap()
    }

    // Take field
    pub fn take_clan(&mut self) -> ::std::string::String {
        self.clan.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ETeam team = 6;

    pub fn team(&self) -> ETeam {
        match self.team {
            Some(e) => e.enum_value_or(ETeam::ET_Unknown),
            None => ETeam::ET_Unknown,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: ETeam) {
        self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 health = 10;

    pub fn health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional int32 armor = 11;

    pub fn armor(&self) -> i32 {
        self.armor.unwrap_or(0)
    }

    pub fn clear_armor(&mut self) {
        self.armor = ::std::option::Option::None;
    }

    pub fn has_armor(&self) -> bool {
        self.armor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor(&mut self, v: i32) {
        self.armor = ::std::option::Option::Some(v);
    }

    // optional float flashed = 12;

    pub fn flashed(&self) -> f32 {
        self.flashed.unwrap_or(0.)
    }

    pub fn clear_flashed(&mut self) {
        self.flashed = ::std::option::Option::None;
    }

    pub fn has_flashed(&self) -> bool {
        self.flashed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flashed(&mut self, v: f32) {
        self.flashed = ::std::option::Option::Some(v);
    }

    // optional float smoked = 13;

    pub fn smoked(&self) -> f32 {
        self.smoked.unwrap_or(0.)
    }

    pub fn clear_smoked(&mut self) {
        self.smoked = ::std::option::Option::None;
    }

    pub fn has_smoked(&self) -> bool {
        self.smoked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smoked(&mut self, v: f32) {
        self.smoked = ::std::option::Option::Some(v);
    }

    // optional int32 money = 14;

    pub fn money(&self) -> i32 {
        self.money.unwrap_or(0)
    }

    pub fn clear_money(&mut self) {
        self.money = ::std::option::Option::None;
    }

    pub fn has_money(&self) -> bool {
        self.money.is_some()
    }

    // Param is passed by value, moved
    pub fn set_money(&mut self, v: i32) {
        self.money = ::std::option::Option::Some(v);
    }

    // optional int32 round_kills = 15;

    pub fn round_kills(&self) -> i32 {
        self.round_kills.unwrap_or(0)
    }

    pub fn clear_round_kills(&mut self) {
        self.round_kills = ::std::option::Option::None;
    }

    pub fn has_round_kills(&self) -> bool {
        self.round_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_kills(&mut self, v: i32) {
        self.round_kills = ::std::option::Option::Some(v);
    }

    // optional int32 round_killhs = 16;

    pub fn round_killhs(&self) -> i32 {
        self.round_killhs.unwrap_or(0)
    }

    pub fn clear_round_killhs(&mut self) {
        self.round_killhs = ::std::option::Option::None;
    }

    pub fn has_round_killhs(&self) -> bool {
        self.round_killhs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_killhs(&mut self, v: i32) {
        self.round_killhs = ::std::option::Option::Some(v);
    }

    // optional float burning = 17;

    pub fn burning(&self) -> f32 {
        self.burning.unwrap_or(0.)
    }

    pub fn clear_burning(&mut self) {
        self.burning = ::std::option::Option::None;
    }

    pub fn has_burning(&self) -> bool {
        self.burning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burning(&mut self, v: f32) {
        self.burning = ::std::option::Option::Some(v);
    }

    // optional bool helmet = 18;

    pub fn helmet(&self) -> bool {
        self.helmet.unwrap_or(false)
    }

    pub fn clear_helmet(&mut self) {
        self.helmet = ::std::option::Option::None;
    }

    pub fn has_helmet(&self) -> bool {
        self.helmet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_helmet(&mut self, v: bool) {
        self.helmet = ::std::option::Option::Some(v);
    }

    // optional bool defuse_kit = 19;

    pub fn defuse_kit(&self) -> bool {
        self.defuse_kit.unwrap_or(false)
    }

    pub fn clear_defuse_kit(&mut self) {
        self.defuse_kit = ::std::option::Option::None;
    }

    pub fn has_defuse_kit(&self) -> bool {
        self.defuse_kit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defuse_kit(&mut self, v: bool) {
        self.defuse_kit = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLPlayerState {
    const NAME: &'static str = "MLPlayerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.clan = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.abspos)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.eyeangle)?;
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.eyeangle_fwd)?;
                },
                80 => {
                    self.health = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.armor = ::std::option::Option::Some(is.read_int32()?);
                },
                101 => {
                    self.flashed = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.smoked = ::std::option::Option::Some(is.read_float()?);
                },
                112 => {
                    self.money = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.round_kills = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.round_killhs = ::std::option::Option::Some(is.read_int32()?);
                },
                141 => {
                    self.burning = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.helmet = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.defuse_kit = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.weapons.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.clan.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.abspos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eyeangle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eyeangle_fwd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.health {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.armor {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.flashed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.smoked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.money {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.round_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.round_killhs {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, v);
        }
        if let Some(v) = self.burning {
            my_size += 2 + 4;
        }
        if let Some(v) = self.helmet {
            my_size += 2 + 1;
        }
        if let Some(v) = self.defuse_kit {
            my_size += 2 + 1;
        }
        for value in &self.weapons {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.clan.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.team {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.abspos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.eyeangle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.eyeangle_fwd.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.health {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.armor {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.flashed {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.smoked {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.money {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.round_kills {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.round_killhs {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.burning {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.helmet {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.defuse_kit {
            os.write_bool(19, v)?;
        }
        for v in &self.weapons {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLPlayerState {
        MLPlayerState::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.clan = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.abspos.clear();
        self.eyeangle.clear();
        self.eyeangle_fwd.clear();
        self.health = ::std::option::Option::None;
        self.armor = ::std::option::Option::None;
        self.flashed = ::std::option::Option::None;
        self.smoked = ::std::option::Option::None;
        self.money = ::std::option::Option::None;
        self.round_kills = ::std::option::Option::None;
        self.round_killhs = ::std::option::Option::None;
        self.burning = ::std::option::Option::None;
        self.helmet = ::std::option::Option::None;
        self.defuse_kit = ::std::option::Option::None;
        self.weapons.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLPlayerState {
        static instance: MLPlayerState = MLPlayerState {
            account_id: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            entindex: ::std::option::Option::None,
            name: ::std::option::Option::None,
            clan: ::std::option::Option::None,
            team: ::std::option::Option::None,
            abspos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            eyeangle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            eyeangle_fwd: ::steam_vent_proto_common::protobuf::MessageField::none(),
            health: ::std::option::Option::None,
            armor: ::std::option::Option::None,
            flashed: ::std::option::Option::None,
            smoked: ::std::option::Option::None,
            money: ::std::option::Option::None,
            round_kills: ::std::option::Option::None,
            round_killhs: ::std::option::Option::None,
            burning: ::std::option::Option::None,
            helmet: ::std::option::Option::None,
            defuse_kit: ::std::option::Option::None,
            weapons: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLGameState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLGameState {
    // message fields
    // @@protoc_insertion_point(field:MLGameState.match)
    pub match_: ::steam_vent_proto_common::protobuf::MessageField<MLMatchState>,
    // @@protoc_insertion_point(field:MLGameState.round)
    pub round: ::steam_vent_proto_common::protobuf::MessageField<MLRoundState>,
    // @@protoc_insertion_point(field:MLGameState.players)
    pub players: ::std::vec::Vec<MLPlayerState>,
    // special fields
    // @@protoc_insertion_point(special_field:MLGameState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLGameState {
    fn default() -> &'a MLGameState {
        <MLGameState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLGameState {
    pub fn new() -> MLGameState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLGameState {
    const NAME: &'static str = "MLGameState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.round)?;
                },
                26 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.round.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.round.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLGameState {
        MLGameState::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.round.clear();
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLGameState {
        static instance: MLGameState = MLGameState {
            match_: ::steam_vent_proto_common::protobuf::MessageField::none(),
            round: ::steam_vent_proto_common::protobuf::MessageField::none(),
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLDemoHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLDemoHeader {
    // message fields
    // @@protoc_insertion_point(field:MLDemoHeader.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLDemoHeader.tick_rate)
    pub tick_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLDemoHeader.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MLDemoHeader.steam_universe)
    pub steam_universe: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLDemoHeader.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLDemoHeader {
    fn default() -> &'a MLDemoHeader {
        <MLDemoHeader as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLDemoHeader {
    pub fn new() -> MLDemoHeader {
        ::std::default::Default::default()
    }

    // optional string map_name = 1;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tick_rate = 2;

    pub fn tick_rate(&self) -> i32 {
        self.tick_rate.unwrap_or(0)
    }

    pub fn clear_tick_rate(&mut self) {
        self.tick_rate = ::std::option::Option::None;
    }

    pub fn has_tick_rate(&self) -> bool {
        self.tick_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_rate(&mut self, v: i32) {
        self.tick_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 version = 3;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_universe = 4;

    pub fn steam_universe(&self) -> u32 {
        self.steam_universe.unwrap_or(0)
    }

    pub fn clear_steam_universe(&mut self) {
        self.steam_universe = ::std::option::Option::None;
    }

    pub fn has_steam_universe(&self) -> bool {
        self.steam_universe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_universe(&mut self, v: u32) {
        self.steam_universe = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLDemoHeader {
    const NAME: &'static str = "MLDemoHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.tick_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.steam_universe = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tick_rate {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.steam_universe {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.tick_rate {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steam_universe {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLDemoHeader {
        MLDemoHeader::new()
    }

    fn clear(&mut self) {
        self.map_name = ::std::option::Option::None;
        self.tick_rate = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.steam_universe = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLDemoHeader {
        static instance: MLDemoHeader = MLDemoHeader {
            map_name: ::std::option::Option::None,
            tick_rate: ::std::option::Option::None,
            version: ::std::option::Option::None,
            steam_universe: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:MLTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLTick {
    // message fields
    // @@protoc_insertion_point(field:MLTick.tick_count)
    pub tick_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLTick.state)
    pub state: ::steam_vent_proto_common::protobuf::MessageField<MLGameState>,
    // @@protoc_insertion_point(field:MLTick.events)
    pub events: ::std::vec::Vec<MLEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:MLTick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLTick {
    fn default() -> &'a MLTick {
        <MLTick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl MLTick {
    pub fn new() -> MLTick {
        ::std::default::Default::default()
    }

    // optional int32 tick_count = 1;

    pub fn tick_count(&self) -> i32 {
        self.tick_count.unwrap_or(0)
    }

    pub fn clear_tick_count(&mut self) {
        self.tick_count = ::std::option::Option::None;
    }

    pub fn has_tick_count(&self) -> bool {
        self.tick_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_count(&mut self, v: i32) {
        self.tick_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for MLTick {
    const NAME: &'static str = "MLTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick_count = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tick_count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLTick {
        MLTick::new()
    }

    fn clear(&mut self) {
        self.tick_count = ::std::option::Option::None;
        self.state.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLTick {
        static instance: MLTick = MLTick {
            tick_count: ::std::option::Option::None,
            state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:VacNetShot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VacNetShot {
    // message fields
    // @@protoc_insertion_point(field:VacNetShot.steamid_player)
    pub steamid_player: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:VacNetShot.round_number)
    pub round_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:VacNetShot.hit_type)
    pub hit_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:VacNetShot.weapon_type)
    pub weapon_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:VacNetShot.distance_to_hurt_target)
    pub distance_to_hurt_target: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:VacNetShot.delta_yaw_window)
    pub delta_yaw_window: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:VacNetShot.delta_pitch_window)
    pub delta_pitch_window: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:VacNetShot.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VacNetShot {
    fn default() -> &'a VacNetShot {
        <VacNetShot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl VacNetShot {
    pub fn new() -> VacNetShot {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_player = 1;

    pub fn steamid_player(&self) -> u64 {
        self.steamid_player.unwrap_or(0)
    }

    pub fn clear_steamid_player(&mut self) {
        self.steamid_player = ::std::option::Option::None;
    }

    pub fn has_steamid_player(&self) -> bool {
        self.steamid_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_player(&mut self, v: u64) {
        self.steamid_player = ::std::option::Option::Some(v);
    }

    // optional int32 round_number = 2;

    pub fn round_number(&self) -> i32 {
        self.round_number.unwrap_or(0)
    }

    pub fn clear_round_number(&mut self) {
        self.round_number = ::std::option::Option::None;
    }

    pub fn has_round_number(&self) -> bool {
        self.round_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_number(&mut self, v: i32) {
        self.round_number = ::std::option::Option::Some(v);
    }

    // optional int32 hit_type = 3;

    pub fn hit_type(&self) -> i32 {
        self.hit_type.unwrap_or(0)
    }

    pub fn clear_hit_type(&mut self) {
        self.hit_type = ::std::option::Option::None;
    }

    pub fn has_hit_type(&self) -> bool {
        self.hit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hit_type(&mut self, v: i32) {
        self.hit_type = ::std::option::Option::Some(v);
    }

    // optional int32 weapon_type = 4;

    pub fn weapon_type(&self) -> i32 {
        self.weapon_type.unwrap_or(0)
    }

    pub fn clear_weapon_type(&mut self) {
        self.weapon_type = ::std::option::Option::None;
    }

    pub fn has_weapon_type(&self) -> bool {
        self.weapon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weapon_type(&mut self, v: i32) {
        self.weapon_type = ::std::option::Option::Some(v);
    }

    // optional float distance_to_hurt_target = 5;

    pub fn distance_to_hurt_target(&self) -> f32 {
        self.distance_to_hurt_target.unwrap_or(0.)
    }

    pub fn clear_distance_to_hurt_target(&mut self) {
        self.distance_to_hurt_target = ::std::option::Option::None;
    }

    pub fn has_distance_to_hurt_target(&self) -> bool {
        self.distance_to_hurt_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance_to_hurt_target(&mut self, v: f32) {
        self.distance_to_hurt_target = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for VacNetShot {
    const NAME: &'static str = "VacNetShot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_player = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.round_number = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.hit_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.weapon_type = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.distance_to_hurt_target = ::std::option::Option::Some(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_float_into(&mut self.delta_yaw_window)?;
                },
                53 => {
                    self.delta_yaw_window.push(is.read_float()?);
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.delta_pitch_window)?;
                },
                61 => {
                    self.delta_pitch_window.push(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_player {
            my_size += 1 + 8;
        }
        if let Some(v) = self.round_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.hit_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.weapon_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.distance_to_hurt_target {
            my_size += 1 + 4;
        }
        my_size += 5 * self.delta_yaw_window.len() as u64;
        my_size += 5 * self.delta_pitch_window.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid_player {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.round_number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.hit_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.weapon_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.distance_to_hurt_target {
            os.write_float(5, v)?;
        }
        for v in &self.delta_yaw_window {
            os.write_float(6, *v)?;
        };
        for v in &self.delta_pitch_window {
            os.write_float(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VacNetShot {
        VacNetShot::new()
    }

    fn clear(&mut self) {
        self.steamid_player = ::std::option::Option::None;
        self.round_number = ::std::option::Option::None;
        self.hit_type = ::std::option::Option::None;
        self.weapon_type = ::std::option::Option::None;
        self.distance_to_hurt_target = ::std::option::Option::None;
        self.delta_yaw_window.clear();
        self.delta_pitch_window.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VacNetShot {
        static instance: VacNetShot = VacNetShot {
            steamid_player: ::std::option::Option::None,
            round_number: ::std::option::Option::None,
            hit_type: ::std::option::Option::None,
            weapon_type: ::std::option::Option::None,
            distance_to_hurt_target: ::std::option::Option::None,
            delta_yaw_window: ::std::vec::Vec::new(),
            delta_pitch_window: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHitGroup)
pub enum EHitGroup {
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Generic)
    EHG_Generic = 0,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Head)
    EHG_Head = 1,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Chest)
    EHG_Chest = 2,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Stomach)
    EHG_Stomach = 3,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_LeftArm)
    EHG_LeftArm = 4,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_RightArm)
    EHG_RightArm = 5,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_LeftLeg)
    EHG_LeftLeg = 6,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_RightLeg)
    EHG_RightLeg = 7,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Gear)
    EHG_Gear = 8,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Miss)
    EHG_Miss = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for EHitGroup {
    const NAME: &'static str = "EHitGroup";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHitGroup> {
        match value {
            0 => ::std::option::Option::Some(EHitGroup::EHG_Generic),
            1 => ::std::option::Option::Some(EHitGroup::EHG_Head),
            2 => ::std::option::Option::Some(EHitGroup::EHG_Chest),
            3 => ::std::option::Option::Some(EHitGroup::EHG_Stomach),
            4 => ::std::option::Option::Some(EHitGroup::EHG_LeftArm),
            5 => ::std::option::Option::Some(EHitGroup::EHG_RightArm),
            6 => ::std::option::Option::Some(EHitGroup::EHG_LeftLeg),
            7 => ::std::option::Option::Some(EHitGroup::EHG_RightLeg),
            8 => ::std::option::Option::Some(EHitGroup::EHG_Gear),
            9 => ::std::option::Option::Some(EHitGroup::EHG_Miss),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHitGroup> {
        match str {
            "EHG_Generic" => ::std::option::Option::Some(EHitGroup::EHG_Generic),
            "EHG_Head" => ::std::option::Option::Some(EHitGroup::EHG_Head),
            "EHG_Chest" => ::std::option::Option::Some(EHitGroup::EHG_Chest),
            "EHG_Stomach" => ::std::option::Option::Some(EHitGroup::EHG_Stomach),
            "EHG_LeftArm" => ::std::option::Option::Some(EHitGroup::EHG_LeftArm),
            "EHG_RightArm" => ::std::option::Option::Some(EHitGroup::EHG_RightArm),
            "EHG_LeftLeg" => ::std::option::Option::Some(EHitGroup::EHG_LeftLeg),
            "EHG_RightLeg" => ::std::option::Option::Some(EHitGroup::EHG_RightLeg),
            "EHG_Gear" => ::std::option::Option::Some(EHitGroup::EHG_Gear),
            "EHG_Miss" => ::std::option::Option::Some(EHitGroup::EHG_Miss),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHitGroup] = &[
        EHitGroup::EHG_Generic,
        EHitGroup::EHG_Head,
        EHitGroup::EHG_Chest,
        EHitGroup::EHG_Stomach,
        EHitGroup::EHG_LeftArm,
        EHitGroup::EHG_RightArm,
        EHitGroup::EHG_LeftLeg,
        EHitGroup::EHG_RightLeg,
        EHitGroup::EHG_Gear,
        EHitGroup::EHG_Miss,
    ];
}

impl ::std::default::Default for EHitGroup {
    fn default() -> Self {
        EHitGroup::EHG_Generic
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETeam)
pub enum ETeam {
    // @@protoc_insertion_point(enum_value:ETeam.ET_Unknown)
    ET_Unknown = 0,
    // @@protoc_insertion_point(enum_value:ETeam.ET_Spectator)
    ET_Spectator = 1,
    // @@protoc_insertion_point(enum_value:ETeam.ET_Terrorist)
    ET_Terrorist = 2,
    // @@protoc_insertion_point(enum_value:ETeam.ET_CT)
    ET_CT = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETeam {
    const NAME: &'static str = "ETeam";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeam> {
        match value {
            0 => ::std::option::Option::Some(ETeam::ET_Unknown),
            1 => ::std::option::Option::Some(ETeam::ET_Spectator),
            2 => ::std::option::Option::Some(ETeam::ET_Terrorist),
            3 => ::std::option::Option::Some(ETeam::ET_CT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeam> {
        match str {
            "ET_Unknown" => ::std::option::Option::Some(ETeam::ET_Unknown),
            "ET_Spectator" => ::std::option::Option::Some(ETeam::ET_Spectator),
            "ET_Terrorist" => ::std::option::Option::Some(ETeam::ET_Terrorist),
            "ET_CT" => ::std::option::Option::Some(ETeam::ET_CT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeam] = &[
        ETeam::ET_Unknown,
        ETeam::ET_Spectator,
        ETeam::ET_Terrorist,
        ETeam::ET_CT,
    ];
}

impl ::std::default::Default for ETeam {
    fn default() -> Self {
        ETeam::ET_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EWeaponType)
pub enum EWeaponType {
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Knife)
    EWT_Knife = 0,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Pistol)
    EWT_Pistol = 1,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_SubMachineGun)
    EWT_SubMachineGun = 2,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Rifle)
    EWT_Rifle = 3,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Shotgun)
    EWT_Shotgun = 4,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_SniperRifle)
    EWT_SniperRifle = 5,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_MachineGun)
    EWT_MachineGun = 6,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_C4)
    EWT_C4 = 7,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Grenade)
    EWT_Grenade = 8,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Equipment)
    EWT_Equipment = 9,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_StackableItem)
    EWT_StackableItem = 10,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Unknown)
    EWT_Unknown = 11,
}

impl ::steam_vent_proto_common::protobuf::Enum for EWeaponType {
    const NAME: &'static str = "EWeaponType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EWeaponType> {
        match value {
            0 => ::std::option::Option::Some(EWeaponType::EWT_Knife),
            1 => ::std::option::Option::Some(EWeaponType::EWT_Pistol),
            2 => ::std::option::Option::Some(EWeaponType::EWT_SubMachineGun),
            3 => ::std::option::Option::Some(EWeaponType::EWT_Rifle),
            4 => ::std::option::Option::Some(EWeaponType::EWT_Shotgun),
            5 => ::std::option::Option::Some(EWeaponType::EWT_SniperRifle),
            6 => ::std::option::Option::Some(EWeaponType::EWT_MachineGun),
            7 => ::std::option::Option::Some(EWeaponType::EWT_C4),
            8 => ::std::option::Option::Some(EWeaponType::EWT_Grenade),
            9 => ::std::option::Option::Some(EWeaponType::EWT_Equipment),
            10 => ::std::option::Option::Some(EWeaponType::EWT_StackableItem),
            11 => ::std::option::Option::Some(EWeaponType::EWT_Unknown),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EWeaponType> {
        match str {
            "EWT_Knife" => ::std::option::Option::Some(EWeaponType::EWT_Knife),
            "EWT_Pistol" => ::std::option::Option::Some(EWeaponType::EWT_Pistol),
            "EWT_SubMachineGun" => ::std::option::Option::Some(EWeaponType::EWT_SubMachineGun),
            "EWT_Rifle" => ::std::option::Option::Some(EWeaponType::EWT_Rifle),
            "EWT_Shotgun" => ::std::option::Option::Some(EWeaponType::EWT_Shotgun),
            "EWT_SniperRifle" => ::std::option::Option::Some(EWeaponType::EWT_SniperRifle),
            "EWT_MachineGun" => ::std::option::Option::Some(EWeaponType::EWT_MachineGun),
            "EWT_C4" => ::std::option::Option::Some(EWeaponType::EWT_C4),
            "EWT_Grenade" => ::std::option::Option::Some(EWeaponType::EWT_Grenade),
            "EWT_Equipment" => ::std::option::Option::Some(EWeaponType::EWT_Equipment),
            "EWT_StackableItem" => ::std::option::Option::Some(EWeaponType::EWT_StackableItem),
            "EWT_Unknown" => ::std::option::Option::Some(EWeaponType::EWT_Unknown),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EWeaponType] = &[
        EWeaponType::EWT_Knife,
        EWeaponType::EWT_Pistol,
        EWeaponType::EWT_SubMachineGun,
        EWeaponType::EWT_Rifle,
        EWeaponType::EWT_Shotgun,
        EWeaponType::EWT_SniperRifle,
        EWeaponType::EWT_MachineGun,
        EWeaponType::EWT_C4,
        EWeaponType::EWT_Grenade,
        EWeaponType::EWT_Equipment,
        EWeaponType::EWT_StackableItem,
        EWeaponType::EWT_Unknown,
    ];
}

impl ::std::default::Default for EWeaponType {
    fn default() -> Self {
        EWeaponType::EWT_Knife
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::networkbasetypes::*;
impl ::steam_vent_proto_common::RpcMessage for MLDict {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLMatchState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLRoundState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLWeaponState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLPlayerState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLGameState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLDemoHeader {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for MLTick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for VacNetShot {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
