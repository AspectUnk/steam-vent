// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_scenariomessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CScenario_Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenario_Position {
    // message fields
    // @@protoc_insertion_point(field:CScenario_Position.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CScenario_Position.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CScenario_Position.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenario_Position {
    fn default() -> &'a CScenario_Position {
        <CScenario_Position as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CScenario_Position {
    pub fn new() -> CScenario_Position {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CScenario_Position {
    const NAME: &'static str = "CScenario_Position";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenario_Position {
        CScenario_Position::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenario_Position {
        static instance: CScenario_Position = CScenario_Position {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CScenarioGame_RoshanSpawner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioGame_RoshanSpawner {
    // message fields
    // @@protoc_insertion_point(field:CScenarioGame_RoshanSpawner.kill_count)
    pub kill_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CScenarioGame_RoshanSpawner.state)
    pub state: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CScenarioGame_RoshanSpawner.cooldown)
    pub cooldown: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CScenarioGame_RoshanSpawner.killer_team)
    pub killer_team: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CScenarioGame_RoshanSpawner.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioGame_RoshanSpawner {
    fn default() -> &'a CScenarioGame_RoshanSpawner {
        <CScenarioGame_RoshanSpawner as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CScenarioGame_RoshanSpawner {
    pub fn new() -> CScenarioGame_RoshanSpawner {
        ::std::default::Default::default()
    }

    // optional int32 kill_count = 1;

    pub fn kill_count(&self) -> i32 {
        self.kill_count.unwrap_or(0)
    }

    pub fn clear_kill_count(&mut self) {
        self.kill_count = ::std::option::Option::None;
    }

    pub fn has_kill_count(&self) -> bool {
        self.kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_count(&mut self, v: i32) {
        self.kill_count = ::std::option::Option::Some(v);
    }

    // optional int32 state = 2;

    pub fn state(&self) -> i32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional float cooldown = 3;

    pub fn cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(0.)
    }

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }

    // optional int32 killer_team = 4;

    pub fn killer_team(&self) -> i32 {
        self.killer_team.unwrap_or(0)
    }

    pub fn clear_killer_team(&mut self) {
        self.killer_team = ::std::option::Option::None;
    }

    pub fn has_killer_team(&self) -> bool {
        self.killer_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_team(&mut self, v: i32) {
        self.killer_team = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CScenarioGame_RoshanSpawner {
    const NAME: &'static str = "CScenarioGame_RoshanSpawner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kill_count = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.state = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.cooldown = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.killer_team = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kill_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.cooldown {
            my_size += 1 + 4;
        }
        if let Some(v) = self.killer_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.kill_count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.killer_team {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioGame_RoshanSpawner {
        CScenarioGame_RoshanSpawner::new()
    }

    fn clear(&mut self) {
        self.kill_count = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.cooldown = ::std::option::Option::None;
        self.killer_team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioGame_RoshanSpawner {
        static instance: CScenarioGame_RoshanSpawner = CScenarioGame_RoshanSpawner {
            kill_count: ::std::option::Option::None,
            state: ::std::option::Option::None,
            cooldown: ::std::option::Option::None,
            killer_team: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CScenarioEnt_Courier)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_Courier {
    // message fields
    // @@protoc_insertion_point(field:CScenarioEnt_Courier.team_number)
    pub team_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CScenarioEnt_Courier.owner_player_id)
    pub owner_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CScenarioEnt_Courier.cooldown)
    pub cooldown: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CScenarioEnt_Courier.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_Courier {
    fn default() -> &'a CScenarioEnt_Courier {
        <CScenarioEnt_Courier as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_Courier {
    pub fn new() -> CScenarioEnt_Courier {
        ::std::default::Default::default()
    }

    // optional int32 team_number = 1;

    pub fn team_number(&self) -> i32 {
        self.team_number.unwrap_or(0)
    }

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: i32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    // optional int32 owner_player_id = 2;

    pub fn owner_player_id(&self) -> i32 {
        self.owner_player_id.unwrap_or(-1i32)
    }

    pub fn clear_owner_player_id(&mut self) {
        self.owner_player_id = ::std::option::Option::None;
    }

    pub fn has_owner_player_id(&self) -> bool {
        self.owner_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_player_id(&mut self, v: i32) {
        self.owner_player_id = ::std::option::Option::Some(v);
    }

    // optional float cooldown = 3;

    pub fn cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(-1.0f32)
    }

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CScenarioEnt_Courier {
    const NAME: &'static str = "CScenarioEnt_Courier";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_number = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.owner_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.cooldown = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.owner_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.cooldown {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_Courier {
        CScenarioEnt_Courier::new()
    }

    fn clear(&mut self) {
        self.team_number = ::std::option::Option::None;
        self.owner_player_id = ::std::option::Option::None;
        self.cooldown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_Courier {
        static instance: CScenarioEnt_Courier = CScenarioEnt_Courier {
            team_number: ::std::option::Option::None,
            owner_player_id: ::std::option::Option::None,
            cooldown: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CScenarioEnt_NPC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_NPC {
    // message fields
    // @@protoc_insertion_point(field:CScenarioEnt_NPC.position)
    pub position: ::steam_vent_proto_common::protobuf::MessageField<CScenario_Position>,
    // @@protoc_insertion_point(field:CScenarioEnt_NPC.unit_name)
    pub unit_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CScenarioEnt_NPC.team_number)
    pub team_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CScenarioEnt_NPC.health_frac)
    pub health_frac: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CScenarioEnt_NPC.owning_camp)
    pub owning_camp: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CScenarioEnt_NPC.owning_camp_position)
    pub owning_camp_position: ::steam_vent_proto_common::protobuf::MessageField<CScenario_Position>,
    // @@protoc_insertion_point(field:CScenarioEnt_NPC.invade_goal)
    pub invade_goal: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CScenarioEnt_NPC.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_NPC {
    fn default() -> &'a CScenarioEnt_NPC {
        <CScenarioEnt_NPC as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_NPC {
    pub fn new() -> CScenarioEnt_NPC {
        ::std::default::Default::default()
    }

    // optional string unit_name = 2;

    pub fn unit_name(&self) -> &str {
        match self.unit_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unit_name(&mut self) {
        self.unit_name = ::std::option::Option::None;
    }

    pub fn has_unit_name(&self) -> bool {
        self.unit_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_name(&mut self, v: ::std::string::String) {
        self.unit_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_name(&mut self) -> &mut ::std::string::String {
        if self.unit_name.is_none() {
            self.unit_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unit_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_name(&mut self) -> ::std::string::String {
        self.unit_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 team_number = 3;

    pub fn team_number(&self) -> i32 {
        self.team_number.unwrap_or(0)
    }

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: i32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    // optional float health_frac = 4;

    pub fn health_frac(&self) -> f32 {
        self.health_frac.unwrap_or(1.0f32)
    }

    pub fn clear_health_frac(&mut self) {
        self.health_frac = ::std::option::Option::None;
    }

    pub fn has_health_frac(&self) -> bool {
        self.health_frac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_frac(&mut self, v: f32) {
        self.health_frac = ::std::option::Option::Some(v);
    }

    // optional string owning_camp = 10;

    pub fn owning_camp(&self) -> &str {
        match self.owning_camp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_owning_camp(&mut self) {
        self.owning_camp = ::std::option::Option::None;
    }

    pub fn has_owning_camp(&self) -> bool {
        self.owning_camp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_camp(&mut self, v: ::std::string::String) {
        self.owning_camp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owning_camp(&mut self) -> &mut ::std::string::String {
        if self.owning_camp.is_none() {
            self.owning_camp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.owning_camp.as_mut().unwrap()
    }

    // Take field
    pub fn take_owning_camp(&mut self) -> ::std::string::String {
        self.owning_camp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string invade_goal = 20;

    pub fn invade_goal(&self) -> &str {
        match self.invade_goal.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invade_goal(&mut self) {
        self.invade_goal = ::std::option::Option::None;
    }

    pub fn has_invade_goal(&self) -> bool {
        self.invade_goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invade_goal(&mut self, v: ::std::string::String) {
        self.invade_goal = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invade_goal(&mut self) -> &mut ::std::string::String {
        if self.invade_goal.is_none() {
            self.invade_goal = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invade_goal.as_mut().unwrap()
    }

    // Take field
    pub fn take_invade_goal(&mut self) -> ::std::string::String {
        self.invade_goal.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CScenarioEnt_NPC {
    const NAME: &'static str = "CScenarioEnt_NPC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                18 => {
                    self.unit_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.team_number = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.health_frac = ::std::option::Option::Some(is.read_float()?);
                },
                82 => {
                    self.owning_camp = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owning_camp_position)?;
                },
                162 => {
                    self.invade_goal = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.team_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.health_frac {
            my_size += 1 + 4;
        }
        if let Some(v) = self.owning_camp.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.owning_camp_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.invade_goal.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(20, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.unit_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.team_number {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.health_frac {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.owning_camp.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.owning_camp_position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.invade_goal.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_NPC {
        CScenarioEnt_NPC::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.unit_name = ::std::option::Option::None;
        self.team_number = ::std::option::Option::None;
        self.health_frac = ::std::option::Option::None;
        self.owning_camp = ::std::option::Option::None;
        self.owning_camp_position.clear();
        self.invade_goal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_NPC {
        static instance: CScenarioEnt_NPC = CScenarioEnt_NPC {
            position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            unit_name: ::std::option::Option::None,
            team_number: ::std::option::Option::None,
            health_frac: ::std::option::Option::None,
            owning_camp: ::std::option::Option::None,
            owning_camp_position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            invade_goal: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CScenarioEnt_SpiritBear)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_SpiritBear {
    // message fields
    // @@protoc_insertion_point(field:CScenarioEnt_SpiritBear.owner_id)
    pub owner_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CScenarioEnt_SpiritBear.team_id)
    pub team_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CScenarioEnt_SpiritBear.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_SpiritBear {
    fn default() -> &'a CScenarioEnt_SpiritBear {
        <CScenarioEnt_SpiritBear as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_SpiritBear {
    pub fn new() -> CScenarioEnt_SpiritBear {
        ::std::default::Default::default()
    }

    // optional int32 owner_id = 1;

    pub fn owner_id(&self) -> i32 {
        self.owner_id.unwrap_or(-1i32)
    }

    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: i32) {
        self.owner_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id = 2;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CScenarioEnt_SpiritBear {
    const NAME: &'static str = "CScenarioEnt_SpiritBear";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owner_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owner_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_SpiritBear {
        CScenarioEnt_SpiritBear::new()
    }

    fn clear(&mut self) {
        self.owner_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_SpiritBear {
        static instance: CScenarioEnt_SpiritBear = CScenarioEnt_SpiritBear {
            owner_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CScenarioEnt_DroppedItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CScenarioEnt_DroppedItem {
    // message fields
    // @@protoc_insertion_point(field:CScenarioEnt_DroppedItem.position)
    pub position: ::steam_vent_proto_common::protobuf::MessageField<CScenario_Position>,
    // special fields
    // @@protoc_insertion_point(special_field:CScenarioEnt_DroppedItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CScenarioEnt_DroppedItem {
    fn default() -> &'a CScenarioEnt_DroppedItem {
        <CScenarioEnt_DroppedItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CScenarioEnt_DroppedItem {
    pub fn new() -> CScenarioEnt_DroppedItem {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CScenarioEnt_DroppedItem {
    const NAME: &'static str = "CScenarioEnt_DroppedItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CScenarioEnt_DroppedItem {
        CScenarioEnt_DroppedItem::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CScenarioEnt_DroppedItem {
        static instance: CScenarioEnt_DroppedItem = CScenarioEnt_DroppedItem {
            position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDotaScenario)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDotaScenario {
    // message fields
    // @@protoc_insertion_point(field:CMsgDotaScenario.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.game)
    pub game: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dota_scenario::Game>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.teams)
    pub teams: ::std::vec::Vec<cmsg_dota_scenario::Team>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.heroes)
    pub heroes: ::std::vec::Vec<cmsg_dota_scenario::Hero>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.stock)
    pub stock: ::std::vec::Vec<cmsg_dota_scenario::Stock>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.buildings)
    pub buildings: ::std::vec::Vec<cmsg_dota_scenario::Building>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.entities)
    pub entities: ::std::vec::Vec<cmsg_dota_scenario::Entity>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.items)
    pub items: ::std::vec::Vec<cmsg_dota_scenario::Item>,
    // @@protoc_insertion_point(field:CMsgDotaScenario.modifiers)
    pub modifiers: ::std::vec::Vec<cmsg_dota_scenario::Modifier>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDotaScenario.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDotaScenario {
    fn default() -> &'a CMsgDotaScenario {
        <CMsgDotaScenario as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDotaScenario {
    pub fn new() -> CMsgDotaScenario {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDotaScenario {
    const NAME: &'static str = "CMsgDotaScenario";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.game)?;
                },
                26 => {
                    self.teams.push(is.read_message()?);
                },
                34 => {
                    self.heroes.push(is.read_message()?);
                },
                42 => {
                    self.stock.push(is.read_message()?);
                },
                50 => {
                    self.buildings.push(is.read_message()?);
                },
                58 => {
                    self.entities.push(is.read_message()?);
                },
                66 => {
                    self.items.push(is.read_message()?);
                },
                74 => {
                    self.modifiers.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.stock {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.modifiers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.teams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.heroes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.stock {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.buildings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.entities {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.modifiers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDotaScenario {
        CMsgDotaScenario::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.game.clear();
        self.teams.clear();
        self.heroes.clear();
        self.stock.clear();
        self.buildings.clear();
        self.entities.clear();
        self.items.clear();
        self.modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDotaScenario {
        static instance: CMsgDotaScenario = CMsgDotaScenario {
            lobby_id: ::std::option::Option::None,
            game: ::steam_vent_proto_common::protobuf::MessageField::none(),
            teams: ::std::vec::Vec::new(),
            heroes: ::std::vec::Vec::new(),
            stock: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            entities: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            modifiers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDotaScenario`
pub mod cmsg_dota_scenario {
    // @@protoc_insertion_point(message:CMsgDotaScenario.EntityRef)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EntityRef {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.EntityRef.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.EntityRef.neutral_stash_id)
        pub neutral_stash_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.EntityRef.entity_idx)
        pub entity_idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.EntityRef.roshan)
        pub roshan: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.EntityRef.ability_name)
        pub ability_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.EntityRef.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EntityRef {
        fn default() -> &'a EntityRef {
            <EntityRef as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl EntityRef {
        pub fn new() -> EntityRef {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 neutral_stash_id = 2;

        pub fn neutral_stash_id(&self) -> i32 {
            self.neutral_stash_id.unwrap_or(-1i32)
        }

        pub fn clear_neutral_stash_id(&mut self) {
            self.neutral_stash_id = ::std::option::Option::None;
        }

        pub fn has_neutral_stash_id(&self) -> bool {
            self.neutral_stash_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_stash_id(&mut self, v: i32) {
            self.neutral_stash_id = ::std::option::Option::Some(v);
        }

        // optional int32 entity_idx = 3;

        pub fn entity_idx(&self) -> i32 {
            self.entity_idx.unwrap_or(-1i32)
        }

        pub fn clear_entity_idx(&mut self) {
            self.entity_idx = ::std::option::Option::None;
        }

        pub fn has_entity_idx(&self) -> bool {
            self.entity_idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_idx(&mut self, v: i32) {
            self.entity_idx = ::std::option::Option::Some(v);
        }

        // optional bool roshan = 4;

        pub fn roshan(&self) -> bool {
            self.roshan.unwrap_or(false)
        }

        pub fn clear_roshan(&mut self) {
            self.roshan = ::std::option::Option::None;
        }

        pub fn has_roshan(&self) -> bool {
            self.roshan.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan(&mut self, v: bool) {
            self.roshan = ::std::option::Option::Some(v);
        }

        // optional string ability_name = 10;

        pub fn ability_name(&self) -> &str {
            match self.ability_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ability_name(&mut self) {
            self.ability_name = ::std::option::Option::None;
        }

        pub fn has_ability_name(&self) -> bool {
            self.ability_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ability_name(&mut self, v: ::std::string::String) {
            self.ability_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ability_name(&mut self) -> &mut ::std::string::String {
            if self.ability_name.is_none() {
                self.ability_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ability_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_ability_name(&mut self) -> ::std::string::String {
            self.ability_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for EntityRef {
        const NAME: &'static str = "EntityRef";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.neutral_stash_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.entity_idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.roshan = ::std::option::Option::Some(is.read_bool()?);
                    },
                    82 => {
                        self.ability_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.neutral_stash_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.entity_idx {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.roshan {
                my_size += 1 + 1;
            }
            if let Some(v) = self.ability_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.neutral_stash_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.entity_idx {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.roshan {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.ability_name.as_ref() {
                os.write_string(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EntityRef {
            EntityRef::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.neutral_stash_id = ::std::option::Option::None;
            self.entity_idx = ::std::option::Option::None;
            self.roshan = ::std::option::Option::None;
            self.ability_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EntityRef {
            static instance: EntityRef = EntityRef {
                player_id: ::std::option::Option::None,
                neutral_stash_id: ::std::option::Option::None,
                entity_idx: ::std::option::Option::None,
                roshan: ::std::option::Option::None,
                ability_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Game)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Game {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Game.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Game.game_mode)
        pub game_mode: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Game.clock_time)
        pub clock_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Game.internal_time)
        pub internal_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Game.roshan)
        pub roshan: ::steam_vent_proto_common::protobuf::MessageField<super::CScenarioGame_RoshanSpawner>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Game.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Game {
        fn default() -> &'a Game {
            <Game as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Game {
        pub fn new() -> Game {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional int32 game_mode = 2;

        pub fn game_mode(&self) -> i32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: i32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional float clock_time = 3;

        pub fn clock_time(&self) -> f32 {
            self.clock_time.unwrap_or(0.)
        }

        pub fn clear_clock_time(&mut self) {
            self.clock_time = ::std::option::Option::None;
        }

        pub fn has_clock_time(&self) -> bool {
            self.clock_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clock_time(&mut self, v: f32) {
            self.clock_time = ::std::option::Option::Some(v);
        }

        // optional float internal_time = 4;

        pub fn internal_time(&self) -> f32 {
            self.internal_time.unwrap_or(0.)
        }

        pub fn clear_internal_time(&mut self) {
            self.internal_time = ::std::option::Option::None;
        }

        pub fn has_internal_time(&self) -> bool {
            self.internal_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_time(&mut self, v: f32) {
            self.internal_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Game {
        const NAME: &'static str = "Game";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.game_mode = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.clock_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.internal_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.roshan)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_mode {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.clock_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.internal_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.roshan.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_mode {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.clock_time {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.internal_time {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.roshan.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Game {
            Game::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.game_mode = ::std::option::Option::None;
            self.clock_time = ::std::option::Option::None;
            self.internal_time = ::std::option::Option::None;
            self.roshan.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Game {
            static instance: Game = Game {
                match_id: ::std::option::Option::None,
                game_mode: ::std::option::Option::None,
                clock_time: ::std::option::Option::None,
                internal_time: ::std::option::Option::None,
                roshan: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.TeamNeutralItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamNeutralItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.TeamNeutralItem.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.TeamNeutralItem.consumed)
        pub consumed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.TeamNeutralItem.tier)
        pub tier: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.TeamNeutralItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamNeutralItem {
        fn default() -> &'a TeamNeutralItem {
            <TeamNeutralItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamNeutralItem {
        pub fn new() -> TeamNeutralItem {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool consumed = 2;

        pub fn consumed(&self) -> bool {
            self.consumed.unwrap_or(false)
        }

        pub fn clear_consumed(&mut self) {
            self.consumed = ::std::option::Option::None;
        }

        pub fn has_consumed(&self) -> bool {
            self.consumed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_consumed(&mut self, v: bool) {
            self.consumed = ::std::option::Option::Some(v);
        }

        // optional int32 tier = 3;

        pub fn tier(&self) -> i32 {
            self.tier.unwrap_or(0)
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: i32) {
            self.tier = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamNeutralItem {
        const NAME: &'static str = "TeamNeutralItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.consumed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.tier = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.consumed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.consumed {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.tier {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamNeutralItem {
            TeamNeutralItem::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.consumed = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamNeutralItem {
            static instance: TeamNeutralItem = TeamNeutralItem {
                name: ::std::option::Option::None,
                consumed: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Team.team_number)
        pub team_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Team.neutral_items)
        pub neutral_items: ::std::vec::Vec<TeamNeutralItem>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Team.hero_kills)
        pub hero_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Team.tower_kills)
        pub tower_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Team.barracks_kills)
        pub barracks_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Team.glyph_cooldown)
        pub glyph_cooldown: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Team.radar_cooldown)
        pub radar_cooldown: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Team.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional int32 team_number = 1;

        pub fn team_number(&self) -> i32 {
            self.team_number.unwrap_or(0)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: i32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional int32 hero_kills = 3;

        pub fn hero_kills(&self) -> i32 {
            self.hero_kills.unwrap_or(0)
        }

        pub fn clear_hero_kills(&mut self) {
            self.hero_kills = ::std::option::Option::None;
        }

        pub fn has_hero_kills(&self) -> bool {
            self.hero_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_kills(&mut self, v: i32) {
            self.hero_kills = ::std::option::Option::Some(v);
        }

        // optional int32 tower_kills = 4;

        pub fn tower_kills(&self) -> i32 {
            self.tower_kills.unwrap_or(0)
        }

        pub fn clear_tower_kills(&mut self) {
            self.tower_kills = ::std::option::Option::None;
        }

        pub fn has_tower_kills(&self) -> bool {
            self.tower_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_kills(&mut self, v: i32) {
            self.tower_kills = ::std::option::Option::Some(v);
        }

        // optional int32 barracks_kills = 5;

        pub fn barracks_kills(&self) -> i32 {
            self.barracks_kills.unwrap_or(0)
        }

        pub fn clear_barracks_kills(&mut self) {
            self.barracks_kills = ::std::option::Option::None;
        }

        pub fn has_barracks_kills(&self) -> bool {
            self.barracks_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_barracks_kills(&mut self, v: i32) {
            self.barracks_kills = ::std::option::Option::Some(v);
        }

        // optional float glyph_cooldown = 6;

        pub fn glyph_cooldown(&self) -> f32 {
            self.glyph_cooldown.unwrap_or(0.)
        }

        pub fn clear_glyph_cooldown(&mut self) {
            self.glyph_cooldown = ::std::option::Option::None;
        }

        pub fn has_glyph_cooldown(&self) -> bool {
            self.glyph_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_glyph_cooldown(&mut self, v: f32) {
            self.glyph_cooldown = ::std::option::Option::Some(v);
        }

        // optional float radar_cooldown = 7;

        pub fn radar_cooldown(&self) -> f32 {
            self.radar_cooldown.unwrap_or(0.)
        }

        pub fn clear_radar_cooldown(&mut self) {
            self.radar_cooldown = ::std::option::Option::None;
        }

        pub fn has_radar_cooldown(&self) -> bool {
            self.radar_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radar_cooldown(&mut self, v: f32) {
            self.radar_cooldown = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.neutral_items.push(is.read_message()?);
                    },
                    24 => {
                        self.hero_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.tower_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.barracks_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    53 => {
                        self.glyph_cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    61 => {
                        self.radar_cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            for value in &self.neutral_items {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.hero_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.tower_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.barracks_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.glyph_cooldown {
                my_size += 1 + 4;
            }
            if let Some(v) = self.radar_cooldown {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team_number {
                os.write_int32(1, v)?;
            }
            for v in &self.neutral_items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.hero_kills {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.tower_kills {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.barracks_kills {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.glyph_cooldown {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.radar_cooldown {
                os.write_float(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.team_number = ::std::option::Option::None;
            self.neutral_items.clear();
            self.hero_kills = ::std::option::Option::None;
            self.tower_kills = ::std::option::Option::None;
            self.barracks_kills = ::std::option::Option::None;
            self.glyph_cooldown = ::std::option::Option::None;
            self.radar_cooldown = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                team_number: ::std::option::Option::None,
                neutral_items: ::std::vec::Vec::new(),
                hero_kills: ::std::option::Option::None,
                tower_kills: ::std::option::Option::None,
                barracks_kills: ::std::option::Option::None,
                glyph_cooldown: ::std::option::Option::None,
                radar_cooldown: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.HeroHeroInt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroHeroInt {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.HeroHeroInt.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.HeroHeroInt.value)
        pub value: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.HeroHeroInt.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroHeroInt {
        fn default() -> &'a HeroHeroInt {
            <HeroHeroInt as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroHeroInt {
        pub fn new() -> HeroHeroInt {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 value = 2;

        pub fn value(&self) -> i32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: i32) {
            self.value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroHeroInt {
        const NAME: &'static str = "HeroHeroInt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroHeroInt {
            HeroHeroInt::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroHeroInt {
            static instance: HeroHeroInt = HeroHeroInt {
                player_id: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.HeroHeroFloat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroHeroFloat {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.HeroHeroFloat.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.HeroHeroFloat.value)
        pub value: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.HeroHeroFloat.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroHeroFloat {
        fn default() -> &'a HeroHeroFloat {
            <HeroHeroFloat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroHeroFloat {
        pub fn new() -> HeroHeroFloat {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional float value = 2;

        pub fn value(&self) -> f32 {
            self.value.unwrap_or(0.)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: f32) {
            self.value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroHeroFloat {
        const NAME: &'static str = "HeroHeroFloat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    21 => {
                        self.value = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroHeroFloat {
            HeroHeroFloat::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroHeroFloat {
            static instance: HeroHeroFloat = HeroHeroFloat {
                player_id: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.DamageStatsByType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DamageStatsByType {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.DamageStatsByType.damage_type)
        pub damage_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.DamageStatsByType.received_pre_reduction)
        pub received_pre_reduction: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.DamageStatsByType.received_post_reduction)
        pub received_post_reduction: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.DamageStatsByType.outgoing_pre_reduction)
        pub outgoing_pre_reduction: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.DamageStatsByType.outgoing_post_reduction)
        pub outgoing_post_reduction: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.DamageStatsByType.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DamageStatsByType {
        fn default() -> &'a DamageStatsByType {
            <DamageStatsByType as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DamageStatsByType {
        pub fn new() -> DamageStatsByType {
            ::std::default::Default::default()
        }

        // optional int32 damage_type = 1;

        pub fn damage_type(&self) -> i32 {
            self.damage_type.unwrap_or(0)
        }

        pub fn clear_damage_type(&mut self) {
            self.damage_type = ::std::option::Option::None;
        }

        pub fn has_damage_type(&self) -> bool {
            self.damage_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage_type(&mut self, v: i32) {
            self.damage_type = ::std::option::Option::Some(v);
        }

        // optional int32 received_pre_reduction = 2;

        pub fn received_pre_reduction(&self) -> i32 {
            self.received_pre_reduction.unwrap_or(0)
        }

        pub fn clear_received_pre_reduction(&mut self) {
            self.received_pre_reduction = ::std::option::Option::None;
        }

        pub fn has_received_pre_reduction(&self) -> bool {
            self.received_pre_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_received_pre_reduction(&mut self, v: i32) {
            self.received_pre_reduction = ::std::option::Option::Some(v);
        }

        // optional int32 received_post_reduction = 3;

        pub fn received_post_reduction(&self) -> i32 {
            self.received_post_reduction.unwrap_or(0)
        }

        pub fn clear_received_post_reduction(&mut self) {
            self.received_post_reduction = ::std::option::Option::None;
        }

        pub fn has_received_post_reduction(&self) -> bool {
            self.received_post_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_received_post_reduction(&mut self, v: i32) {
            self.received_post_reduction = ::std::option::Option::Some(v);
        }

        // optional int32 outgoing_pre_reduction = 4;

        pub fn outgoing_pre_reduction(&self) -> i32 {
            self.outgoing_pre_reduction.unwrap_or(0)
        }

        pub fn clear_outgoing_pre_reduction(&mut self) {
            self.outgoing_pre_reduction = ::std::option::Option::None;
        }

        pub fn has_outgoing_pre_reduction(&self) -> bool {
            self.outgoing_pre_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outgoing_pre_reduction(&mut self, v: i32) {
            self.outgoing_pre_reduction = ::std::option::Option::Some(v);
        }

        // optional int32 outgoing_post_reduction = 5;

        pub fn outgoing_post_reduction(&self) -> i32 {
            self.outgoing_post_reduction.unwrap_or(0)
        }

        pub fn clear_outgoing_post_reduction(&mut self) {
            self.outgoing_post_reduction = ::std::option::Option::None;
        }

        pub fn has_outgoing_post_reduction(&self) -> bool {
            self.outgoing_post_reduction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outgoing_post_reduction(&mut self, v: i32) {
            self.outgoing_post_reduction = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DamageStatsByType {
        const NAME: &'static str = "DamageStatsByType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.damage_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.received_pre_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.received_post_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.outgoing_pre_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.outgoing_post_reduction = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.damage_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.received_pre_reduction {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.received_post_reduction {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.outgoing_pre_reduction {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.outgoing_post_reduction {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.damage_type {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.received_pre_reduction {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.received_post_reduction {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.outgoing_pre_reduction {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.outgoing_post_reduction {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DamageStatsByType {
            DamageStatsByType::new()
        }

        fn clear(&mut self) {
            self.damage_type = ::std::option::Option::None;
            self.received_pre_reduction = ::std::option::Option::None;
            self.received_post_reduction = ::std::option::Option::None;
            self.outgoing_pre_reduction = ::std::option::Option::None;
            self.outgoing_post_reduction = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DamageStatsByType {
            static instance: DamageStatsByType = DamageStatsByType {
                damage_type: ::std::option::Option::None,
                received_pre_reduction: ::std::option::Option::None,
                received_post_reduction: ::std::option::Option::None,
                outgoing_pre_reduction: ::std::option::Option::None,
                outgoing_post_reduction: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.HeroAbility)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroAbility {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.HeroAbility.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.HeroAbility.level)
        pub level: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.HeroAbility.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroAbility {
        fn default() -> &'a HeroAbility {
            <HeroAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroAbility {
        pub fn new() -> HeroAbility {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 level = 2;

        pub fn level(&self) -> i32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: i32) {
            self.level = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroAbility {
        const NAME: &'static str = "HeroAbility";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.level {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroAbility {
            HeroAbility::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroAbility {
            static instance: HeroAbility = HeroAbility {
                name: ::std::option::Option::None,
                level: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Hero)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Hero {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.team_id)
        pub team_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.hero)
        pub hero: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.total_xp)
        pub total_xp: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.bkb_charges_used)
        pub bkb_charges_used: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.aeon_charges_used)
        pub aeon_charges_used: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.reliable_gold)
        pub reliable_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.unreliable_gold)
        pub unreliable_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.total_earned_gold)
        pub total_earned_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.shared_gold)
        pub shared_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.hero_kill_gold)
        pub hero_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.creep_kill_gold)
        pub creep_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.neutral_kill_gold)
        pub neutral_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.courier_gold)
        pub courier_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.bounty_gold)
        pub bounty_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.roshan_gold)
        pub roshan_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.building_gold)
        pub building_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.other_gold)
        pub other_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.income_gold)
        pub income_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.ward_kill_gold)
        pub ward_kill_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.ability_gold)
        pub ability_gold: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.denies)
        pub denies: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.last_hits)
        pub last_hits: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.last_hit_streak)
        pub last_hit_streak: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.last_hit_multikill)
        pub last_hit_multikill: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.nearby_creep_death_count)
        pub nearby_creep_death_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.claimed_deny_count)
        pub claimed_deny_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.claimed_miss_count)
        pub claimed_miss_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.miss_count)
        pub miss_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.buyback_cooldown_time)
        pub buyback_cooldown_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.buyback_gold_limit_time)
        pub buyback_gold_limit_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.stun_duration)
        pub stun_duration: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.healing)
        pub healing: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.tower_kills)
        pub tower_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.roshan_kills)
        pub roshan_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.observer_wards_placed)
        pub observer_wards_placed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.sentry_wards_placed)
        pub sentry_wards_placed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.creeps_stacked)
        pub creeps_stacked: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.camps_stacked)
        pub camps_stacked: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.rune_pickups)
        pub rune_pickups: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.gold_spent_on_support)
        pub gold_spent_on_support: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.hero_damage)
        pub hero_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.wards_purchased)
        pub wards_purchased: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.wards_destroyed)
        pub wards_destroyed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.gold_spent_on_consumables)
        pub gold_spent_on_consumables: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.gold_spent_on_items)
        pub gold_spent_on_items: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.gold_spent_on_buybacks)
        pub gold_spent_on_buybacks: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.gold_lost_to_death)
        pub gold_lost_to_death: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.kills)
        pub kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.assists)
        pub assists: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.deaths)
        pub deaths: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.kill_streak)
        pub kill_streak: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.respawn_seconds)
        pub respawn_seconds: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.last_buyback_time)
        pub last_buyback_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.first_blood_claimed)
        pub first_blood_claimed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.first_blood_given)
        pub first_blood_given: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.bounty_runes)
        pub bounty_runes: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.outposts_captured)
        pub outposts_captured: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.position)
        pub position: ::steam_vent_proto_common::protobuf::MessageField<super::CScenario_Position>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.enemy_kills)
        pub enemy_kills: ::std::vec::Vec<HeroHeroInt>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.damage_stats)
        pub damage_stats: ::std::vec::Vec<DamageStatsByType>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.abilities)
        pub abilities: ::std::vec::Vec<HeroAbility>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Hero.hero_facet)
        pub hero_facet: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Hero.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Hero {
        fn default() -> &'a Hero {
            <Hero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Hero {
        pub fn new() -> Hero {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional int32 player_id = 2;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 team_id = 3;

        pub fn team_id(&self) -> i32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: i32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string hero = 4;

        pub fn hero(&self) -> &str {
            match self.hero.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: ::std::string::String) {
            self.hero = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero(&mut self) -> &mut ::std::string::String {
            if self.hero.is_none() {
                self.hero = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero(&mut self) -> ::std::string::String {
            self.hero.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 total_xp = 5;

        pub fn total_xp(&self) -> i32 {
            self.total_xp.unwrap_or(0)
        }

        pub fn clear_total_xp(&mut self) {
            self.total_xp = ::std::option::Option::None;
        }

        pub fn has_total_xp(&self) -> bool {
            self.total_xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_xp(&mut self, v: i32) {
            self.total_xp = ::std::option::Option::Some(v);
        }

        // optional int32 bkb_charges_used = 6;

        pub fn bkb_charges_used(&self) -> i32 {
            self.bkb_charges_used.unwrap_or(0)
        }

        pub fn clear_bkb_charges_used(&mut self) {
            self.bkb_charges_used = ::std::option::Option::None;
        }

        pub fn has_bkb_charges_used(&self) -> bool {
            self.bkb_charges_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bkb_charges_used(&mut self, v: i32) {
            self.bkb_charges_used = ::std::option::Option::Some(v);
        }

        // optional int32 aeon_charges_used = 7;

        pub fn aeon_charges_used(&self) -> i32 {
            self.aeon_charges_used.unwrap_or(0)
        }

        pub fn clear_aeon_charges_used(&mut self) {
            self.aeon_charges_used = ::std::option::Option::None;
        }

        pub fn has_aeon_charges_used(&self) -> bool {
            self.aeon_charges_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_aeon_charges_used(&mut self, v: i32) {
            self.aeon_charges_used = ::std::option::Option::Some(v);
        }

        // optional int32 reliable_gold = 8;

        pub fn reliable_gold(&self) -> i32 {
            self.reliable_gold.unwrap_or(0)
        }

        pub fn clear_reliable_gold(&mut self) {
            self.reliable_gold = ::std::option::Option::None;
        }

        pub fn has_reliable_gold(&self) -> bool {
            self.reliable_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reliable_gold(&mut self, v: i32) {
            self.reliable_gold = ::std::option::Option::Some(v);
        }

        // optional int32 unreliable_gold = 9;

        pub fn unreliable_gold(&self) -> i32 {
            self.unreliable_gold.unwrap_or(0)
        }

        pub fn clear_unreliable_gold(&mut self) {
            self.unreliable_gold = ::std::option::Option::None;
        }

        pub fn has_unreliable_gold(&self) -> bool {
            self.unreliable_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unreliable_gold(&mut self, v: i32) {
            self.unreliable_gold = ::std::option::Option::Some(v);
        }

        // optional int32 total_earned_gold = 10;

        pub fn total_earned_gold(&self) -> i32 {
            self.total_earned_gold.unwrap_or(0)
        }

        pub fn clear_total_earned_gold(&mut self) {
            self.total_earned_gold = ::std::option::Option::None;
        }

        pub fn has_total_earned_gold(&self) -> bool {
            self.total_earned_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_earned_gold(&mut self, v: i32) {
            self.total_earned_gold = ::std::option::Option::Some(v);
        }

        // optional int32 shared_gold = 11;

        pub fn shared_gold(&self) -> i32 {
            self.shared_gold.unwrap_or(0)
        }

        pub fn clear_shared_gold(&mut self) {
            self.shared_gold = ::std::option::Option::None;
        }

        pub fn has_shared_gold(&self) -> bool {
            self.shared_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shared_gold(&mut self, v: i32) {
            self.shared_gold = ::std::option::Option::Some(v);
        }

        // optional int32 hero_kill_gold = 12;

        pub fn hero_kill_gold(&self) -> i32 {
            self.hero_kill_gold.unwrap_or(0)
        }

        pub fn clear_hero_kill_gold(&mut self) {
            self.hero_kill_gold = ::std::option::Option::None;
        }

        pub fn has_hero_kill_gold(&self) -> bool {
            self.hero_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_kill_gold(&mut self, v: i32) {
            self.hero_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 creep_kill_gold = 13;

        pub fn creep_kill_gold(&self) -> i32 {
            self.creep_kill_gold.unwrap_or(0)
        }

        pub fn clear_creep_kill_gold(&mut self) {
            self.creep_kill_gold = ::std::option::Option::None;
        }

        pub fn has_creep_kill_gold(&self) -> bool {
            self.creep_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_kill_gold(&mut self, v: i32) {
            self.creep_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 neutral_kill_gold = 14;

        pub fn neutral_kill_gold(&self) -> i32 {
            self.neutral_kill_gold.unwrap_or(0)
        }

        pub fn clear_neutral_kill_gold(&mut self) {
            self.neutral_kill_gold = ::std::option::Option::None;
        }

        pub fn has_neutral_kill_gold(&self) -> bool {
            self.neutral_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_kill_gold(&mut self, v: i32) {
            self.neutral_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 courier_gold = 15;

        pub fn courier_gold(&self) -> i32 {
            self.courier_gold.unwrap_or(0)
        }

        pub fn clear_courier_gold(&mut self) {
            self.courier_gold = ::std::option::Option::None;
        }

        pub fn has_courier_gold(&self) -> bool {
            self.courier_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_courier_gold(&mut self, v: i32) {
            self.courier_gold = ::std::option::Option::Some(v);
        }

        // optional int32 bounty_gold = 16;

        pub fn bounty_gold(&self) -> i32 {
            self.bounty_gold.unwrap_or(0)
        }

        pub fn clear_bounty_gold(&mut self) {
            self.bounty_gold = ::std::option::Option::None;
        }

        pub fn has_bounty_gold(&self) -> bool {
            self.bounty_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bounty_gold(&mut self, v: i32) {
            self.bounty_gold = ::std::option::Option::Some(v);
        }

        // optional int32 roshan_gold = 17;

        pub fn roshan_gold(&self) -> i32 {
            self.roshan_gold.unwrap_or(0)
        }

        pub fn clear_roshan_gold(&mut self) {
            self.roshan_gold = ::std::option::Option::None;
        }

        pub fn has_roshan_gold(&self) -> bool {
            self.roshan_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan_gold(&mut self, v: i32) {
            self.roshan_gold = ::std::option::Option::Some(v);
        }

        // optional int32 building_gold = 18;

        pub fn building_gold(&self) -> i32 {
            self.building_gold.unwrap_or(0)
        }

        pub fn clear_building_gold(&mut self) {
            self.building_gold = ::std::option::Option::None;
        }

        pub fn has_building_gold(&self) -> bool {
            self.building_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_building_gold(&mut self, v: i32) {
            self.building_gold = ::std::option::Option::Some(v);
        }

        // optional int32 other_gold = 19;

        pub fn other_gold(&self) -> i32 {
            self.other_gold.unwrap_or(0)
        }

        pub fn clear_other_gold(&mut self) {
            self.other_gold = ::std::option::Option::None;
        }

        pub fn has_other_gold(&self) -> bool {
            self.other_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_other_gold(&mut self, v: i32) {
            self.other_gold = ::std::option::Option::Some(v);
        }

        // optional int32 income_gold = 26;

        pub fn income_gold(&self) -> i32 {
            self.income_gold.unwrap_or(0)
        }

        pub fn clear_income_gold(&mut self) {
            self.income_gold = ::std::option::Option::None;
        }

        pub fn has_income_gold(&self) -> bool {
            self.income_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_income_gold(&mut self, v: i32) {
            self.income_gold = ::std::option::Option::Some(v);
        }

        // optional int32 ward_kill_gold = 27;

        pub fn ward_kill_gold(&self) -> i32 {
            self.ward_kill_gold.unwrap_or(0)
        }

        pub fn clear_ward_kill_gold(&mut self) {
            self.ward_kill_gold = ::std::option::Option::None;
        }

        pub fn has_ward_kill_gold(&self) -> bool {
            self.ward_kill_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ward_kill_gold(&mut self, v: i32) {
            self.ward_kill_gold = ::std::option::Option::Some(v);
        }

        // optional int32 ability_gold = 28;

        pub fn ability_gold(&self) -> i32 {
            self.ability_gold.unwrap_or(0)
        }

        pub fn clear_ability_gold(&mut self) {
            self.ability_gold = ::std::option::Option::None;
        }

        pub fn has_ability_gold(&self) -> bool {
            self.ability_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ability_gold(&mut self, v: i32) {
            self.ability_gold = ::std::option::Option::Some(v);
        }

        // optional int32 denies = 29;

        pub fn denies(&self) -> i32 {
            self.denies.unwrap_or(0)
        }

        pub fn clear_denies(&mut self) {
            self.denies = ::std::option::Option::None;
        }

        pub fn has_denies(&self) -> bool {
            self.denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies(&mut self, v: i32) {
            self.denies = ::std::option::Option::Some(v);
        }

        // optional int32 last_hits = 30;

        pub fn last_hits(&self) -> i32 {
            self.last_hits.unwrap_or(0)
        }

        pub fn clear_last_hits(&mut self) {
            self.last_hits = ::std::option::Option::None;
        }

        pub fn has_last_hits(&self) -> bool {
            self.last_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hits(&mut self, v: i32) {
            self.last_hits = ::std::option::Option::Some(v);
        }

        // optional int32 last_hit_streak = 31;

        pub fn last_hit_streak(&self) -> i32 {
            self.last_hit_streak.unwrap_or(0)
        }

        pub fn clear_last_hit_streak(&mut self) {
            self.last_hit_streak = ::std::option::Option::None;
        }

        pub fn has_last_hit_streak(&self) -> bool {
            self.last_hit_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hit_streak(&mut self, v: i32) {
            self.last_hit_streak = ::std::option::Option::Some(v);
        }

        // optional int32 last_hit_multikill = 32;

        pub fn last_hit_multikill(&self) -> i32 {
            self.last_hit_multikill.unwrap_or(0)
        }

        pub fn clear_last_hit_multikill(&mut self) {
            self.last_hit_multikill = ::std::option::Option::None;
        }

        pub fn has_last_hit_multikill(&self) -> bool {
            self.last_hit_multikill.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hit_multikill(&mut self, v: i32) {
            self.last_hit_multikill = ::std::option::Option::Some(v);
        }

        // optional int32 nearby_creep_death_count = 33;

        pub fn nearby_creep_death_count(&self) -> i32 {
            self.nearby_creep_death_count.unwrap_or(0)
        }

        pub fn clear_nearby_creep_death_count(&mut self) {
            self.nearby_creep_death_count = ::std::option::Option::None;
        }

        pub fn has_nearby_creep_death_count(&self) -> bool {
            self.nearby_creep_death_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nearby_creep_death_count(&mut self, v: i32) {
            self.nearby_creep_death_count = ::std::option::Option::Some(v);
        }

        // optional int32 claimed_deny_count = 34;

        pub fn claimed_deny_count(&self) -> i32 {
            self.claimed_deny_count.unwrap_or(0)
        }

        pub fn clear_claimed_deny_count(&mut self) {
            self.claimed_deny_count = ::std::option::Option::None;
        }

        pub fn has_claimed_deny_count(&self) -> bool {
            self.claimed_deny_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_deny_count(&mut self, v: i32) {
            self.claimed_deny_count = ::std::option::Option::Some(v);
        }

        // optional int32 claimed_miss_count = 35;

        pub fn claimed_miss_count(&self) -> i32 {
            self.claimed_miss_count.unwrap_or(0)
        }

        pub fn clear_claimed_miss_count(&mut self) {
            self.claimed_miss_count = ::std::option::Option::None;
        }

        pub fn has_claimed_miss_count(&self) -> bool {
            self.claimed_miss_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_miss_count(&mut self, v: i32) {
            self.claimed_miss_count = ::std::option::Option::Some(v);
        }

        // optional int32 miss_count = 36;

        pub fn miss_count(&self) -> i32 {
            self.miss_count.unwrap_or(0)
        }

        pub fn clear_miss_count(&mut self) {
            self.miss_count = ::std::option::Option::None;
        }

        pub fn has_miss_count(&self) -> bool {
            self.miss_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_miss_count(&mut self, v: i32) {
            self.miss_count = ::std::option::Option::Some(v);
        }

        // optional float buyback_cooldown_time = 40;

        pub fn buyback_cooldown_time(&self) -> f32 {
            self.buyback_cooldown_time.unwrap_or(0.)
        }

        pub fn clear_buyback_cooldown_time(&mut self) {
            self.buyback_cooldown_time = ::std::option::Option::None;
        }

        pub fn has_buyback_cooldown_time(&self) -> bool {
            self.buyback_cooldown_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buyback_cooldown_time(&mut self, v: f32) {
            self.buyback_cooldown_time = ::std::option::Option::Some(v);
        }

        // optional float buyback_gold_limit_time = 41;

        pub fn buyback_gold_limit_time(&self) -> f32 {
            self.buyback_gold_limit_time.unwrap_or(0.)
        }

        pub fn clear_buyback_gold_limit_time(&mut self) {
            self.buyback_gold_limit_time = ::std::option::Option::None;
        }

        pub fn has_buyback_gold_limit_time(&self) -> bool {
            self.buyback_gold_limit_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buyback_gold_limit_time(&mut self, v: f32) {
            self.buyback_gold_limit_time = ::std::option::Option::Some(v);
        }

        // optional float stun_duration = 44;

        pub fn stun_duration(&self) -> f32 {
            self.stun_duration.unwrap_or(0.)
        }

        pub fn clear_stun_duration(&mut self) {
            self.stun_duration = ::std::option::Option::None;
        }

        pub fn has_stun_duration(&self) -> bool {
            self.stun_duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stun_duration(&mut self, v: f32) {
            self.stun_duration = ::std::option::Option::Some(v);
        }

        // optional float healing = 45;

        pub fn healing(&self) -> f32 {
            self.healing.unwrap_or(0.)
        }

        pub fn clear_healing(&mut self) {
            self.healing = ::std::option::Option::None;
        }

        pub fn has_healing(&self) -> bool {
            self.healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healing(&mut self, v: f32) {
            self.healing = ::std::option::Option::Some(v);
        }

        // optional int32 tower_kills = 46;

        pub fn tower_kills(&self) -> i32 {
            self.tower_kills.unwrap_or(0)
        }

        pub fn clear_tower_kills(&mut self) {
            self.tower_kills = ::std::option::Option::None;
        }

        pub fn has_tower_kills(&self) -> bool {
            self.tower_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_kills(&mut self, v: i32) {
            self.tower_kills = ::std::option::Option::Some(v);
        }

        // optional int32 roshan_kills = 47;

        pub fn roshan_kills(&self) -> i32 {
            self.roshan_kills.unwrap_or(0)
        }

        pub fn clear_roshan_kills(&mut self) {
            self.roshan_kills = ::std::option::Option::None;
        }

        pub fn has_roshan_kills(&self) -> bool {
            self.roshan_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan_kills(&mut self, v: i32) {
            self.roshan_kills = ::std::option::Option::Some(v);
        }

        // optional int32 observer_wards_placed = 48;

        pub fn observer_wards_placed(&self) -> i32 {
            self.observer_wards_placed.unwrap_or(0)
        }

        pub fn clear_observer_wards_placed(&mut self) {
            self.observer_wards_placed = ::std::option::Option::None;
        }

        pub fn has_observer_wards_placed(&self) -> bool {
            self.observer_wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_observer_wards_placed(&mut self, v: i32) {
            self.observer_wards_placed = ::std::option::Option::Some(v);
        }

        // optional int32 sentry_wards_placed = 49;

        pub fn sentry_wards_placed(&self) -> i32 {
            self.sentry_wards_placed.unwrap_or(0)
        }

        pub fn clear_sentry_wards_placed(&mut self) {
            self.sentry_wards_placed = ::std::option::Option::None;
        }

        pub fn has_sentry_wards_placed(&self) -> bool {
            self.sentry_wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sentry_wards_placed(&mut self, v: i32) {
            self.sentry_wards_placed = ::std::option::Option::Some(v);
        }

        // optional int32 creeps_stacked = 50;

        pub fn creeps_stacked(&self) -> i32 {
            self.creeps_stacked.unwrap_or(0)
        }

        pub fn clear_creeps_stacked(&mut self) {
            self.creeps_stacked = ::std::option::Option::None;
        }

        pub fn has_creeps_stacked(&self) -> bool {
            self.creeps_stacked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creeps_stacked(&mut self, v: i32) {
            self.creeps_stacked = ::std::option::Option::Some(v);
        }

        // optional int32 camps_stacked = 51;

        pub fn camps_stacked(&self) -> i32 {
            self.camps_stacked.unwrap_or(0)
        }

        pub fn clear_camps_stacked(&mut self) {
            self.camps_stacked = ::std::option::Option::None;
        }

        pub fn has_camps_stacked(&self) -> bool {
            self.camps_stacked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_camps_stacked(&mut self, v: i32) {
            self.camps_stacked = ::std::option::Option::Some(v);
        }

        // optional int32 rune_pickups = 52;

        pub fn rune_pickups(&self) -> i32 {
            self.rune_pickups.unwrap_or(0)
        }

        pub fn clear_rune_pickups(&mut self) {
            self.rune_pickups = ::std::option::Option::None;
        }

        pub fn has_rune_pickups(&self) -> bool {
            self.rune_pickups.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rune_pickups(&mut self, v: i32) {
            self.rune_pickups = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_support = 53;

        pub fn gold_spent_on_support(&self) -> i32 {
            self.gold_spent_on_support.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_support(&mut self) {
            self.gold_spent_on_support = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_support(&self) -> bool {
            self.gold_spent_on_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_support(&mut self, v: i32) {
            self.gold_spent_on_support = ::std::option::Option::Some(v);
        }

        // optional int32 hero_damage = 54;

        pub fn hero_damage(&self) -> i32 {
            self.hero_damage.unwrap_or(0)
        }

        pub fn clear_hero_damage(&mut self) {
            self.hero_damage = ::std::option::Option::None;
        }

        pub fn has_hero_damage(&self) -> bool {
            self.hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_damage(&mut self, v: i32) {
            self.hero_damage = ::std::option::Option::Some(v);
        }

        // optional int32 wards_purchased = 55;

        pub fn wards_purchased(&self) -> i32 {
            self.wards_purchased.unwrap_or(0)
        }

        pub fn clear_wards_purchased(&mut self) {
            self.wards_purchased = ::std::option::Option::None;
        }

        pub fn has_wards_purchased(&self) -> bool {
            self.wards_purchased.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_purchased(&mut self, v: i32) {
            self.wards_purchased = ::std::option::Option::Some(v);
        }

        // optional int32 wards_destroyed = 56;

        pub fn wards_destroyed(&self) -> i32 {
            self.wards_destroyed.unwrap_or(0)
        }

        pub fn clear_wards_destroyed(&mut self) {
            self.wards_destroyed = ::std::option::Option::None;
        }

        pub fn has_wards_destroyed(&self) -> bool {
            self.wards_destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_destroyed(&mut self, v: i32) {
            self.wards_destroyed = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_consumables = 58;

        pub fn gold_spent_on_consumables(&self) -> i32 {
            self.gold_spent_on_consumables.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_consumables(&mut self) {
            self.gold_spent_on_consumables = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_consumables(&self) -> bool {
            self.gold_spent_on_consumables.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_consumables(&mut self, v: i32) {
            self.gold_spent_on_consumables = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_items = 59;

        pub fn gold_spent_on_items(&self) -> i32 {
            self.gold_spent_on_items.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_items(&mut self) {
            self.gold_spent_on_items = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_items(&self) -> bool {
            self.gold_spent_on_items.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_items(&mut self, v: i32) {
            self.gold_spent_on_items = ::std::option::Option::Some(v);
        }

        // optional int32 gold_spent_on_buybacks = 60;

        pub fn gold_spent_on_buybacks(&self) -> i32 {
            self.gold_spent_on_buybacks.unwrap_or(0)
        }

        pub fn clear_gold_spent_on_buybacks(&mut self) {
            self.gold_spent_on_buybacks = ::std::option::Option::None;
        }

        pub fn has_gold_spent_on_buybacks(&self) -> bool {
            self.gold_spent_on_buybacks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent_on_buybacks(&mut self, v: i32) {
            self.gold_spent_on_buybacks = ::std::option::Option::Some(v);
        }

        // optional int32 gold_lost_to_death = 61;

        pub fn gold_lost_to_death(&self) -> i32 {
            self.gold_lost_to_death.unwrap_or(0)
        }

        pub fn clear_gold_lost_to_death(&mut self) {
            self.gold_lost_to_death = ::std::option::Option::None;
        }

        pub fn has_gold_lost_to_death(&self) -> bool {
            self.gold_lost_to_death.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_lost_to_death(&mut self, v: i32) {
            self.gold_lost_to_death = ::std::option::Option::Some(v);
        }

        // optional int32 kills = 62;

        pub fn kills(&self) -> i32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: i32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional int32 assists = 63;

        pub fn assists(&self) -> i32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: i32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional int32 deaths = 64;

        pub fn deaths(&self) -> i32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: i32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional int32 kill_streak = 65;

        pub fn kill_streak(&self) -> i32 {
            self.kill_streak.unwrap_or(0)
        }

        pub fn clear_kill_streak(&mut self) {
            self.kill_streak = ::std::option::Option::None;
        }

        pub fn has_kill_streak(&self) -> bool {
            self.kill_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_streak(&mut self, v: i32) {
            self.kill_streak = ::std::option::Option::Some(v);
        }

        // optional int32 respawn_seconds = 68;

        pub fn respawn_seconds(&self) -> i32 {
            self.respawn_seconds.unwrap_or(-1i32)
        }

        pub fn clear_respawn_seconds(&mut self) {
            self.respawn_seconds = ::std::option::Option::None;
        }

        pub fn has_respawn_seconds(&self) -> bool {
            self.respawn_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_seconds(&mut self, v: i32) {
            self.respawn_seconds = ::std::option::Option::Some(v);
        }

        // optional int32 last_buyback_time = 69;

        pub fn last_buyback_time(&self) -> i32 {
            self.last_buyback_time.unwrap_or(0)
        }

        pub fn clear_last_buyback_time(&mut self) {
            self.last_buyback_time = ::std::option::Option::None;
        }

        pub fn has_last_buyback_time(&self) -> bool {
            self.last_buyback_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_buyback_time(&mut self, v: i32) {
            self.last_buyback_time = ::std::option::Option::Some(v);
        }

        // optional bool first_blood_claimed = 71;

        pub fn first_blood_claimed(&self) -> bool {
            self.first_blood_claimed.unwrap_or(false)
        }

        pub fn clear_first_blood_claimed(&mut self) {
            self.first_blood_claimed = ::std::option::Option::None;
        }

        pub fn has_first_blood_claimed(&self) -> bool {
            self.first_blood_claimed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_blood_claimed(&mut self, v: bool) {
            self.first_blood_claimed = ::std::option::Option::Some(v);
        }

        // optional bool first_blood_given = 72;

        pub fn first_blood_given(&self) -> bool {
            self.first_blood_given.unwrap_or(false)
        }

        pub fn clear_first_blood_given(&mut self) {
            self.first_blood_given = ::std::option::Option::None;
        }

        pub fn has_first_blood_given(&self) -> bool {
            self.first_blood_given.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_blood_given(&mut self, v: bool) {
            self.first_blood_given = ::std::option::Option::Some(v);
        }

        // optional int32 bounty_runes = 73;

        pub fn bounty_runes(&self) -> i32 {
            self.bounty_runes.unwrap_or(0)
        }

        pub fn clear_bounty_runes(&mut self) {
            self.bounty_runes = ::std::option::Option::None;
        }

        pub fn has_bounty_runes(&self) -> bool {
            self.bounty_runes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bounty_runes(&mut self, v: i32) {
            self.bounty_runes = ::std::option::Option::Some(v);
        }

        // optional int32 outposts_captured = 74;

        pub fn outposts_captured(&self) -> i32 {
            self.outposts_captured.unwrap_or(0)
        }

        pub fn clear_outposts_captured(&mut self) {
            self.outposts_captured = ::std::option::Option::None;
        }

        pub fn has_outposts_captured(&self) -> bool {
            self.outposts_captured.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outposts_captured(&mut self, v: i32) {
            self.outposts_captured = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_facet = 153;

        pub fn hero_facet(&self) -> u32 {
            self.hero_facet.unwrap_or(0)
        }

        pub fn clear_hero_facet(&mut self) {
            self.hero_facet = ::std::option::Option::None;
        }

        pub fn has_hero_facet(&self) -> bool {
            self.hero_facet.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_facet(&mut self, v: u32) {
            self.hero_facet = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Hero {
        const NAME: &'static str = "Hero";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.hero = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.total_xp = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.bkb_charges_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.aeon_charges_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.reliable_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.unreliable_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.total_earned_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.shared_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.hero_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    104 => {
                        self.creep_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.neutral_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.courier_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.bounty_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    136 => {
                        self.roshan_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    144 => {
                        self.building_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    152 => {
                        self.other_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    208 => {
                        self.income_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    216 => {
                        self.ward_kill_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    224 => {
                        self.ability_gold = ::std::option::Option::Some(is.read_int32()?);
                    },
                    232 => {
                        self.denies = ::std::option::Option::Some(is.read_int32()?);
                    },
                    240 => {
                        self.last_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    248 => {
                        self.last_hit_streak = ::std::option::Option::Some(is.read_int32()?);
                    },
                    256 => {
                        self.last_hit_multikill = ::std::option::Option::Some(is.read_int32()?);
                    },
                    264 => {
                        self.nearby_creep_death_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    272 => {
                        self.claimed_deny_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    280 => {
                        self.claimed_miss_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    288 => {
                        self.miss_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    325 => {
                        self.buyback_cooldown_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    333 => {
                        self.buyback_gold_limit_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    357 => {
                        self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    365 => {
                        self.healing = ::std::option::Option::Some(is.read_float()?);
                    },
                    368 => {
                        self.tower_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    376 => {
                        self.roshan_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    384 => {
                        self.observer_wards_placed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    392 => {
                        self.sentry_wards_placed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    400 => {
                        self.creeps_stacked = ::std::option::Option::Some(is.read_int32()?);
                    },
                    408 => {
                        self.camps_stacked = ::std::option::Option::Some(is.read_int32()?);
                    },
                    416 => {
                        self.rune_pickups = ::std::option::Option::Some(is.read_int32()?);
                    },
                    424 => {
                        self.gold_spent_on_support = ::std::option::Option::Some(is.read_int32()?);
                    },
                    432 => {
                        self.hero_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    440 => {
                        self.wards_purchased = ::std::option::Option::Some(is.read_int32()?);
                    },
                    448 => {
                        self.wards_destroyed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    464 => {
                        self.gold_spent_on_consumables = ::std::option::Option::Some(is.read_int32()?);
                    },
                    472 => {
                        self.gold_spent_on_items = ::std::option::Option::Some(is.read_int32()?);
                    },
                    480 => {
                        self.gold_spent_on_buybacks = ::std::option::Option::Some(is.read_int32()?);
                    },
                    488 => {
                        self.gold_lost_to_death = ::std::option::Option::Some(is.read_int32()?);
                    },
                    496 => {
                        self.kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    504 => {
                        self.assists = ::std::option::Option::Some(is.read_int32()?);
                    },
                    512 => {
                        self.deaths = ::std::option::Option::Some(is.read_int32()?);
                    },
                    520 => {
                        self.kill_streak = ::std::option::Option::Some(is.read_int32()?);
                    },
                    544 => {
                        self.respawn_seconds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    552 => {
                        self.last_buyback_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    568 => {
                        self.first_blood_claimed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    576 => {
                        self.first_blood_given = ::std::option::Option::Some(is.read_bool()?);
                    },
                    584 => {
                        self.bounty_runes = ::std::option::Option::Some(is.read_int32()?);
                    },
                    592 => {
                        self.outposts_captured = ::std::option::Option::Some(is.read_int32()?);
                    },
                    602 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    1202 => {
                        self.enemy_kills.push(is.read_message()?);
                    },
                    1210 => {
                        self.damage_stats.push(is.read_message()?);
                    },
                    1218 => {
                        self.abilities.push(is.read_message()?);
                    },
                    1224 => {
                        self.hero_facet = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.hero.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.total_xp {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.bkb_charges_used {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.aeon_charges_used {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.reliable_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.unreliable_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.total_earned_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.shared_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.hero_kill_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
            }
            if let Some(v) = self.creep_kill_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.neutral_kill_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.courier_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.bounty_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, v);
            }
            if let Some(v) = self.roshan_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, v);
            }
            if let Some(v) = self.building_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(18, v);
            }
            if let Some(v) = self.other_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(19, v);
            }
            if let Some(v) = self.income_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(26, v);
            }
            if let Some(v) = self.ward_kill_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(27, v);
            }
            if let Some(v) = self.ability_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(28, v);
            }
            if let Some(v) = self.denies {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(29, v);
            }
            if let Some(v) = self.last_hits {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(30, v);
            }
            if let Some(v) = self.last_hit_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(31, v);
            }
            if let Some(v) = self.last_hit_multikill {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(32, v);
            }
            if let Some(v) = self.nearby_creep_death_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(33, v);
            }
            if let Some(v) = self.claimed_deny_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(34, v);
            }
            if let Some(v) = self.claimed_miss_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(35, v);
            }
            if let Some(v) = self.miss_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(36, v);
            }
            if let Some(v) = self.buyback_cooldown_time {
                my_size += 2 + 4;
            }
            if let Some(v) = self.buyback_gold_limit_time {
                my_size += 2 + 4;
            }
            if let Some(v) = self.stun_duration {
                my_size += 2 + 4;
            }
            if let Some(v) = self.healing {
                my_size += 2 + 4;
            }
            if let Some(v) = self.tower_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(46, v);
            }
            if let Some(v) = self.roshan_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(47, v);
            }
            if let Some(v) = self.observer_wards_placed {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(48, v);
            }
            if let Some(v) = self.sentry_wards_placed {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(49, v);
            }
            if let Some(v) = self.creeps_stacked {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(50, v);
            }
            if let Some(v) = self.camps_stacked {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(51, v);
            }
            if let Some(v) = self.rune_pickups {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(52, v);
            }
            if let Some(v) = self.gold_spent_on_support {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(53, v);
            }
            if let Some(v) = self.hero_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(54, v);
            }
            if let Some(v) = self.wards_purchased {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(55, v);
            }
            if let Some(v) = self.wards_destroyed {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(56, v);
            }
            if let Some(v) = self.gold_spent_on_consumables {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(58, v);
            }
            if let Some(v) = self.gold_spent_on_items {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(59, v);
            }
            if let Some(v) = self.gold_spent_on_buybacks {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(60, v);
            }
            if let Some(v) = self.gold_lost_to_death {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(61, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(62, v);
            }
            if let Some(v) = self.assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(63, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(64, v);
            }
            if let Some(v) = self.kill_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(65, v);
            }
            if let Some(v) = self.respawn_seconds {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(68, v);
            }
            if let Some(v) = self.last_buyback_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(69, v);
            }
            if let Some(v) = self.first_blood_claimed {
                my_size += 2 + 1;
            }
            if let Some(v) = self.first_blood_given {
                my_size += 2 + 1;
            }
            if let Some(v) = self.bounty_runes {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(73, v);
            }
            if let Some(v) = self.outposts_captured {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(74, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.enemy_kills {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.damage_stats {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.abilities {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.hero_facet {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(153, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.player_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.hero.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.total_xp {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.bkb_charges_used {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.aeon_charges_used {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.reliable_gold {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.unreliable_gold {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.total_earned_gold {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.shared_gold {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.hero_kill_gold {
                os.write_int32(12, v)?;
            }
            if let Some(v) = self.creep_kill_gold {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.neutral_kill_gold {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.courier_gold {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.bounty_gold {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.roshan_gold {
                os.write_int32(17, v)?;
            }
            if let Some(v) = self.building_gold {
                os.write_int32(18, v)?;
            }
            if let Some(v) = self.other_gold {
                os.write_int32(19, v)?;
            }
            if let Some(v) = self.income_gold {
                os.write_int32(26, v)?;
            }
            if let Some(v) = self.ward_kill_gold {
                os.write_int32(27, v)?;
            }
            if let Some(v) = self.ability_gold {
                os.write_int32(28, v)?;
            }
            if let Some(v) = self.denies {
                os.write_int32(29, v)?;
            }
            if let Some(v) = self.last_hits {
                os.write_int32(30, v)?;
            }
            if let Some(v) = self.last_hit_streak {
                os.write_int32(31, v)?;
            }
            if let Some(v) = self.last_hit_multikill {
                os.write_int32(32, v)?;
            }
            if let Some(v) = self.nearby_creep_death_count {
                os.write_int32(33, v)?;
            }
            if let Some(v) = self.claimed_deny_count {
                os.write_int32(34, v)?;
            }
            if let Some(v) = self.claimed_miss_count {
                os.write_int32(35, v)?;
            }
            if let Some(v) = self.miss_count {
                os.write_int32(36, v)?;
            }
            if let Some(v) = self.buyback_cooldown_time {
                os.write_float(40, v)?;
            }
            if let Some(v) = self.buyback_gold_limit_time {
                os.write_float(41, v)?;
            }
            if let Some(v) = self.stun_duration {
                os.write_float(44, v)?;
            }
            if let Some(v) = self.healing {
                os.write_float(45, v)?;
            }
            if let Some(v) = self.tower_kills {
                os.write_int32(46, v)?;
            }
            if let Some(v) = self.roshan_kills {
                os.write_int32(47, v)?;
            }
            if let Some(v) = self.observer_wards_placed {
                os.write_int32(48, v)?;
            }
            if let Some(v) = self.sentry_wards_placed {
                os.write_int32(49, v)?;
            }
            if let Some(v) = self.creeps_stacked {
                os.write_int32(50, v)?;
            }
            if let Some(v) = self.camps_stacked {
                os.write_int32(51, v)?;
            }
            if let Some(v) = self.rune_pickups {
                os.write_int32(52, v)?;
            }
            if let Some(v) = self.gold_spent_on_support {
                os.write_int32(53, v)?;
            }
            if let Some(v) = self.hero_damage {
                os.write_int32(54, v)?;
            }
            if let Some(v) = self.wards_purchased {
                os.write_int32(55, v)?;
            }
            if let Some(v) = self.wards_destroyed {
                os.write_int32(56, v)?;
            }
            if let Some(v) = self.gold_spent_on_consumables {
                os.write_int32(58, v)?;
            }
            if let Some(v) = self.gold_spent_on_items {
                os.write_int32(59, v)?;
            }
            if let Some(v) = self.gold_spent_on_buybacks {
                os.write_int32(60, v)?;
            }
            if let Some(v) = self.gold_lost_to_death {
                os.write_int32(61, v)?;
            }
            if let Some(v) = self.kills {
                os.write_int32(62, v)?;
            }
            if let Some(v) = self.assists {
                os.write_int32(63, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_int32(64, v)?;
            }
            if let Some(v) = self.kill_streak {
                os.write_int32(65, v)?;
            }
            if let Some(v) = self.respawn_seconds {
                os.write_int32(68, v)?;
            }
            if let Some(v) = self.last_buyback_time {
                os.write_int32(69, v)?;
            }
            if let Some(v) = self.first_blood_claimed {
                os.write_bool(71, v)?;
            }
            if let Some(v) = self.first_blood_given {
                os.write_bool(72, v)?;
            }
            if let Some(v) = self.bounty_runes {
                os.write_int32(73, v)?;
            }
            if let Some(v) = self.outposts_captured {
                os.write_int32(74, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(75, v, os)?;
            }
            for v in &self.enemy_kills {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(150, v, os)?;
            };
            for v in &self.damage_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(151, v, os)?;
            };
            for v in &self.abilities {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(152, v, os)?;
            };
            if let Some(v) = self.hero_facet {
                os.write_uint32(153, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Hero {
            Hero::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.player_id = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.hero = ::std::option::Option::None;
            self.total_xp = ::std::option::Option::None;
            self.bkb_charges_used = ::std::option::Option::None;
            self.aeon_charges_used = ::std::option::Option::None;
            self.reliable_gold = ::std::option::Option::None;
            self.unreliable_gold = ::std::option::Option::None;
            self.total_earned_gold = ::std::option::Option::None;
            self.shared_gold = ::std::option::Option::None;
            self.hero_kill_gold = ::std::option::Option::None;
            self.creep_kill_gold = ::std::option::Option::None;
            self.neutral_kill_gold = ::std::option::Option::None;
            self.courier_gold = ::std::option::Option::None;
            self.bounty_gold = ::std::option::Option::None;
            self.roshan_gold = ::std::option::Option::None;
            self.building_gold = ::std::option::Option::None;
            self.other_gold = ::std::option::Option::None;
            self.income_gold = ::std::option::Option::None;
            self.ward_kill_gold = ::std::option::Option::None;
            self.ability_gold = ::std::option::Option::None;
            self.denies = ::std::option::Option::None;
            self.last_hits = ::std::option::Option::None;
            self.last_hit_streak = ::std::option::Option::None;
            self.last_hit_multikill = ::std::option::Option::None;
            self.nearby_creep_death_count = ::std::option::Option::None;
            self.claimed_deny_count = ::std::option::Option::None;
            self.claimed_miss_count = ::std::option::Option::None;
            self.miss_count = ::std::option::Option::None;
            self.buyback_cooldown_time = ::std::option::Option::None;
            self.buyback_gold_limit_time = ::std::option::Option::None;
            self.stun_duration = ::std::option::Option::None;
            self.healing = ::std::option::Option::None;
            self.tower_kills = ::std::option::Option::None;
            self.roshan_kills = ::std::option::Option::None;
            self.observer_wards_placed = ::std::option::Option::None;
            self.sentry_wards_placed = ::std::option::Option::None;
            self.creeps_stacked = ::std::option::Option::None;
            self.camps_stacked = ::std::option::Option::None;
            self.rune_pickups = ::std::option::Option::None;
            self.gold_spent_on_support = ::std::option::Option::None;
            self.hero_damage = ::std::option::Option::None;
            self.wards_purchased = ::std::option::Option::None;
            self.wards_destroyed = ::std::option::Option::None;
            self.gold_spent_on_consumables = ::std::option::Option::None;
            self.gold_spent_on_items = ::std::option::Option::None;
            self.gold_spent_on_buybacks = ::std::option::Option::None;
            self.gold_lost_to_death = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.kill_streak = ::std::option::Option::None;
            self.respawn_seconds = ::std::option::Option::None;
            self.last_buyback_time = ::std::option::Option::None;
            self.first_blood_claimed = ::std::option::Option::None;
            self.first_blood_given = ::std::option::Option::None;
            self.bounty_runes = ::std::option::Option::None;
            self.outposts_captured = ::std::option::Option::None;
            self.position.clear();
            self.enemy_kills.clear();
            self.damage_stats.clear();
            self.abilities.clear();
            self.hero_facet = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Hero {
            static instance: Hero = Hero {
                steam_id: ::std::option::Option::None,
                player_id: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                hero: ::std::option::Option::None,
                total_xp: ::std::option::Option::None,
                bkb_charges_used: ::std::option::Option::None,
                aeon_charges_used: ::std::option::Option::None,
                reliable_gold: ::std::option::Option::None,
                unreliable_gold: ::std::option::Option::None,
                total_earned_gold: ::std::option::Option::None,
                shared_gold: ::std::option::Option::None,
                hero_kill_gold: ::std::option::Option::None,
                creep_kill_gold: ::std::option::Option::None,
                neutral_kill_gold: ::std::option::Option::None,
                courier_gold: ::std::option::Option::None,
                bounty_gold: ::std::option::Option::None,
                roshan_gold: ::std::option::Option::None,
                building_gold: ::std::option::Option::None,
                other_gold: ::std::option::Option::None,
                income_gold: ::std::option::Option::None,
                ward_kill_gold: ::std::option::Option::None,
                ability_gold: ::std::option::Option::None,
                denies: ::std::option::Option::None,
                last_hits: ::std::option::Option::None,
                last_hit_streak: ::std::option::Option::None,
                last_hit_multikill: ::std::option::Option::None,
                nearby_creep_death_count: ::std::option::Option::None,
                claimed_deny_count: ::std::option::Option::None,
                claimed_miss_count: ::std::option::Option::None,
                miss_count: ::std::option::Option::None,
                buyback_cooldown_time: ::std::option::Option::None,
                buyback_gold_limit_time: ::std::option::Option::None,
                stun_duration: ::std::option::Option::None,
                healing: ::std::option::Option::None,
                tower_kills: ::std::option::Option::None,
                roshan_kills: ::std::option::Option::None,
                observer_wards_placed: ::std::option::Option::None,
                sentry_wards_placed: ::std::option::Option::None,
                creeps_stacked: ::std::option::Option::None,
                camps_stacked: ::std::option::Option::None,
                rune_pickups: ::std::option::Option::None,
                gold_spent_on_support: ::std::option::Option::None,
                hero_damage: ::std::option::Option::None,
                wards_purchased: ::std::option::Option::None,
                wards_destroyed: ::std::option::Option::None,
                gold_spent_on_consumables: ::std::option::Option::None,
                gold_spent_on_items: ::std::option::Option::None,
                gold_spent_on_buybacks: ::std::option::Option::None,
                gold_lost_to_death: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                kill_streak: ::std::option::Option::None,
                respawn_seconds: ::std::option::Option::None,
                last_buyback_time: ::std::option::Option::None,
                first_blood_claimed: ::std::option::Option::None,
                first_blood_given: ::std::option::Option::None,
                bounty_runes: ::std::option::Option::None,
                outposts_captured: ::std::option::Option::None,
                position: ::steam_vent_proto_common::protobuf::MessageField::none(),
                enemy_kills: ::std::vec::Vec::new(),
                damage_stats: ::std::vec::Vec::new(),
                abilities: ::std::vec::Vec::new(),
                hero_facet: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Stock)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stock {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Stock.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Stock.team_number)
        pub team_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Stock.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Stock.current_stock)
        pub current_stock: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Stock.cooldown)
        pub cooldown: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Stock.bonus_stock)
        pub bonus_stock: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Stock.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stock {
        fn default() -> &'a Stock {
            <Stock as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Stock {
        pub fn new() -> Stock {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 team_number = 2;

        pub fn team_number(&self) -> i32 {
            self.team_number.unwrap_or(-1i32)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: i32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional int32 player_id = 3;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 current_stock = 4;

        pub fn current_stock(&self) -> i32 {
            self.current_stock.unwrap_or(0)
        }

        pub fn clear_current_stock(&mut self) {
            self.current_stock = ::std::option::Option::None;
        }

        pub fn has_current_stock(&self) -> bool {
            self.current_stock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_current_stock(&mut self, v: i32) {
            self.current_stock = ::std::option::Option::Some(v);
        }

        // optional float cooldown = 5;

        pub fn cooldown(&self) -> f32 {
            self.cooldown.unwrap_or(0.)
        }

        pub fn clear_cooldown(&mut self) {
            self.cooldown = ::std::option::Option::None;
        }

        pub fn has_cooldown(&self) -> bool {
            self.cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cooldown(&mut self, v: f32) {
            self.cooldown = ::std::option::Option::Some(v);
        }

        // optional int32 bonus_stock = 6;

        pub fn bonus_stock(&self) -> i32 {
            self.bonus_stock.unwrap_or(0)
        }

        pub fn clear_bonus_stock(&mut self) {
            self.bonus_stock = ::std::option::Option::None;
        }

        pub fn has_bonus_stock(&self) -> bool {
            self.bonus_stock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_stock(&mut self, v: i32) {
            self.bonus_stock = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Stock {
        const NAME: &'static str = "Stock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.team_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.current_stock = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.bonus_stock = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.team_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.current_stock {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.cooldown {
                my_size += 1 + 4;
            }
            if let Some(v) = self.bonus_stock {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.team_number {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.player_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.current_stock {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.cooldown {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.bonus_stock {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stock {
            Stock::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.team_number = ::std::option::Option::None;
            self.player_id = ::std::option::Option::None;
            self.current_stock = ::std::option::Option::None;
            self.cooldown = ::std::option::Option::None;
            self.bonus_stock = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stock {
            static instance: Stock = Stock {
                name: ::std::option::Option::None,
                team_number: ::std::option::Option::None,
                player_id: ::std::option::Option::None,
                current_stock: ::std::option::Option::None,
                cooldown: ::std::option::Option::None,
                bonus_stock: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Building)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Building {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Building.entity_name)
        pub entity_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Building.entity_class)
        pub entity_class: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Building.team_id)
        pub team_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Building.is_destroyed)
        pub is_destroyed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Building.health_frac)
        pub health_frac: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Building.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Building {
        fn default() -> &'a Building {
            <Building as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Building {
        pub fn new() -> Building {
            ::std::default::Default::default()
        }

        // optional string entity_name = 1;

        pub fn entity_name(&self) -> &str {
            match self.entity_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_entity_name(&mut self) {
            self.entity_name = ::std::option::Option::None;
        }

        pub fn has_entity_name(&self) -> bool {
            self.entity_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_name(&mut self, v: ::std::string::String) {
            self.entity_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_entity_name(&mut self) -> &mut ::std::string::String {
            if self.entity_name.is_none() {
                self.entity_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.entity_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_entity_name(&mut self) -> ::std::string::String {
            self.entity_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string entity_class = 2;

        pub fn entity_class(&self) -> &str {
            match self.entity_class.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_entity_class(&mut self) {
            self.entity_class = ::std::option::Option::None;
        }

        pub fn has_entity_class(&self) -> bool {
            self.entity_class.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_class(&mut self, v: ::std::string::String) {
            self.entity_class = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_entity_class(&mut self) -> &mut ::std::string::String {
            if self.entity_class.is_none() {
                self.entity_class = ::std::option::Option::Some(::std::string::String::new());
            }
            self.entity_class.as_mut().unwrap()
        }

        // Take field
        pub fn take_entity_class(&mut self) -> ::std::string::String {
            self.entity_class.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 team_id = 3;

        pub fn team_id(&self) -> i32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: i32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional bool is_destroyed = 4;

        pub fn is_destroyed(&self) -> bool {
            self.is_destroyed.unwrap_or(false)
        }

        pub fn clear_is_destroyed(&mut self) {
            self.is_destroyed = ::std::option::Option::None;
        }

        pub fn has_is_destroyed(&self) -> bool {
            self.is_destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_destroyed(&mut self, v: bool) {
            self.is_destroyed = ::std::option::Option::Some(v);
        }

        // optional float health_frac = 5;

        pub fn health_frac(&self) -> f32 {
            self.health_frac.unwrap_or(1.0f32)
        }

        pub fn clear_health_frac(&mut self) {
            self.health_frac = ::std::option::Option::None;
        }

        pub fn has_health_frac(&self) -> bool {
            self.health_frac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_health_frac(&mut self, v: f32) {
            self.health_frac = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Building {
        const NAME: &'static str = "Building";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.entity_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.entity_class = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.is_destroyed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    45 => {
                        self.health_frac = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.entity_class.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.is_destroyed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.health_frac {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.entity_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.entity_class.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.is_destroyed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.health_frac {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Building {
            Building::new()
        }

        fn clear(&mut self) {
            self.entity_name = ::std::option::Option::None;
            self.entity_class = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.is_destroyed = ::std::option::Option::None;
            self.health_frac = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Building {
            static instance: Building = Building {
                entity_name: ::std::option::Option::None,
                entity_class: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                is_destroyed: ::std::option::Option::None,
                health_frac: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Entity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entity {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Entity.courier)
        pub courier: ::steam_vent_proto_common::protobuf::MessageField<super::CScenarioEnt_Courier>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Entity.npc)
        pub npc: ::steam_vent_proto_common::protobuf::MessageField<super::CScenarioEnt_NPC>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Entity.spirit_bear)
        pub spirit_bear: ::steam_vent_proto_common::protobuf::MessageField<super::CScenarioEnt_SpiritBear>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Entity.dropped_item)
        pub dropped_item: ::steam_vent_proto_common::protobuf::MessageField<super::CScenarioEnt_DroppedItem>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Entity.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entity {
        fn default() -> &'a Entity {
            <Entity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Entity {
        pub fn new() -> Entity {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Entity {
        const NAME: &'static str = "Entity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.courier)?;
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.npc)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.spirit_bear)?;
                    },
                    34 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dropped_item)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.courier.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.npc.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.spirit_bear.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dropped_item.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.courier.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.npc.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.spirit_bear.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.dropped_item.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entity {
            Entity::new()
        }

        fn clear(&mut self) {
            self.courier.clear();
            self.npc.clear();
            self.spirit_bear.clear();
            self.dropped_item.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entity {
            static instance: Entity = Entity {
                courier: ::steam_vent_proto_common::protobuf::MessageField::none(),
                npc: ::steam_vent_proto_common::protobuf::MessageField::none(),
                spirit_bear: ::steam_vent_proto_common::protobuf::MessageField::none(),
                dropped_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.location)
        pub location: ::steam_vent_proto_common::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.owner_id)
        pub owner_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.item_slot)
        pub item_slot: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.neutral_drop_team)
        pub neutral_drop_team: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.charges)
        pub charges: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.secondary_charges)
        pub secondary_charges: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.lifetime)
        pub lifetime: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Item.stored_rune_type)
        pub stored_rune_type: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 owner_id = 3;

        pub fn owner_id(&self) -> i32 {
            self.owner_id.unwrap_or(-1i32)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: i32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional int32 item_slot = 4;

        pub fn item_slot(&self) -> i32 {
            self.item_slot.unwrap_or(0)
        }

        pub fn clear_item_slot(&mut self) {
            self.item_slot = ::std::option::Option::None;
        }

        pub fn has_item_slot(&self) -> bool {
            self.item_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_slot(&mut self, v: i32) {
            self.item_slot = ::std::option::Option::Some(v);
        }

        // optional int32 neutral_drop_team = 5;

        pub fn neutral_drop_team(&self) -> i32 {
            self.neutral_drop_team.unwrap_or(0)
        }

        pub fn clear_neutral_drop_team(&mut self) {
            self.neutral_drop_team = ::std::option::Option::None;
        }

        pub fn has_neutral_drop_team(&self) -> bool {
            self.neutral_drop_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_drop_team(&mut self, v: i32) {
            self.neutral_drop_team = ::std::option::Option::Some(v);
        }

        // optional int32 charges = 6;

        pub fn charges(&self) -> i32 {
            self.charges.unwrap_or(0)
        }

        pub fn clear_charges(&mut self) {
            self.charges = ::std::option::Option::None;
        }

        pub fn has_charges(&self) -> bool {
            self.charges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_charges(&mut self, v: i32) {
            self.charges = ::std::option::Option::Some(v);
        }

        // optional int32 secondary_charges = 7;

        pub fn secondary_charges(&self) -> i32 {
            self.secondary_charges.unwrap_or(0)
        }

        pub fn clear_secondary_charges(&mut self) {
            self.secondary_charges = ::std::option::Option::None;
        }

        pub fn has_secondary_charges(&self) -> bool {
            self.secondary_charges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_secondary_charges(&mut self, v: i32) {
            self.secondary_charges = ::std::option::Option::Some(v);
        }

        // optional float lifetime = 8;

        pub fn lifetime(&self) -> f32 {
            self.lifetime.unwrap_or(-1.0f32)
        }

        pub fn clear_lifetime(&mut self) {
            self.lifetime = ::std::option::Option::None;
        }

        pub fn has_lifetime(&self) -> bool {
            self.lifetime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lifetime(&mut self, v: f32) {
            self.lifetime = ::std::option::Option::Some(v);
        }

        // optional int32 stored_rune_type = 9;

        pub fn stored_rune_type(&self) -> i32 {
            self.stored_rune_type.unwrap_or(-1i32)
        }

        pub fn clear_stored_rune_type(&mut self) {
            self.stored_rune_type = ::std::option::Option::None;
        }

        pub fn has_stored_rune_type(&self) -> bool {
            self.stored_rune_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stored_rune_type(&mut self, v: i32) {
            self.stored_rune_type = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                    },
                    24 => {
                        self.owner_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.item_slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.neutral_drop_team = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.charges = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                    },
                    69 => {
                        self.lifetime = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.stored_rune_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.location.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.owner_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.item_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.neutral_drop_team {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.charges {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.secondary_charges {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.lifetime {
                my_size += 1 + 4;
            }
            if let Some(v) = self.stored_rune_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.location.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.owner_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.item_slot {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.neutral_drop_team {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.charges {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.secondary_charges {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.lifetime {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.stored_rune_type {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.location.clear();
            self.owner_id = ::std::option::Option::None;
            self.item_slot = ::std::option::Option::None;
            self.neutral_drop_team = ::std::option::Option::None;
            self.charges = ::std::option::Option::None;
            self.secondary_charges = ::std::option::Option::None;
            self.lifetime = ::std::option::Option::None;
            self.stored_rune_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                name: ::std::option::Option::None,
                location: ::steam_vent_proto_common::protobuf::MessageField::none(),
                owner_id: ::std::option::Option::None,
                item_slot: ::std::option::Option::None,
                neutral_drop_team: ::std::option::Option::None,
                charges: ::std::option::Option::None,
                secondary_charges: ::std::option::Option::None,
                lifetime: ::std::option::Option::None,
                stored_rune_type: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDotaScenario.Modifier)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Modifier {
        // message fields
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.parent)
        pub parent: ::steam_vent_proto_common::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.caster)
        pub caster: ::steam_vent_proto_common::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.ability)
        pub ability: ::steam_vent_proto_common::protobuf::MessageField<EntityRef>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.duration)
        pub duration: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.lifetime_remaining)
        pub lifetime_remaining: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.stack_count)
        pub stack_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.create_even_if_existing)
        pub create_even_if_existing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.create_without_caster)
        pub create_without_caster: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.create_without_ability)
        pub create_without_ability: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.moonshard_consumed_bonus)
        pub moonshard_consumed_bonus: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.moonshard_consumed_bonus_night_vision)
        pub moonshard_consumed_bonus_night_vision: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.wardtruesight_range)
        pub wardtruesight_range: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_all_stats)
        pub ultimate_scepter_consumed_alchemist_bonus_all_stats: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_health)
        pub ultimate_scepter_consumed_alchemist_bonus_health: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_mana)
        pub ultimate_scepter_consumed_alchemist_bonus_mana: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDotaScenario.Modifier.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Modifier {
        fn default() -> &'a Modifier {
            <Modifier as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Modifier {
        pub fn new() -> Modifier {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float duration = 5;

        pub fn duration(&self) -> f32 {
            self.duration.unwrap_or(-1.0f32)
        }

        pub fn clear_duration(&mut self) {
            self.duration = ::std::option::Option::None;
        }

        pub fn has_duration(&self) -> bool {
            self.duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration(&mut self, v: f32) {
            self.duration = ::std::option::Option::Some(v);
        }

        // optional float lifetime_remaining = 6;

        pub fn lifetime_remaining(&self) -> f32 {
            self.lifetime_remaining.unwrap_or(0.0f32)
        }

        pub fn clear_lifetime_remaining(&mut self) {
            self.lifetime_remaining = ::std::option::Option::None;
        }

        pub fn has_lifetime_remaining(&self) -> bool {
            self.lifetime_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lifetime_remaining(&mut self, v: f32) {
            self.lifetime_remaining = ::std::option::Option::Some(v);
        }

        // optional int32 stack_count = 7;

        pub fn stack_count(&self) -> i32 {
            self.stack_count.unwrap_or(0)
        }

        pub fn clear_stack_count(&mut self) {
            self.stack_count = ::std::option::Option::None;
        }

        pub fn has_stack_count(&self) -> bool {
            self.stack_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stack_count(&mut self, v: i32) {
            self.stack_count = ::std::option::Option::Some(v);
        }

        // optional bool create_even_if_existing = 8;

        pub fn create_even_if_existing(&self) -> bool {
            self.create_even_if_existing.unwrap_or(false)
        }

        pub fn clear_create_even_if_existing(&mut self) {
            self.create_even_if_existing = ::std::option::Option::None;
        }

        pub fn has_create_even_if_existing(&self) -> bool {
            self.create_even_if_existing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_create_even_if_existing(&mut self, v: bool) {
            self.create_even_if_existing = ::std::option::Option::Some(v);
        }

        // optional bool create_without_caster = 9;

        pub fn create_without_caster(&self) -> bool {
            self.create_without_caster.unwrap_or(false)
        }

        pub fn clear_create_without_caster(&mut self) {
            self.create_without_caster = ::std::option::Option::None;
        }

        pub fn has_create_without_caster(&self) -> bool {
            self.create_without_caster.is_some()
        }

        // Param is passed by value, moved
        pub fn set_create_without_caster(&mut self, v: bool) {
            self.create_without_caster = ::std::option::Option::Some(v);
        }

        // optional bool create_without_ability = 10;

        pub fn create_without_ability(&self) -> bool {
            self.create_without_ability.unwrap_or(false)
        }

        pub fn clear_create_without_ability(&mut self) {
            self.create_without_ability = ::std::option::Option::None;
        }

        pub fn has_create_without_ability(&self) -> bool {
            self.create_without_ability.is_some()
        }

        // Param is passed by value, moved
        pub fn set_create_without_ability(&mut self, v: bool) {
            self.create_without_ability = ::std::option::Option::Some(v);
        }

        // optional int32 moonshard_consumed_bonus = 100;

        pub fn moonshard_consumed_bonus(&self) -> i32 {
            self.moonshard_consumed_bonus.unwrap_or(0)
        }

        pub fn clear_moonshard_consumed_bonus(&mut self) {
            self.moonshard_consumed_bonus = ::std::option::Option::None;
        }

        pub fn has_moonshard_consumed_bonus(&self) -> bool {
            self.moonshard_consumed_bonus.is_some()
        }

        // Param is passed by value, moved
        pub fn set_moonshard_consumed_bonus(&mut self, v: i32) {
            self.moonshard_consumed_bonus = ::std::option::Option::Some(v);
        }

        // optional int32 moonshard_consumed_bonus_night_vision = 101;

        pub fn moonshard_consumed_bonus_night_vision(&self) -> i32 {
            self.moonshard_consumed_bonus_night_vision.unwrap_or(0)
        }

        pub fn clear_moonshard_consumed_bonus_night_vision(&mut self) {
            self.moonshard_consumed_bonus_night_vision = ::std::option::Option::None;
        }

        pub fn has_moonshard_consumed_bonus_night_vision(&self) -> bool {
            self.moonshard_consumed_bonus_night_vision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_moonshard_consumed_bonus_night_vision(&mut self, v: i32) {
            self.moonshard_consumed_bonus_night_vision = ::std::option::Option::Some(v);
        }

        // optional int32 wardtruesight_range = 110;

        pub fn wardtruesight_range(&self) -> i32 {
            self.wardtruesight_range.unwrap_or(0)
        }

        pub fn clear_wardtruesight_range(&mut self) {
            self.wardtruesight_range = ::std::option::Option::None;
        }

        pub fn has_wardtruesight_range(&self) -> bool {
            self.wardtruesight_range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wardtruesight_range(&mut self, v: i32) {
            self.wardtruesight_range = ::std::option::Option::Some(v);
        }

        // optional int32 ultimate_scepter_consumed_alchemist_bonus_all_stats = 120;

        pub fn ultimate_scepter_consumed_alchemist_bonus_all_stats(&self) -> i32 {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats.unwrap_or(0)
        }

        pub fn clear_ultimate_scepter_consumed_alchemist_bonus_all_stats(&mut self) {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::None;
        }

        pub fn has_ultimate_scepter_consumed_alchemist_bonus_all_stats(&self) -> bool {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_scepter_consumed_alchemist_bonus_all_stats(&mut self, v: i32) {
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::Some(v);
        }

        // optional int32 ultimate_scepter_consumed_alchemist_bonus_health = 121;

        pub fn ultimate_scepter_consumed_alchemist_bonus_health(&self) -> i32 {
            self.ultimate_scepter_consumed_alchemist_bonus_health.unwrap_or(0)
        }

        pub fn clear_ultimate_scepter_consumed_alchemist_bonus_health(&mut self) {
            self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::None;
        }

        pub fn has_ultimate_scepter_consumed_alchemist_bonus_health(&self) -> bool {
            self.ultimate_scepter_consumed_alchemist_bonus_health.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_scepter_consumed_alchemist_bonus_health(&mut self, v: i32) {
            self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::Some(v);
        }

        // optional int32 ultimate_scepter_consumed_alchemist_bonus_mana = 122;

        pub fn ultimate_scepter_consumed_alchemist_bonus_mana(&self) -> i32 {
            self.ultimate_scepter_consumed_alchemist_bonus_mana.unwrap_or(0)
        }

        pub fn clear_ultimate_scepter_consumed_alchemist_bonus_mana(&mut self) {
            self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::None;
        }

        pub fn has_ultimate_scepter_consumed_alchemist_bonus_mana(&self) -> bool {
            self.ultimate_scepter_consumed_alchemist_bonus_mana.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_scepter_consumed_alchemist_bonus_mana(&mut self, v: i32) {
            self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Modifier {
        const NAME: &'static str = "Modifier";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.parent)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.caster)?;
                    },
                    34 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ability)?;
                    },
                    45 => {
                        self.duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    53 => {
                        self.lifetime_remaining = ::std::option::Option::Some(is.read_float()?);
                    },
                    56 => {
                        self.stack_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.create_even_if_existing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.create_without_caster = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.create_without_ability = ::std::option::Option::Some(is.read_bool()?);
                    },
                    800 => {
                        self.moonshard_consumed_bonus = ::std::option::Option::Some(is.read_int32()?);
                    },
                    808 => {
                        self.moonshard_consumed_bonus_night_vision = ::std::option::Option::Some(is.read_int32()?);
                    },
                    880 => {
                        self.wardtruesight_range = ::std::option::Option::Some(is.read_int32()?);
                    },
                    960 => {
                        self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::Some(is.read_int32()?);
                    },
                    968 => {
                        self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::Some(is.read_int32()?);
                    },
                    976 => {
                        self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.parent.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.caster.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.ability.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.duration {
                my_size += 1 + 4;
            }
            if let Some(v) = self.lifetime_remaining {
                my_size += 1 + 4;
            }
            if let Some(v) = self.stack_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.create_even_if_existing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.create_without_caster {
                my_size += 1 + 1;
            }
            if let Some(v) = self.create_without_ability {
                my_size += 1 + 1;
            }
            if let Some(v) = self.moonshard_consumed_bonus {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(100, v);
            }
            if let Some(v) = self.moonshard_consumed_bonus_night_vision {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(101, v);
            }
            if let Some(v) = self.wardtruesight_range {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(110, v);
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_all_stats {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(120, v);
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_health {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(121, v);
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_mana {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(122, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.parent.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.caster.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.ability.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.duration {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.lifetime_remaining {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.stack_count {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.create_even_if_existing {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.create_without_caster {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.create_without_ability {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.moonshard_consumed_bonus {
                os.write_int32(100, v)?;
            }
            if let Some(v) = self.moonshard_consumed_bonus_night_vision {
                os.write_int32(101, v)?;
            }
            if let Some(v) = self.wardtruesight_range {
                os.write_int32(110, v)?;
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_all_stats {
                os.write_int32(120, v)?;
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_health {
                os.write_int32(121, v)?;
            }
            if let Some(v) = self.ultimate_scepter_consumed_alchemist_bonus_mana {
                os.write_int32(122, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Modifier {
            Modifier::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.parent.clear();
            self.caster.clear();
            self.ability.clear();
            self.duration = ::std::option::Option::None;
            self.lifetime_remaining = ::std::option::Option::None;
            self.stack_count = ::std::option::Option::None;
            self.create_even_if_existing = ::std::option::Option::None;
            self.create_without_caster = ::std::option::Option::None;
            self.create_without_ability = ::std::option::Option::None;
            self.moonshard_consumed_bonus = ::std::option::Option::None;
            self.moonshard_consumed_bonus_night_vision = ::std::option::Option::None;
            self.wardtruesight_range = ::std::option::Option::None;
            self.ultimate_scepter_consumed_alchemist_bonus_all_stats = ::std::option::Option::None;
            self.ultimate_scepter_consumed_alchemist_bonus_health = ::std::option::Option::None;
            self.ultimate_scepter_consumed_alchemist_bonus_mana = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Modifier {
            static instance: Modifier = Modifier {
                name: ::std::option::Option::None,
                parent: ::steam_vent_proto_common::protobuf::MessageField::none(),
                caster: ::steam_vent_proto_common::protobuf::MessageField::none(),
                ability: ::steam_vent_proto_common::protobuf::MessageField::none(),
                duration: ::std::option::Option::None,
                lifetime_remaining: ::std::option::Option::None,
                stack_count: ::std::option::Option::None,
                create_even_if_existing: ::std::option::Option::None,
                create_without_caster: ::std::option::Option::None,
                create_without_ability: ::std::option::Option::None,
                moonshard_consumed_bonus: ::std::option::Option::None,
                moonshard_consumed_bonus_night_vision: ::std::option::Option::None,
                wardtruesight_range: ::std::option::Option::None,
                ultimate_scepter_consumed_alchemist_bonus_all_stats: ::std::option::Option::None,
                ultimate_scepter_consumed_alchemist_bonus_health: ::std::option::Option::None,
                ultimate_scepter_consumed_alchemist_bonus_mana: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}


const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::dota_shared_enums::*;
impl ::steam_vent_proto_common::RpcMessage for CScenario_Position {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CScenarioGame_RoshanSpawner {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CScenarioEnt_Courier {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CScenarioEnt_NPC {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CScenarioEnt_SpiritBear {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CScenarioEnt_DroppedItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDotaScenario {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
