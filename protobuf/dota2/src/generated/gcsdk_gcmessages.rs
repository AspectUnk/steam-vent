// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gcsdk_gcmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CExtraMsgBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CExtraMsgBlock {
    // message fields
    // @@protoc_insertion_point(field:CExtraMsgBlock.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CExtraMsgBlock.contents)
    pub contents: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CExtraMsgBlock.msg_key)
    pub msg_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CExtraMsgBlock.is_compressed)
    pub is_compressed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CExtraMsgBlock.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CExtraMsgBlock {
    fn default() -> &'a CExtraMsgBlock {
        <CExtraMsgBlock as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CExtraMsgBlock {
    pub fn new() -> CExtraMsgBlock {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes contents = 2;

    pub fn contents(&self) -> &[u8] {
        match self.contents.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_contents(&mut self) {
        self.contents = ::std::option::Option::None;
    }

    pub fn has_contents(&self) -> bool {
        self.contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.contents = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.contents.is_none() {
            self.contents = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
        self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 msg_key = 3;

    pub fn msg_key(&self) -> u64 {
        self.msg_key.unwrap_or(0)
    }

    pub fn clear_msg_key(&mut self) {
        self.msg_key = ::std::option::Option::None;
    }

    pub fn has_msg_key(&self) -> bool {
        self.msg_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_key(&mut self, v: u64) {
        self.msg_key = ::std::option::Option::Some(v);
    }

    // optional bool is_compressed = 4;

    pub fn is_compressed(&self) -> bool {
        self.is_compressed.unwrap_or(false)
    }

    pub fn clear_is_compressed(&mut self) {
        self.is_compressed = ::std::option::Option::None;
    }

    pub fn has_is_compressed(&self) -> bool {
        self.is_compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_compressed(&mut self, v: bool) {
        self.is_compressed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CExtraMsgBlock {
    const NAME: &'static str = "CExtraMsgBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.contents = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.msg_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.is_compressed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.contents.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.msg_key {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.is_compressed {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.contents.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.msg_key {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.is_compressed {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CExtraMsgBlock {
        CExtraMsgBlock::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.contents = ::std::option::Option::None;
        self.msg_key = ::std::option::Option::None;
        self.is_compressed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CExtraMsgBlock {
        static instance: CExtraMsgBlock = CExtraMsgBlock {
            msg_type: ::std::option::Option::None,
            contents: ::std::option::Option::None,
            msg_key: ::std::option::Option::None,
            is_compressed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnServerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnServerInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnServerInfo.enable_data_submission)
    pub enable_data_submission: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamLearnServerInfo.access_tokens)
    pub access_tokens: ::steam_vent_proto_common::protobuf::MessageField<super::steammessages_steamlearn_steamworkssdk::CMsgSteamLearnAccessTokens>,
    // @@protoc_insertion_point(field:CMsgSteamLearnServerInfo.project_infos)
    pub project_infos: ::std::vec::Vec<cmsg_steam_learn_server_info::ProjectInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnServerInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnServerInfo {
    fn default() -> &'a CMsgSteamLearnServerInfo {
        <CMsgSteamLearnServerInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnServerInfo {
    pub fn new() -> CMsgSteamLearnServerInfo {
        ::std::default::Default::default()
    }

    // optional bool enable_data_submission = 1;

    pub fn enable_data_submission(&self) -> bool {
        self.enable_data_submission.unwrap_or(false)
    }

    pub fn clear_enable_data_submission(&mut self) {
        self.enable_data_submission = ::std::option::Option::None;
    }

    pub fn has_enable_data_submission(&self) -> bool {
        self.enable_data_submission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_data_submission(&mut self, v: bool) {
        self.enable_data_submission = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnServerInfo {
    const NAME: &'static str = "CMsgSteamLearnServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enable_data_submission = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.access_tokens)?;
                },
                42 => {
                    self.project_infos.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enable_data_submission {
            my_size += 1 + 1;
        }
        if let Some(v) = self.access_tokens.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.project_infos {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enable_data_submission {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.access_tokens.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.project_infos {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnServerInfo {
        CMsgSteamLearnServerInfo::new()
    }

    fn clear(&mut self) {
        self.enable_data_submission = ::std::option::Option::None;
        self.access_tokens.clear();
        self.project_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnServerInfo {
        static instance: CMsgSteamLearnServerInfo = CMsgSteamLearnServerInfo {
            enable_data_submission: ::std::option::Option::None,
            access_tokens: ::steam_vent_proto_common::protobuf::MessageField::none(),
            project_infos: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamLearnServerInfo`
pub mod cmsg_steam_learn_server_info {
    // @@protoc_insertion_point(message:CMsgSteamLearnServerInfo.ProjectInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProjectInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearnServerInfo.ProjectInfo.project_id)
        pub project_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnServerInfo.ProjectInfo.snapshot_published_version)
        pub snapshot_published_version: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnServerInfo.ProjectInfo.inference_published_version)
        pub inference_published_version: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearnServerInfo.ProjectInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProjectInfo {
        fn default() -> &'a ProjectInfo {
            <ProjectInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ProjectInfo {
        pub fn new() -> ProjectInfo {
            ::std::default::Default::default()
        }

        // optional uint32 project_id = 1;

        pub fn project_id(&self) -> u32 {
            self.project_id.unwrap_or(0)
        }

        pub fn clear_project_id(&mut self) {
            self.project_id = ::std::option::Option::None;
        }

        pub fn has_project_id(&self) -> bool {
            self.project_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_project_id(&mut self, v: u32) {
            self.project_id = ::std::option::Option::Some(v);
        }

        // optional uint32 snapshot_published_version = 2;

        pub fn snapshot_published_version(&self) -> u32 {
            self.snapshot_published_version.unwrap_or(0)
        }

        pub fn clear_snapshot_published_version(&mut self) {
            self.snapshot_published_version = ::std::option::Option::None;
        }

        pub fn has_snapshot_published_version(&self) -> bool {
            self.snapshot_published_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_snapshot_published_version(&mut self, v: u32) {
            self.snapshot_published_version = ::std::option::Option::Some(v);
        }

        // optional uint32 inference_published_version = 3;

        pub fn inference_published_version(&self) -> u32 {
            self.inference_published_version.unwrap_or(0)
        }

        pub fn clear_inference_published_version(&mut self) {
            self.inference_published_version = ::std::option::Option::None;
        }

        pub fn has_inference_published_version(&self) -> bool {
            self.inference_published_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inference_published_version(&mut self, v: u32) {
            self.inference_published_version = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ProjectInfo {
        const NAME: &'static str = "ProjectInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.project_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.snapshot_published_version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.inference_published_version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.project_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.snapshot_published_version {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.inference_published_version {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.project_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.snapshot_published_version {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.inference_published_version {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProjectInfo {
            ProjectInfo::new()
        }

        fn clear(&mut self) {
            self.project_id = ::std::option::Option::None;
            self.snapshot_published_version = ::std::option::Option::None;
            self.inference_published_version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProjectInfo {
            static instance: ProjectInfo = ProjectInfo {
                project_id: ::std::option::Option::None,
                snapshot_published_version: ::std::option::Option::None,
                inference_published_version: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCAssertJobData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCAssertJobData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCAssertJobData.message_type)
    pub message_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCAssertJobData.message_data)
    pub message_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCAssertJobData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCAssertJobData {
    fn default() -> &'a CMsgGCAssertJobData {
        <CMsgGCAssertJobData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCAssertJobData {
    pub fn new() -> CMsgGCAssertJobData {
        ::std::default::Default::default()
    }

    // optional string message_type = 1;

    pub fn message_type(&self) -> &str {
        match self.message_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: ::std::string::String) {
        self.message_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_type(&mut self) -> &mut ::std::string::String {
        if self.message_type.is_none() {
            self.message_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_type(&mut self) -> ::std::string::String {
        self.message_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes message_data = 2;

    pub fn message_data(&self) -> &[u8] {
        match self.message_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_data(&mut self) {
        self.message_data = ::std::option::Option::None;
    }

    pub fn has_message_data(&self) -> bool {
        self.message_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_data.is_none() {
            self.message_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_data(&mut self) -> ::std::vec::Vec<u8> {
        self.message_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCAssertJobData {
    const NAME: &'static str = "CMsgGCAssertJobData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_type = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_type.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message_type.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCAssertJobData {
        CMsgGCAssertJobData::new()
    }

    fn clear(&mut self) {
        self.message_type = ::std::option::Option::None;
        self.message_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCAssertJobData {
        static instance: CMsgGCAssertJobData = CMsgGCAssertJobData {
            message_type: ::std::option::Option::None,
            message_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCConCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCConCommand {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCConCommand.command)
    pub command: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCConCommand.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCConCommand {
    fn default() -> &'a CMsgGCConCommand {
        <CMsgGCConCommand as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCConCommand {
    pub fn new() -> CMsgGCConCommand {
        ::std::default::Default::default()
    }

    // optional string command = 1;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCConCommand {
    const NAME: &'static str = "CMsgGCConCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.command.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCConCommand {
        CMsgGCConCommand::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCConCommand {
        static instance: CMsgGCConCommand = CMsgGCConCommand {
            command: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSDOAssert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSDOAssert {
    // message fields
    // @@protoc_insertion_point(field:CMsgSDOAssert.sdo_type)
    pub sdo_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSDOAssert.requests)
    pub requests: ::std::vec::Vec<cmsg_sdoassert::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSDOAssert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSDOAssert {
    fn default() -> &'a CMsgSDOAssert {
        <CMsgSDOAssert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSDOAssert {
    pub fn new() -> CMsgSDOAssert {
        ::std::default::Default::default()
    }

    // optional int32 sdo_type = 1;

    pub fn sdo_type(&self) -> i32 {
        self.sdo_type.unwrap_or(0)
    }

    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: i32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSDOAssert {
    const NAME: &'static str = "CMsgSDOAssert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sdo_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.requests.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.sdo_type {
            os.write_int32(1, v)?;
        }
        for v in &self.requests {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSDOAssert {
        CMsgSDOAssert::new()
    }

    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSDOAssert {
        static instance: CMsgSDOAssert = CMsgSDOAssert {
            sdo_type: ::std::option::Option::None,
            requests: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSDOAssert`
pub mod cmsg_sdoassert {
    // @@protoc_insertion_point(message:CMsgSDOAssert.Request)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Request {
        // message fields
        // @@protoc_insertion_point(field:CMsgSDOAssert.Request.key)
        pub key: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:CMsgSDOAssert.Request.requesting_job)
        pub requesting_job: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSDOAssert.Request.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Request {
        fn default() -> &'a Request {
            <Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Request {
        pub fn new() -> Request {
            ::std::default::Default::default()
        }

        // optional string requesting_job = 2;

        pub fn requesting_job(&self) -> &str {
            match self.requesting_job.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_requesting_job(&mut self) {
            self.requesting_job = ::std::option::Option::None;
        }

        pub fn has_requesting_job(&self) -> bool {
            self.requesting_job.is_some()
        }

        // Param is passed by value, moved
        pub fn set_requesting_job(&mut self, v: ::std::string::String) {
            self.requesting_job = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_requesting_job(&mut self) -> &mut ::std::string::String {
            if self.requesting_job.is_none() {
                self.requesting_job = ::std::option::Option::Some(::std::string::String::new());
            }
            self.requesting_job.as_mut().unwrap()
        }

        // Take field
        pub fn take_requesting_job(&mut self) -> ::std::string::String {
            self.requesting_job.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Request {
        const NAME: &'static str = "Request";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_uint64_into(&mut self.key)?;
                    },
                    8 => {
                        self.key.push(is.read_uint64()?);
                    },
                    18 => {
                        self.requesting_job = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.key {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
            };
            if let Some(v) = self.requesting_job.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.key {
                os.write_uint64(1, *v)?;
            };
            if let Some(v) = self.requesting_job.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Request {
            Request::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.requesting_job = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Request {
            static instance: Request = Request {
                key: ::std::vec::Vec::new(),
                requesting_job: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSOIDOwner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOIDOwner {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOIDOwner.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOIDOwner.id)
    pub id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOIDOwner.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOIDOwner {
    fn default() -> &'a CMsgSOIDOwner {
        <CMsgSOIDOwner as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOIDOwner {
    pub fn new() -> CMsgSOIDOwner {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint64 id = 2;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOIDOwner {
    const NAME: &'static str = "CMsgSOIDOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOIDOwner {
        CMsgSOIDOwner::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOIDOwner {
        static instance: CMsgSOIDOwner = CMsgSOIDOwner {
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOSingleObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOSingleObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOSingleObject.type_id)
    pub type_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.object_data)
    pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.service_id)
    pub service_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOSingleObject.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOSingleObject {
    fn default() -> &'a CMsgSOSingleObject {
        <CMsgSOSingleObject as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOSingleObject {
    pub fn new() -> CMsgSOSingleObject {
        ::std::default::Default::default()
    }

    // optional int32 type_id = 2;

    pub fn type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }

    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // optional bytes object_data = 3;

    pub fn object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_object_data(&mut self) {
        self.object_data = ::std::option::Option::None;
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 version = 4;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 6;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOSingleObject {
    const NAME: &'static str = "CMsgSOSingleObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.type_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                33 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                48 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.object_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.object_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOSingleObject {
        CMsgSOSingleObject::new()
    }

    fn clear(&mut self) {
        self.type_id = ::std::option::Option::None;
        self.object_data = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOSingleObject {
        static instance: CMsgSOSingleObject = CMsgSOSingleObject {
            type_id: ::std::option::Option::None,
            object_data: ::std::option::Option::None,
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOMultipleObjects)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOMultipleObjects {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.objects_modified)
    pub objects_modified: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.objects_added)
    pub objects_added: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.objects_removed)
    pub objects_removed: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.service_id)
    pub service_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOMultipleObjects {
    fn default() -> &'a CMsgSOMultipleObjects {
        <CMsgSOMultipleObjects as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOMultipleObjects {
    pub fn new() -> CMsgSOMultipleObjects {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 7;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOMultipleObjects {
    const NAME: &'static str = "CMsgSOMultipleObjects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects_modified.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.objects_added.push(is.read_message()?);
                },
                42 => {
                    self.objects_removed.push(is.read_message()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                56 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects_modified {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        for value in &self.objects_added {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.objects_removed {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.objects_modified {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        for v in &self.objects_added {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.objects_removed {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOMultipleObjects {
        CMsgSOMultipleObjects::new()
    }

    fn clear(&mut self) {
        self.objects_modified.clear();
        self.version = ::std::option::Option::None;
        self.objects_added.clear();
        self.objects_removed.clear();
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOMultipleObjects {
        static instance: CMsgSOMultipleObjects = CMsgSOMultipleObjects {
            objects_modified: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            objects_added: ::std::vec::Vec::new(),
            objects_removed: ::std::vec::Vec::new(),
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSOMultipleObjects`
pub mod cmsg_somultiple_objects {
    // @@protoc_insertion_point(message:CMsgSOMultipleObjects.SingleObject)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleObject {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.object_data)
        pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.SingleObject.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleObject {
        fn default() -> &'a SingleObject {
            <SingleObject as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleObject {
        pub fn new() -> SingleObject {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        // optional bytes object_data = 2;

        pub fn object_data(&self) -> &[u8] {
            match self.object_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_object_data(&mut self) {
            self.object_data = ::std::option::Option::None;
        }

        pub fn has_object_data(&self) -> bool {
            self.object_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.object_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.object_data.is_none() {
                self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.object_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
            self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleObject {
        const NAME: &'static str = "SingleObject";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.object_data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.object_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleObject {
            SingleObject::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleObject {
            static instance: SingleObject = SingleObject {
                type_id: ::std::option::Option::None,
                object_data: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.objects)
    pub objects: ::std::vec::Vec<cmsg_socache_subscribed::SubscribedType>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribed {
    fn default() -> &'a CMsgSOCacheSubscribed {
        <CMsgSOCacheSubscribed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribed {
    pub fn new() -> CMsgSOCacheSubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 5;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 7;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheSubscribed {
    const NAME: &'static str = "CMsgSOCacheSubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                40 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                48 => {
                    self.service_list.push(is.read_uint32()?);
                },
                57 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.service_list {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.objects {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(5, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribed {
        CMsgSOCacheSubscribed::new()
    }

    fn clear(&mut self) {
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribed {
        static instance: CMsgSOCacheSubscribed = CMsgSOCacheSubscribed {
            objects: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSOCacheSubscribed`
pub mod cmsg_socache_subscribed {
    // @@protoc_insertion_point(message:CMsgSOCacheSubscribed.SubscribedType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubscribedType {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.object_data)
        pub object_data: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.SubscribedType.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubscribedType {
        fn default() -> &'a SubscribedType {
            <SubscribedType as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SubscribedType {
        pub fn new() -> SubscribedType {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SubscribedType {
        const NAME: &'static str = "SubscribedType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data.push(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            for value in &self.object_data {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            for v in &self.object_data {
                os.write_bytes(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubscribedType {
            SubscribedType::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubscribedType {
            static instance: SubscribedType = SubscribedType {
                type_id: ::std::option::Option::None,
                object_data: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscribedUpToDate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribedUpToDate {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribedUpToDate.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribedUpToDate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribedUpToDate {
    fn default() -> &'a CMsgSOCacheSubscribedUpToDate {
        <CMsgSOCacheSubscribedUpToDate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribedUpToDate {
    pub fn new() -> CMsgSOCacheSubscribedUpToDate {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 3;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 5;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheSubscribedUpToDate {
    const NAME: &'static str = "CMsgSOCacheSubscribedUpToDate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                24 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                32 => {
                    self.service_list.push(is.read_uint32()?);
                },
                41 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.service_list {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribedUpToDate {
        CMsgSOCacheSubscribedUpToDate::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribedUpToDate {
        static instance: CMsgSOCacheSubscribedUpToDate = CMsgSOCacheSubscribedUpToDate {
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheUnsubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheUnsubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheUnsubscribed.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheUnsubscribed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheUnsubscribed {
    fn default() -> &'a CMsgSOCacheUnsubscribed {
        <CMsgSOCacheUnsubscribed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheUnsubscribed {
    pub fn new() -> CMsgSOCacheUnsubscribed {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheUnsubscribed {
    const NAME: &'static str = "CMsgSOCacheUnsubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheUnsubscribed {
        CMsgSOCacheUnsubscribed::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheUnsubscribed {
        static instance: CMsgSOCacheUnsubscribed = CMsgSOCacheUnsubscribed {
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionCheck {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.service_list)
    pub service_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionCheck.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionCheck {
    fn default() -> &'a CMsgSOCacheSubscriptionCheck {
        <CMsgSOCacheSubscriptionCheck as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionCheck {
    pub fn new() -> CMsgSOCacheSubscriptionCheck {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 4;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 6;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheSubscriptionCheck {
    const NAME: &'static str = "CMsgSOCacheSubscriptionCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                32 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.service_list)?;
                },
                40 => {
                    self.service_list.push(is.read_uint32()?);
                },
                49 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.service_list {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(4, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionCheck {
        CMsgSOCacheSubscriptionCheck::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionCheck {
        static instance: CMsgSOCacheSubscriptionCheck = CMsgSOCacheSubscriptionCheck {
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            service_id: ::std::option::Option::None,
            service_list: ::std::vec::Vec::new(),
            sync_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionRefresh {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionRefresh.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionRefresh.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionRefresh {
    fn default() -> &'a CMsgSOCacheSubscriptionRefresh {
        <CMsgSOCacheSubscriptionRefresh as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionRefresh {
    pub fn new() -> CMsgSOCacheSubscriptionRefresh {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheSubscriptionRefresh {
    const NAME: &'static str = "CMsgSOCacheSubscriptionRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionRefresh {
        CMsgSOCacheSubscriptionRefresh::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionRefresh {
        static instance: CMsgSOCacheSubscriptionRefresh = CMsgSOCacheSubscriptionRefresh {
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheVersion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheVersion {
    fn default() -> &'a CMsgSOCacheVersion {
        <CMsgSOCacheVersion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheVersion {
    pub fn new() -> CMsgSOCacheVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheVersion {
    const NAME: &'static str = "CMsgSOCacheVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheVersion {
        CMsgSOCacheVersion::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheVersion {
        static instance: CMsgSOCacheVersion = CMsgSOCacheVersion {
            version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMultiplexMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMultiplexMessage {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.steamids)
    pub steamids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMultiplexMessage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage {
    fn default() -> &'a CMsgGCMultiplexMessage {
        <CMsgGCMultiplexMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage {
    pub fn new() -> CMsgGCMultiplexMessage {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMultiplexMessage {
    const NAME: &'static str = "CMsgGCMultiplexMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamids)?;
                },
                25 => {
                    self.steamids.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += 9 * self.steamids.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMultiplexMessage {
        CMsgGCMultiplexMessage::new()
    }

    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage {
        static instance: CMsgGCMultiplexMessage = CMsgGCMultiplexMessage {
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCSubGCStarting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSubGCStarting {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSubGCStarting.dir_index)
    pub dir_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSubGCStarting.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSubGCStarting {
    fn default() -> &'a CMsgGCToGCSubGCStarting {
        <CMsgGCToGCSubGCStarting as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSubGCStarting {
    pub fn new() -> CMsgGCToGCSubGCStarting {
        ::std::default::Default::default()
    }

    // optional int32 dir_index = 1;

    pub fn dir_index(&self) -> i32 {
        self.dir_index.unwrap_or(-1i32)
    }

    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: i32) {
        self.dir_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCSubGCStarting {
    const NAME: &'static str = "CMsgGCToGCSubGCStarting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dir_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSubGCStarting {
        CMsgGCToGCSubGCStarting::new()
    }

    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSubGCStarting {
        static instance: CMsgGCToGCSubGCStarting = CMsgGCToGCSubGCStarting {
            dir_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.dir_index)
    pub dir_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.machine_name)
    pub machine_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.process_name)
    pub process_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.directory)
    pub directory: ::std::vec::Vec<cgcto_gcmsg_master_ack::Process>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck {
    fn default() -> &'a CGCToGCMsgMasterAck {
        <CGCToGCMsgMasterAck as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck {
    pub fn new() -> CGCToGCMsgMasterAck {
        ::std::default::Default::default()
    }

    // optional int32 dir_index = 1;

    pub fn dir_index(&self) -> i32 {
        self.dir_index.unwrap_or(-1i32)
    }

    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: i32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 3;

    pub fn machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name = ::std::option::Option::None;
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string process_name = 4;

    pub fn process_name(&self) -> &str {
        match self.process_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_process_name(&mut self) {
        self.process_name = ::std::option::Option::None;
    }

    pub fn has_process_name(&self) -> bool {
        self.process_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_name(&mut self, v: ::std::string::String) {
        self.process_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process_name(&mut self) -> &mut ::std::string::String {
        if self.process_name.is_none() {
            self.process_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.process_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_process_name(&mut self) -> ::std::string::String {
        self.process_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgMasterAck {
    const NAME: &'static str = "CGCToGCMsgMasterAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.machine_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.process_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.directory.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.process_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        for value in &self.directory {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dir_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.process_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.directory {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck {
        CGCToGCMsgMasterAck::new()
    }

    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.machine_name = ::std::option::Option::None;
        self.process_name = ::std::option::Option::None;
        self.directory.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck {
        static instance: CGCToGCMsgMasterAck = CGCToGCMsgMasterAck {
            dir_index: ::std::option::Option::None,
            machine_name: ::std::option::Option::None,
            process_name: ::std::option::Option::None,
            directory: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGCToGCMsgMasterAck`
pub mod cgcto_gcmsg_master_ack {
    // @@protoc_insertion_point(message:CGCToGCMsgMasterAck.Process)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Process {
        // message fields
        // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.Process.dir_index)
        pub dir_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.Process.type_instances)
        pub type_instances: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck.Process.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Process {
        fn default() -> &'a Process {
            <Process as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Process {
        pub fn new() -> Process {
            ::std::default::Default::default()
        }

        // optional int32 dir_index = 1;

        pub fn dir_index(&self) -> i32 {
            self.dir_index.unwrap_or(-1i32)
        }

        pub fn clear_dir_index(&mut self) {
            self.dir_index = ::std::option::Option::None;
        }

        pub fn has_dir_index(&self) -> bool {
            self.dir_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dir_index(&mut self, v: i32) {
            self.dir_index = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Process {
        const NAME: &'static str = "Process";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.type_instances)?;
                    },
                    16 => {
                        self.type_instances.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dir_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            for value in &self.type_instances {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.dir_index {
                os.write_int32(1, v)?;
            }
            for v in &self.type_instances {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Process {
            Process::new()
        }

        fn clear(&mut self) {
            self.dir_index = ::std::option::Option::None;
            self.type_instances.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Process {
            static instance: Process = Process {
                dir_index: ::std::option::Option::None,
                type_instances: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck_Response {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck_Response.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck_Response {
    fn default() -> &'a CGCToGCMsgMasterAck_Response {
        <CGCToGCMsgMasterAck_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck_Response {
    pub fn new() -> CGCToGCMsgMasterAck_Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgMasterAck_Response {
    const NAME: &'static str = "CGCToGCMsgMasterAck_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck_Response {
        CGCToGCMsgMasterAck_Response::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck_Response {
        static instance: CGCToGCMsgMasterAck_Response = CGCToGCMsgMasterAck_Response {
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCUniverseStartup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUniverseStartup {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCUniverseStartup.is_initial_startup)
    pub is_initial_startup: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCUniverseStartup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUniverseStartup {
    fn default() -> &'a CMsgGCToGCUniverseStartup {
        <CMsgGCToGCUniverseStartup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUniverseStartup {
    pub fn new() -> CMsgGCToGCUniverseStartup {
        ::std::default::Default::default()
    }

    // optional bool is_initial_startup = 1;

    pub fn is_initial_startup(&self) -> bool {
        self.is_initial_startup.unwrap_or(false)
    }

    pub fn clear_is_initial_startup(&mut self) {
        self.is_initial_startup = ::std::option::Option::None;
    }

    pub fn has_is_initial_startup(&self) -> bool {
        self.is_initial_startup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_initial_startup(&mut self, v: bool) {
        self.is_initial_startup = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCUniverseStartup {
    const NAME: &'static str = "CMsgGCToGCUniverseStartup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_initial_startup = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_initial_startup {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.is_initial_startup {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUniverseStartup {
        CMsgGCToGCUniverseStartup::new()
    }

    fn clear(&mut self) {
        self.is_initial_startup = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUniverseStartup {
        static instance: CMsgGCToGCUniverseStartup = CMsgGCToGCUniverseStartup {
            is_initial_startup: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCUniverseStartupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUniverseStartupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCUniverseStartupResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCUniverseStartupResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUniverseStartupResponse {
    fn default() -> &'a CMsgGCToGCUniverseStartupResponse {
        <CMsgGCToGCUniverseStartupResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUniverseStartupResponse {
    pub fn new() -> CMsgGCToGCUniverseStartupResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCUniverseStartupResponse {
    const NAME: &'static str = "CMsgGCToGCUniverseStartupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUniverseStartupResponse {
        CMsgGCToGCUniverseStartupResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUniverseStartupResponse {
        static instance: CMsgGCToGCUniverseStartupResponse = CMsgGCToGCUniverseStartupResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterStartupComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterStartupComplete {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterStartupComplete.gc_info)
    pub gc_info: ::std::vec::Vec<cgcto_gcmsg_master_startup_complete::GCInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterStartupComplete.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterStartupComplete {
    fn default() -> &'a CGCToGCMsgMasterStartupComplete {
        <CGCToGCMsgMasterStartupComplete as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterStartupComplete {
    pub fn new() -> CGCToGCMsgMasterStartupComplete {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgMasterStartupComplete {
    const NAME: &'static str = "CGCToGCMsgMasterStartupComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gc_info.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gc_info {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.gc_info {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterStartupComplete {
        CGCToGCMsgMasterStartupComplete::new()
    }

    fn clear(&mut self) {
        self.gc_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterStartupComplete {
        static instance: CGCToGCMsgMasterStartupComplete = CGCToGCMsgMasterStartupComplete {
            gc_info: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGCToGCMsgMasterStartupComplete`
pub mod cgcto_gcmsg_master_startup_complete {
    // @@protoc_insertion_point(message:CGCToGCMsgMasterStartupComplete.GCInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GCInfo {
        // message fields
        // @@protoc_insertion_point(field:CGCToGCMsgMasterStartupComplete.GCInfo.dir_index)
        pub dir_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CGCToGCMsgMasterStartupComplete.GCInfo.machine_name)
        pub machine_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CGCToGCMsgMasterStartupComplete.GCInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GCInfo {
        fn default() -> &'a GCInfo {
            <GCInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GCInfo {
        pub fn new() -> GCInfo {
            ::std::default::Default::default()
        }

        // optional int32 dir_index = 1;

        pub fn dir_index(&self) -> i32 {
            self.dir_index.unwrap_or(-1i32)
        }

        pub fn clear_dir_index(&mut self) {
            self.dir_index = ::std::option::Option::None;
        }

        pub fn has_dir_index(&self) -> bool {
            self.dir_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dir_index(&mut self, v: i32) {
            self.dir_index = ::std::option::Option::Some(v);
        }

        // optional string machine_name = 2;

        pub fn machine_name(&self) -> &str {
            match self.machine_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_machine_name(&mut self) {
            self.machine_name = ::std::option::Option::None;
        }

        pub fn has_machine_name(&self) -> bool {
            self.machine_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_machine_name(&mut self, v: ::std::string::String) {
            self.machine_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
            if self.machine_name.is_none() {
                self.machine_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.machine_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_machine_name(&mut self) -> ::std::string::String {
            self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GCInfo {
        const NAME: &'static str = "GCInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dir_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.machine_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dir_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.machine_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.dir_index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.machine_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GCInfo {
            GCInfo::new()
        }

        fn clear(&mut self) {
            self.dir_index = ::std::option::Option::None;
            self.machine_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GCInfo {
            static instance: GCInfo = GCInfo {
                dir_index: ::std::option::Option::None,
                machine_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgRouted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRouted {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRouted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRouted {
    fn default() -> &'a CGCToGCMsgRouted {
        <CGCToGCMsgRouted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRouted {
    pub fn new() -> CGCToGCMsgRouted {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 3;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgRouted {
    const NAME: &'static str = "CGCToGCMsgRouted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRouted {
        CGCToGCMsgRouted::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRouted {
        static instance: CGCToGCMsgRouted = CGCToGCMsgRouted {
            msg_type: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgRoutedReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRoutedReply {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRoutedReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRoutedReply {
    fn default() -> &'a CGCToGCMsgRoutedReply {
        <CGCToGCMsgRoutedReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRoutedReply {
    pub fn new() -> CGCToGCMsgRoutedReply {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 2;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgRoutedReply {
    const NAME: &'static str = "CGCToGCMsgRoutedReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRoutedReply {
        CGCToGCMsgRoutedReply::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRoutedReply {
        static instance: CGCToGCMsgRoutedReply = CGCToGCMsgRoutedReply {
            msg_type: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCUpdateSubGCSessionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCUpdateSubGCSessionInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.updates)
    pub updates: ::std::vec::Vec<cmsg_gcupdate_sub_gcsession_info::CMsgUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCUpdateSubGCSessionInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCUpdateSubGCSessionInfo {
    fn default() -> &'a CMsgGCUpdateSubGCSessionInfo {
        <CMsgGCUpdateSubGCSessionInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCUpdateSubGCSessionInfo {
    pub fn new() -> CMsgGCUpdateSubGCSessionInfo {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCUpdateSubGCSessionInfo {
    const NAME: &'static str = "CMsgGCUpdateSubGCSessionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.updates.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.updates {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.updates {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCUpdateSubGCSessionInfo {
        CMsgGCUpdateSubGCSessionInfo::new()
    }

    fn clear(&mut self) {
        self.updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCUpdateSubGCSessionInfo {
        static instance: CMsgGCUpdateSubGCSessionInfo = CMsgGCUpdateSubGCSessionInfo {
            updates: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCUpdateSubGCSessionInfo`
pub mod cmsg_gcupdate_sub_gcsession_info {
    // @@protoc_insertion_point(message:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgUpdate {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.ip)
        pub ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.trusted)
        pub trusted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgUpdate {
        fn default() -> &'a CMsgUpdate {
            <CMsgUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CMsgUpdate {
        pub fn new() -> CMsgUpdate {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional fixed32 ip = 2;

        pub fn ip(&self) -> u32 {
            self.ip.unwrap_or(0)
        }

        pub fn clear_ip(&mut self) {
            self.ip = ::std::option::Option::None;
        }

        pub fn has_ip(&self) -> bool {
            self.ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip(&mut self, v: u32) {
            self.ip = ::std::option::Option::Some(v);
        }

        // optional bool trusted = 3;

        pub fn trusted(&self) -> bool {
            self.trusted.unwrap_or(false)
        }

        pub fn clear_trusted(&mut self) {
            self.trusted = ::std::option::Option::None;
        }

        pub fn has_trusted(&self) -> bool {
            self.trusted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trusted(&mut self, v: bool) {
            self.trusted = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CMsgUpdate {
        const NAME: &'static str = "CMsgUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    21 => {
                        self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.trusted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.ip {
                my_size += 1 + 4;
            }
            if let Some(v) = self.trusted {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.ip {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.trusted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgUpdate {
            CMsgUpdate::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.ip = ::std::option::Option::None;
            self.trusted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgUpdate {
            static instance: CMsgUpdate = CMsgUpdate {
                steamid: ::std::option::Option::None,
                ip: ::std::option::Option::None,
                trusted: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestSubGCSessionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSubGCSessionInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfo.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSubGCSessionInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfo {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfo {
        <CMsgGCRequestSubGCSessionInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfo {
    pub fn new() -> CMsgGCRequestSubGCSessionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestSubGCSessionInfo {
    const NAME: &'static str = "CMsgGCRequestSubGCSessionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSubGCSessionInfo {
        CMsgGCRequestSubGCSessionInfo::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfo {
        static instance: CMsgGCRequestSubGCSessionInfo = CMsgGCRequestSubGCSessionInfo {
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestSubGCSessionInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSubGCSessionInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfoResponse.ip)
    pub ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfoResponse.trusted)
    pub trusted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfoResponse.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestSubGCSessionInfoResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSubGCSessionInfoResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfoResponse {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfoResponse {
        <CMsgGCRequestSubGCSessionInfoResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfoResponse {
    pub fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ip = 1;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional bool trusted = 2;

    pub fn trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }

    pub fn clear_trusted(&mut self) {
        self.trusted = ::std::option::Option::None;
    }

    pub fn has_trusted(&self) -> bool {
        self.trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = ::std::option::Option::Some(v);
    }

    // optional uint32 port = 3;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional bool success = 4;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestSubGCSessionInfoResponse {
    const NAME: &'static str = "CMsgGCRequestSubGCSessionInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.trusted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.trusted {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.success {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        CMsgGCRequestSubGCSessionInfoResponse::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.trusted = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfoResponse {
        static instance: CMsgGCRequestSubGCSessionInfoResponse = CMsgGCRequestSubGCSessionInfoResponse {
            ip: ::std::option::Option::None,
            trusted: ::std::option::Option::None,
            port: ::std::option::Option::None,
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheHaveVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheHaveVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.soid)
    pub soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.service_id)
    pub service_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.cached_file_version)
    pub cached_file_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheHaveVersion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheHaveVersion {
    fn default() -> &'a CMsgSOCacheHaveVersion {
        <CMsgSOCacheHaveVersion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheHaveVersion {
    pub fn new() -> CMsgSOCacheHaveVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 3;

    pub fn service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }

    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cached_file_version = 4;

    pub fn cached_file_version(&self) -> u32 {
        self.cached_file_version.unwrap_or(0)
    }

    pub fn clear_cached_file_version(&mut self) {
        self.cached_file_version = ::std::option::Option::None;
    }

    pub fn has_cached_file_version(&self) -> bool {
        self.cached_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cached_file_version(&mut self, v: u32) {
        self.cached_file_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheHaveVersion {
    const NAME: &'static str = "CMsgSOCacheHaveVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.soid)?;
                },
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.cached_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.service_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.cached_file_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.cached_file_version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheHaveVersion {
        CMsgSOCacheHaveVersion::new()
    }

    fn clear(&mut self) {
        self.soid.clear();
        self.version = ::std::option::Option::None;
        self.service_id = ::std::option::Option::None;
        self.cached_file_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheHaveVersion {
        static instance: CMsgSOCacheHaveVersion = CMsgSOCacheHaveVersion {
            soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            version: ::std::option::Option::None,
            service_id: ::std::option::Option::None,
            cached_file_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientHello.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.socache_have_versions)
    pub socache_have_versions: ::std::vec::Vec<CMsgSOCacheHaveVersion>,
    // @@protoc_insertion_point(field:CMsgClientHello.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.client_launcher)
    pub client_launcher: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<PartnerAccountType>>,
    // @@protoc_insertion_point(field:CMsgClientHello.secret_key)
    pub secret_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientHello.client_language)
    pub client_language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.engine)
    pub engine: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ESourceEngine>>,
    // @@protoc_insertion_point(field:CMsgClientHello.steamdatagram_login)
    pub steamdatagram_login: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientHello.platform_id)
    pub platform_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.game_msg)
    pub game_msg: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientHello.os_type)
    pub os_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientHello.render_system)
    pub render_system: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.render_system_req)
    pub render_system_req: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.screen_width)
    pub screen_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.screen_height)
    pub screen_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.screen_refresh)
    pub screen_refresh: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.render_width)
    pub render_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.render_height)
    pub render_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.swap_width)
    pub swap_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.swap_height)
    pub swap_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.is_steam_china)
    pub is_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientHello.is_steam_china_client)
    pub is_steam_china_client: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientHello.platform_name)
    pub platform_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientHello.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHello {
    fn default() -> &'a CMsgClientHello {
        <CMsgClientHello as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHello {
    pub fn new() -> CMsgClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 client_session_need = 3;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional .PartnerAccountType client_launcher = 4;

    pub fn client_launcher(&self) -> PartnerAccountType {
        match self.client_launcher {
            Some(e) => e.enum_value_or(PartnerAccountType::PARTNER_NONE),
            None => PartnerAccountType::PARTNER_NONE,
        }
    }

    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: PartnerAccountType) {
        self.client_launcher = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string secret_key = 5;

    pub fn secret_key(&self) -> &str {
        match self.secret_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secret_key(&mut self) {
        self.secret_key = ::std::option::Option::None;
    }

    pub fn has_secret_key(&self) -> bool {
        self.secret_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret_key(&mut self, v: ::std::string::String) {
        self.secret_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret_key(&mut self) -> &mut ::std::string::String {
        if self.secret_key.is_none() {
            self.secret_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secret_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret_key(&mut self) -> ::std::string::String {
        self.secret_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_language = 6;

    pub fn client_language(&self) -> u32 {
        self.client_language.unwrap_or(0)
    }

    pub fn clear_client_language(&mut self) {
        self.client_language = ::std::option::Option::None;
    }

    pub fn has_client_language(&self) -> bool {
        self.client_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_language(&mut self, v: u32) {
        self.client_language = ::std::option::Option::Some(v);
    }

    // optional .ESourceEngine engine = 7;

    pub fn engine(&self) -> ESourceEngine {
        match self.engine {
            Some(e) => e.enum_value_or(ESourceEngine::k_ESE_Source1),
            None => ESourceEngine::k_ESE_Source1,
        }
    }

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: ESourceEngine) {
        self.engine = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes steamdatagram_login = 8;

    pub fn steamdatagram_login(&self) -> &[u8] {
        match self.steamdatagram_login.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_steamdatagram_login(&mut self) {
        self.steamdatagram_login = ::std::option::Option::None;
    }

    pub fn has_steamdatagram_login(&self) -> bool {
        self.steamdatagram_login.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamdatagram_login(&mut self, v: ::std::vec::Vec<u8>) {
        self.steamdatagram_login = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamdatagram_login(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.steamdatagram_login.is_none() {
            self.steamdatagram_login = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.steamdatagram_login.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamdatagram_login(&mut self) -> ::std::vec::Vec<u8> {
        self.steamdatagram_login.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 platform_id = 9;

    pub fn platform_id(&self) -> u32 {
        self.platform_id.unwrap_or(0)
    }

    pub fn clear_platform_id(&mut self) {
        self.platform_id = ::std::option::Option::None;
    }

    pub fn has_platform_id(&self) -> bool {
        self.platform_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_id(&mut self, v: u32) {
        self.platform_id = ::std::option::Option::Some(v);
    }

    // optional bytes game_msg = 10;

    pub fn game_msg(&self) -> &[u8] {
        match self.game_msg.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_msg(&mut self) {
        self.game_msg = ::std::option::Option::None;
    }

    pub fn has_game_msg(&self) -> bool {
        self.game_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_msg.is_none() {
            self.game_msg = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_msg(&mut self) -> ::std::vec::Vec<u8> {
        self.game_msg.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 os_type = 11;

    pub fn os_type(&self) -> i32 {
        self.os_type.unwrap_or(0)
    }

    pub fn clear_os_type(&mut self) {
        self.os_type = ::std::option::Option::None;
    }

    pub fn has_os_type(&self) -> bool {
        self.os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_type(&mut self, v: i32) {
        self.os_type = ::std::option::Option::Some(v);
    }

    // optional uint32 render_system = 12;

    pub fn render_system(&self) -> u32 {
        self.render_system.unwrap_or(0)
    }

    pub fn clear_render_system(&mut self) {
        self.render_system = ::std::option::Option::None;
    }

    pub fn has_render_system(&self) -> bool {
        self.render_system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_system(&mut self, v: u32) {
        self.render_system = ::std::option::Option::Some(v);
    }

    // optional uint32 render_system_req = 13;

    pub fn render_system_req(&self) -> u32 {
        self.render_system_req.unwrap_or(0)
    }

    pub fn clear_render_system_req(&mut self) {
        self.render_system_req = ::std::option::Option::None;
    }

    pub fn has_render_system_req(&self) -> bool {
        self.render_system_req.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_system_req(&mut self, v: u32) {
        self.render_system_req = ::std::option::Option::Some(v);
    }

    // optional uint32 screen_width = 14;

    pub fn screen_width(&self) -> u32 {
        self.screen_width.unwrap_or(0)
    }

    pub fn clear_screen_width(&mut self) {
        self.screen_width = ::std::option::Option::None;
    }

    pub fn has_screen_width(&self) -> bool {
        self.screen_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_width(&mut self, v: u32) {
        self.screen_width = ::std::option::Option::Some(v);
    }

    // optional uint32 screen_height = 15;

    pub fn screen_height(&self) -> u32 {
        self.screen_height.unwrap_or(0)
    }

    pub fn clear_screen_height(&mut self) {
        self.screen_height = ::std::option::Option::None;
    }

    pub fn has_screen_height(&self) -> bool {
        self.screen_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_height(&mut self, v: u32) {
        self.screen_height = ::std::option::Option::Some(v);
    }

    // optional uint32 screen_refresh = 16;

    pub fn screen_refresh(&self) -> u32 {
        self.screen_refresh.unwrap_or(0)
    }

    pub fn clear_screen_refresh(&mut self) {
        self.screen_refresh = ::std::option::Option::None;
    }

    pub fn has_screen_refresh(&self) -> bool {
        self.screen_refresh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_refresh(&mut self, v: u32) {
        self.screen_refresh = ::std::option::Option::Some(v);
    }

    // optional uint32 render_width = 17;

    pub fn render_width(&self) -> u32 {
        self.render_width.unwrap_or(0)
    }

    pub fn clear_render_width(&mut self) {
        self.render_width = ::std::option::Option::None;
    }

    pub fn has_render_width(&self) -> bool {
        self.render_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_width(&mut self, v: u32) {
        self.render_width = ::std::option::Option::Some(v);
    }

    // optional uint32 render_height = 18;

    pub fn render_height(&self) -> u32 {
        self.render_height.unwrap_or(0)
    }

    pub fn clear_render_height(&mut self) {
        self.render_height = ::std::option::Option::None;
    }

    pub fn has_render_height(&self) -> bool {
        self.render_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_height(&mut self, v: u32) {
        self.render_height = ::std::option::Option::Some(v);
    }

    // optional uint32 swap_width = 19;

    pub fn swap_width(&self) -> u32 {
        self.swap_width.unwrap_or(0)
    }

    pub fn clear_swap_width(&mut self) {
        self.swap_width = ::std::option::Option::None;
    }

    pub fn has_swap_width(&self) -> bool {
        self.swap_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap_width(&mut self, v: u32) {
        self.swap_width = ::std::option::Option::Some(v);
    }

    // optional uint32 swap_height = 20;

    pub fn swap_height(&self) -> u32 {
        self.swap_height.unwrap_or(0)
    }

    pub fn clear_swap_height(&mut self) {
        self.swap_height = ::std::option::Option::None;
    }

    pub fn has_swap_height(&self) -> bool {
        self.swap_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap_height(&mut self, v: u32) {
        self.swap_height = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_china = 22;

    pub fn is_steam_china(&self) -> bool {
        self.is_steam_china.unwrap_or(false)
    }

    pub fn clear_is_steam_china(&mut self) {
        self.is_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_steam_china(&self) -> bool {
        self.is_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_china(&mut self, v: bool) {
        self.is_steam_china = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_china_client = 24;

    pub fn is_steam_china_client(&self) -> bool {
        self.is_steam_china_client.unwrap_or(false)
    }

    pub fn clear_is_steam_china_client(&mut self) {
        self.is_steam_china_client = ::std::option::Option::None;
    }

    pub fn has_is_steam_china_client(&self) -> bool {
        self.is_steam_china_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_china_client(&mut self, v: bool) {
        self.is_steam_china_client = ::std::option::Option::Some(v);
    }

    // optional string platform_name = 23;

    pub fn platform_name(&self) -> &str {
        match self.platform_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_platform_name(&mut self) {
        self.platform_name = ::std::option::Option::None;
    }

    pub fn has_platform_name(&self) -> bool {
        self.platform_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_name(&mut self, v: ::std::string::String) {
        self.platform_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_name(&mut self) -> &mut ::std::string::String {
        if self.platform_name.is_none() {
            self.platform_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.platform_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_name(&mut self) -> ::std::string::String {
        self.platform_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientHello {
    const NAME: &'static str = "CMsgClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.socache_have_versions.push(is.read_message()?);
                },
                24 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_launcher = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.secret_key = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.client_language = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.engine = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                66 => {
                    self.steamdatagram_login = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.platform_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.game_msg = ::std::option::Option::Some(is.read_bytes()?);
                },
                88 => {
                    self.os_type = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.render_system = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.render_system_req = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.screen_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.screen_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.screen_refresh = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.render_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.render_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.swap_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.swap_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.is_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.is_steam_china_client = ::std::option::Option::Some(is.read_bool()?);
                },
                186 => {
                    self.platform_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.socache_have_versions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.client_session_need {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.secret_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.client_language {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.engine {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.platform_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.game_msg.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.os_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.render_system {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.render_system_req {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.screen_width {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.screen_height {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.screen_refresh {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.render_width {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.render_height {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.swap_width {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.swap_height {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.is_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_steam_china_client {
            my_size += 2 + 1;
        }
        if let Some(v) = self.platform_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(23, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.socache_have_versions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.client_session_need {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.secret_key.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.client_language {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.engine {
            os.write_enum(7, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.platform_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.game_msg.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.os_type {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.render_system {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.render_system_req {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.screen_width {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.screen_height {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.screen_refresh {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.render_width {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.render_height {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.swap_width {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.swap_height {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.is_steam_china {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.is_steam_china_client {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.platform_name.as_ref() {
            os.write_string(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHello {
        CMsgClientHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.socache_have_versions.clear();
        self.client_session_need = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.secret_key = ::std::option::Option::None;
        self.client_language = ::std::option::Option::None;
        self.engine = ::std::option::Option::None;
        self.steamdatagram_login = ::std::option::Option::None;
        self.platform_id = ::std::option::Option::None;
        self.game_msg = ::std::option::Option::None;
        self.os_type = ::std::option::Option::None;
        self.render_system = ::std::option::Option::None;
        self.render_system_req = ::std::option::Option::None;
        self.screen_width = ::std::option::Option::None;
        self.screen_height = ::std::option::Option::None;
        self.screen_refresh = ::std::option::Option::None;
        self.render_width = ::std::option::Option::None;
        self.render_height = ::std::option::Option::None;
        self.swap_width = ::std::option::Option::None;
        self.swap_height = ::std::option::Option::None;
        self.is_steam_china = ::std::option::Option::None;
        self.is_steam_china_client = ::std::option::Option::None;
        self.platform_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHello {
        static instance: CMsgClientHello = CMsgClientHello {
            version: ::std::option::Option::None,
            socache_have_versions: ::std::vec::Vec::new(),
            client_session_need: ::std::option::Option::None,
            client_launcher: ::std::option::Option::None,
            secret_key: ::std::option::Option::None,
            client_language: ::std::option::Option::None,
            engine: ::std::option::Option::None,
            steamdatagram_login: ::std::option::Option::None,
            platform_id: ::std::option::Option::None,
            game_msg: ::std::option::Option::None,
            os_type: ::std::option::Option::None,
            render_system: ::std::option::Option::None,
            render_system_req: ::std::option::Option::None,
            screen_width: ::std::option::Option::None,
            screen_height: ::std::option::Option::None,
            screen_refresh: ::std::option::Option::None,
            render_width: ::std::option::Option::None,
            render_height: ::std::option::Option::None,
            swap_width: ::std::option::Option::None,
            swap_height: ::std::option::Option::None,
            is_steam_china: ::std::option::Option::None,
            is_steam_china_client: ::std::option::Option::None,
            platform_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWelcome.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data)
    pub game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.outofdate_subscribed_caches)
    pub outofdate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscribed>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.uptodate_subscribed_caches)
    pub uptodate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscriptionCheck>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.location)
    pub location: ::steam_vent_proto_common::protobuf::MessageField<cmsg_client_welcome::Location>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.save_game_key)
    pub save_game_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.gc_socache_file_version)
    pub gc_socache_file_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.txn_country_code)
    pub txn_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data2)
    pub game_data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.rtime32_gc_welcome_timestamp)
    pub rtime32_gc_welcome_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.balance)
    pub balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.balance_url)
    pub balance_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.has_accepted_china_ssa)
    pub has_accepted_china_ssa: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.is_banned_steam_china)
    pub is_banned_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.additional_welcome_msgs)
    pub additional_welcome_msgs: ::steam_vent_proto_common::protobuf::MessageField<CExtraMsgBlock>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.steam_learn_server_info)
    pub steam_learn_server_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamLearnServerInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWelcome.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWelcome {
    fn default() -> &'a CMsgClientWelcome {
        <CMsgClientWelcome as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWelcome {
    pub fn new() -> CMsgClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;

    pub fn game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes save_game_key = 6;

    pub fn save_game_key(&self) -> &[u8] {
        match self.save_game_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_save_game_key(&mut self) {
        self.save_game_key = ::std::option::Option::None;
    }

    pub fn has_save_game_key(&self) -> bool {
        self.save_game_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_key.is_none() {
            self.save_game_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.save_game_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_key(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 gc_socache_file_version = 9;

    pub fn gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }

    // optional string txn_country_code = 10;

    pub fn txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code = ::std::option::Option::None;
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes game_data2 = 11;

    pub fn game_data2(&self) -> &[u8] {
        match self.game_data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data2(&mut self) {
        self.game_data2 = ::std::option::Option::None;
    }

    pub fn has_game_data2(&self) -> bool {
        self.game_data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data2.is_none() {
            self.game_data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 rtime32_gc_welcome_timestamp = 12;

    pub fn rtime32_gc_welcome_timestamp(&self) -> u32 {
        self.rtime32_gc_welcome_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_gc_welcome_timestamp(&mut self) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_gc_welcome_timestamp(&self) -> bool {
        self.rtime32_gc_welcome_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_gc_welcome_timestamp(&mut self, v: u32) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 13;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional uint32 balance = 14;

    pub fn balance(&self) -> u32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional string balance_url = 15;

    pub fn balance_url(&self) -> &str {
        match self.balance_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_balance_url(&mut self) {
        self.balance_url = ::std::option::Option::None;
    }

    pub fn has_balance_url(&self) -> bool {
        self.balance_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_url(&mut self, v: ::std::string::String) {
        self.balance_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_url(&mut self) -> &mut ::std::string::String {
        if self.balance_url.is_none() {
            self.balance_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.balance_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance_url(&mut self) -> ::std::string::String {
        self.balance_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_accepted_china_ssa = 16;

    pub fn has_accepted_china_ssa(&self) -> bool {
        self.has_accepted_china_ssa.unwrap_or(false)
    }

    pub fn clear_has_accepted_china_ssa(&mut self) {
        self.has_accepted_china_ssa = ::std::option::Option::None;
    }

    pub fn has_has_accepted_china_ssa(&self) -> bool {
        self.has_accepted_china_ssa.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_accepted_china_ssa(&mut self, v: bool) {
        self.has_accepted_china_ssa = ::std::option::Option::Some(v);
    }

    // optional bool is_banned_steam_china = 17;

    pub fn is_banned_steam_china(&self) -> bool {
        self.is_banned_steam_china.unwrap_or(false)
    }

    pub fn clear_is_banned_steam_china(&mut self) {
        self.is_banned_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_banned_steam_china(&self) -> bool {
        self.is_banned_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_banned_steam_china(&mut self, v: bool) {
        self.is_banned_steam_china = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientWelcome {
    const NAME: &'static str = "CMsgClientWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.outofdate_subscribed_caches.push(is.read_message()?);
                },
                34 => {
                    self.uptodate_subscribed_caches.push(is.read_message()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                50 => {
                    self.save_game_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.gc_socache_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.txn_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.game_data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.balance_url = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.has_accepted_china_ssa = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_banned_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.additional_welcome_msgs)?;
                },
                162 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.steam_learn_server_info)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.outofdate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.uptodate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.save_game_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.game_data2.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.balance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.balance_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.has_accepted_china_ssa {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_banned_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.additional_welcome_msgs.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.steam_learn_server_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.outofdate_subscribed_caches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.uptodate_subscribed_caches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.location.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.save_game_key.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.game_data2.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.balance {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.balance_url.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.has_accepted_china_ssa {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_banned_steam_china {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.additional_welcome_msgs.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.steam_learn_server_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWelcome {
        CMsgClientWelcome::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.outofdate_subscribed_caches.clear();
        self.uptodate_subscribed_caches.clear();
        self.location.clear();
        self.save_game_key = ::std::option::Option::None;
        self.gc_socache_file_version = ::std::option::Option::None;
        self.txn_country_code = ::std::option::Option::None;
        self.game_data2 = ::std::option::Option::None;
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.balance_url = ::std::option::Option::None;
        self.has_accepted_china_ssa = ::std::option::Option::None;
        self.is_banned_steam_china = ::std::option::Option::None;
        self.additional_welcome_msgs.clear();
        self.steam_learn_server_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWelcome {
        static instance: CMsgClientWelcome = CMsgClientWelcome {
            version: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            outofdate_subscribed_caches: ::std::vec::Vec::new(),
            uptodate_subscribed_caches: ::std::vec::Vec::new(),
            location: ::steam_vent_proto_common::protobuf::MessageField::none(),
            save_game_key: ::std::option::Option::None,
            gc_socache_file_version: ::std::option::Option::None,
            txn_country_code: ::std::option::Option::None,
            game_data2: ::std::option::Option::None,
            rtime32_gc_welcome_timestamp: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            balance_url: ::std::option::Option::None,
            has_accepted_china_ssa: ::std::option::Option::None,
            is_banned_steam_china: ::std::option::Option::None,
            additional_welcome_msgs: ::steam_vent_proto_common::protobuf::MessageField::none(),
            steam_learn_server_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientWelcome`
pub mod cmsg_client_welcome {
    // @@protoc_insertion_point(message:CMsgClientWelcome.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.latitude)
        pub latitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.longitude)
        pub longitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.country)
        pub country: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWelcome.Location.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional float latitude = 1;

        pub fn latitude(&self) -> f32 {
            self.latitude.unwrap_or(0.)
        }

        pub fn clear_latitude(&mut self) {
            self.latitude = ::std::option::Option::None;
        }

        pub fn has_latitude(&self) -> bool {
            self.latitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_latitude(&mut self, v: f32) {
            self.latitude = ::std::option::Option::Some(v);
        }

        // optional float longitude = 2;

        pub fn longitude(&self) -> f32 {
            self.longitude.unwrap_or(0.)
        }

        pub fn clear_longitude(&mut self) {
            self.longitude = ::std::option::Option::None;
        }

        pub fn has_longitude(&self) -> bool {
            self.longitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_longitude(&mut self, v: f32) {
            self.longitude = ::std::option::Option::Some(v);
        }

        // optional string country = 3;

        pub fn country(&self) -> &str {
            match self.country.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country(&mut self) {
            self.country = ::std::option::Option::None;
        }

        pub fn has_country(&self) -> bool {
            self.country.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country(&mut self, v: ::std::string::String) {
            self.country = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country(&mut self) -> &mut ::std::string::String {
            if self.country.is_none() {
                self.country = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country.as_mut().unwrap()
        }

        // Take field
        pub fn take_country(&mut self) -> ::std::string::String {
            self.country.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.latitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.longitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.country = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.latitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.longitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.country.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.latitude {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.longitude {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.country.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.latitude = ::std::option::Option::None;
            self.longitude = ::std::option::Option::None;
            self.country = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                latitude: ::std::option::Option::None,
                longitude: ::std::option::Option::None,
                country: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgConnectionStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConnectionStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgConnectionStatus.status)
    pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<GCConnectionStatus>>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_size)
    pub queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.wait_seconds)
    pub wait_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.estimated_wait_seconds_remaining)
    pub estimated_wait_seconds_remaining: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConnectionStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConnectionStatus {
    fn default() -> &'a CMsgConnectionStatus {
        <CMsgConnectionStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectionStatus {
    pub fn new() -> CMsgConnectionStatus {
        ::std::default::Default::default()
    }

    // optional .GCConnectionStatus status = 1;

    pub fn status(&self) -> GCConnectionStatus {
        match self.status {
            Some(e) => e.enum_value_or(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            None => GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GCConnectionStatus) {
        self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 client_session_need = 2;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 queue_size = 4;

    pub fn queue_size(&self) -> i32 {
        self.queue_size.unwrap_or(0)
    }

    pub fn clear_queue_size(&mut self) {
        self.queue_size = ::std::option::Option::None;
    }

    pub fn has_queue_size(&self) -> bool {
        self.queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_size(&mut self, v: i32) {
        self.queue_size = ::std::option::Option::Some(v);
    }

    // optional int32 wait_seconds = 5;

    pub fn wait_seconds(&self) -> i32 {
        self.wait_seconds.unwrap_or(0)
    }

    pub fn clear_wait_seconds(&mut self) {
        self.wait_seconds = ::std::option::Option::None;
    }

    pub fn has_wait_seconds(&self) -> bool {
        self.wait_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait_seconds(&mut self, v: i32) {
        self.wait_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 estimated_wait_seconds_remaining = 6;

    pub fn estimated_wait_seconds_remaining(&self) -> i32 {
        self.estimated_wait_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_estimated_wait_seconds_remaining(&mut self) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_estimated_wait_seconds_remaining(&self) -> bool {
        self.estimated_wait_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_wait_seconds_remaining(&mut self, v: i32) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConnectionStatus {
    const NAME: &'static str = "CMsgConnectionStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wait_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.estimated_wait_seconds_remaining = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.client_session_need {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.queue_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.wait_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.client_session_need {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wait_seconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConnectionStatus {
        CMsgConnectionStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.client_session_need = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.queue_size = ::std::option::Option::None;
        self.wait_seconds = ::std::option::Option::None;
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConnectionStatus {
        static instance: CMsgConnectionStatus = CMsgConnectionStatus {
            status: ::std::option::Option::None,
            client_session_need: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            queue_size: ::std::option::Option::None,
            wait_seconds: ::std::option::Option::None,
            estimated_wait_seconds_remaining: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCSOCacheSubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSOCacheSubscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.subscriber)
    pub subscriber: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.subscribe_to_id)
    pub subscribe_to_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.sync_version)
    pub sync_version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.have_versions)
    pub have_versions: ::std::vec::Vec<cmsg_gcto_gcsocache_subscribe::CMsgHaveVersions>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.subscribe_to_type)
    pub subscribe_to_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSOCacheSubscribe.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheSubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheSubscribe {
        <CMsgGCToGCSOCacheSubscribe as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheSubscribe {
    pub fn new() -> CMsgGCToGCSOCacheSubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;

    pub fn subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }

    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 subscribe_to_id = 2;

    pub fn subscribe_to_id(&self) -> u64 {
        self.subscribe_to_id.unwrap_or(0)
    }

    pub fn clear_subscribe_to_id(&mut self) {
        self.subscribe_to_id = ::std::option::Option::None;
    }

    pub fn has_subscribe_to_id(&self) -> bool {
        self.subscribe_to_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe_to_id(&mut self, v: u64) {
        self.subscribe_to_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 3;

    pub fn sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }

    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    // optional uint32 subscribe_to_type = 5;

    pub fn subscribe_to_type(&self) -> u32 {
        self.subscribe_to_type.unwrap_or(0)
    }

    pub fn clear_subscribe_to_type(&mut self) {
        self.subscribe_to_type = ::std::option::Option::None;
    }

    pub fn has_subscribe_to_type(&self) -> bool {
        self.subscribe_to_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe_to_type(&mut self, v: u32) {
        self.subscribe_to_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCSOCacheSubscribe {
    const NAME: &'static str = "CMsgGCToGCSOCacheSubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.subscriber = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.subscribe_to_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.sync_version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.have_versions.push(is.read_message()?);
                },
                40 => {
                    self.subscribe_to_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 1 + 8;
        }
        if let Some(v) = self.subscribe_to_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sync_version {
            my_size += 1 + 8;
        }
        for value in &self.have_versions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.subscribe_to_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.subscribe_to_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sync_version {
            os.write_fixed64(3, v)?;
        }
        for v in &self.have_versions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.subscribe_to_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSOCacheSubscribe {
        CMsgGCToGCSOCacheSubscribe::new()
    }

    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.subscribe_to_id = ::std::option::Option::None;
        self.sync_version = ::std::option::Option::None;
        self.have_versions.clear();
        self.subscribe_to_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheSubscribe {
        static instance: CMsgGCToGCSOCacheSubscribe = CMsgGCToGCSOCacheSubscribe {
            subscriber: ::std::option::Option::None,
            subscribe_to_id: ::std::option::Option::None,
            sync_version: ::std::option::Option::None,
            have_versions: ::std::vec::Vec::new(),
            subscribe_to_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToGCSOCacheSubscribe`
pub mod cmsg_gcto_gcsocache_subscribe {
    // @@protoc_insertion_point(message:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgHaveVersions {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.service_id)
        pub service_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.version)
        pub version: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgHaveVersions {
        fn default() -> &'a CMsgHaveVersions {
            <CMsgHaveVersions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CMsgHaveVersions {
        pub fn new() -> CMsgHaveVersions {
            ::std::default::Default::default()
        }

        // optional uint32 service_id = 1;

        pub fn service_id(&self) -> u32 {
            self.service_id.unwrap_or(0)
        }

        pub fn clear_service_id(&mut self) {
            self.service_id = ::std::option::Option::None;
        }

        pub fn has_service_id(&self) -> bool {
            self.service_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_id(&mut self, v: u32) {
            self.service_id = ::std::option::Option::Some(v);
        }

        // optional uint64 version = 2;

        pub fn version(&self) -> u64 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: u64) {
            self.version = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CMsgHaveVersions {
        const NAME: &'static str = "CMsgHaveVersions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.version = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.service_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.version {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.service_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.version {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgHaveVersions {
            CMsgHaveVersions::new()
        }

        fn clear(&mut self) {
            self.service_id = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgHaveVersions {
            static instance: CMsgHaveVersions = CMsgHaveVersions {
                service_id: ::std::option::Option::None,
                version: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCSOCacheUnsubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSOCacheUnsubscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheUnsubscribe.subscriber)
    pub subscriber: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheUnsubscribe.unsubscribe_from_id)
    pub unsubscribe_from_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCSOCacheUnsubscribe.unsubscribe_from_type)
    pub unsubscribe_from_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSOCacheUnsubscribe.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheUnsubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheUnsubscribe {
        <CMsgGCToGCSOCacheUnsubscribe as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheUnsubscribe {
    pub fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;

    pub fn subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }

    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 unsubscribe_from_id = 2;

    pub fn unsubscribe_from_id(&self) -> u64 {
        self.unsubscribe_from_id.unwrap_or(0)
    }

    pub fn clear_unsubscribe_from_id(&mut self) {
        self.unsubscribe_from_id = ::std::option::Option::None;
    }

    pub fn has_unsubscribe_from_id(&self) -> bool {
        self.unsubscribe_from_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe_from_id(&mut self, v: u64) {
        self.unsubscribe_from_id = ::std::option::Option::Some(v);
    }

    // optional uint32 unsubscribe_from_type = 3;

    pub fn unsubscribe_from_type(&self) -> u32 {
        self.unsubscribe_from_type.unwrap_or(0)
    }

    pub fn clear_unsubscribe_from_type(&mut self) {
        self.unsubscribe_from_type = ::std::option::Option::None;
    }

    pub fn has_unsubscribe_from_type(&self) -> bool {
        self.unsubscribe_from_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe_from_type(&mut self, v: u32) {
        self.unsubscribe_from_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCSOCacheUnsubscribe {
    const NAME: &'static str = "CMsgGCToGCSOCacheUnsubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.subscriber = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.unsubscribe_from_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.unsubscribe_from_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unsubscribe_from_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unsubscribe_from_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unsubscribe_from_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.unsubscribe_from_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        CMsgGCToGCSOCacheUnsubscribe::new()
    }

    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.unsubscribe_from_id = ::std::option::Option::None;
        self.unsubscribe_from_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheUnsubscribe {
        static instance: CMsgGCToGCSOCacheUnsubscribe = CMsgGCToGCSOCacheUnsubscribe {
            subscriber: ::std::option::Option::None,
            unsubscribe_from_id: ::std::option::Option::None,
            unsubscribe_from_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCClientPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientPing {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientPing {
    fn default() -> &'a CMsgGCClientPing {
        <CMsgGCClientPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientPing {
    pub fn new() -> CMsgGCClientPing {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCClientPing {
    const NAME: &'static str = "CMsgGCClientPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientPing {
        CMsgGCClientPing::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientPing {
        static instance: CMsgGCClientPing = CMsgGCClientPing {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCForwardAccountDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCForwardAccountDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCForwardAccountDetails.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCForwardAccountDetails.account_details)
    pub account_details: ::steam_vent_proto_common::protobuf::MessageField<super::steammessages::CGCSystemMsg_GetAccountDetails_Response>,
    // @@protoc_insertion_point(field:CMsgGCToGCForwardAccountDetails.age_seconds)
    pub age_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCForwardAccountDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCForwardAccountDetails {
    fn default() -> &'a CMsgGCToGCForwardAccountDetails {
        <CMsgGCToGCForwardAccountDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCForwardAccountDetails {
    pub fn new() -> CMsgGCToGCForwardAccountDetails {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 age_seconds = 3;

    pub fn age_seconds(&self) -> u32 {
        self.age_seconds.unwrap_or(0)
    }

    pub fn clear_age_seconds(&mut self) {
        self.age_seconds = ::std::option::Option::None;
    }

    pub fn has_age_seconds(&self) -> bool {
        self.age_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_age_seconds(&mut self, v: u32) {
        self.age_seconds = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCForwardAccountDetails {
    const NAME: &'static str = "CMsgGCToGCForwardAccountDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.account_details)?;
                },
                24 => {
                    self.age_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.account_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.age_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.account_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.age_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCForwardAccountDetails {
        CMsgGCToGCForwardAccountDetails::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.account_details.clear();
        self.age_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCForwardAccountDetails {
        static instance: CMsgGCToGCForwardAccountDetails = CMsgGCToGCForwardAccountDetails {
            steamid: ::std::option::Option::None,
            account_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            age_seconds: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCLoadSessionSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCLoadSessionSOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCLoadSessionSOCache.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCLoadSessionSOCache.forward_account_details)
    pub forward_account_details: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToGCForwardAccountDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCLoadSessionSOCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCLoadSessionSOCache {
    fn default() -> &'a CMsgGCToGCLoadSessionSOCache {
        <CMsgGCToGCLoadSessionSOCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCLoadSessionSOCache {
    pub fn new() -> CMsgGCToGCLoadSessionSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCLoadSessionSOCache {
    const NAME: &'static str = "CMsgGCToGCLoadSessionSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.forward_account_details)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.forward_account_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.forward_account_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCLoadSessionSOCache {
        CMsgGCToGCLoadSessionSOCache::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.forward_account_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCLoadSessionSOCache {
        static instance: CMsgGCToGCLoadSessionSOCache = CMsgGCToGCLoadSessionSOCache {
            account_id: ::std::option::Option::None,
            forward_account_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCLoadSessionSOCacheResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCLoadSessionSOCacheResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCLoadSessionSOCacheResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCLoadSessionSOCacheResponse {
    fn default() -> &'a CMsgGCToGCLoadSessionSOCacheResponse {
        <CMsgGCToGCLoadSessionSOCacheResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCLoadSessionSOCacheResponse {
    pub fn new() -> CMsgGCToGCLoadSessionSOCacheResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCLoadSessionSOCacheResponse {
    const NAME: &'static str = "CMsgGCToGCLoadSessionSOCacheResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCLoadSessionSOCacheResponse {
        CMsgGCToGCLoadSessionSOCacheResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCLoadSessionSOCacheResponse {
        static instance: CMsgGCToGCLoadSessionSOCacheResponse = CMsgGCToGCLoadSessionSOCacheResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCUpdateSessionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateSessionStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateSessionStats.user_sessions)
    pub user_sessions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateSessionStats.server_sessions)
    pub server_sessions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateSessionStats.in_logon_surge)
    pub in_logon_surge: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCUpdateSessionStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSessionStats {
    fn default() -> &'a CMsgGCToGCUpdateSessionStats {
        <CMsgGCToGCUpdateSessionStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSessionStats {
    pub fn new() -> CMsgGCToGCUpdateSessionStats {
        ::std::default::Default::default()
    }

    // optional uint32 user_sessions = 1;

    pub fn user_sessions(&self) -> u32 {
        self.user_sessions.unwrap_or(0)
    }

    pub fn clear_user_sessions(&mut self) {
        self.user_sessions = ::std::option::Option::None;
    }

    pub fn has_user_sessions(&self) -> bool {
        self.user_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_sessions(&mut self, v: u32) {
        self.user_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 server_sessions = 2;

    pub fn server_sessions(&self) -> u32 {
        self.server_sessions.unwrap_or(0)
    }

    pub fn clear_server_sessions(&mut self) {
        self.server_sessions = ::std::option::Option::None;
    }

    pub fn has_server_sessions(&self) -> bool {
        self.server_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_sessions(&mut self, v: u32) {
        self.server_sessions = ::std::option::Option::Some(v);
    }

    // optional bool in_logon_surge = 3;

    pub fn in_logon_surge(&self) -> bool {
        self.in_logon_surge.unwrap_or(false)
    }

    pub fn clear_in_logon_surge(&mut self) {
        self.in_logon_surge = ::std::option::Option::None;
    }

    pub fn has_in_logon_surge(&self) -> bool {
        self.in_logon_surge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_logon_surge(&mut self, v: bool) {
        self.in_logon_surge = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCUpdateSessionStats {
    const NAME: &'static str = "CMsgGCToGCUpdateSessionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_sessions = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.server_sessions = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.in_logon_surge = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_sessions {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.server_sessions {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.in_logon_surge {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.user_sessions {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_sessions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_logon_surge {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateSessionStats {
        CMsgGCToGCUpdateSessionStats::new()
    }

    fn clear(&mut self) {
        self.user_sessions = ::std::option::Option::None;
        self.server_sessions = ::std::option::Option::None;
        self.in_logon_surge = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSessionStats {
        static instance: CMsgGCToGCUpdateSessionStats = CMsgGCToGCUpdateSessionStats {
            user_sessions: ::std::option::Option::None,
            server_sessions: ::std::option::Option::None,
            in_logon_surge: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRequestDropped)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestDropped {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRequestDropped.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestDropped {
    fn default() -> &'a CMsgGCToClientRequestDropped {
        <CMsgGCToClientRequestDropped as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestDropped {
    pub fn new() -> CMsgGCToClientRequestDropped {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRequestDropped {
    const NAME: &'static str = "CMsgGCToClientRequestDropped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestDropped {
        CMsgGCToClientRequestDropped::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestDropped {
        static instance: CMsgGCToClientRequestDropped = CMsgGCToClientRequestDropped {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_PopulateItemDescriptions_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.languages)
    pub languages: ::std::vec::Vec<cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request {
        <CWorkshop_PopulateItemDescriptions_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request {
    const NAME: &'static str = "CWorkshop_PopulateItemDescriptions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        CWorkshop_PopulateItemDescriptions_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request {
        static instance: CWorkshop_PopulateItemDescriptions_Request = CWorkshop_PopulateItemDescriptions_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_PopulateItemDescriptions_Request`
pub mod cworkshop_populate_item_descriptions_request {
    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleItemDescription {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.gameitemid)
        pub gameitemid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description)
        pub item_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleItemDescription {
        fn default() -> &'a SingleItemDescription {
            <SingleItemDescription as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleItemDescription {
        pub fn new() -> SingleItemDescription {
            ::std::default::Default::default()
        }

        // optional uint32 gameitemid = 1;

        pub fn gameitemid(&self) -> u32 {
            self.gameitemid.unwrap_or(0)
        }

        pub fn clear_gameitemid(&mut self) {
            self.gameitemid = ::std::option::Option::None;
        }

        pub fn has_gameitemid(&self) -> bool {
            self.gameitemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameitemid(&mut self, v: u32) {
            self.gameitemid = ::std::option::Option::Some(v);
        }

        // optional string item_description = 2;

        pub fn item_description(&self) -> &str {
            match self.item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_item_description(&mut self) {
            self.item_description = ::std::option::Option::None;
        }

        pub fn has_item_description(&self) -> bool {
            self.item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_description(&mut self, v: ::std::string::String) {
            self.item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
            if self.item_description.is_none() {
                self.item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_description(&mut self) -> ::std::string::String {
            self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleItemDescription {
        const NAME: &'static str = "SingleItemDescription";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gameitemid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.gameitemid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleItemDescription {
            SingleItemDescription::new()
        }

        fn clear(&mut self) {
            self.gameitemid = ::std::option::Option::None;
            self.item_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleItemDescription {
            static instance: SingleItemDescription = SingleItemDescription {
                gameitemid: ::std::option::Option::None,
                item_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDescriptionsLanguageBlock {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.descriptions)
        pub descriptions: ::std::vec::Vec<SingleItemDescription>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDescriptionsLanguageBlock {
        fn default() -> &'a ItemDescriptionsLanguageBlock {
            <ItemDescriptionsLanguageBlock as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemDescriptionsLanguageBlock {
        pub fn new() -> ItemDescriptionsLanguageBlock {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemDescriptionsLanguageBlock {
        const NAME: &'static str = "ItemDescriptionsLanguageBlock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.descriptions.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            for value in &self.descriptions {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.descriptions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDescriptionsLanguageBlock {
            ItemDescriptionsLanguageBlock::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.descriptions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDescriptionsLanguageBlock {
            static instance: ItemDescriptionsLanguageBlock = ItemDescriptionsLanguageBlock {
                language: ::std::option::Option::None,
                descriptions: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Request {
    fn default() -> &'a CWorkshop_GetContributors_Request {
        <CWorkshop_GetContributors_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Request {
    pub fn new() -> CWorkshop_GetContributors_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetContributors_Request {
    const NAME: &'static str = "CWorkshop_GetContributors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Request {
        CWorkshop_GetContributors_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Request {
        static instance: CWorkshop_GetContributors_Request = CWorkshop_GetContributors_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Response.contributors)
    pub contributors: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Response {
    fn default() -> &'a CWorkshop_GetContributors_Response {
        <CWorkshop_GetContributors_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Response {
    pub fn new() -> CWorkshop_GetContributors_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetContributors_Response {
    const NAME: &'static str = "CWorkshop_GetContributors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.contributors)?;
                },
                9 => {
                    self.contributors.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.contributors.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.contributors {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Response {
        CWorkshop_GetContributors_Response::new()
    }

    fn clear(&mut self) {
        self.contributors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Response {
        static instance: CWorkshop_GetContributors_Response = CWorkshop_GetContributors_Response {
            contributors: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_files)
    pub associated_workshop_files: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.partner_accounts)
    pub partner_accounts: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.validate_only)
    pub validate_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.make_workshop_files_subscribable)
    pub make_workshop_files_subscribable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_file_for_direct_payments)
    pub associated_workshop_file_for_direct_payments: ::steam_vent_proto_common::protobuf::MessageField<cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request {
        <CWorkshop_SetItemPaymentRules_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // optional bool validate_only = 5;

    pub fn validate_only(&self) -> bool {
        self.validate_only.unwrap_or(false)
    }

    pub fn clear_validate_only(&mut self) {
        self.validate_only = ::std::option::Option::None;
    }

    pub fn has_validate_only(&self) -> bool {
        self.validate_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = ::std::option::Option::Some(v);
    }

    // optional bool make_workshop_files_subscribable = 6;

    pub fn make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.unwrap_or(false)
    }

    pub fn clear_make_workshop_files_subscribable(&mut self) {
        self.make_workshop_files_subscribable = ::std::option::Option::None;
    }

    pub fn has_make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_make_workshop_files_subscribable(&mut self, v: bool) {
        self.make_workshop_files_subscribable = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_SetItemPaymentRules_Request {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.associated_workshop_files.push(is.read_message()?);
                },
                34 => {
                    self.partner_accounts.push(is.read_message()?);
                },
                40 => {
                    self.validate_only = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.make_workshop_files_subscribable = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.associated_workshop_file_for_direct_payments)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.associated_workshop_files {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.partner_accounts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.validate_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        for v in &self.associated_workshop_files {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.partner_accounts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.validate_only {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request {
        CWorkshop_SetItemPaymentRules_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.associated_workshop_files.clear();
        self.partner_accounts.clear();
        self.validate_only = ::std::option::Option::None;
        self.make_workshop_files_subscribable = ::std::option::Option::None;
        self.associated_workshop_file_for_direct_payments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request {
        static instance: CWorkshop_SetItemPaymentRules_Request = CWorkshop_SetItemPaymentRules_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            associated_workshop_files: ::std::vec::Vec::new(),
            partner_accounts: ::std::vec::Vec::new(),
            validate_only: ::std::option::Option::None,
            make_workshop_files_subscribable: ::std::option::Option::None,
            associated_workshop_file_for_direct_payments: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_SetItemPaymentRules_Request`
pub mod cworkshop_set_item_payment_rules_request {
    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_type)
        pub rule_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemPaymentRule {
        fn default() -> &'a WorkshopItemPaymentRule {
            <WorkshopItemPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemPaymentRule {
        pub fn new() -> WorkshopItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 rule_type = 4;

        pub fn rule_type(&self) -> u32 {
            self.rule_type.unwrap_or(1u32)
        }

        pub fn clear_rule_type(&mut self) {
            self.rule_type = ::std::option::Option::None;
        }

        pub fn has_rule_type(&self) -> bool {
            self.rule_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_type(&mut self, v: u32) {
            self.rule_type = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WorkshopItemPaymentRule {
        const NAME: &'static str = "WorkshopItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.rule_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.rule_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.rule_type {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemPaymentRule {
            WorkshopItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.rule_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemPaymentRule {
            static instance: WorkshopItemPaymentRule = WorkshopItemPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                rule_type: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopDirectPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopDirectPaymentRule {
        fn default() -> &'a WorkshopDirectPaymentRule {
            <WorkshopDirectPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopDirectPaymentRule {
        pub fn new() -> WorkshopDirectPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 2;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WorkshopDirectPaymentRule {
        const NAME: &'static str = "WorkshopDirectPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopDirectPaymentRule {
            WorkshopDirectPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopDirectPaymentRule {
            static instance: WorkshopDirectPaymentRule = WorkshopDirectPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartnerItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerItemPaymentRule {
        fn default() -> &'a PartnerItemPaymentRule {
            <PartnerItemPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PartnerItemPaymentRule {
        pub fn new() -> PartnerItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PartnerItemPaymentRule {
        const NAME: &'static str = "PartnerItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerItemPaymentRule {
            PartnerItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerItemPaymentRule {
            static instance: PartnerItemPaymentRule = PartnerItemPaymentRule {
                account_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Response.validation_errors)
    pub validation_errors: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Response {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Response {
        <CWorkshop_SetItemPaymentRules_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Response {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_SetItemPaymentRules_Response {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validation_errors.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.validation_errors {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.validation_errors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Response {
        CWorkshop_SetItemPaymentRules_Response::new()
    }

    fn clear(&mut self) {
        self.validation_errors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Response {
        static instance: CWorkshop_SetItemPaymentRules_Response = CWorkshop_SetItemPaymentRules_Response {
            validation_errors: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_ClanAnnouncementInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClanAnnouncementInfo {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.clanid)
    pub clanid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posterid)
    pub posterid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posttime)
    pub posttime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.updatetime)
    pub updatetime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.commentcount)
    pub commentcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClanAnnouncementInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClanAnnouncementInfo {
    fn default() -> &'a CCommunity_ClanAnnouncementInfo {
        <CCommunity_ClanAnnouncementInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClanAnnouncementInfo {
    pub fn new() -> CCommunity_ClanAnnouncementInfo {
        ::std::default::Default::default()
    }

    // optional uint64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint64 clanid = 2;

    pub fn clanid(&self) -> u64 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u64) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint64 posterid = 3;

    pub fn posterid(&self) -> u64 {
        self.posterid.unwrap_or(0)
    }

    pub fn clear_posterid(&mut self) {
        self.posterid = ::std::option::Option::None;
    }

    pub fn has_posterid(&self) -> bool {
        self.posterid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posterid(&mut self, v: u64) {
        self.posterid = ::std::option::Option::Some(v);
    }

    // optional string headline = 4;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 posttime = 5;

    pub fn posttime(&self) -> u32 {
        self.posttime.unwrap_or(0)
    }

    pub fn clear_posttime(&mut self) {
        self.posttime = ::std::option::Option::None;
    }

    pub fn has_posttime(&self) -> bool {
        self.posttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttime(&mut self, v: u32) {
        self.posttime = ::std::option::Option::Some(v);
    }

    // optional uint32 updatetime = 6;

    pub fn updatetime(&self) -> u32 {
        self.updatetime.unwrap_or(0)
    }

    pub fn clear_updatetime(&mut self) {
        self.updatetime = ::std::option::Option::None;
    }

    pub fn has_updatetime(&self) -> bool {
        self.updatetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatetime(&mut self, v: u32) {
        self.updatetime = ::std::option::Option::Some(v);
    }

    // optional string body = 7;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 commentcount = 8;

    pub fn commentcount(&self) -> i32 {
        self.commentcount.unwrap_or(0)
    }

    pub fn clear_commentcount(&mut self) {
        self.commentcount = ::std::option::Option::None;
    }

    pub fn has_commentcount(&self) -> bool {
        self.commentcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentcount(&mut self, v: i32) {
        self.commentcount = ::std::option::Option::Some(v);
    }

    // optional int32 language = 10;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 11;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 12;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_ClanAnnouncementInfo {
    const NAME: &'static str = "CCommunity_ClanAnnouncementInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.posterid = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.posttime = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.updatetime = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.commentcount = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.tags.push(is.read_string()?);
                },
                80 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                97 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.clanid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.posterid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.posttime {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.updatetime {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.commentcount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        for value in &self.tags {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &value);
        };
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.posterid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.posttime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.updatetime {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.commentcount {
            os.write_int32(8, v)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.language {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClanAnnouncementInfo {
        CCommunity_ClanAnnouncementInfo::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.posterid = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.posttime = ::std::option::Option::None;
        self.updatetime = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.commentcount = ::std::option::Option::None;
        self.tags.clear();
        self.language = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClanAnnouncementInfo {
        static instance: CCommunity_ClanAnnouncementInfo = CCommunity_ClanAnnouncementInfo {
            gid: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            posterid: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            posttime: ::std::option::Option::None,
            updatetime: ::std::option::Option::None,
            body: ::std::option::Option::None,
            commentcount: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            language: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetClanAnnouncements_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetClanAnnouncements_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.maxchars)
    pub maxchars: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.strip_html)
    pub strip_html: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.required_tags)
    pub required_tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.require_no_tags)
    pub require_no_tags: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.language_preference)
    pub language_preference: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.hidden_only)
    pub hidden_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.only_gid)
    pub only_gid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.rtime_oldest_date)
    pub rtime_oldest_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.include_hidden)
    pub include_hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Request.include_partner_events)
    pub include_partner_events: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetClanAnnouncements_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetClanAnnouncements_Request {
    fn default() -> &'a CCommunity_GetClanAnnouncements_Request {
        <CCommunity_GetClanAnnouncements_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetClanAnnouncements_Request {
    pub fn new() -> CCommunity_GetClanAnnouncements_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 maxchars = 4;

    pub fn maxchars(&self) -> u32 {
        self.maxchars.unwrap_or(0)
    }

    pub fn clear_maxchars(&mut self) {
        self.maxchars = ::std::option::Option::None;
    }

    pub fn has_maxchars(&self) -> bool {
        self.maxchars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxchars(&mut self, v: u32) {
        self.maxchars = ::std::option::Option::Some(v);
    }

    // optional bool strip_html = 5;

    pub fn strip_html(&self) -> bool {
        self.strip_html.unwrap_or(false)
    }

    pub fn clear_strip_html(&mut self) {
        self.strip_html = ::std::option::Option::None;
    }

    pub fn has_strip_html(&self) -> bool {
        self.strip_html.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_html(&mut self, v: bool) {
        self.strip_html = ::std::option::Option::Some(v);
    }

    // optional bool require_no_tags = 7;

    pub fn require_no_tags(&self) -> bool {
        self.require_no_tags.unwrap_or(false)
    }

    pub fn clear_require_no_tags(&mut self) {
        self.require_no_tags = ::std::option::Option::None;
    }

    pub fn has_require_no_tags(&self) -> bool {
        self.require_no_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_require_no_tags(&mut self, v: bool) {
        self.require_no_tags = ::std::option::Option::Some(v);
    }

    // optional bool hidden_only = 9;

    pub fn hidden_only(&self) -> bool {
        self.hidden_only.unwrap_or(false)
    }

    pub fn clear_hidden_only(&mut self) {
        self.hidden_only = ::std::option::Option::None;
    }

    pub fn has_hidden_only(&self) -> bool {
        self.hidden_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden_only(&mut self, v: bool) {
        self.hidden_only = ::std::option::Option::Some(v);
    }

    // optional bool only_gid = 10;

    pub fn only_gid(&self) -> bool {
        self.only_gid.unwrap_or(false)
    }

    pub fn clear_only_gid(&mut self) {
        self.only_gid = ::std::option::Option::None;
    }

    pub fn has_only_gid(&self) -> bool {
        self.only_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_gid(&mut self, v: bool) {
        self.only_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_oldest_date = 11;

    pub fn rtime_oldest_date(&self) -> u32 {
        self.rtime_oldest_date.unwrap_or(0)
    }

    pub fn clear_rtime_oldest_date(&mut self) {
        self.rtime_oldest_date = ::std::option::Option::None;
    }

    pub fn has_rtime_oldest_date(&self) -> bool {
        self.rtime_oldest_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_oldest_date(&mut self, v: u32) {
        self.rtime_oldest_date = ::std::option::Option::Some(v);
    }

    // optional bool include_hidden = 12;

    pub fn include_hidden(&self) -> bool {
        self.include_hidden.unwrap_or(false)
    }

    pub fn clear_include_hidden(&mut self) {
        self.include_hidden = ::std::option::Option::None;
    }

    pub fn has_include_hidden(&self) -> bool {
        self.include_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_hidden(&mut self, v: bool) {
        self.include_hidden = ::std::option::Option::Some(v);
    }

    // optional bool include_partner_events = 13;

    pub fn include_partner_events(&self) -> bool {
        self.include_partner_events.unwrap_or(false)
    }

    pub fn clear_include_partner_events(&mut self) {
        self.include_partner_events = ::std::option::Option::None;
    }

    pub fn has_include_partner_events(&self) -> bool {
        self.include_partner_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_partner_events(&mut self, v: bool) {
        self.include_partner_events = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetClanAnnouncements_Request {
    const NAME: &'static str = "CCommunity_GetClanAnnouncements_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.maxchars = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.strip_html = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.required_tags.push(is.read_string()?);
                },
                56 => {
                    self.require_no_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.language_preference)?;
                },
                64 => {
                    self.language_preference.push(is.read_uint32()?);
                },
                72 => {
                    self.hidden_only = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.only_gid = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.rtime_oldest_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.include_hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.include_partner_events = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.maxchars {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.strip_html {
            my_size += 1 + 1;
        }
        for value in &self.required_tags {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.require_no_tags {
            my_size += 1 + 1;
        }
        for value in &self.language_preference {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, *value);
        };
        if let Some(v) = self.hidden_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.only_gid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rtime_oldest_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.include_hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_partner_events {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.maxchars {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.strip_html {
            os.write_bool(5, v)?;
        }
        for v in &self.required_tags {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.require_no_tags {
            os.write_bool(7, v)?;
        }
        for v in &self.language_preference {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.hidden_only {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.only_gid {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.rtime_oldest_date {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.include_hidden {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.include_partner_events {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetClanAnnouncements_Request {
        CCommunity_GetClanAnnouncements_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.maxchars = ::std::option::Option::None;
        self.strip_html = ::std::option::Option::None;
        self.required_tags.clear();
        self.require_no_tags = ::std::option::Option::None;
        self.language_preference.clear();
        self.hidden_only = ::std::option::Option::None;
        self.only_gid = ::std::option::Option::None;
        self.rtime_oldest_date = ::std::option::Option::None;
        self.include_hidden = ::std::option::Option::None;
        self.include_partner_events = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetClanAnnouncements_Request {
        static instance: CCommunity_GetClanAnnouncements_Request = CCommunity_GetClanAnnouncements_Request {
            steamid: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            count: ::std::option::Option::None,
            maxchars: ::std::option::Option::None,
            strip_html: ::std::option::Option::None,
            required_tags: ::std::vec::Vec::new(),
            require_no_tags: ::std::option::Option::None,
            language_preference: ::std::vec::Vec::new(),
            hidden_only: ::std::option::Option::None,
            only_gid: ::std::option::Option::None,
            rtime_oldest_date: ::std::option::Option::None,
            include_hidden: ::std::option::Option::None,
            include_partner_events: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetClanAnnouncements_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetClanAnnouncements_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Response.maxchars)
    pub maxchars: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Response.strip_html)
    pub strip_html: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncements_Response.announcements)
    pub announcements: ::std::vec::Vec<CCommunity_ClanAnnouncementInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetClanAnnouncements_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetClanAnnouncements_Response {
    fn default() -> &'a CCommunity_GetClanAnnouncements_Response {
        <CCommunity_GetClanAnnouncements_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetClanAnnouncements_Response {
    pub fn new() -> CCommunity_GetClanAnnouncements_Response {
        ::std::default::Default::default()
    }

    // optional uint32 maxchars = 1;

    pub fn maxchars(&self) -> u32 {
        self.maxchars.unwrap_or(0)
    }

    pub fn clear_maxchars(&mut self) {
        self.maxchars = ::std::option::Option::None;
    }

    pub fn has_maxchars(&self) -> bool {
        self.maxchars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxchars(&mut self, v: u32) {
        self.maxchars = ::std::option::Option::Some(v);
    }

    // optional bool strip_html = 2;

    pub fn strip_html(&self) -> bool {
        self.strip_html.unwrap_or(false)
    }

    pub fn clear_strip_html(&mut self) {
        self.strip_html = ::std::option::Option::None;
    }

    pub fn has_strip_html(&self) -> bool {
        self.strip_html.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_html(&mut self, v: bool) {
        self.strip_html = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetClanAnnouncements_Response {
    const NAME: &'static str = "CCommunity_GetClanAnnouncements_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.maxchars = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.strip_html = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.announcements.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxchars {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.strip_html {
            my_size += 1 + 1;
        }
        for value in &self.announcements {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.maxchars {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.strip_html {
            os.write_bool(2, v)?;
        }
        for v in &self.announcements {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetClanAnnouncements_Response {
        CCommunity_GetClanAnnouncements_Response::new()
    }

    fn clear(&mut self) {
        self.maxchars = ::std::option::Option::None;
        self.strip_html = ::std::option::Option::None;
        self.announcements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetClanAnnouncements_Response {
        static instance: CCommunity_GetClanAnnouncements_Response = CCommunity_GetClanAnnouncements_Response {
            maxchars: ::std::option::Option::None,
            strip_html: ::std::option::Option::None,
            announcements: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBroadcast_PostGameDataFrame_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBroadcast_PostGameDataFrame_Request {
    // message fields
    // @@protoc_insertion_point(field:CBroadcast_PostGameDataFrame_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBroadcast_PostGameDataFrame_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_PostGameDataFrame_Request.broadcast_id)
    pub broadcast_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CBroadcast_PostGameDataFrame_Request.frame_data)
    pub frame_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CBroadcast_PostGameDataFrame_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBroadcast_PostGameDataFrame_Request {
    fn default() -> &'a CBroadcast_PostGameDataFrame_Request {
        <CBroadcast_PostGameDataFrame_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_PostGameDataFrame_Request {
    pub fn new() -> CBroadcast_PostGameDataFrame_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 3;

    pub fn broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }

    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional bytes frame_data = 4;

    pub fn frame_data(&self) -> &[u8] {
        match self.frame_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_frame_data(&mut self) {
        self.frame_data = ::std::option::Option::None;
    }

    pub fn has_frame_data(&self) -> bool {
        self.frame_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.frame_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frame_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.frame_data.is_none() {
            self.frame_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.frame_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_frame_data(&mut self) -> ::std::vec::Vec<u8> {
        self.frame_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CBroadcast_PostGameDataFrame_Request {
    const NAME: &'static str = "CBroadcast_PostGameDataFrame_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.frame_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.frame_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.frame_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBroadcast_PostGameDataFrame_Request {
        CBroadcast_PostGameDataFrame_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.frame_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBroadcast_PostGameDataFrame_Request {
        static instance: CBroadcast_PostGameDataFrame_Request = CBroadcast_PostGameDataFrame_Request {
            appid: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            broadcast_id: ::std::option::Option::None,
            frame_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSerializedSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSerializedSOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.file_version)
    pub file_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.caches)
    pub caches: ::std::vec::Vec<cmsg_serialized_socache::Cache>,
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.gc_socache_file_version)
    pub gc_socache_file_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSerializedSOCache {
    fn default() -> &'a CMsgSerializedSOCache {
        <CMsgSerializedSOCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSerializedSOCache {
    pub fn new() -> CMsgSerializedSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 file_version = 1;

    pub fn file_version(&self) -> u32 {
        self.file_version.unwrap_or(0)
    }

    pub fn clear_file_version(&mut self) {
        self.file_version = ::std::option::Option::None;
    }

    pub fn has_file_version(&self) -> bool {
        self.file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_version(&mut self, v: u32) {
        self.file_version = ::std::option::Option::Some(v);
    }

    // optional uint32 gc_socache_file_version = 3;

    pub fn gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSerializedSOCache {
    const NAME: &'static str = "CMsgSerializedSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.caches.push(is.read_message()?);
                },
                24 => {
                    self.gc_socache_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.caches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.file_version {
            os.write_uint32(1, v)?;
        }
        for v in &self.caches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSerializedSOCache {
        CMsgSerializedSOCache::new()
    }

    fn clear(&mut self) {
        self.file_version = ::std::option::Option::None;
        self.caches.clear();
        self.gc_socache_file_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSerializedSOCache {
        static instance: CMsgSerializedSOCache = CMsgSerializedSOCache {
            file_version: ::std::option::Option::None,
            caches: ::std::vec::Vec::new(),
            gc_socache_file_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSerializedSOCache`
pub mod cmsg_serialized_socache {
    // @@protoc_insertion_point(message:CMsgSerializedSOCache.TypeCache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TypeCache {
        // message fields
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.objects)
        pub objects: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.service_id)
        pub service_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.TypeCache.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TypeCache {
        fn default() -> &'a TypeCache {
            <TypeCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TypeCache {
        pub fn new() -> TypeCache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint32 service_id = 3;

        pub fn service_id(&self) -> u32 {
            self.service_id.unwrap_or(0)
        }

        pub fn clear_service_id(&mut self) {
            self.service_id = ::std::option::Option::None;
        }

        pub fn has_service_id(&self) -> bool {
            self.service_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_id(&mut self, v: u32) {
            self.service_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TypeCache {
        const NAME: &'static str = "TypeCache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.objects.push(is.read_bytes()?);
                    },
                    24 => {
                        self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.objects {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &value);
            };
            if let Some(v) = self.service_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            for v in &self.objects {
                os.write_bytes(2, &v)?;
            };
            if let Some(v) = self.service_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TypeCache {
            TypeCache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.objects.clear();
            self.service_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TypeCache {
            static instance: TypeCache = TypeCache {
                type_: ::std::option::Option::None,
                objects: ::std::vec::Vec::new(),
                service_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSerializedSOCache.Cache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cache {
        // message fields
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.id)
        pub id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.versions)
        pub versions: ::std::vec::Vec<cache::Version>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.type_caches)
        pub type_caches: ::std::vec::Vec<TypeCache>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.Cache.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cache {
        fn default() -> &'a Cache {
            <Cache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Cache {
        pub fn new() -> Cache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint64 id = 2;

        pub fn id(&self) -> u64 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u64) {
            self.id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Cache {
        const NAME: &'static str = "Cache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.versions.push(is.read_message()?);
                    },
                    34 => {
                        self.type_caches.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            for value in &self.versions {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.type_caches {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.id {
                os.write_uint64(2, v)?;
            }
            for v in &self.versions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.type_caches {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cache {
            Cache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.id = ::std::option::Option::None;
            self.versions.clear();
            self.type_caches.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cache {
            static instance: Cache = Cache {
                type_: ::std::option::Option::None,
                id: ::std::option::Option::None,
                versions: ::std::vec::Vec::new(),
                type_caches: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Cache`
    pub mod cache {
        // @@protoc_insertion_point(message:CMsgSerializedSOCache.Cache.Version)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Version {
            // message fields
            // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.Version.service)
            pub service: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.Version.version)
            pub version: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.Cache.Version.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Version {
            fn default() -> &'a Version {
                <Version as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Version {
            pub fn new() -> Version {
                ::std::default::Default::default()
            }

            // optional uint32 service = 1;

            pub fn service(&self) -> u32 {
                self.service.unwrap_or(0)
            }

            pub fn clear_service(&mut self) {
                self.service = ::std::option::Option::None;
            }

            pub fn has_service(&self) -> bool {
                self.service.is_some()
            }

            // Param is passed by value, moved
            pub fn set_service(&mut self, v: u32) {
                self.service = ::std::option::Option::Some(v);
            }

            // optional uint64 version = 2;

            pub fn version(&self) -> u64 {
                self.version.unwrap_or(0)
            }

            pub fn clear_version(&mut self) {
                self.version = ::std::option::Option::None;
            }

            pub fn has_version(&self) -> bool {
                self.version.is_some()
            }

            // Param is passed by value, moved
            pub fn set_version(&mut self, v: u64) {
                self.version = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Version {
            const NAME: &'static str = "Version";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.service = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.version = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.service {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.version {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.service {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.version {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Version {
                Version::new()
            }

            fn clear(&mut self) {
                self.service = ::std::option::Option::None;
                self.version = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Version {
                static instance: Version = Version {
                    service: ::std::option::Option::None,
                    version: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPollConvarRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollConvarRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPollConvarRequest.convar_name)
    pub convar_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCToClientPollConvarRequest.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPollConvarRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollConvarRequest {
    fn default() -> &'a CMsgGCToClientPollConvarRequest {
        <CMsgGCToClientPollConvarRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollConvarRequest {
    pub fn new() -> CMsgGCToClientPollConvarRequest {
        ::std::default::Default::default()
    }

    // optional string convar_name = 1;

    pub fn convar_name(&self) -> &str {
        match self.convar_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_convar_name(&mut self) {
        self.convar_name = ::std::option::Option::None;
    }

    pub fn has_convar_name(&self) -> bool {
        self.convar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convar_name(&mut self, v: ::std::string::String) {
        self.convar_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convar_name(&mut self) -> &mut ::std::string::String {
        if self.convar_name.is_none() {
            self.convar_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.convar_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_convar_name(&mut self) -> ::std::string::String {
        self.convar_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 poll_id = 2;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPollConvarRequest {
    const NAME: &'static str = "CMsgGCToClientPollConvarRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.convar_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.convar_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.poll_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.convar_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.poll_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollConvarRequest {
        CMsgGCToClientPollConvarRequest::new()
    }

    fn clear(&mut self) {
        self.convar_name = ::std::option::Option::None;
        self.poll_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollConvarRequest {
        static instance: CMsgGCToClientPollConvarRequest = CMsgGCToClientPollConvarRequest {
            convar_name: ::std::option::Option::None,
            poll_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPollConvarResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollConvarResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPollConvarResponse.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPollConvarResponse.convar_value)
    pub convar_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPollConvarResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollConvarResponse {
    fn default() -> &'a CMsgGCToClientPollConvarResponse {
        <CMsgGCToClientPollConvarResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollConvarResponse {
    pub fn new() -> CMsgGCToClientPollConvarResponse {
        ::std::default::Default::default()
    }

    // optional uint32 poll_id = 1;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }

    // optional string convar_value = 2;

    pub fn convar_value(&self) -> &str {
        match self.convar_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_convar_value(&mut self) {
        self.convar_value = ::std::option::Option::None;
    }

    pub fn has_convar_value(&self) -> bool {
        self.convar_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convar_value(&mut self, v: ::std::string::String) {
        self.convar_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convar_value(&mut self) -> &mut ::std::string::String {
        if self.convar_value.is_none() {
            self.convar_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.convar_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_convar_value(&mut self) -> ::std::string::String {
        self.convar_value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPollConvarResponse {
    const NAME: &'static str = "CMsgGCToClientPollConvarResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.convar_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.poll_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.convar_value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.poll_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.convar_value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollConvarResponse {
        CMsgGCToClientPollConvarResponse::new()
    }

    fn clear(&mut self) {
        self.poll_id = ::std::option::Option::None;
        self.convar_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollConvarResponse {
        static instance: CMsgGCToClientPollConvarResponse = CMsgGCToClientPollConvarResponse {
            poll_id: ::std::option::Option::None,
            convar_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsgCompressedMsgToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgCompressedMsgToClient {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgCompressedMsgToClient.msg_id)
    pub msg_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgCompressedMsgToClient.compressed_msg)
    pub compressed_msg: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgCompressedMsgToClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgCompressedMsgToClient {
    fn default() -> &'a CGCMsgCompressedMsgToClient {
        <CGCMsgCompressedMsgToClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgCompressedMsgToClient {
    pub fn new() -> CGCMsgCompressedMsgToClient {
        ::std::default::Default::default()
    }

    // optional uint32 msg_id = 1;

    pub fn msg_id(&self) -> u32 {
        self.msg_id.unwrap_or(0)
    }

    pub fn clear_msg_id(&mut self) {
        self.msg_id = ::std::option::Option::None;
    }

    pub fn has_msg_id(&self) -> bool {
        self.msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_id(&mut self, v: u32) {
        self.msg_id = ::std::option::Option::Some(v);
    }

    // optional bytes compressed_msg = 2;

    pub fn compressed_msg(&self) -> &[u8] {
        match self.compressed_msg.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_compressed_msg(&mut self) {
        self.compressed_msg = ::std::option::Option::None;
    }

    pub fn has_compressed_msg(&self) -> bool {
        self.compressed_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.compressed_msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compressed_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.compressed_msg.is_none() {
            self.compressed_msg = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.compressed_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_compressed_msg(&mut self) -> ::std::vec::Vec<u8> {
        self.compressed_msg.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgCompressedMsgToClient {
    const NAME: &'static str = "CGCMsgCompressedMsgToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.compressed_msg = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.compressed_msg.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.compressed_msg.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgCompressedMsgToClient {
        CGCMsgCompressedMsgToClient::new()
    }

    fn clear(&mut self) {
        self.msg_id = ::std::option::Option::None;
        self.compressed_msg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgCompressedMsgToClient {
        static instance: CGCMsgCompressedMsgToClient = CGCMsgCompressedMsgToClient {
            msg_id: ::std::option::Option::None,
            compressed_msg: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCMasterBroadcastMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterBroadcastMessage {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCMasterBroadcastMessage.users_per_second)
    pub users_per_second: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterBroadcastMessage.send_to_users)
    pub send_to_users: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterBroadcastMessage.send_to_servers)
    pub send_to_servers: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterBroadcastMessage.msg_id)
    pub msg_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterBroadcastMessage.msg_data)
    pub msg_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCMasterBroadcastMessage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterBroadcastMessage {
    fn default() -> &'a CMsgGCToGCMasterBroadcastMessage {
        <CMsgGCToGCMasterBroadcastMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterBroadcastMessage {
    pub fn new() -> CMsgGCToGCMasterBroadcastMessage {
        ::std::default::Default::default()
    }

    // optional uint32 users_per_second = 1;

    pub fn users_per_second(&self) -> u32 {
        self.users_per_second.unwrap_or(0)
    }

    pub fn clear_users_per_second(&mut self) {
        self.users_per_second = ::std::option::Option::None;
    }

    pub fn has_users_per_second(&self) -> bool {
        self.users_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_users_per_second(&mut self, v: u32) {
        self.users_per_second = ::std::option::Option::Some(v);
    }

    // optional bool send_to_users = 2;

    pub fn send_to_users(&self) -> bool {
        self.send_to_users.unwrap_or(false)
    }

    pub fn clear_send_to_users(&mut self) {
        self.send_to_users = ::std::option::Option::None;
    }

    pub fn has_send_to_users(&self) -> bool {
        self.send_to_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_to_users(&mut self, v: bool) {
        self.send_to_users = ::std::option::Option::Some(v);
    }

    // optional bool send_to_servers = 3;

    pub fn send_to_servers(&self) -> bool {
        self.send_to_servers.unwrap_or(false)
    }

    pub fn clear_send_to_servers(&mut self) {
        self.send_to_servers = ::std::option::Option::None;
    }

    pub fn has_send_to_servers(&self) -> bool {
        self.send_to_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_to_servers(&mut self, v: bool) {
        self.send_to_servers = ::std::option::Option::Some(v);
    }

    // optional uint32 msg_id = 4;

    pub fn msg_id(&self) -> u32 {
        self.msg_id.unwrap_or(0)
    }

    pub fn clear_msg_id(&mut self) {
        self.msg_id = ::std::option::Option::None;
    }

    pub fn has_msg_id(&self) -> bool {
        self.msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_id(&mut self, v: u32) {
        self.msg_id = ::std::option::Option::Some(v);
    }

    // optional bytes msg_data = 5;

    pub fn msg_data(&self) -> &[u8] {
        match self.msg_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_msg_data(&mut self) {
        self.msg_data = ::std::option::Option::None;
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.msg_data.is_none() {
            self.msg_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_data(&mut self) -> ::std::vec::Vec<u8> {
        self.msg_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCMasterBroadcastMessage {
    const NAME: &'static str = "CMsgGCToGCMasterBroadcastMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.users_per_second = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.send_to_users = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.send_to_servers = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.msg_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.msg_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.users_per_second {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.send_to_users {
            my_size += 1 + 1;
        }
        if let Some(v) = self.send_to_servers {
            my_size += 1 + 1;
        }
        if let Some(v) = self.msg_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.msg_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.users_per_second {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_to_users {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.send_to_servers {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.msg_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.msg_data.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterBroadcastMessage {
        CMsgGCToGCMasterBroadcastMessage::new()
    }

    fn clear(&mut self) {
        self.users_per_second = ::std::option::Option::None;
        self.send_to_users = ::std::option::Option::None;
        self.send_to_servers = ::std::option::Option::None;
        self.msg_id = ::std::option::Option::None;
        self.msg_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterBroadcastMessage {
        static instance: CMsgGCToGCMasterBroadcastMessage = CMsgGCToGCMasterBroadcastMessage {
            users_per_second: ::std::option::Option::None,
            send_to_users: ::std::option::Option::None,
            send_to_servers: ::std::option::Option::None,
            msg_id: ::std::option::Option::None,
            msg_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCMasterSubscribeToCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterSubscribeToCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCMasterSubscribeToCache.soid_type)
    pub soid_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterSubscribeToCache.soid_id)
    pub soid_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterSubscribeToCache.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterSubscribeToCache.steam_ids)
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCMasterSubscribeToCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterSubscribeToCache {
    fn default() -> &'a CMsgGCToGCMasterSubscribeToCache {
        <CMsgGCToGCMasterSubscribeToCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterSubscribeToCache {
    pub fn new() -> CMsgGCToGCMasterSubscribeToCache {
        ::std::default::Default::default()
    }

    // optional uint32 soid_type = 1;

    pub fn soid_type(&self) -> u32 {
        self.soid_type.unwrap_or(0)
    }

    pub fn clear_soid_type(&mut self) {
        self.soid_type = ::std::option::Option::None;
    }

    pub fn has_soid_type(&self) -> bool {
        self.soid_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_type(&mut self, v: u32) {
        self.soid_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 soid_id = 2;

    pub fn soid_id(&self) -> u64 {
        self.soid_id.unwrap_or(0)
    }

    pub fn clear_soid_id(&mut self) {
        self.soid_id = ::std::option::Option::None;
    }

    pub fn has_soid_id(&self) -> bool {
        self.soid_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_id(&mut self, v: u64) {
        self.soid_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCMasterSubscribeToCache {
    const NAME: &'static str = "CMsgGCToGCMasterSubscribeToCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soid_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.soid_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                24 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_ids)?;
                },
                33 => {
                    self.steam_ids.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.soid_id {
            my_size += 1 + 8;
        }
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += 9 * self.steam_ids.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soid_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.soid_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(3, *v)?;
        };
        for v in &self.steam_ids {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterSubscribeToCache {
        CMsgGCToGCMasterSubscribeToCache::new()
    }

    fn clear(&mut self) {
        self.soid_type = ::std::option::Option::None;
        self.soid_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterSubscribeToCache {
        static instance: CMsgGCToGCMasterSubscribeToCache = CMsgGCToGCMasterSubscribeToCache {
            soid_type: ::std::option::Option::None,
            soid_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            steam_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCMasterSubscribeToCacheResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterSubscribeToCacheResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCMasterSubscribeToCacheResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterSubscribeToCacheResponse {
    fn default() -> &'a CMsgGCToGCMasterSubscribeToCacheResponse {
        <CMsgGCToGCMasterSubscribeToCacheResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterSubscribeToCacheResponse {
    pub fn new() -> CMsgGCToGCMasterSubscribeToCacheResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCMasterSubscribeToCacheResponse {
    const NAME: &'static str = "CMsgGCToGCMasterSubscribeToCacheResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterSubscribeToCacheResponse {
        CMsgGCToGCMasterSubscribeToCacheResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterSubscribeToCacheResponse {
        static instance: CMsgGCToGCMasterSubscribeToCacheResponse = CMsgGCToGCMasterSubscribeToCacheResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCMasterSubscribeToCacheAsync)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterSubscribeToCacheAsync {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCMasterSubscribeToCacheAsync.subscribe_msg)
    pub subscribe_msg: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToGCMasterSubscribeToCache>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCMasterSubscribeToCacheAsync.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterSubscribeToCacheAsync {
    fn default() -> &'a CMsgGCToGCMasterSubscribeToCacheAsync {
        <CMsgGCToGCMasterSubscribeToCacheAsync as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterSubscribeToCacheAsync {
    pub fn new() -> CMsgGCToGCMasterSubscribeToCacheAsync {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCMasterSubscribeToCacheAsync {
    const NAME: &'static str = "CMsgGCToGCMasterSubscribeToCacheAsync";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.subscribe_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscribe_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.subscribe_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterSubscribeToCacheAsync {
        CMsgGCToGCMasterSubscribeToCacheAsync::new()
    }

    fn clear(&mut self) {
        self.subscribe_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterSubscribeToCacheAsync {
        static instance: CMsgGCToGCMasterSubscribeToCacheAsync = CMsgGCToGCMasterSubscribeToCacheAsync {
            subscribe_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCMasterUnsubscribeFromCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterUnsubscribeFromCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCMasterUnsubscribeFromCache.soid_type)
    pub soid_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterUnsubscribeFromCache.soid_id)
    pub soid_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterUnsubscribeFromCache.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterUnsubscribeFromCache.steam_ids)
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCMasterUnsubscribeFromCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterUnsubscribeFromCache {
    fn default() -> &'a CMsgGCToGCMasterUnsubscribeFromCache {
        <CMsgGCToGCMasterUnsubscribeFromCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterUnsubscribeFromCache {
    pub fn new() -> CMsgGCToGCMasterUnsubscribeFromCache {
        ::std::default::Default::default()
    }

    // optional uint32 soid_type = 1;

    pub fn soid_type(&self) -> u32 {
        self.soid_type.unwrap_or(0)
    }

    pub fn clear_soid_type(&mut self) {
        self.soid_type = ::std::option::Option::None;
    }

    pub fn has_soid_type(&self) -> bool {
        self.soid_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_type(&mut self, v: u32) {
        self.soid_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 soid_id = 2;

    pub fn soid_id(&self) -> u64 {
        self.soid_id.unwrap_or(0)
    }

    pub fn clear_soid_id(&mut self) {
        self.soid_id = ::std::option::Option::None;
    }

    pub fn has_soid_id(&self) -> bool {
        self.soid_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_id(&mut self, v: u64) {
        self.soid_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCMasterUnsubscribeFromCache {
    const NAME: &'static str = "CMsgGCToGCMasterUnsubscribeFromCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soid_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.soid_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                24 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_ids)?;
                },
                33 => {
                    self.steam_ids.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.soid_id {
            my_size += 1 + 8;
        }
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += 9 * self.steam_ids.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soid_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.soid_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(3, *v)?;
        };
        for v in &self.steam_ids {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterUnsubscribeFromCache {
        CMsgGCToGCMasterUnsubscribeFromCache::new()
    }

    fn clear(&mut self) {
        self.soid_type = ::std::option::Option::None;
        self.soid_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterUnsubscribeFromCache {
        static instance: CMsgGCToGCMasterUnsubscribeFromCache = CMsgGCToGCMasterUnsubscribeFromCache {
            soid_type: ::std::option::Option::None,
            soid_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            steam_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCMasterDestroyCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCMasterDestroyCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCMasterDestroyCache.soid_type)
    pub soid_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCMasterDestroyCache.soid_id)
    pub soid_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCMasterDestroyCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCMasterDestroyCache {
    fn default() -> &'a CMsgGCToGCMasterDestroyCache {
        <CMsgGCToGCMasterDestroyCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCMasterDestroyCache {
    pub fn new() -> CMsgGCToGCMasterDestroyCache {
        ::std::default::Default::default()
    }

    // optional uint32 soid_type = 1;

    pub fn soid_type(&self) -> u32 {
        self.soid_type.unwrap_or(0)
    }

    pub fn clear_soid_type(&mut self) {
        self.soid_type = ::std::option::Option::None;
    }

    pub fn has_soid_type(&self) -> bool {
        self.soid_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_type(&mut self, v: u32) {
        self.soid_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 soid_id = 2;

    pub fn soid_id(&self) -> u64 {
        self.soid_id.unwrap_or(0)
    }

    pub fn clear_soid_id(&mut self) {
        self.soid_id = ::std::option::Option::None;
    }

    pub fn has_soid_id(&self) -> bool {
        self.soid_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid_id(&mut self, v: u64) {
        self.soid_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCMasterDestroyCache {
    const NAME: &'static str = "CMsgGCToGCMasterDestroyCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soid_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.soid_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.soid_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soid_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.soid_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCMasterDestroyCache {
        CMsgGCToGCMasterDestroyCache::new()
    }

    fn clear(&mut self) {
        self.soid_type = ::std::option::Option::None;
        self.soid_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCMasterDestroyCache {
        static instance: CMsgGCToGCMasterDestroyCache = CMsgGCToGCMasterDestroyCache {
            soid_type: ::std::option::Option::None,
            soid_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESourceEngine)
pub enum ESourceEngine {
    // @@protoc_insertion_point(enum_value:ESourceEngine.k_ESE_Source1)
    k_ESE_Source1 = 0,
    // @@protoc_insertion_point(enum_value:ESourceEngine.k_ESE_Source2)
    k_ESE_Source2 = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESourceEngine {
    const NAME: &'static str = "ESourceEngine";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESourceEngine> {
        match value {
            0 => ::std::option::Option::Some(ESourceEngine::k_ESE_Source1),
            1 => ::std::option::Option::Some(ESourceEngine::k_ESE_Source2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESourceEngine> {
        match str {
            "k_ESE_Source1" => ::std::option::Option::Some(ESourceEngine::k_ESE_Source1),
            "k_ESE_Source2" => ::std::option::Option::Some(ESourceEngine::k_ESE_Source2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESourceEngine] = &[
        ESourceEngine::k_ESE_Source1,
        ESourceEngine::k_ESE_Source2,
    ];
}

impl ::std::default::Default for ESourceEngine {
    fn default() -> Self {
        ESourceEngine::k_ESE_Source1
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PartnerAccountType)
pub enum PartnerAccountType {
    // @@protoc_insertion_point(enum_value:PartnerAccountType.PARTNER_NONE)
    PARTNER_NONE = 0,
    // @@protoc_insertion_point(enum_value:PartnerAccountType.PARTNER_PERFECT_WORLD)
    PARTNER_PERFECT_WORLD = 1,
    // @@protoc_insertion_point(enum_value:PartnerAccountType.PARTNER_INVALID)
    PARTNER_INVALID = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for PartnerAccountType {
    const NAME: &'static str = "PartnerAccountType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerAccountType> {
        match value {
            0 => ::std::option::Option::Some(PartnerAccountType::PARTNER_NONE),
            1 => ::std::option::Option::Some(PartnerAccountType::PARTNER_PERFECT_WORLD),
            3 => ::std::option::Option::Some(PartnerAccountType::PARTNER_INVALID),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PartnerAccountType> {
        match str {
            "PARTNER_NONE" => ::std::option::Option::Some(PartnerAccountType::PARTNER_NONE),
            "PARTNER_PERFECT_WORLD" => ::std::option::Option::Some(PartnerAccountType::PARTNER_PERFECT_WORLD),
            "PARTNER_INVALID" => ::std::option::Option::Some(PartnerAccountType::PARTNER_INVALID),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PartnerAccountType] = &[
        PartnerAccountType::PARTNER_NONE,
        PartnerAccountType::PARTNER_PERFECT_WORLD,
        PartnerAccountType::PARTNER_INVALID,
    ];
}

impl ::std::default::Default for PartnerAccountType {
    fn default() -> Self {
        PartnerAccountType::PARTNER_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCConnectionStatus)
pub enum GCConnectionStatus {
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_HAVE_SESSION)
    GCConnectionStatus_HAVE_SESSION = 0,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_GC_GOING_DOWN)
    GCConnectionStatus_GC_GOING_DOWN = 1,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION)
    GCConnectionStatus_NO_SESSION = 2,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE)
    GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_STEAM)
    GCConnectionStatus_NO_STEAM = 4,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_SUSPENDED)
    GCConnectionStatus_SUSPENDED = 5,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_STEAM_GOING_DOWN)
    GCConnectionStatus_STEAM_GOING_DOWN = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for GCConnectionStatus {
    const NAME: &'static str = "GCConnectionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCConnectionStatus> {
        match value {
            0 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            1 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            3 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            4 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            5 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_SUSPENDED),
            6 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_STEAM_GOING_DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCConnectionStatus> {
        match str {
            "GCConnectionStatus_HAVE_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            "GCConnectionStatus_GC_GOING_DOWN" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            "GCConnectionStatus_NO_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            "GCConnectionStatus_NO_STEAM" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            "GCConnectionStatus_SUSPENDED" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_SUSPENDED),
            "GCConnectionStatus_STEAM_GOING_DOWN" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_STEAM_GOING_DOWN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCConnectionStatus] = &[
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE,
        GCConnectionStatus::GCConnectionStatus_NO_STEAM,
        GCConnectionStatus::GCConnectionStatus_SUSPENDED,
        GCConnectionStatus::GCConnectionStatus_STEAM_GOING_DOWN,
    ];
}

impl ::std::default::Default for GCConnectionStatus {
    fn default() -> Self {
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::steammessages_steamlearn_steamworkssdk::*;
impl ::steam_vent_proto_common::RpcMessage for CExtraMsgBlock {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnServerInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCAssertJobData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCConCommand {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSDOAssert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOIDOwner {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOSingleObject {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOMultipleObjects {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheSubscribed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheSubscribed {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheSubscribed;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheSubscribedUpToDate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheSubscribedUpToDate {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheSubscribedUpToDate;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheUnsubscribed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheUnsubscribed {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheUnsubscribed;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheSubscriptionCheck {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheSubscriptionRefresh {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheSubscriptionRefresh {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheSubscriptionRefresh;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheVersion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMultiplexMessage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCSubGCStarting {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgMasterAck {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgMasterAck_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCUniverseStartup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCUniverseStartupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgMasterStartupComplete {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgRouted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgRoutedReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCUpdateSubGCSessionInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestSubGCSessionInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestSubGCSessionInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheHaveVersion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientHello {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientHello {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCClientHello;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientWelcome {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientWelcome {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCClientWelcome;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConnectionStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCSOCacheSubscribe {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCSOCacheUnsubscribe {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCClientPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCForwardAccountDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCLoadSessionSOCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCLoadSessionSOCacheResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCUpdateSessionStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientRequestDropped {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientRequestDropped {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCToClientRequestDropped;
}
impl ::steam_vent_proto_common::RpcMessage
for CWorkshop_PopulateItemDescriptions_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetContributors_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetContributors_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_SetItemPaymentRules_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_SetItemPaymentRules_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_ClanAnnouncementInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetClanAnnouncements_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetClanAnnouncements_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CBroadcast_PostGameDataFrame_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSerializedSOCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPollConvarRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPollConvarRequest {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCToClientPollConvarRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPollConvarResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPollConvarResponse {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCToClientPollConvarResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgCompressedMsgToClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCMasterBroadcastMessage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCMasterSubscribeToCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCMasterSubscribeToCacheResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCMasterSubscribeToCacheAsync {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCMasterUnsubscribeFromCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCMasterDestroyCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
