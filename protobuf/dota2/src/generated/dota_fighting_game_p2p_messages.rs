// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_fighting_game_p2p_messages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgFightingGame_GameData_Fighting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFightingGame_GameData_Fighting {
    // message fields
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.last_acked_frame)
    pub last_acked_frame: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.last_crc_frame)
    pub last_crc_frame: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.last_crc_value)
    pub last_crc_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.now)
    pub now: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.peer_ack_time)
    pub peer_ack_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.input_start_frame)
    pub input_start_frame: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.input_sample)
    pub input_sample: ::std::vec::Vec<cmsg_fighting_game_game_data_fighting::InputSample>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFightingGame_GameData_Fighting.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFightingGame_GameData_Fighting {
    fn default() -> &'a CMsgFightingGame_GameData_Fighting {
        <CMsgFightingGame_GameData_Fighting as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFightingGame_GameData_Fighting {
    pub fn new() -> CMsgFightingGame_GameData_Fighting {
        ::std::default::Default::default()
    }

    // optional int32 last_acked_frame = 1;

    pub fn last_acked_frame(&self) -> i32 {
        self.last_acked_frame.unwrap_or(0)
    }

    pub fn clear_last_acked_frame(&mut self) {
        self.last_acked_frame = ::std::option::Option::None;
    }

    pub fn has_last_acked_frame(&self) -> bool {
        self.last_acked_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_acked_frame(&mut self, v: i32) {
        self.last_acked_frame = ::std::option::Option::Some(v);
    }

    // optional uint32 player_id = 2;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 last_crc_frame = 3;

    pub fn last_crc_frame(&self) -> i32 {
        self.last_crc_frame.unwrap_or(0)
    }

    pub fn clear_last_crc_frame(&mut self) {
        self.last_crc_frame = ::std::option::Option::None;
    }

    pub fn has_last_crc_frame(&self) -> bool {
        self.last_crc_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_crc_frame(&mut self, v: i32) {
        self.last_crc_frame = ::std::option::Option::Some(v);
    }

    // optional uint32 last_crc_value = 4;

    pub fn last_crc_value(&self) -> u32 {
        self.last_crc_value.unwrap_or(0)
    }

    pub fn clear_last_crc_value(&mut self) {
        self.last_crc_value = ::std::option::Option::None;
    }

    pub fn has_last_crc_value(&self) -> bool {
        self.last_crc_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_crc_value(&mut self, v: u32) {
        self.last_crc_value = ::std::option::Option::Some(v);
    }

    // optional float now = 5;

    pub fn now(&self) -> f32 {
        self.now.unwrap_or(0.)
    }

    pub fn clear_now(&mut self) {
        self.now = ::std::option::Option::None;
    }

    pub fn has_now(&self) -> bool {
        self.now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_now(&mut self, v: f32) {
        self.now = ::std::option::Option::Some(v);
    }

    // optional float peer_ack_time = 6;

    pub fn peer_ack_time(&self) -> f32 {
        self.peer_ack_time.unwrap_or(0.)
    }

    pub fn clear_peer_ack_time(&mut self) {
        self.peer_ack_time = ::std::option::Option::None;
    }

    pub fn has_peer_ack_time(&self) -> bool {
        self.peer_ack_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_ack_time(&mut self, v: f32) {
        self.peer_ack_time = ::std::option::Option::Some(v);
    }

    // optional int32 input_start_frame = 7;

    pub fn input_start_frame(&self) -> i32 {
        self.input_start_frame.unwrap_or(0)
    }

    pub fn clear_input_start_frame(&mut self) {
        self.input_start_frame = ::std::option::Option::None;
    }

    pub fn has_input_start_frame(&self) -> bool {
        self.input_start_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_start_frame(&mut self, v: i32) {
        self.input_start_frame = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFightingGame_GameData_Fighting {
    const NAME: &'static str = "CMsgFightingGame_GameData_Fighting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_acked_frame = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.last_crc_frame = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.last_crc_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.now = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.peer_ack_time = ::std::option::Option::Some(is.read_float()?);
                },
                56 => {
                    self.input_start_frame = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.input_sample.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.last_acked_frame {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.last_crc_frame {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.last_crc_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.now {
            my_size += 1 + 4;
        }
        if let Some(v) = self.peer_ack_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.input_start_frame {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        for value in &self.input_sample {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.last_acked_frame {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_crc_frame {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.last_crc_value {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.now {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.peer_ack_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.input_start_frame {
            os.write_int32(7, v)?;
        }
        for v in &self.input_sample {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFightingGame_GameData_Fighting {
        CMsgFightingGame_GameData_Fighting::new()
    }

    fn clear(&mut self) {
        self.last_acked_frame = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.last_crc_frame = ::std::option::Option::None;
        self.last_crc_value = ::std::option::Option::None;
        self.now = ::std::option::Option::None;
        self.peer_ack_time = ::std::option::Option::None;
        self.input_start_frame = ::std::option::Option::None;
        self.input_sample.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFightingGame_GameData_Fighting {
        static instance: CMsgFightingGame_GameData_Fighting = CMsgFightingGame_GameData_Fighting {
            last_acked_frame: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            last_crc_frame: ::std::option::Option::None,
            last_crc_value: ::std::option::Option::None,
            now: ::std::option::Option::None,
            peer_ack_time: ::std::option::Option::None,
            input_start_frame: ::std::option::Option::None,
            input_sample: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgFightingGame_GameData_Fighting`
pub mod cmsg_fighting_game_game_data_fighting {
    // @@protoc_insertion_point(message:CMsgFightingGame_GameData_Fighting.InputSample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InputSample {
        // message fields
        // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Fighting.InputSample.button_mask)
        pub button_mask: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFightingGame_GameData_Fighting.InputSample.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InputSample {
        fn default() -> &'a InputSample {
            <InputSample as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl InputSample {
        pub fn new() -> InputSample {
            ::std::default::Default::default()
        }

        // optional uint32 button_mask = 1;

        pub fn button_mask(&self) -> u32 {
            self.button_mask.unwrap_or(0)
        }

        pub fn clear_button_mask(&mut self) {
            self.button_mask = ::std::option::Option::None;
        }

        pub fn has_button_mask(&self) -> bool {
            self.button_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_button_mask(&mut self, v: u32) {
            self.button_mask = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for InputSample {
        const NAME: &'static str = "InputSample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.button_mask = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.button_mask {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.button_mask {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InputSample {
            InputSample::new()
        }

        fn clear(&mut self) {
            self.button_mask = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InputSample {
            static instance: InputSample = InputSample {
                button_mask: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgFightingGame_GameData_CharacterSelect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFightingGame_GameData_CharacterSelect {
    // message fields
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.cursor_index)
    pub cursor_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.selected_hero_id)
    pub selected_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.selected_style)
    pub selected_style: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.econ_item_refs)
    pub econ_item_refs: ::std::vec::Vec<cmsg_fighting_game_game_data_character_select::Item>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.message_ack)
    pub message_ack: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.confirmed_style)
    pub confirmed_style: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFightingGame_GameData_CharacterSelect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFightingGame_GameData_CharacterSelect {
    fn default() -> &'a CMsgFightingGame_GameData_CharacterSelect {
        <CMsgFightingGame_GameData_CharacterSelect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFightingGame_GameData_CharacterSelect {
    pub fn new() -> CMsgFightingGame_GameData_CharacterSelect {
        ::std::default::Default::default()
    }

    // optional uint32 cursor_index = 1;

    pub fn cursor_index(&self) -> u32 {
        self.cursor_index.unwrap_or(0)
    }

    pub fn clear_cursor_index(&mut self) {
        self.cursor_index = ::std::option::Option::None;
    }

    pub fn has_cursor_index(&self) -> bool {
        self.cursor_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_index(&mut self, v: u32) {
        self.cursor_index = ::std::option::Option::Some(v);
    }

    // optional int32 selected_hero_id = 2;

    pub fn selected_hero_id(&self) -> i32 {
        self.selected_hero_id.unwrap_or(0)
    }

    pub fn clear_selected_hero_id(&mut self) {
        self.selected_hero_id = ::std::option::Option::None;
    }

    pub fn has_selected_hero_id(&self) -> bool {
        self.selected_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_hero_id(&mut self, v: i32) {
        self.selected_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_style = 3;

    pub fn selected_style(&self) -> u32 {
        self.selected_style.unwrap_or(0)
    }

    pub fn clear_selected_style(&mut self) {
        self.selected_style = ::std::option::Option::None;
    }

    pub fn has_selected_style(&self) -> bool {
        self.selected_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_style(&mut self, v: u32) {
        self.selected_style = ::std::option::Option::Some(v);
    }

    // optional int64 message_ack = 5;

    pub fn message_ack(&self) -> i64 {
        self.message_ack.unwrap_or(0)
    }

    pub fn clear_message_ack(&mut self) {
        self.message_ack = ::std::option::Option::None;
    }

    pub fn has_message_ack(&self) -> bool {
        self.message_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_ack(&mut self, v: i64) {
        self.message_ack = ::std::option::Option::Some(v);
    }

    // optional bool confirmed_style = 6;

    pub fn confirmed_style(&self) -> bool {
        self.confirmed_style.unwrap_or(false)
    }

    pub fn clear_confirmed_style(&mut self) {
        self.confirmed_style = ::std::option::Option::None;
    }

    pub fn has_confirmed_style(&self) -> bool {
        self.confirmed_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirmed_style(&mut self, v: bool) {
        self.confirmed_style = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFightingGame_GameData_CharacterSelect {
    const NAME: &'static str = "CMsgFightingGame_GameData_CharacterSelect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.selected_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.selected_style = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.econ_item_refs.push(is.read_message()?);
                },
                40 => {
                    self.message_ack = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.confirmed_style = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.selected_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.selected_style {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.econ_item_refs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.message_ack {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.confirmed_style {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cursor_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.selected_hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.selected_style {
            os.write_uint32(3, v)?;
        }
        for v in &self.econ_item_refs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.message_ack {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.confirmed_style {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFightingGame_GameData_CharacterSelect {
        CMsgFightingGame_GameData_CharacterSelect::new()
    }

    fn clear(&mut self) {
        self.cursor_index = ::std::option::Option::None;
        self.selected_hero_id = ::std::option::Option::None;
        self.selected_style = ::std::option::Option::None;
        self.econ_item_refs.clear();
        self.message_ack = ::std::option::Option::None;
        self.confirmed_style = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFightingGame_GameData_CharacterSelect {
        static instance: CMsgFightingGame_GameData_CharacterSelect = CMsgFightingGame_GameData_CharacterSelect {
            cursor_index: ::std::option::Option::None,
            selected_hero_id: ::std::option::Option::None,
            selected_style: ::std::option::Option::None,
            econ_item_refs: ::std::vec::Vec::new(),
            message_ack: ::std::option::Option::None,
            confirmed_style: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgFightingGame_GameData_CharacterSelect`
pub mod cmsg_fighting_game_game_data_character_select {
    // @@protoc_insertion_point(message:CMsgFightingGame_GameData_CharacterSelect.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.Item.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgFightingGame_GameData_CharacterSelect.Item.style_index)
        pub style_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFightingGame_GameData_CharacterSelect.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 style_index = 2;

        pub fn style_index(&self) -> u32 {
            self.style_index.unwrap_or(255u32)
        }

        pub fn clear_style_index(&mut self) {
            self.style_index = ::std::option::Option::None;
        }

        pub fn has_style_index(&self) -> bool {
            self.style_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_style_index(&mut self, v: u32) {
            self.style_index = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.style_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.style_index {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.style_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_def: ::std::option::Option::None,
                style_index: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgFightingGame_GameData_Loaded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFightingGame_GameData_Loaded {
    // message fields
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Loaded.now)
    pub now: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Loaded.peer_ack_time)
    pub peer_ack_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Loaded.proposed_start_time)
    pub proposed_start_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgFightingGame_GameData_Loaded.accepted_start_time)
    pub accepted_start_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFightingGame_GameData_Loaded.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFightingGame_GameData_Loaded {
    fn default() -> &'a CMsgFightingGame_GameData_Loaded {
        <CMsgFightingGame_GameData_Loaded as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFightingGame_GameData_Loaded {
    pub fn new() -> CMsgFightingGame_GameData_Loaded {
        ::std::default::Default::default()
    }

    // optional float now = 1;

    pub fn now(&self) -> f32 {
        self.now.unwrap_or(0.)
    }

    pub fn clear_now(&mut self) {
        self.now = ::std::option::Option::None;
    }

    pub fn has_now(&self) -> bool {
        self.now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_now(&mut self, v: f32) {
        self.now = ::std::option::Option::Some(v);
    }

    // optional float peer_ack_time = 2;

    pub fn peer_ack_time(&self) -> f32 {
        self.peer_ack_time.unwrap_or(0.)
    }

    pub fn clear_peer_ack_time(&mut self) {
        self.peer_ack_time = ::std::option::Option::None;
    }

    pub fn has_peer_ack_time(&self) -> bool {
        self.peer_ack_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_ack_time(&mut self, v: f32) {
        self.peer_ack_time = ::std::option::Option::Some(v);
    }

    // optional float proposed_start_time = 3;

    pub fn proposed_start_time(&self) -> f32 {
        self.proposed_start_time.unwrap_or(0.)
    }

    pub fn clear_proposed_start_time(&mut self) {
        self.proposed_start_time = ::std::option::Option::None;
    }

    pub fn has_proposed_start_time(&self) -> bool {
        self.proposed_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposed_start_time(&mut self, v: f32) {
        self.proposed_start_time = ::std::option::Option::Some(v);
    }

    // optional float accepted_start_time = 4;

    pub fn accepted_start_time(&self) -> f32 {
        self.accepted_start_time.unwrap_or(0.)
    }

    pub fn clear_accepted_start_time(&mut self) {
        self.accepted_start_time = ::std::option::Option::None;
    }

    pub fn has_accepted_start_time(&self) -> bool {
        self.accepted_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accepted_start_time(&mut self, v: f32) {
        self.accepted_start_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFightingGame_GameData_Loaded {
    const NAME: &'static str = "CMsgFightingGame_GameData_Loaded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.now = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.peer_ack_time = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.proposed_start_time = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.accepted_start_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.now {
            my_size += 1 + 4;
        }
        if let Some(v) = self.peer_ack_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.proposed_start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.accepted_start_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.now {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.peer_ack_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.proposed_start_time {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.accepted_start_time {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFightingGame_GameData_Loaded {
        CMsgFightingGame_GameData_Loaded::new()
    }

    fn clear(&mut self) {
        self.now = ::std::option::Option::None;
        self.peer_ack_time = ::std::option::Option::None;
        self.proposed_start_time = ::std::option::Option::None;
        self.accepted_start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFightingGame_GameData_Loaded {
        static instance: CMsgFightingGame_GameData_Loaded = CMsgFightingGame_GameData_Loaded {
            now: ::std::option::Option::None,
            peer_ack_time: ::std::option::Option::None,
            proposed_start_time: ::std::option::Option::None,
            accepted_start_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CP2P_FightingGame_GameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CP2P_FightingGame_GameData {
    // message fields
    // @@protoc_insertion_point(field:CP2P_FightingGame_GameData.state)
    pub state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cp2p_fighting_game_game_data::EState>>,
    // message oneof groups
    pub state_data: ::std::option::Option<cp2p_fighting_game_game_data::State_data>,
    // special fields
    // @@protoc_insertion_point(special_field:CP2P_FightingGame_GameData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CP2P_FightingGame_GameData {
    fn default() -> &'a CP2P_FightingGame_GameData {
        <CP2P_FightingGame_GameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CP2P_FightingGame_GameData {
    pub fn new() -> CP2P_FightingGame_GameData {
        ::std::default::Default::default()
    }

    // optional .CP2P_FightingGame_GameData.EState state = 1;

    pub fn state(&self) -> cp2p_fighting_game_game_data::EState {
        match self.state {
            Some(e) => e.enum_value_or(cp2p_fighting_game_game_data::EState::k_ChoosingCharacter),
            None => cp2p_fighting_game_game_data::EState::k_ChoosingCharacter,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: cp2p_fighting_game_game_data::EState) {
        self.state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgFightingGame_GameData_Fighting fight = 2;

    pub fn fight(&self) -> &CMsgFightingGame_GameData_Fighting {
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(ref v)) => v,
            _ => <CMsgFightingGame_GameData_Fighting as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fight(&mut self) {
        self.state_data = ::std::option::Option::None;
    }

    pub fn has_fight(&self) -> bool {
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fight(&mut self, v: CMsgFightingGame_GameData_Fighting) {
        self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fight(&mut self) -> &mut CMsgFightingGame_GameData_Fighting {
        if let ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(_)) = self.state_data {
        } else {
            self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(CMsgFightingGame_GameData_Fighting::new()));
        }
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fight(&mut self) -> CMsgFightingGame_GameData_Fighting {
        if self.has_fight() {
            match self.state_data.take() {
                ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgFightingGame_GameData_Fighting::new()
        }
    }

    // optional .CMsgFightingGame_GameData_CharacterSelect character_select = 3;

    pub fn character_select(&self) -> &CMsgFightingGame_GameData_CharacterSelect {
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(ref v)) => v,
            _ => <CMsgFightingGame_GameData_CharacterSelect as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_character_select(&mut self) {
        self.state_data = ::std::option::Option::None;
    }

    pub fn has_character_select(&self) -> bool {
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_character_select(&mut self, v: CMsgFightingGame_GameData_CharacterSelect) {
        self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_character_select(&mut self) -> &mut CMsgFightingGame_GameData_CharacterSelect {
        if let ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(_)) = self.state_data {
        } else {
            self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(CMsgFightingGame_GameData_CharacterSelect::new()));
        }
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_character_select(&mut self) -> CMsgFightingGame_GameData_CharacterSelect {
        if self.has_character_select() {
            match self.state_data.take() {
                ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgFightingGame_GameData_CharacterSelect::new()
        }
    }

    // optional .CMsgFightingGame_GameData_Loaded loaded = 4;

    pub fn loaded(&self) -> &CMsgFightingGame_GameData_Loaded {
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(ref v)) => v,
            _ => <CMsgFightingGame_GameData_Loaded as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_loaded(&mut self) {
        self.state_data = ::std::option::Option::None;
    }

    pub fn has_loaded(&self) -> bool {
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_loaded(&mut self, v: CMsgFightingGame_GameData_Loaded) {
        self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(v))
    }

    // Mutable pointer to the field.
    pub fn mut_loaded(&mut self) -> &mut CMsgFightingGame_GameData_Loaded {
        if let ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(_)) = self.state_data {
        } else {
            self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(CMsgFightingGame_GameData_Loaded::new()));
        }
        match self.state_data {
            ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_loaded(&mut self) -> CMsgFightingGame_GameData_Loaded {
        if self.has_loaded() {
            match self.state_data.take() {
                ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgFightingGame_GameData_Loaded::new()
        }
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CP2P_FightingGame_GameData {
    const NAME: &'static str = "CP2P_FightingGame_GameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Fight(is.read_message()?));
                },
                26 => {
                    self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::CharacterSelect(is.read_message()?));
                },
                34 => {
                    self.state_data = ::std::option::Option::Some(cp2p_fighting_game_game_data::State_data::Loaded(is.read_message()?));
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.state_data {
            match v {
                &cp2p_fighting_game_game_data::State_data::Fight(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cp2p_fighting_game_game_data::State_data::CharacterSelect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cp2p_fighting_game_game_data::State_data::Loaded(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.state_data {
            match v {
                &cp2p_fighting_game_game_data::State_data::Fight(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cp2p_fighting_game_game_data::State_data::CharacterSelect(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cp2p_fighting_game_game_data::State_data::Loaded(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CP2P_FightingGame_GameData {
        CP2P_FightingGame_GameData::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.state_data = ::std::option::Option::None;
        self.state_data = ::std::option::Option::None;
        self.state_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CP2P_FightingGame_GameData {
        static instance: CP2P_FightingGame_GameData = CP2P_FightingGame_GameData {
            state: ::std::option::Option::None,
            state_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CP2P_FightingGame_GameData`
pub mod cp2p_fighting_game_game_data {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CP2P_FightingGame_GameData.state_data)
    pub enum State_data {
        // @@protoc_insertion_point(oneof_field:CP2P_FightingGame_GameData.fight)
        Fight(super::CMsgFightingGame_GameData_Fighting),
        // @@protoc_insertion_point(oneof_field:CP2P_FightingGame_GameData.character_select)
        CharacterSelect(super::CMsgFightingGame_GameData_CharacterSelect),
        // @@protoc_insertion_point(oneof_field:CP2P_FightingGame_GameData.loaded)
        Loaded(super::CMsgFightingGame_GameData_Loaded),
    }

    impl ::steam_vent_proto_common::protobuf::Oneof for State_data {
    }

    impl State_data {
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CP2P_FightingGame_GameData.EState)
    pub enum EState {
        // @@protoc_insertion_point(enum_value:CP2P_FightingGame_GameData.EState.k_ChoosingCharacter)
        k_ChoosingCharacter = 1,
        // @@protoc_insertion_point(enum_value:CP2P_FightingGame_GameData.EState.k_Loaded)
        k_Loaded = 2,
        // @@protoc_insertion_point(enum_value:CP2P_FightingGame_GameData.EState.k_Fighting)
        k_Fighting = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EState {
        const NAME: &'static str = "EState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EState> {
            match value {
                1 => ::std::option::Option::Some(EState::k_ChoosingCharacter),
                2 => ::std::option::Option::Some(EState::k_Loaded),
                3 => ::std::option::Option::Some(EState::k_Fighting),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EState> {
            match str {
                "k_ChoosingCharacter" => ::std::option::Option::Some(EState::k_ChoosingCharacter),
                "k_Loaded" => ::std::option::Option::Some(EState::k_Loaded),
                "k_Fighting" => ::std::option::Option::Some(EState::k_Fighting),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EState] = &[
            EState::k_ChoosingCharacter,
            EState::k_Loaded,
            EState::k_Fighting,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EState {
        fn default() -> Self {
            EState::k_ChoosingCharacter
        }
    }

}


const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::netmessages::*;
#[allow(unused_imports)]
use crate::networkbasetypes::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgFightingGame_GameData_Fighting {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgFightingGame_GameData_CharacterSelect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgFightingGame_GameData_Loaded {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CP2P_FightingGame_GameData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
