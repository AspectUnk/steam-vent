// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_webapi.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgArcanaVotes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgArcanaVotes {
    // message fields
    // @@protoc_insertion_point(field:CMsgArcanaVotes.matches)
    pub matches: ::std::vec::Vec<cmsg_arcana_votes::Match>,
    // @@protoc_insertion_point(field:CMsgArcanaVotes.round_time_remaining)
    pub round_time_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgArcanaVotes.round_number)
    pub round_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgArcanaVotes.voting_state)
    pub voting_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgArcanaVotes.is_current_round_calibrating)
    pub is_current_round_calibrating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgArcanaVotes.closest_active_match_id)
    pub closest_active_match_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgArcanaVotes.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgArcanaVotes.voting_start_time)
    pub voting_start_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgArcanaVotes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgArcanaVotes {
    fn default() -> &'a CMsgArcanaVotes {
        <CMsgArcanaVotes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgArcanaVotes {
    pub fn new() -> CMsgArcanaVotes {
        ::std::default::Default::default()
    }

    // optional uint32 round_time_remaining = 2;

    pub fn round_time_remaining(&self) -> u32 {
        self.round_time_remaining.unwrap_or(0)
    }

    pub fn clear_round_time_remaining(&mut self) {
        self.round_time_remaining = ::std::option::Option::None;
    }

    pub fn has_round_time_remaining(&self) -> bool {
        self.round_time_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_time_remaining(&mut self, v: u32) {
        self.round_time_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 round_number = 3;

    pub fn round_number(&self) -> u32 {
        self.round_number.unwrap_or(0)
    }

    pub fn clear_round_number(&mut self) {
        self.round_number = ::std::option::Option::None;
    }

    pub fn has_round_number(&self) -> bool {
        self.round_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_number(&mut self, v: u32) {
        self.round_number = ::std::option::Option::Some(v);
    }

    // optional uint32 voting_state = 4;

    pub fn voting_state(&self) -> u32 {
        self.voting_state.unwrap_or(0)
    }

    pub fn clear_voting_state(&mut self) {
        self.voting_state = ::std::option::Option::None;
    }

    pub fn has_voting_state(&self) -> bool {
        self.voting_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voting_state(&mut self, v: u32) {
        self.voting_state = ::std::option::Option::Some(v);
    }

    // optional bool is_current_round_calibrating = 5;

    pub fn is_current_round_calibrating(&self) -> bool {
        self.is_current_round_calibrating.unwrap_or(false)
    }

    pub fn clear_is_current_round_calibrating(&mut self) {
        self.is_current_round_calibrating = ::std::option::Option::None;
    }

    pub fn has_is_current_round_calibrating(&self) -> bool {
        self.is_current_round_calibrating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_current_round_calibrating(&mut self, v: bool) {
        self.is_current_round_calibrating = ::std::option::Option::Some(v);
    }

    // optional uint32 closest_active_match_id = 6;

    pub fn closest_active_match_id(&self) -> u32 {
        self.closest_active_match_id.unwrap_or(0)
    }

    pub fn clear_closest_active_match_id(&mut self) {
        self.closest_active_match_id = ::std::option::Option::None;
    }

    pub fn has_closest_active_match_id(&self) -> bool {
        self.closest_active_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closest_active_match_id(&mut self, v: u32) {
        self.closest_active_match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 7;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 voting_start_time = 8;

    pub fn voting_start_time(&self) -> u32 {
        self.voting_start_time.unwrap_or(0)
    }

    pub fn clear_voting_start_time(&mut self) {
        self.voting_start_time = ::std::option::Option::None;
    }

    pub fn has_voting_start_time(&self) -> bool {
        self.voting_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voting_start_time(&mut self, v: u32) {
        self.voting_start_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgArcanaVotes {
    const NAME: &'static str = "CMsgArcanaVotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                16 => {
                    self.round_time_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.round_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.voting_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.is_current_round_calibrating = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.closest_active_match_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.voting_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.round_time_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.round_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.voting_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.is_current_round_calibrating {
            my_size += 1 + 1;
        }
        if let Some(v) = self.closest_active_match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.voting_start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.matches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.round_time_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.round_number {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.voting_state {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_current_round_calibrating {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.closest_active_match_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.voting_start_time {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgArcanaVotes {
        CMsgArcanaVotes::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.round_time_remaining = ::std::option::Option::None;
        self.round_number = ::std::option::Option::None;
        self.voting_state = ::std::option::Option::None;
        self.is_current_round_calibrating = ::std::option::Option::None;
        self.closest_active_match_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.voting_start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgArcanaVotes {
        static instance: CMsgArcanaVotes = CMsgArcanaVotes {
            matches: ::std::vec::Vec::new(),
            round_time_remaining: ::std::option::Option::None,
            round_number: ::std::option::Option::None,
            voting_state: ::std::option::Option::None,
            is_current_round_calibrating: ::std::option::Option::None,
            closest_active_match_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            voting_start_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgArcanaVotes`
pub mod cmsg_arcana_votes {
    // @@protoc_insertion_point(message:CMsgArcanaVotes.Match)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Match {
        // message fields
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.match_id)
        pub match_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.hero_id_0)
        pub hero_id_0: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.hero_id_1)
        pub hero_id_1: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.hero_seeding_0)
        pub hero_seeding_0: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.hero_seeding_1)
        pub hero_seeding_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.vote_count_0)
        pub vote_count_0: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.vote_count_1)
        pub vote_count_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.voting_state)
        pub voting_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.round_number)
        pub round_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.is_votes_hidden)
        pub is_votes_hidden: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgArcanaVotes.Match.calibration_time_remaining)
        pub calibration_time_remaining: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgArcanaVotes.Match.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Match {
        fn default() -> &'a Match {
            <Match as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Match {
        pub fn new() -> Match {
            ::std::default::Default::default()
        }

        // optional uint32 match_id = 1;

        pub fn match_id(&self) -> u32 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u32) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id_0 = 2;

        pub fn hero_id_0(&self) -> i32 {
            self.hero_id_0.unwrap_or(0)
        }

        pub fn clear_hero_id_0(&mut self) {
            self.hero_id_0 = ::std::option::Option::None;
        }

        pub fn has_hero_id_0(&self) -> bool {
            self.hero_id_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id_0(&mut self, v: i32) {
            self.hero_id_0 = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id_1 = 3;

        pub fn hero_id_1(&self) -> i32 {
            self.hero_id_1.unwrap_or(0)
        }

        pub fn clear_hero_id_1(&mut self) {
            self.hero_id_1 = ::std::option::Option::None;
        }

        pub fn has_hero_id_1(&self) -> bool {
            self.hero_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id_1(&mut self, v: i32) {
            self.hero_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_seeding_0 = 4;

        pub fn hero_seeding_0(&self) -> u32 {
            self.hero_seeding_0.unwrap_or(0)
        }

        pub fn clear_hero_seeding_0(&mut self) {
            self.hero_seeding_0 = ::std::option::Option::None;
        }

        pub fn has_hero_seeding_0(&self) -> bool {
            self.hero_seeding_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_seeding_0(&mut self, v: u32) {
            self.hero_seeding_0 = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_seeding_1 = 5;

        pub fn hero_seeding_1(&self) -> u32 {
            self.hero_seeding_1.unwrap_or(0)
        }

        pub fn clear_hero_seeding_1(&mut self) {
            self.hero_seeding_1 = ::std::option::Option::None;
        }

        pub fn has_hero_seeding_1(&self) -> bool {
            self.hero_seeding_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_seeding_1(&mut self, v: u32) {
            self.hero_seeding_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 vote_count_0 = 6;

        pub fn vote_count_0(&self) -> u32 {
            self.vote_count_0.unwrap_or(0)
        }

        pub fn clear_vote_count_0(&mut self) {
            self.vote_count_0 = ::std::option::Option::None;
        }

        pub fn has_vote_count_0(&self) -> bool {
            self.vote_count_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_count_0(&mut self, v: u32) {
            self.vote_count_0 = ::std::option::Option::Some(v);
        }

        // optional uint32 vote_count_1 = 7;

        pub fn vote_count_1(&self) -> u32 {
            self.vote_count_1.unwrap_or(0)
        }

        pub fn clear_vote_count_1(&mut self) {
            self.vote_count_1 = ::std::option::Option::None;
        }

        pub fn has_vote_count_1(&self) -> bool {
            self.vote_count_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_count_1(&mut self, v: u32) {
            self.vote_count_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 voting_state = 8;

        pub fn voting_state(&self) -> u32 {
            self.voting_state.unwrap_or(0)
        }

        pub fn clear_voting_state(&mut self) {
            self.voting_state = ::std::option::Option::None;
        }

        pub fn has_voting_state(&self) -> bool {
            self.voting_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voting_state(&mut self, v: u32) {
            self.voting_state = ::std::option::Option::Some(v);
        }

        // optional uint32 round_number = 9;

        pub fn round_number(&self) -> u32 {
            self.round_number.unwrap_or(0)
        }

        pub fn clear_round_number(&mut self) {
            self.round_number = ::std::option::Option::None;
        }

        pub fn has_round_number(&self) -> bool {
            self.round_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_round_number(&mut self, v: u32) {
            self.round_number = ::std::option::Option::Some(v);
        }

        // optional bool is_votes_hidden = 10;

        pub fn is_votes_hidden(&self) -> bool {
            self.is_votes_hidden.unwrap_or(false)
        }

        pub fn clear_is_votes_hidden(&mut self) {
            self.is_votes_hidden = ::std::option::Option::None;
        }

        pub fn has_is_votes_hidden(&self) -> bool {
            self.is_votes_hidden.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_votes_hidden(&mut self, v: bool) {
            self.is_votes_hidden = ::std::option::Option::Some(v);
        }

        // optional uint32 calibration_time_remaining = 11;

        pub fn calibration_time_remaining(&self) -> u32 {
            self.calibration_time_remaining.unwrap_or(0)
        }

        pub fn clear_calibration_time_remaining(&mut self) {
            self.calibration_time_remaining = ::std::option::Option::None;
        }

        pub fn has_calibration_time_remaining(&self) -> bool {
            self.calibration_time_remaining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_calibration_time_remaining(&mut self, v: u32) {
            self.calibration_time_remaining = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Match {
        const NAME: &'static str = "Match";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id_0 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.hero_id_1 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.hero_seeding_0 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.hero_seeding_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.vote_count_0 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.vote_count_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.voting_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.round_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.is_votes_hidden = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.calibration_time_remaining = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id_0 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.hero_id_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.hero_seeding_0 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.hero_seeding_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.vote_count_0 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.vote_count_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.voting_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.round_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.is_votes_hidden {
                my_size += 1 + 1;
            }
            if let Some(v) = self.calibration_time_remaining {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id_0 {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.hero_id_1 {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.hero_seeding_0 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.hero_seeding_1 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.vote_count_0 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.vote_count_1 {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.voting_state {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.round_number {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.is_votes_hidden {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.calibration_time_remaining {
                os.write_uint32(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Match {
            Match::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.hero_id_0 = ::std::option::Option::None;
            self.hero_id_1 = ::std::option::Option::None;
            self.hero_seeding_0 = ::std::option::Option::None;
            self.hero_seeding_1 = ::std::option::Option::None;
            self.vote_count_0 = ::std::option::Option::None;
            self.vote_count_1 = ::std::option::Option::None;
            self.voting_state = ::std::option::Option::None;
            self.round_number = ::std::option::Option::None;
            self.is_votes_hidden = ::std::option::Option::None;
            self.calibration_time_remaining = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Match {
            static instance: Match = Match {
                match_id: ::std::option::Option::None,
                hero_id_0: ::std::option::Option::None,
                hero_id_1: ::std::option::Option::None,
                hero_seeding_0: ::std::option::Option::None,
                hero_seeding_1: ::std::option::Option::None,
                vote_count_0: ::std::option::Option::None,
                vote_count_1: ::std::option::Option::None,
                voting_state: ::std::option::Option::None,
                round_number: ::std::option::Option::None,
                is_votes_hidden: ::std::option::Option::None,
                calibration_time_remaining: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgArcanaVotes.VotingState)
    pub enum VotingState {
        // @@protoc_insertion_point(enum_value:CMsgArcanaVotes.VotingState.FINISHED)
        FINISHED = 0,
        // @@protoc_insertion_point(enum_value:CMsgArcanaVotes.VotingState.IN_PROGRESS)
        IN_PROGRESS = 1,
        // @@protoc_insertion_point(enum_value:CMsgArcanaVotes.VotingState.IN_FUTURE)
        IN_FUTURE = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for VotingState {
        const NAME: &'static str = "VotingState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<VotingState> {
            match value {
                0 => ::std::option::Option::Some(VotingState::FINISHED),
                1 => ::std::option::Option::Some(VotingState::IN_PROGRESS),
                2 => ::std::option::Option::Some(VotingState::IN_FUTURE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<VotingState> {
            match str {
                "FINISHED" => ::std::option::Option::Some(VotingState::FINISHED),
                "IN_PROGRESS" => ::std::option::Option::Some(VotingState::IN_PROGRESS),
                "IN_FUTURE" => ::std::option::Option::Some(VotingState::IN_FUTURE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [VotingState] = &[
            VotingState::FINISHED,
            VotingState::IN_PROGRESS,
            VotingState::IN_FUTURE,
        ];
    }

    impl ::std::default::Default for VotingState {
        fn default() -> Self {
            VotingState::FINISHED
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTADPCFeed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCFeed {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADPCFeed.elements)
    pub elements: ::std::vec::Vec<cmsg_dotadpcfeed::Element>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADPCFeed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCFeed {
    fn default() -> &'a CMsgDOTADPCFeed {
        <CMsgDOTADPCFeed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCFeed {
    pub fn new() -> CMsgDOTADPCFeed {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADPCFeed {
    const NAME: &'static str = "CMsgDOTADPCFeed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.elements.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.elements {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCFeed {
        CMsgDOTADPCFeed::new()
    }

    fn clear(&mut self) {
        self.elements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCFeed {
        static instance: CMsgDOTADPCFeed = CMsgDOTADPCFeed {
            elements: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTADPCFeed`
pub mod cmsg_dotadpcfeed {
    // @@protoc_insertion_point(message:CMsgDOTADPCFeed.Element)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Element {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.type)
        pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EFeedElementType>>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.series_id)
        pub series_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.data_1)
        pub data_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.data_2)
        pub data_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.data_3)
        pub data_3: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCFeed.Element.data_4)
        pub data_4: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTADPCFeed.Element.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Element {
        fn default() -> &'a Element {
            <Element as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Element {
        pub fn new() -> Element {
            ::std::default::Default::default()
        }

        // optional .CMsgDOTADPCFeed.EFeedElementType type = 1;

        pub fn type_(&self) -> EFeedElementType {
            match self.type_ {
                Some(e) => e.enum_value_or(EFeedElementType::FEED_SERIES_RESULT),
                None => EFeedElementType::FEED_SERIES_RESULT,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: EFeedElementType) {
            self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 series_id = 3;

        pub fn series_id(&self) -> u32 {
            self.series_id.unwrap_or(0)
        }

        pub fn clear_series_id(&mut self) {
            self.series_id = ::std::option::Option::None;
        }

        pub fn has_series_id(&self) -> bool {
            self.series_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_id(&mut self, v: u32) {
            self.series_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 4;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 5;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 6;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 7;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 node_id = 8;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }

        // optional uint64 server_steam_id = 13;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 data_1 = 9;

        pub fn data_1(&self) -> u32 {
            self.data_1.unwrap_or(0)
        }

        pub fn clear_data_1(&mut self) {
            self.data_1 = ::std::option::Option::None;
        }

        pub fn has_data_1(&self) -> bool {
            self.data_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_1(&mut self, v: u32) {
            self.data_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 data_2 = 10;

        pub fn data_2(&self) -> u32 {
            self.data_2.unwrap_or(0)
        }

        pub fn clear_data_2(&mut self) {
            self.data_2 = ::std::option::Option::None;
        }

        pub fn has_data_2(&self) -> bool {
            self.data_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_2(&mut self, v: u32) {
            self.data_2 = ::std::option::Option::Some(v);
        }

        // optional uint32 data_3 = 11;

        pub fn data_3(&self) -> u32 {
            self.data_3.unwrap_or(0)
        }

        pub fn clear_data_3(&mut self) {
            self.data_3 = ::std::option::Option::None;
        }

        pub fn has_data_3(&self) -> bool {
            self.data_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_3(&mut self, v: u32) {
            self.data_3 = ::std::option::Option::Some(v);
        }

        // optional uint32 data_4 = 12;

        pub fn data_4(&self) -> u32 {
            self.data_4.unwrap_or(0)
        }

        pub fn clear_data_4(&mut self) {
            self.data_4 = ::std::option::Option::None;
        }

        pub fn has_data_4(&self) -> bool {
            self.data_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_4(&mut self, v: u32) {
            self.data_4 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Element {
        const NAME: &'static str = "Element";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.data_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.data_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.data_3 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.data_4 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.series_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.server_steam_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(13, v);
            }
            if let Some(v) = self.data_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.data_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.data_3 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.data_4 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.series_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.node_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.server_steam_id {
                os.write_uint64(13, v)?;
            }
            if let Some(v) = self.data_1 {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.data_2 {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.data_3 {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.data_4 {
                os.write_uint32(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Element {
            Element::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.series_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.node_id = ::std::option::Option::None;
            self.server_steam_id = ::std::option::Option::None;
            self.data_1 = ::std::option::Option::None;
            self.data_2 = ::std::option::Option::None;
            self.data_3 = ::std::option::Option::None;
            self.data_4 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Element {
            static instance: Element = Element {
                type_: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                series_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                node_id: ::std::option::Option::None,
                server_steam_id: ::std::option::Option::None,
                data_1: ::std::option::Option::None,
                data_2: ::std::option::Option::None,
                data_3: ::std::option::Option::None,
                data_4: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTADPCFeed.EFeedElementType)
    pub enum EFeedElementType {
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_SERIES_RESULT)
        FEED_SERIES_RESULT = 1,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_MATCH_POPULAR)
        FEED_MATCH_POPULAR = 2,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_UPCOMING_MATCH)
        FEED_TEAM_UPCOMING_MATCH = 3,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_LEAGUE_RESULT)
        FEED_TEAM_LEAGUE_RESULT = 4,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_ADD_PLAYER)
        FEED_TEAM_ADD_PLAYER = 5,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_REMOVE_PLAYER)
        FEED_TEAM_REMOVE_PLAYER = 6,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_TEAM_DISBAND)
        FEED_TEAM_DISBAND = 7,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_UPCOMING)
        FEED_LEAGUE_UPCOMING = 8,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_CONCLUDED)
        FEED_LEAGUE_CONCLUDED = 9,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_DPC_STANDINGS)
        FEED_DPC_STANDINGS = 10,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_ALERT_PREDICTIONS)
        FEED_ALERT_PREDICTIONS = 11,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_ALERT_FANTASY)
        FEED_ALERT_FANTASY = 12,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_LIVE_MATCH)
        FEED_LEAGUE_LIVE_MATCH = 13,
        // @@protoc_insertion_point(enum_value:CMsgDOTADPCFeed.EFeedElementType.FEED_LEAGUE_INPROGRESS_SERIES)
        FEED_LEAGUE_INPROGRESS_SERIES = 14,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EFeedElementType {
        const NAME: &'static str = "EFeedElementType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EFeedElementType> {
            match value {
                1 => ::std::option::Option::Some(EFeedElementType::FEED_SERIES_RESULT),
                2 => ::std::option::Option::Some(EFeedElementType::FEED_MATCH_POPULAR),
                3 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_UPCOMING_MATCH),
                4 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_LEAGUE_RESULT),
                5 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_ADD_PLAYER),
                6 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_REMOVE_PLAYER),
                7 => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_DISBAND),
                8 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_UPCOMING),
                9 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_CONCLUDED),
                10 => ::std::option::Option::Some(EFeedElementType::FEED_DPC_STANDINGS),
                11 => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_PREDICTIONS),
                12 => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_FANTASY),
                13 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_LIVE_MATCH),
                14 => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_INPROGRESS_SERIES),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EFeedElementType> {
            match str {
                "FEED_SERIES_RESULT" => ::std::option::Option::Some(EFeedElementType::FEED_SERIES_RESULT),
                "FEED_MATCH_POPULAR" => ::std::option::Option::Some(EFeedElementType::FEED_MATCH_POPULAR),
                "FEED_TEAM_UPCOMING_MATCH" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_UPCOMING_MATCH),
                "FEED_TEAM_LEAGUE_RESULT" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_LEAGUE_RESULT),
                "FEED_TEAM_ADD_PLAYER" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_ADD_PLAYER),
                "FEED_TEAM_REMOVE_PLAYER" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_REMOVE_PLAYER),
                "FEED_TEAM_DISBAND" => ::std::option::Option::Some(EFeedElementType::FEED_TEAM_DISBAND),
                "FEED_LEAGUE_UPCOMING" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_UPCOMING),
                "FEED_LEAGUE_CONCLUDED" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_CONCLUDED),
                "FEED_DPC_STANDINGS" => ::std::option::Option::Some(EFeedElementType::FEED_DPC_STANDINGS),
                "FEED_ALERT_PREDICTIONS" => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_PREDICTIONS),
                "FEED_ALERT_FANTASY" => ::std::option::Option::Some(EFeedElementType::FEED_ALERT_FANTASY),
                "FEED_LEAGUE_LIVE_MATCH" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_LIVE_MATCH),
                "FEED_LEAGUE_INPROGRESS_SERIES" => ::std::option::Option::Some(EFeedElementType::FEED_LEAGUE_INPROGRESS_SERIES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EFeedElementType] = &[
            EFeedElementType::FEED_SERIES_RESULT,
            EFeedElementType::FEED_MATCH_POPULAR,
            EFeedElementType::FEED_TEAM_UPCOMING_MATCH,
            EFeedElementType::FEED_TEAM_LEAGUE_RESULT,
            EFeedElementType::FEED_TEAM_ADD_PLAYER,
            EFeedElementType::FEED_TEAM_REMOVE_PLAYER,
            EFeedElementType::FEED_TEAM_DISBAND,
            EFeedElementType::FEED_LEAGUE_UPCOMING,
            EFeedElementType::FEED_LEAGUE_CONCLUDED,
            EFeedElementType::FEED_DPC_STANDINGS,
            EFeedElementType::FEED_ALERT_PREDICTIONS,
            EFeedElementType::FEED_ALERT_FANTASY,
            EFeedElementType::FEED_LEAGUE_LIVE_MATCH,
            EFeedElementType::FEED_LEAGUE_INPROGRESS_SERIES,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EFeedElementType {
        fn default() -> Self {
            EFeedElementType::FEED_SERIES_RESULT
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTADPCUserInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCUserInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADPCUserInfo.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADPCUserInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCUserInfo {
    fn default() -> &'a CMsgDOTADPCUserInfo {
        <CMsgDOTADPCUserInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCUserInfo {
    pub fn new() -> CMsgDOTADPCUserInfo {
        ::std::default::Default::default()
    }

    // optional bool is_plus_subscriber = 1;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADPCUserInfo {
    const NAME: &'static str = "CMsgDOTADPCUserInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_plus_subscriber {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCUserInfo {
        CMsgDOTADPCUserInfo::new()
    }

    fn clear(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCUserInfo {
        static instance: CMsgDOTADPCUserInfo = CMsgDOTADPCUserInfo {
            is_plus_subscriber: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDraftTrivia)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDraftTrivia {
    // message fields
    // @@protoc_insertion_point(field:CMsgDraftTrivia.has_valid_match)
    pub has_valid_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDraftTrivia.match_hero_info)
    pub match_hero_info: ::steam_vent_proto_common::protobuf::MessageField<cmsg_draft_trivia::DraftTriviaMatchInfo>,
    // @@protoc_insertion_point(field:CMsgDraftTrivia.match_rank_tier)
    pub match_rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraftTrivia.end_time)
    pub end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraftTrivia.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraftTrivia.current_match_voted_radiant)
    pub current_match_voted_radiant: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDraftTrivia.previous_result)
    pub previous_result: ::steam_vent_proto_common::protobuf::MessageField<cmsg_draft_trivia::PreviousResult>,
    // @@protoc_insertion_point(field:CMsgDraftTrivia.current_streak)
    pub current_streak: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDraftTrivia.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDraftTrivia {
    fn default() -> &'a CMsgDraftTrivia {
        <CMsgDraftTrivia as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDraftTrivia {
    pub fn new() -> CMsgDraftTrivia {
        ::std::default::Default::default()
    }

    // optional bool has_valid_match = 1;

    pub fn has_valid_match(&self) -> bool {
        self.has_valid_match.unwrap_or(false)
    }

    pub fn clear_has_valid_match(&mut self) {
        self.has_valid_match = ::std::option::Option::None;
    }

    pub fn has_has_valid_match(&self) -> bool {
        self.has_valid_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_valid_match(&mut self, v: bool) {
        self.has_valid_match = ::std::option::Option::Some(v);
    }

    // optional uint32 match_rank_tier = 3;

    pub fn match_rank_tier(&self) -> u32 {
        self.match_rank_tier.unwrap_or(0)
    }

    pub fn clear_match_rank_tier(&mut self) {
        self.match_rank_tier = ::std::option::Option::None;
    }

    pub fn has_match_rank_tier(&self) -> bool {
        self.match_rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_rank_tier(&mut self, v: u32) {
        self.match_rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time = 4;

    pub fn end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 5;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional bool current_match_voted_radiant = 6;

    pub fn current_match_voted_radiant(&self) -> bool {
        self.current_match_voted_radiant.unwrap_or(false)
    }

    pub fn clear_current_match_voted_radiant(&mut self) {
        self.current_match_voted_radiant = ::std::option::Option::None;
    }

    pub fn has_current_match_voted_radiant(&self) -> bool {
        self.current_match_voted_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_match_voted_radiant(&mut self, v: bool) {
        self.current_match_voted_radiant = ::std::option::Option::Some(v);
    }

    // optional uint32 current_streak = 8;

    pub fn current_streak(&self) -> u32 {
        self.current_streak.unwrap_or(0)
    }

    pub fn clear_current_streak(&mut self) {
        self.current_streak = ::std::option::Option::None;
    }

    pub fn has_current_streak(&self) -> bool {
        self.current_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_streak(&mut self, v: u32) {
        self.current_streak = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDraftTrivia {
    const NAME: &'static str = "CMsgDraftTrivia";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_valid_match = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_hero_info)?;
                },
                24 => {
                    self.match_rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.current_match_voted_radiant = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.previous_result)?;
                },
                64 => {
                    self.current_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_valid_match {
            my_size += 1 + 1;
        }
        if let Some(v) = self.match_hero_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_rank_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.end_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.current_match_voted_radiant {
            my_size += 1 + 1;
        }
        if let Some(v) = self.previous_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_streak {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.has_valid_match {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.match_hero_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.match_rank_tier {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.current_match_voted_radiant {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.previous_result.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.current_streak {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDraftTrivia {
        CMsgDraftTrivia::new()
    }

    fn clear(&mut self) {
        self.has_valid_match = ::std::option::Option::None;
        self.match_hero_info.clear();
        self.match_rank_tier = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.current_match_voted_radiant = ::std::option::Option::None;
        self.previous_result.clear();
        self.current_streak = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDraftTrivia {
        static instance: CMsgDraftTrivia = CMsgDraftTrivia {
            has_valid_match: ::std::option::Option::None,
            match_hero_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            match_rank_tier: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            current_match_voted_radiant: ::std::option::Option::None,
            previous_result: ::steam_vent_proto_common::protobuf::MessageField::none(),
            current_streak: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDraftTrivia`
pub mod cmsg_draft_trivia {
    // @@protoc_insertion_point(message:CMsgDraftTrivia.DraftTriviaHeroInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DraftTriviaHeroInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDraftTrivia.DraftTriviaHeroInfo.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDraftTrivia.DraftTriviaHeroInfo.role)
        pub role: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDraftTrivia.DraftTriviaHeroInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DraftTriviaHeroInfo {
        fn default() -> &'a DraftTriviaHeroInfo {
            <DraftTriviaHeroInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DraftTriviaHeroInfo {
        pub fn new() -> DraftTriviaHeroInfo {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 role = 2;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DraftTriviaHeroInfo {
        const NAME: &'static str = "DraftTriviaHeroInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.role {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DraftTriviaHeroInfo {
            DraftTriviaHeroInfo::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DraftTriviaHeroInfo {
            static instance: DraftTriviaHeroInfo = DraftTriviaHeroInfo {
                hero_id: ::std::option::Option::None,
                role: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDraftTrivia.DraftTriviaMatchInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DraftTriviaMatchInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDraftTrivia.DraftTriviaMatchInfo.radiant_heroes)
        pub radiant_heroes: ::std::vec::Vec<DraftTriviaHeroInfo>,
        // @@protoc_insertion_point(field:CMsgDraftTrivia.DraftTriviaMatchInfo.dire_heroes)
        pub dire_heroes: ::std::vec::Vec<DraftTriviaHeroInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDraftTrivia.DraftTriviaMatchInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DraftTriviaMatchInfo {
        fn default() -> &'a DraftTriviaMatchInfo {
            <DraftTriviaMatchInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DraftTriviaMatchInfo {
        pub fn new() -> DraftTriviaMatchInfo {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DraftTriviaMatchInfo {
        const NAME: &'static str = "DraftTriviaMatchInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.radiant_heroes.push(is.read_message()?);
                    },
                    18 => {
                        self.dire_heroes.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.radiant_heroes {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.dire_heroes {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.radiant_heroes {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.dire_heroes {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DraftTriviaMatchInfo {
            DraftTriviaMatchInfo::new()
        }

        fn clear(&mut self) {
            self.radiant_heroes.clear();
            self.dire_heroes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DraftTriviaMatchInfo {
            static instance: DraftTriviaMatchInfo = DraftTriviaMatchInfo {
                radiant_heroes: ::std::vec::Vec::new(),
                dire_heroes: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDraftTrivia.PreviousResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PreviousResult {
        // message fields
        // @@protoc_insertion_point(field:CMsgDraftTrivia.PreviousResult.voted_correctly)
        pub voted_correctly: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDraftTrivia.PreviousResult.voted_radiant)
        pub voted_radiant: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDraftTrivia.PreviousResult.match_hero_info)
        pub match_hero_info: ::steam_vent_proto_common::protobuf::MessageField<DraftTriviaMatchInfo>,
        // @@protoc_insertion_point(field:CMsgDraftTrivia.PreviousResult.match_rank_tier)
        pub match_rank_tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDraftTrivia.PreviousResult.end_time)
        pub end_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDraftTrivia.PreviousResult.match_id)
        pub match_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDraftTrivia.PreviousResult.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PreviousResult {
        fn default() -> &'a PreviousResult {
            <PreviousResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PreviousResult {
        pub fn new() -> PreviousResult {
            ::std::default::Default::default()
        }

        // optional bool voted_correctly = 1;

        pub fn voted_correctly(&self) -> bool {
            self.voted_correctly.unwrap_or(false)
        }

        pub fn clear_voted_correctly(&mut self) {
            self.voted_correctly = ::std::option::Option::None;
        }

        pub fn has_voted_correctly(&self) -> bool {
            self.voted_correctly.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voted_correctly(&mut self, v: bool) {
            self.voted_correctly = ::std::option::Option::Some(v);
        }

        // optional bool voted_radiant = 2;

        pub fn voted_radiant(&self) -> bool {
            self.voted_radiant.unwrap_or(false)
        }

        pub fn clear_voted_radiant(&mut self) {
            self.voted_radiant = ::std::option::Option::None;
        }

        pub fn has_voted_radiant(&self) -> bool {
            self.voted_radiant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voted_radiant(&mut self, v: bool) {
            self.voted_radiant = ::std::option::Option::Some(v);
        }

        // optional uint32 match_rank_tier = 4;

        pub fn match_rank_tier(&self) -> u32 {
            self.match_rank_tier.unwrap_or(0)
        }

        pub fn clear_match_rank_tier(&mut self) {
            self.match_rank_tier = ::std::option::Option::None;
        }

        pub fn has_match_rank_tier(&self) -> bool {
            self.match_rank_tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_rank_tier(&mut self, v: u32) {
            self.match_rank_tier = ::std::option::Option::Some(v);
        }

        // optional uint32 end_time = 5;

        pub fn end_time(&self) -> u32 {
            self.end_time.unwrap_or(0)
        }

        pub fn clear_end_time(&mut self) {
            self.end_time = ::std::option::Option::None;
        }

        pub fn has_end_time(&self) -> bool {
            self.end_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_time(&mut self, v: u32) {
            self.end_time = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 6;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PreviousResult {
        const NAME: &'static str = "PreviousResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.voted_correctly = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.voted_radiant = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_hero_info)?;
                    },
                    32 => {
                        self.match_rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.voted_correctly {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voted_radiant {
                my_size += 1 + 1;
            }
            if let Some(v) = self.match_hero_info.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.match_rank_tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.end_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.voted_correctly {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.voted_radiant {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.match_hero_info.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.match_rank_tier {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.end_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PreviousResult {
            PreviousResult::new()
        }

        fn clear(&mut self) {
            self.voted_correctly = ::std::option::Option::None;
            self.voted_radiant = ::std::option::Option::None;
            self.match_hero_info.clear();
            self.match_rank_tier = ::std::option::Option::None;
            self.end_time = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PreviousResult {
            static instance: PreviousResult = PreviousResult {
                voted_correctly: ::std::option::Option::None,
                voted_radiant: ::std::option::Option::None,
                match_hero_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
                match_rank_tier: ::std::option::Option::None,
                end_time: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTeamFanContentAssetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentAssetStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgTeamFanContentAssetStatus.asset_type)
    pub asset_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETeamFanContentAssetType>>,
    // @@protoc_insertion_point(field:CMsgTeamFanContentAssetStatus.asset_index)
    pub asset_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTeamFanContentAssetStatus.asset_status)
    pub asset_status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETeamFanContentAssetStatus>>,
    // @@protoc_insertion_point(field:CMsgTeamFanContentAssetStatus.crc)
    pub crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTeamFanContentAssetStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentAssetStatus {
    fn default() -> &'a CMsgTeamFanContentAssetStatus {
        <CMsgTeamFanContentAssetStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentAssetStatus {
    pub fn new() -> CMsgTeamFanContentAssetStatus {
        ::std::default::Default::default()
    }

    // optional .ETeamFanContentAssetType asset_type = 1;

    pub fn asset_type(&self) -> ETeamFanContentAssetType {
        match self.asset_type {
            Some(e) => e.enum_value_or(ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG),
            None => ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG,
        }
    }

    pub fn clear_asset_type(&mut self) {
        self.asset_type = ::std::option::Option::None;
    }

    pub fn has_asset_type(&self) -> bool {
        self.asset_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_type(&mut self, v: ETeamFanContentAssetType) {
        self.asset_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 asset_index = 2;

    pub fn asset_index(&self) -> u32 {
        self.asset_index.unwrap_or(0)
    }

    pub fn clear_asset_index(&mut self) {
        self.asset_index = ::std::option::Option::None;
    }

    pub fn has_asset_index(&self) -> bool {
        self.asset_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_index(&mut self, v: u32) {
        self.asset_index = ::std::option::Option::Some(v);
    }

    // optional .ETeamFanContentAssetStatus asset_status = 3;

    pub fn asset_status(&self) -> ETeamFanContentAssetStatus {
        match self.asset_status {
            Some(e) => e.enum_value_or(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None),
            None => ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None,
        }
    }

    pub fn clear_asset_status(&mut self) {
        self.asset_status = ::std::option::Option::None;
    }

    pub fn has_asset_status(&self) -> bool {
        self.asset_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_status(&mut self, v: ETeamFanContentAssetStatus) {
        self.asset_status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 crc = 4;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTeamFanContentAssetStatus {
    const NAME: &'static str = "CMsgTeamFanContentAssetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.asset_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.asset_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.asset_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.asset_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.asset_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.asset_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.crc {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.asset_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.asset_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.asset_status {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.crc {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentAssetStatus {
        CMsgTeamFanContentAssetStatus::new()
    }

    fn clear(&mut self) {
        self.asset_type = ::std::option::Option::None;
        self.asset_index = ::std::option::Option::None;
        self.asset_status = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentAssetStatus {
        static instance: CMsgTeamFanContentAssetStatus = CMsgTeamFanContentAssetStatus {
            asset_type: ::std::option::Option::None,
            asset_index: ::std::option::Option::None,
            asset_status: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTeamFanContentAssetStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentAssetStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTeamFanContentAssetStatusResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_team_fan_content_asset_status_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTeamFanContentAssetStatusResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentAssetStatusResponse {
    fn default() -> &'a CMsgTeamFanContentAssetStatusResponse {
        <CMsgTeamFanContentAssetStatusResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentAssetStatusResponse {
    pub fn new() -> CMsgTeamFanContentAssetStatusResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgTeamFanContentAssetStatusResponse.EResult result = 1;

    pub fn result(&self) -> cmsg_team_fan_content_asset_status_response::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_team_fan_content_asset_status_response::EResult::k_eSuccess),
            None => cmsg_team_fan_content_asset_status_response::EResult::k_eSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_team_fan_content_asset_status_response::EResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTeamFanContentAssetStatusResponse {
    const NAME: &'static str = "CMsgTeamFanContentAssetStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentAssetStatusResponse {
        CMsgTeamFanContentAssetStatusResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentAssetStatusResponse {
        static instance: CMsgTeamFanContentAssetStatusResponse = CMsgTeamFanContentAssetStatusResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTeamFanContentAssetStatusResponse`
pub mod cmsg_team_fan_content_asset_status_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgTeamFanContentAssetStatusResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgTeamFanContentAssetStatusResponse.EResult.k_eSuccess)
        k_eSuccess = 0,
        // @@protoc_insertion_point(enum_value:CMsgTeamFanContentAssetStatusResponse.EResult.k_eInternalError)
        k_eInternalError = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_eSuccess),
                1 => ::std::option::Option::Some(EResult::k_eInternalError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_eSuccess" => ::std::option::Option::Some(EResult::k_eSuccess),
                "k_eInternalError" => ::std::option::Option::Some(EResult::k_eInternalError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_eSuccess,
            EResult::k_eInternalError,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_eSuccess
        }
    }

}

// @@protoc_insertion_point(message:CMsgTeamFanContentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.team_status_list)
    pub team_status_list: ::std::vec::Vec<cmsg_team_fan_content_status::TeamStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTeamFanContentStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentStatus {
    fn default() -> &'a CMsgTeamFanContentStatus {
        <CMsgTeamFanContentStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentStatus {
    pub fn new() -> CMsgTeamFanContentStatus {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTeamFanContentStatus {
    const NAME: &'static str = "CMsgTeamFanContentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.team_status_list.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.team_status_list {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.team_status_list {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentStatus {
        CMsgTeamFanContentStatus::new()
    }

    fn clear(&mut self) {
        self.team_status_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentStatus {
        static instance: CMsgTeamFanContentStatus = CMsgTeamFanContentStatus {
            team_status_list: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTeamFanContentStatus`
pub mod cmsg_team_fan_content_status {
    // @@protoc_insertion_point(message:CMsgTeamFanContentStatus.TeamStatus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamStatus {
        // message fields
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.logo_url)
        pub logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.status)
        pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::ETeamFanContentStatus>>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.ugc_logo)
        pub ugc_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.workshop_account_id)
        pub workshop_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.abbreviation)
        pub abbreviation: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.voiceline_count)
        pub voiceline_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.spray_count)
        pub spray_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.emoticon_count)
        pub emoticon_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.wallpaper_count)
        pub wallpaper_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.comment)
        pub comment: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.comment_timestamp)
        pub comment_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.asset_status)
        pub asset_status: ::std::vec::Vec<super::CMsgTeamFanContentAssetStatus>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.email_timestamp)
        pub email_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.email_tier)
        pub email_tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentStatus.TeamStatus.languages)
        pub languages: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTeamFanContentStatus.TeamStatus.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStatus {
        fn default() -> &'a TeamStatus {
            <TeamStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamStatus {
        pub fn new() -> TeamStatus {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string logo_url = 3;

        pub fn logo_url(&self) -> &str {
            match self.logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_logo_url(&mut self) {
            self.logo_url = ::std::option::Option::None;
        }

        pub fn has_logo_url(&self) -> bool {
            self.logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_logo_url(&mut self, v: ::std::string::String) {
            self.logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_logo_url(&mut self) -> &mut ::std::string::String {
            if self.logo_url.is_none() {
                self.logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_logo_url(&mut self) -> ::std::string::String {
            self.logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .ETeamFanContentStatus status = 4;

        pub fn status(&self) -> super::ETeamFanContentStatus {
            match self.status {
                Some(e) => e.enum_value_or(super::ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID),
                None => super::ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID,
            }
        }

        pub fn clear_status(&mut self) {
            self.status = ::std::option::Option::None;
        }

        pub fn has_status(&self) -> bool {
            self.status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_status(&mut self, v: super::ETeamFanContentStatus) {
            self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 timestamp = 5;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint64 ugc_logo = 7;

        pub fn ugc_logo(&self) -> u64 {
            self.ugc_logo.unwrap_or(0)
        }

        pub fn clear_ugc_logo(&mut self) {
            self.ugc_logo = ::std::option::Option::None;
        }

        pub fn has_ugc_logo(&self) -> bool {
            self.ugc_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ugc_logo(&mut self, v: u64) {
            self.ugc_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 workshop_account_id = 8;

        pub fn workshop_account_id(&self) -> u32 {
            self.workshop_account_id.unwrap_or(0)
        }

        pub fn clear_workshop_account_id(&mut self) {
            self.workshop_account_id = ::std::option::Option::None;
        }

        pub fn has_workshop_account_id(&self) -> bool {
            self.workshop_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_account_id(&mut self, v: u32) {
            self.workshop_account_id = ::std::option::Option::Some(v);
        }

        // optional string abbreviation = 9;

        pub fn abbreviation(&self) -> &str {
            match self.abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_abbreviation(&mut self) {
            self.abbreviation = ::std::option::Option::None;
        }

        pub fn has_abbreviation(&self) -> bool {
            self.abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_abbreviation(&mut self, v: ::std::string::String) {
            self.abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.abbreviation.is_none() {
                self.abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_abbreviation(&mut self) -> ::std::string::String {
            self.abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 voiceline_count = 10;

        pub fn voiceline_count(&self) -> u32 {
            self.voiceline_count.unwrap_or(0)
        }

        pub fn clear_voiceline_count(&mut self) {
            self.voiceline_count = ::std::option::Option::None;
        }

        pub fn has_voiceline_count(&self) -> bool {
            self.voiceline_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voiceline_count(&mut self, v: u32) {
            self.voiceline_count = ::std::option::Option::Some(v);
        }

        // optional uint32 spray_count = 11;

        pub fn spray_count(&self) -> u32 {
            self.spray_count.unwrap_or(0)
        }

        pub fn clear_spray_count(&mut self) {
            self.spray_count = ::std::option::Option::None;
        }

        pub fn has_spray_count(&self) -> bool {
            self.spray_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spray_count(&mut self, v: u32) {
            self.spray_count = ::std::option::Option::Some(v);
        }

        // optional uint32 emoticon_count = 12;

        pub fn emoticon_count(&self) -> u32 {
            self.emoticon_count.unwrap_or(0)
        }

        pub fn clear_emoticon_count(&mut self) {
            self.emoticon_count = ::std::option::Option::None;
        }

        pub fn has_emoticon_count(&self) -> bool {
            self.emoticon_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_emoticon_count(&mut self, v: u32) {
            self.emoticon_count = ::std::option::Option::Some(v);
        }

        // optional uint32 wallpaper_count = 13;

        pub fn wallpaper_count(&self) -> u32 {
            self.wallpaper_count.unwrap_or(0)
        }

        pub fn clear_wallpaper_count(&mut self) {
            self.wallpaper_count = ::std::option::Option::None;
        }

        pub fn has_wallpaper_count(&self) -> bool {
            self.wallpaper_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wallpaper_count(&mut self, v: u32) {
            self.wallpaper_count = ::std::option::Option::Some(v);
        }

        // optional string comment = 14;

        pub fn comment(&self) -> &str {
            match self.comment.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_comment(&mut self) {
            self.comment = ::std::option::Option::None;
        }

        pub fn has_comment(&self) -> bool {
            self.comment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comment(&mut self, v: ::std::string::String) {
            self.comment = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_comment(&mut self) -> &mut ::std::string::String {
            if self.comment.is_none() {
                self.comment = ::std::option::Option::Some(::std::string::String::new());
            }
            self.comment.as_mut().unwrap()
        }

        // Take field
        pub fn take_comment(&mut self) -> ::std::string::String {
            self.comment.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 comment_timestamp = 15;

        pub fn comment_timestamp(&self) -> u32 {
            self.comment_timestamp.unwrap_or(0)
        }

        pub fn clear_comment_timestamp(&mut self) {
            self.comment_timestamp = ::std::option::Option::None;
        }

        pub fn has_comment_timestamp(&self) -> bool {
            self.comment_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comment_timestamp(&mut self, v: u32) {
            self.comment_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 email_timestamp = 17;

        pub fn email_timestamp(&self) -> u32 {
            self.email_timestamp.unwrap_or(0)
        }

        pub fn clear_email_timestamp(&mut self) {
            self.email_timestamp = ::std::option::Option::None;
        }

        pub fn has_email_timestamp(&self) -> bool {
            self.email_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_email_timestamp(&mut self, v: u32) {
            self.email_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 email_tier = 18;

        pub fn email_tier(&self) -> u32 {
            self.email_tier.unwrap_or(0)
        }

        pub fn clear_email_tier(&mut self) {
            self.email_tier = ::std::option::Option::None;
        }

        pub fn has_email_tier(&self) -> bool {
            self.email_tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_email_tier(&mut self, v: u32) {
            self.email_tier = ::std::option::Option::Some(v);
        }

        // optional string languages = 19;

        pub fn languages(&self) -> &str {
            match self.languages.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_languages(&mut self) {
            self.languages = ::std::option::Option::None;
        }

        pub fn has_languages(&self) -> bool {
            self.languages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_languages(&mut self, v: ::std::string::String) {
            self.languages = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_languages(&mut self) -> &mut ::std::string::String {
            if self.languages.is_none() {
                self.languages = ::std::option::Option::Some(::std::string::String::new());
            }
            self.languages.as_mut().unwrap()
        }

        // Take field
        pub fn take_languages(&mut self) -> ::std::string::String {
            self.languages.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamStatus {
        const NAME: &'static str = "TeamStatus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    40 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.ugc_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.workshop_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    74 => {
                        self.abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.voiceline_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.spray_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.emoticon_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.wallpaper_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    114 => {
                        self.comment = ::std::option::Option::Some(is.read_string()?);
                    },
                    120 => {
                        self.comment_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    130 => {
                        self.asset_status.push(is.read_message()?);
                    },
                    136 => {
                        self.email_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.email_tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    154 => {
                        self.languages = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.status {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.ugc_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
            }
            if let Some(v) = self.workshop_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.abbreviation.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.voiceline_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.spray_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.emoticon_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.wallpaper_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.comment.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.comment_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
            }
            for value in &self.asset_status {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.email_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.email_tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.languages.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(19, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.logo_url.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.status {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.ugc_logo {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.workshop_account_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.abbreviation.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.voiceline_count {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.spray_count {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.emoticon_count {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.wallpaper_count {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.comment.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.comment_timestamp {
                os.write_uint32(15, v)?;
            }
            for v in &self.asset_status {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
            };
            if let Some(v) = self.email_timestamp {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.email_tier {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.languages.as_ref() {
                os.write_string(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStatus {
            TeamStatus::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.logo_url = ::std::option::Option::None;
            self.status = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.ugc_logo = ::std::option::Option::None;
            self.workshop_account_id = ::std::option::Option::None;
            self.abbreviation = ::std::option::Option::None;
            self.voiceline_count = ::std::option::Option::None;
            self.spray_count = ::std::option::Option::None;
            self.emoticon_count = ::std::option::Option::None;
            self.wallpaper_count = ::std::option::Option::None;
            self.comment = ::std::option::Option::None;
            self.comment_timestamp = ::std::option::Option::None;
            self.asset_status.clear();
            self.email_timestamp = ::std::option::Option::None;
            self.email_tier = ::std::option::Option::None;
            self.languages = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStatus {
            static instance: TeamStatus = TeamStatus {
                name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                logo_url: ::std::option::Option::None,
                status: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                ugc_logo: ::std::option::Option::None,
                workshop_account_id: ::std::option::Option::None,
                abbreviation: ::std::option::Option::None,
                voiceline_count: ::std::option::Option::None,
                spray_count: ::std::option::Option::None,
                emoticon_count: ::std::option::Option::None,
                wallpaper_count: ::std::option::Option::None,
                comment: ::std::option::Option::None,
                comment_timestamp: ::std::option::Option::None,
                asset_status: ::std::vec::Vec::new(),
                email_timestamp: ::std::option::Option::None,
                email_tier: ::std::option::Option::None,
                languages: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTeamFanContentAutographStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanContentAutographStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.team_autographs)
    pub team_autographs: ::std::vec::Vec<cmsg_team_fan_content_autograph_status::TeamStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTeamFanContentAutographStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanContentAutographStatus {
    fn default() -> &'a CMsgTeamFanContentAutographStatus {
        <CMsgTeamFanContentAutographStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanContentAutographStatus {
    pub fn new() -> CMsgTeamFanContentAutographStatus {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTeamFanContentAutographStatus {
    const NAME: &'static str = "CMsgTeamFanContentAutographStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.team_autographs.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.team_autographs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.team_autographs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanContentAutographStatus {
        CMsgTeamFanContentAutographStatus::new()
    }

    fn clear(&mut self) {
        self.team_autographs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanContentAutographStatus {
        static instance: CMsgTeamFanContentAutographStatus = CMsgTeamFanContentAutographStatus {
            team_autographs: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTeamFanContentAutographStatus`
pub mod cmsg_team_fan_content_autograph_status {
    // @@protoc_insertion_point(message:CMsgTeamFanContentAutographStatus.AutographStatus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutographStatus {
        // message fields
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.AutographStatus.pro_name)
        pub pro_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.AutographStatus.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.AutographStatus.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.AutographStatus.file)
        pub file: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTeamFanContentAutographStatus.AutographStatus.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutographStatus {
        fn default() -> &'a AutographStatus {
            <AutographStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AutographStatus {
        pub fn new() -> AutographStatus {
            ::std::default::Default::default()
        }

        // optional string pro_name = 1;

        pub fn pro_name(&self) -> &str {
            match self.pro_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_pro_name(&mut self) {
            self.pro_name = ::std::option::Option::None;
        }

        pub fn has_pro_name(&self) -> bool {
            self.pro_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_name(&mut self, v: ::std::string::String) {
            self.pro_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_pro_name(&mut self) -> &mut ::std::string::String {
            if self.pro_name.is_none() {
                self.pro_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.pro_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_pro_name(&mut self) -> ::std::string::String {
            self.pro_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string file = 4;

        pub fn file(&self) -> &str {
            match self.file.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_file(&mut self) {
            self.file = ::std::option::Option::None;
        }

        pub fn has_file(&self) -> bool {
            self.file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file(&mut self, v: ::std::string::String) {
            self.file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_file(&mut self) -> &mut ::std::string::String {
            if self.file.is_none() {
                self.file = ::std::option::Option::Some(::std::string::String::new());
            }
            self.file.as_mut().unwrap()
        }

        // Take field
        pub fn take_file(&mut self) -> ::std::string::String {
            self.file.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AutographStatus {
        const NAME: &'static str = "AutographStatus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.pro_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.file = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pro_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.file.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.pro_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.file.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutographStatus {
            AutographStatus::new()
        }

        fn clear(&mut self) {
            self.pro_name = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.file = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutographStatus {
            static instance: AutographStatus = AutographStatus {
                pro_name: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                file: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgTeamFanContentAutographStatus.TeamStatus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamStatus {
        // message fields
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.TeamStatus.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.TeamStatus.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.TeamStatus.autographs)
        pub autographs: ::std::vec::Vec<AutographStatus>,
        // @@protoc_insertion_point(field:CMsgTeamFanContentAutographStatus.TeamStatus.workshop_account_id)
        pub workshop_account_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTeamFanContentAutographStatus.TeamStatus.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStatus {
        fn default() -> &'a TeamStatus {
            <TeamStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamStatus {
        pub fn new() -> TeamStatus {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 workshop_account_id = 4;

        pub fn workshop_account_id(&self) -> u32 {
            self.workshop_account_id.unwrap_or(0)
        }

        pub fn clear_workshop_account_id(&mut self) {
            self.workshop_account_id = ::std::option::Option::None;
        }

        pub fn has_workshop_account_id(&self) -> bool {
            self.workshop_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_account_id(&mut self, v: u32) {
            self.workshop_account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamStatus {
        const NAME: &'static str = "TeamStatus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.autographs.push(is.read_message()?);
                    },
                    32 => {
                        self.workshop_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.autographs {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.workshop_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            for v in &self.autographs {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.workshop_account_id {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStatus {
            TeamStatus::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.autographs.clear();
            self.workshop_account_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStatus {
            static instance: TeamStatus = TeamStatus {
                name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                autographs: ::std::vec::Vec::new(),
                workshop_account_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTalentContentAssetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTalentContentAssetStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgTalentContentAssetStatus.asset_type)
    pub asset_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETalentContentAssetType>>,
    // @@protoc_insertion_point(field:CMsgTalentContentAssetStatus.asset_index)
    pub asset_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTalentContentAssetStatus.asset_status)
    pub asset_status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETalentContentAssetStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTalentContentAssetStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTalentContentAssetStatus {
    fn default() -> &'a CMsgTalentContentAssetStatus {
        <CMsgTalentContentAssetStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTalentContentAssetStatus {
    pub fn new() -> CMsgTalentContentAssetStatus {
        ::std::default::Default::default()
    }

    // optional .ETalentContentAssetType asset_type = 1;

    pub fn asset_type(&self) -> ETalentContentAssetType {
        match self.asset_type {
            Some(e) => e.enum_value_or(ETalentContentAssetType::k_eTalentContentAssetType_Photo),
            None => ETalentContentAssetType::k_eTalentContentAssetType_Photo,
        }
    }

    pub fn clear_asset_type(&mut self) {
        self.asset_type = ::std::option::Option::None;
    }

    pub fn has_asset_type(&self) -> bool {
        self.asset_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_type(&mut self, v: ETalentContentAssetType) {
        self.asset_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 asset_index = 2;

    pub fn asset_index(&self) -> u32 {
        self.asset_index.unwrap_or(0)
    }

    pub fn clear_asset_index(&mut self) {
        self.asset_index = ::std::option::Option::None;
    }

    pub fn has_asset_index(&self) -> bool {
        self.asset_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_index(&mut self, v: u32) {
        self.asset_index = ::std::option::Option::Some(v);
    }

    // optional .ETalentContentAssetStatus asset_status = 3;

    pub fn asset_status(&self) -> ETalentContentAssetStatus {
        match self.asset_status {
            Some(e) => e.enum_value_or(ETalentContentAssetStatus::k_eTalentContentAssetStatus_None),
            None => ETalentContentAssetStatus::k_eTalentContentAssetStatus_None,
        }
    }

    pub fn clear_asset_status(&mut self) {
        self.asset_status = ::std::option::Option::None;
    }

    pub fn has_asset_status(&self) -> bool {
        self.asset_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_status(&mut self, v: ETalentContentAssetStatus) {
        self.asset_status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTalentContentAssetStatus {
    const NAME: &'static str = "CMsgTalentContentAssetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.asset_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.asset_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.asset_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.asset_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.asset_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.asset_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.asset_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.asset_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.asset_status {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTalentContentAssetStatus {
        CMsgTalentContentAssetStatus::new()
    }

    fn clear(&mut self) {
        self.asset_type = ::std::option::Option::None;
        self.asset_index = ::std::option::Option::None;
        self.asset_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTalentContentAssetStatus {
        static instance: CMsgTalentContentAssetStatus = CMsgTalentContentAssetStatus {
            asset_type: ::std::option::Option::None,
            asset_index: ::std::option::Option::None,
            asset_status: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTalentContentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTalentContentStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgTalentContentStatus.talent_status)
    pub talent_status: ::std::vec::Vec<cmsg_talent_content_status::TalentDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTalentContentStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTalentContentStatus {
    fn default() -> &'a CMsgTalentContentStatus {
        <CMsgTalentContentStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTalentContentStatus {
    pub fn new() -> CMsgTalentContentStatus {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTalentContentStatus {
    const NAME: &'static str = "CMsgTalentContentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.talent_status.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.talent_status {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.talent_status {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTalentContentStatus {
        CMsgTalentContentStatus::new()
    }

    fn clear(&mut self) {
        self.talent_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTalentContentStatus {
        static instance: CMsgTalentContentStatus = CMsgTalentContentStatus {
            talent_status: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTalentContentStatus`
pub mod cmsg_talent_content_status {
    // @@protoc_insertion_point(message:CMsgTalentContentStatus.TalentDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TalentDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.full_name)
        pub full_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.nickname)
        pub nickname: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.workshop_item_id)
        pub workshop_item_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.zip_file)
        pub zip_file: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.status)
        pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::ETalentContentStatus>>,
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.asset_status)
        pub asset_status: ::std::vec::Vec<super::CMsgTalentContentAssetStatus>,
        // @@protoc_insertion_point(field:CMsgTalentContentStatus.TalentDetails.broadcast_language)
        pub broadcast_language: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTalentContentStatus.TalentDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TalentDetails {
        fn default() -> &'a TalentDetails {
            <TalentDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TalentDetails {
        pub fn new() -> TalentDetails {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string full_name = 2;

        pub fn full_name(&self) -> &str {
            match self.full_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_full_name(&mut self) {
            self.full_name = ::std::option::Option::None;
        }

        pub fn has_full_name(&self) -> bool {
            self.full_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_full_name(&mut self, v: ::std::string::String) {
            self.full_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_full_name(&mut self) -> &mut ::std::string::String {
            if self.full_name.is_none() {
                self.full_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.full_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_full_name(&mut self) -> ::std::string::String {
            self.full_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string nickname = 3;

        pub fn nickname(&self) -> &str {
            match self.nickname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_nickname(&mut self) {
            self.nickname = ::std::option::Option::None;
        }

        pub fn has_nickname(&self) -> bool {
            self.nickname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nickname(&mut self, v: ::std::string::String) {
            self.nickname = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
            if self.nickname.is_none() {
                self.nickname = ::std::option::Option::Some(::std::string::String::new());
            }
            self.nickname.as_mut().unwrap()
        }

        // Take field
        pub fn take_nickname(&mut self) -> ::std::string::String {
            self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 workshop_item_id = 4;

        pub fn workshop_item_id(&self) -> u32 {
            self.workshop_item_id.unwrap_or(0)
        }

        pub fn clear_workshop_item_id(&mut self) {
            self.workshop_item_id = ::std::option::Option::None;
        }

        pub fn has_workshop_item_id(&self) -> bool {
            self.workshop_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_item_id(&mut self, v: u32) {
            self.workshop_item_id = ::std::option::Option::Some(v);
        }

        // optional string zip_file = 5;

        pub fn zip_file(&self) -> &str {
            match self.zip_file.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_zip_file(&mut self) {
            self.zip_file = ::std::option::Option::None;
        }

        pub fn has_zip_file(&self) -> bool {
            self.zip_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_zip_file(&mut self, v: ::std::string::String) {
            self.zip_file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_zip_file(&mut self) -> &mut ::std::string::String {
            if self.zip_file.is_none() {
                self.zip_file = ::std::option::Option::Some(::std::string::String::new());
            }
            self.zip_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_zip_file(&mut self) -> ::std::string::String {
            self.zip_file.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .ETalentContentStatus status = 6;

        pub fn status(&self) -> super::ETalentContentStatus {
            match self.status {
                Some(e) => e.enum_value_or(super::ETalentContentStatus::TALENT_CONTENT_STATUS_INVALID),
                None => super::ETalentContentStatus::TALENT_CONTENT_STATUS_INVALID,
            }
        }

        pub fn clear_status(&mut self) {
            self.status = ::std::option::Option::None;
        }

        pub fn has_status(&self) -> bool {
            self.status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_status(&mut self, v: super::ETalentContentStatus) {
            self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 broadcast_language = 8;

        pub fn broadcast_language(&self) -> u32 {
            self.broadcast_language.unwrap_or(0)
        }

        pub fn clear_broadcast_language(&mut self) {
            self.broadcast_language = ::std::option::Option::None;
        }

        pub fn has_broadcast_language(&self) -> bool {
            self.broadcast_language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_broadcast_language(&mut self, v: u32) {
            self.broadcast_language = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TalentDetails {
        const NAME: &'static str = "TalentDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.full_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.nickname = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.workshop_item_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.zip_file = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    58 => {
                        self.asset_status.push(is.read_message()?);
                    },
                    64 => {
                        self.broadcast_language = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.full_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.nickname.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.workshop_item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.zip_file.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.status {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
            }
            for value in &self.asset_status {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.broadcast_language {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.full_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.nickname.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.workshop_item_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.zip_file.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.status {
                os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.asset_status {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            if let Some(v) = self.broadcast_language {
                os.write_uint32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TalentDetails {
            TalentDetails::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.full_name = ::std::option::Option::None;
            self.nickname = ::std::option::Option::None;
            self.workshop_item_id = ::std::option::Option::None;
            self.zip_file = ::std::option::Option::None;
            self.status = ::std::option::Option::None;
            self.asset_status.clear();
            self.broadcast_language = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TalentDetails {
            static instance: TalentDetails = TalentDetails {
                account_id: ::std::option::Option::None,
                full_name: ::std::option::Option::None,
                nickname: ::std::option::Option::None,
                workshop_item_id: ::std::option::Option::None,
                zip_file: ::std::option::Option::None,
                status: ::std::option::Option::None,
                asset_status: ::std::vec::Vec::new(),
                broadcast_language: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSetTalentContentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetTalentContentResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetTalentContentResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_set_talent_content_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetTalentContentResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetTalentContentResponse {
    fn default() -> &'a CMsgSetTalentContentResponse {
        <CMsgSetTalentContentResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetTalentContentResponse {
    pub fn new() -> CMsgSetTalentContentResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgSetTalentContentResponse.EResult result = 1;

    pub fn result(&self) -> cmsg_set_talent_content_response::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_set_talent_content_response::EResult::k_eSuccess),
            None => cmsg_set_talent_content_response::EResult::k_eSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_set_talent_content_response::EResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetTalentContentResponse {
    const NAME: &'static str = "CMsgSetTalentContentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetTalentContentResponse {
        CMsgSetTalentContentResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetTalentContentResponse {
        static instance: CMsgSetTalentContentResponse = CMsgSetTalentContentResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSetTalentContentResponse`
pub mod cmsg_set_talent_content_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSetTalentContentResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgSetTalentContentResponse.EResult.k_eSuccess)
        k_eSuccess = 0,
        // @@protoc_insertion_point(enum_value:CMsgSetTalentContentResponse.EResult.k_eInternalError)
        k_eInternalError = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_eSuccess),
                1 => ::std::option::Option::Some(EResult::k_eInternalError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_eSuccess" => ::std::option::Option::Some(EResult::k_eSuccess),
                "k_eInternalError" => ::std::option::Option::Some(EResult::k_eInternalError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_eSuccess,
            EResult::k_eInternalError,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_eSuccess
        }
    }

}

// @@protoc_insertion_point(message:CMsgDPCEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPCEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPCEvent.event)
    pub event: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dpcevent::ELeagueEvent>>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.event_type)
    pub event_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dpcevent::ELeagueEventType>>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.leagues)
    pub leagues: ::std::vec::Vec<cmsg_dpcevent::League>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.registration_period)
    pub registration_period: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.is_event_upcoming)
    pub is_event_upcoming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.is_event_completed)
    pub is_event_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.multicast_league_id)
    pub multicast_league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.multicast_streams)
    pub multicast_streams: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.tour)
    pub tour: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dpcevent::ETour>>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.timestamp_drop_lock)
    pub timestamp_drop_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.timestamp_add_lock)
    pub timestamp_add_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.timestamp_content_deadline)
    pub timestamp_content_deadline: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.is_fantasy_enabled)
    pub is_fantasy_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDPCEvent.timestamp_content_review_deadline)
    pub timestamp_content_review_deadline: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPCEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPCEvent {
    fn default() -> &'a CMsgDPCEvent {
        <CMsgDPCEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDPCEvent {
    pub fn new() -> CMsgDPCEvent {
        ::std::default::Default::default()
    }

    // optional .CMsgDPCEvent.ELeagueEvent event = 1;

    pub fn event(&self) -> cmsg_dpcevent::ELeagueEvent {
        match self.event {
            Some(e) => e.enum_value_or(cmsg_dpcevent::ELeagueEvent::EVENT_INVALID),
            None => cmsg_dpcevent::ELeagueEvent::EVENT_INVALID,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: cmsg_dpcevent::ELeagueEvent) {
        self.event = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgDPCEvent.ELeagueEventType event_type = 2;

    pub fn event_type(&self) -> cmsg_dpcevent::ELeagueEventType {
        match self.event_type {
            Some(e) => e.enum_value_or(cmsg_dpcevent::ELeagueEventType::UNKNOWN),
            None => cmsg_dpcevent::ELeagueEventType::UNKNOWN,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: cmsg_dpcevent::ELeagueEventType) {
        self.event_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 registration_period = 4;

    pub fn registration_period(&self) -> u32 {
        self.registration_period.unwrap_or(0)
    }

    pub fn clear_registration_period(&mut self) {
        self.registration_period = ::std::option::Option::None;
    }

    pub fn has_registration_period(&self) -> bool {
        self.registration_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_period(&mut self, v: u32) {
        self.registration_period = ::std::option::Option::Some(v);
    }

    // optional bool is_event_upcoming = 5;

    pub fn is_event_upcoming(&self) -> bool {
        self.is_event_upcoming.unwrap_or(false)
    }

    pub fn clear_is_event_upcoming(&mut self) {
        self.is_event_upcoming = ::std::option::Option::None;
    }

    pub fn has_is_event_upcoming(&self) -> bool {
        self.is_event_upcoming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_upcoming(&mut self, v: bool) {
        self.is_event_upcoming = ::std::option::Option::Some(v);
    }

    // optional bool is_event_completed = 6;

    pub fn is_event_completed(&self) -> bool {
        self.is_event_completed.unwrap_or(false)
    }

    pub fn clear_is_event_completed(&mut self) {
        self.is_event_completed = ::std::option::Option::None;
    }

    pub fn has_is_event_completed(&self) -> bool {
        self.is_event_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_completed(&mut self, v: bool) {
        self.is_event_completed = ::std::option::Option::Some(v);
    }

    // optional string event_name = 7;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 multicast_league_id = 8;

    pub fn multicast_league_id(&self) -> u32 {
        self.multicast_league_id.unwrap_or(0)
    }

    pub fn clear_multicast_league_id(&mut self) {
        self.multicast_league_id = ::std::option::Option::None;
    }

    pub fn has_multicast_league_id(&self) -> bool {
        self.multicast_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast_league_id(&mut self, v: u32) {
        self.multicast_league_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgDPCEvent.ETour tour = 10;

    pub fn tour(&self) -> cmsg_dpcevent::ETour {
        match self.tour {
            Some(e) => e.enum_value_or(cmsg_dpcevent::ETour::TOUR_NONE),
            None => cmsg_dpcevent::ETour::TOUR_NONE,
        }
    }

    pub fn clear_tour(&mut self) {
        self.tour = ::std::option::Option::None;
    }

    pub fn has_tour(&self) -> bool {
        self.tour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour(&mut self, v: cmsg_dpcevent::ETour) {
        self.tour = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp_drop_lock = 12;

    pub fn timestamp_drop_lock(&self) -> u32 {
        self.timestamp_drop_lock.unwrap_or(0)
    }

    pub fn clear_timestamp_drop_lock(&mut self) {
        self.timestamp_drop_lock = ::std::option::Option::None;
    }

    pub fn has_timestamp_drop_lock(&self) -> bool {
        self.timestamp_drop_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_drop_lock(&mut self, v: u32) {
        self.timestamp_drop_lock = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_add_lock = 13;

    pub fn timestamp_add_lock(&self) -> u32 {
        self.timestamp_add_lock.unwrap_or(0)
    }

    pub fn clear_timestamp_add_lock(&mut self) {
        self.timestamp_add_lock = ::std::option::Option::None;
    }

    pub fn has_timestamp_add_lock(&self) -> bool {
        self.timestamp_add_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_add_lock(&mut self, v: u32) {
        self.timestamp_add_lock = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_content_deadline = 14;

    pub fn timestamp_content_deadline(&self) -> u32 {
        self.timestamp_content_deadline.unwrap_or(0)
    }

    pub fn clear_timestamp_content_deadline(&mut self) {
        self.timestamp_content_deadline = ::std::option::Option::None;
    }

    pub fn has_timestamp_content_deadline(&self) -> bool {
        self.timestamp_content_deadline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_content_deadline(&mut self, v: u32) {
        self.timestamp_content_deadline = ::std::option::Option::Some(v);
    }

    // optional bool is_fantasy_enabled = 15;

    pub fn is_fantasy_enabled(&self) -> bool {
        self.is_fantasy_enabled.unwrap_or(false)
    }

    pub fn clear_is_fantasy_enabled(&mut self) {
        self.is_fantasy_enabled = ::std::option::Option::None;
    }

    pub fn has_is_fantasy_enabled(&self) -> bool {
        self.is_fantasy_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_fantasy_enabled(&mut self, v: bool) {
        self.is_fantasy_enabled = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_content_review_deadline = 16;

    pub fn timestamp_content_review_deadline(&self) -> u32 {
        self.timestamp_content_review_deadline.unwrap_or(0)
    }

    pub fn clear_timestamp_content_review_deadline(&mut self) {
        self.timestamp_content_review_deadline = ::std::option::Option::None;
    }

    pub fn has_timestamp_content_review_deadline(&self) -> bool {
        self.timestamp_content_review_deadline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_content_review_deadline(&mut self, v: u32) {
        self.timestamp_content_review_deadline = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDPCEvent {
    const NAME: &'static str = "CMsgDPCEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.leagues.push(is.read_message()?);
                },
                32 => {
                    self.registration_period = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.is_event_upcoming = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_event_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.multicast_league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.multicast_streams)?;
                },
                72 => {
                    self.multicast_streams.push(is.read_uint32()?);
                },
                80 => {
                    self.tour = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.timestamp_drop_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.timestamp_add_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.timestamp_content_deadline = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.is_fantasy_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.timestamp_content_review_deadline = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.registration_period {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.is_event_upcoming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_event_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.multicast_league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.multicast_streams {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.tour {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.timestamp_drop_lock {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.timestamp_add_lock {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.timestamp_content_deadline {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.is_fantasy_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp_content_review_deadline {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.leagues {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.registration_period {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_event_upcoming {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_event_completed {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.multicast_league_id {
            os.write_uint32(8, v)?;
        }
        for v in &self.multicast_streams {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.tour {
            os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp_drop_lock {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.timestamp_add_lock {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.timestamp_content_deadline {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.is_fantasy_enabled {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.timestamp_content_review_deadline {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPCEvent {
        CMsgDPCEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.leagues.clear();
        self.registration_period = ::std::option::Option::None;
        self.is_event_upcoming = ::std::option::Option::None;
        self.is_event_completed = ::std::option::Option::None;
        self.event_name = ::std::option::Option::None;
        self.multicast_league_id = ::std::option::Option::None;
        self.multicast_streams.clear();
        self.tour = ::std::option::Option::None;
        self.timestamp_drop_lock = ::std::option::Option::None;
        self.timestamp_add_lock = ::std::option::Option::None;
        self.timestamp_content_deadline = ::std::option::Option::None;
        self.is_fantasy_enabled = ::std::option::Option::None;
        self.timestamp_content_review_deadline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPCEvent {
        static instance: CMsgDPCEvent = CMsgDPCEvent {
            event: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            leagues: ::std::vec::Vec::new(),
            registration_period: ::std::option::Option::None,
            is_event_upcoming: ::std::option::Option::None,
            is_event_completed: ::std::option::Option::None,
            event_name: ::std::option::Option::None,
            multicast_league_id: ::std::option::Option::None,
            multicast_streams: ::std::vec::Vec::new(),
            tour: ::std::option::Option::None,
            timestamp_drop_lock: ::std::option::Option::None,
            timestamp_add_lock: ::std::option::Option::None,
            timestamp_content_deadline: ::std::option::Option::None,
            is_fantasy_enabled: ::std::option::Option::None,
            timestamp_content_review_deadline: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDPCEvent`
pub mod cmsg_dpcevent {
    // @@protoc_insertion_point(message:CMsgDPCEvent.PhaseInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PhaseInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDPCEvent.PhaseInfo.phase)
        pub phase: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ELeagueEventPhase>>,
        // @@protoc_insertion_point(field:CMsgDPCEvent.PhaseInfo.node_group_id)
        pub node_group_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDPCEvent.PhaseInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PhaseInfo {
        fn default() -> &'a PhaseInfo {
            <PhaseInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PhaseInfo {
        pub fn new() -> PhaseInfo {
            ::std::default::Default::default()
        }

        // optional .CMsgDPCEvent.ELeagueEventPhase phase = 1;

        pub fn phase(&self) -> ELeagueEventPhase {
            match self.phase {
                Some(e) => e.enum_value_or(ELeagueEventPhase::PHASE_INVALID),
                None => ELeagueEventPhase::PHASE_INVALID,
            }
        }

        pub fn clear_phase(&mut self) {
            self.phase = ::std::option::Option::None;
        }

        pub fn has_phase(&self) -> bool {
            self.phase.is_some()
        }

        // Param is passed by value, moved
        pub fn set_phase(&mut self, v: ELeagueEventPhase) {
            self.phase = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 node_group_id = 2;

        pub fn node_group_id(&self) -> u32 {
            self.node_group_id.unwrap_or(0)
        }

        pub fn clear_node_group_id(&mut self) {
            self.node_group_id = ::std::option::Option::None;
        }

        pub fn has_node_group_id(&self) -> bool {
            self.node_group_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_group_id(&mut self, v: u32) {
            self.node_group_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PhaseInfo {
        const NAME: &'static str = "PhaseInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.phase {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.node_group_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.phase {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.node_group_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PhaseInfo {
            PhaseInfo::new()
        }

        fn clear(&mut self) {
            self.phase = ::std::option::Option::None;
            self.node_group_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PhaseInfo {
            static instance: PhaseInfo = PhaseInfo {
                phase: ::std::option::Option::None,
                node_group_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDPCEvent.League)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct League {
        // message fields
        // @@protoc_insertion_point(field:CMsgDPCEvent.League.region)
        pub region: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:CMsgDPCEvent.League.division)
        pub division: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueDivision>>,
        // @@protoc_insertion_point(field:CMsgDPCEvent.League.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDPCEvent.League.phases)
        pub phases: ::std::vec::Vec<PhaseInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDPCEvent.League.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a League {
        fn default() -> &'a League {
            <League as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl League {
        pub fn new() -> League {
            ::std::default::Default::default()
        }

        // optional .ELeagueRegion region = 1;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional .ELeagueDivision division = 2;

        pub fn division(&self) -> super::super::dota_shared_enums::ELeagueDivision {
            match self.division {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET),
                None => super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET,
            }
        }

        pub fn clear_division(&mut self) {
            self.division = ::std::option::Option::None;
        }

        pub fn has_division(&self) -> bool {
            self.division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_division(&mut self, v: super::super::dota_shared_enums::ELeagueDivision) {
            self.division = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 league_id = 3;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for League {
        const NAME: &'static str = "League";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.division = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.phases.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.region {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.division {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.phases {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.region {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.division {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(3, v)?;
            }
            for v in &self.phases {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> League {
            League::new()
        }

        fn clear(&mut self) {
            self.region = ::std::option::Option::None;
            self.division = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.phases.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static League {
            static instance: League = League {
                region: ::std::option::Option::None,
                division: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                phases: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDPCEvent.ELeagueEvent)
    pub enum ELeagueEvent {
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.EVENT_INVALID)
        EVENT_INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SPRING_2021_LEAGUE)
        SPRING_2021_LEAGUE = 1,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SPRING_2021_MAJOR)
        SPRING_2021_MAJOR = 2,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2021_QUALIFIERS)
        INTERNATIONAL_2021_QUALIFIERS = 3,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2021)
        INTERNATIONAL_2021 = 4,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.WINTER_2021_LEAGUE)
        WINTER_2021_LEAGUE = 5,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.WINTER_2021_LEAGUE_FINALS)
        WINTER_2021_LEAGUE_FINALS = 6,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SPRING_2022_LEAGUE)
        SPRING_2022_LEAGUE = 7,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SPRING_2022_MAJOR)
        SPRING_2022_MAJOR = 8,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SUMMER_2022_LEAGUE)
        SUMMER_2022_LEAGUE = 9,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SUMMER_2022_MAJOR)
        SUMMER_2022_MAJOR = 10,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2022)
        INTERNATIONAL_2022 = 11,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.CHINA_REGIONAL_FINALS)
        CHINA_REGIONAL_FINALS = 12,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2022_REGIONAL_QUALIFIERS)
        INTERNATIONAL_2022_REGIONAL_QUALIFIERS = 13,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS)
        INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS = 14,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.WINTER_2023_LEAGUE)
        WINTER_2023_LEAGUE = 15,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.WINTER_2023_MAJOR)
        WINTER_2023_MAJOR = 16,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SPRING_2023_LEAGUE)
        SPRING_2023_LEAGUE = 17,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SPRING_2023_MAJOR)
        SPRING_2023_MAJOR = 18,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SUMMER_2023_LEAGUE)
        SUMMER_2023_LEAGUE = 19,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.SUMMER_2023_MAJOR)
        SUMMER_2023_MAJOR = 20,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEvent.INTERNATIONAL_2023)
        INTERNATIONAL_2023 = 21,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ELeagueEvent {
        const NAME: &'static str = "ELeagueEvent";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ELeagueEvent> {
            match value {
                0 => ::std::option::Option::Some(ELeagueEvent::EVENT_INVALID),
                1 => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_LEAGUE),
                2 => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_MAJOR),
                3 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021_QUALIFIERS),
                4 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021),
                5 => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE),
                6 => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE_FINALS),
                7 => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_LEAGUE),
                8 => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_MAJOR),
                9 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_LEAGUE),
                10 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_MAJOR),
                11 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022),
                12 => ::std::option::Option::Some(ELeagueEvent::CHINA_REGIONAL_FINALS),
                13 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_REGIONAL_QUALIFIERS),
                14 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS),
                15 => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_LEAGUE),
                16 => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_MAJOR),
                17 => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_LEAGUE),
                18 => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_MAJOR),
                19 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_LEAGUE),
                20 => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_MAJOR),
                21 => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2023),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ELeagueEvent> {
            match str {
                "EVENT_INVALID" => ::std::option::Option::Some(ELeagueEvent::EVENT_INVALID),
                "SPRING_2021_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_LEAGUE),
                "SPRING_2021_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SPRING_2021_MAJOR),
                "INTERNATIONAL_2021_QUALIFIERS" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021_QUALIFIERS),
                "INTERNATIONAL_2021" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2021),
                "WINTER_2021_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE),
                "WINTER_2021_LEAGUE_FINALS" => ::std::option::Option::Some(ELeagueEvent::WINTER_2021_LEAGUE_FINALS),
                "SPRING_2022_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_LEAGUE),
                "SPRING_2022_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SPRING_2022_MAJOR),
                "SUMMER_2022_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_LEAGUE),
                "SUMMER_2022_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2022_MAJOR),
                "INTERNATIONAL_2022" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022),
                "CHINA_REGIONAL_FINALS" => ::std::option::Option::Some(ELeagueEvent::CHINA_REGIONAL_FINALS),
                "INTERNATIONAL_2022_REGIONAL_QUALIFIERS" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_REGIONAL_QUALIFIERS),
                "INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS),
                "WINTER_2023_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_LEAGUE),
                "WINTER_2023_MAJOR" => ::std::option::Option::Some(ELeagueEvent::WINTER_2023_MAJOR),
                "SPRING_2023_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_LEAGUE),
                "SPRING_2023_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SPRING_2023_MAJOR),
                "SUMMER_2023_LEAGUE" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_LEAGUE),
                "SUMMER_2023_MAJOR" => ::std::option::Option::Some(ELeagueEvent::SUMMER_2023_MAJOR),
                "INTERNATIONAL_2023" => ::std::option::Option::Some(ELeagueEvent::INTERNATIONAL_2023),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ELeagueEvent] = &[
            ELeagueEvent::EVENT_INVALID,
            ELeagueEvent::SPRING_2021_LEAGUE,
            ELeagueEvent::SPRING_2021_MAJOR,
            ELeagueEvent::INTERNATIONAL_2021_QUALIFIERS,
            ELeagueEvent::INTERNATIONAL_2021,
            ELeagueEvent::WINTER_2021_LEAGUE,
            ELeagueEvent::WINTER_2021_LEAGUE_FINALS,
            ELeagueEvent::SPRING_2022_LEAGUE,
            ELeagueEvent::SPRING_2022_MAJOR,
            ELeagueEvent::SUMMER_2022_LEAGUE,
            ELeagueEvent::SUMMER_2022_MAJOR,
            ELeagueEvent::INTERNATIONAL_2022,
            ELeagueEvent::CHINA_REGIONAL_FINALS,
            ELeagueEvent::INTERNATIONAL_2022_REGIONAL_QUALIFIERS,
            ELeagueEvent::INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS,
            ELeagueEvent::WINTER_2023_LEAGUE,
            ELeagueEvent::WINTER_2023_MAJOR,
            ELeagueEvent::SPRING_2023_LEAGUE,
            ELeagueEvent::SPRING_2023_MAJOR,
            ELeagueEvent::SUMMER_2023_LEAGUE,
            ELeagueEvent::SUMMER_2023_MAJOR,
            ELeagueEvent::INTERNATIONAL_2023,
        ];
    }

    impl ::std::default::Default for ELeagueEvent {
        fn default() -> Self {
            ELeagueEvent::EVENT_INVALID
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDPCEvent.ELeagueEventPhase)
    pub enum ELeagueEventPhase {
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.PHASE_INVALID)
        PHASE_INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.WILD_CARD)
        WILD_CARD = 1,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.GROUP_STAGE)
        GROUP_STAGE = 2,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.GROUP_A)
        GROUP_A = 3,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.GROUP_B)
        GROUP_B = 4,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.OVERALL)
        OVERALL = 5,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.PLAYOFF)
        PLAYOFF = 6,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.RESULTS)
        RESULTS = 7,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.DPC_POINT_STANDINGS)
        DPC_POINT_STANDINGS = 8,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.GROUP_C)
        GROUP_C = 9,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.GROUP_D)
        GROUP_D = 10,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventPhase.PLACEMENT)
        PLACEMENT = 11,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ELeagueEventPhase {
        const NAME: &'static str = "ELeagueEventPhase";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ELeagueEventPhase> {
            match value {
                0 => ::std::option::Option::Some(ELeagueEventPhase::PHASE_INVALID),
                1 => ::std::option::Option::Some(ELeagueEventPhase::WILD_CARD),
                2 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_STAGE),
                3 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_A),
                4 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_B),
                5 => ::std::option::Option::Some(ELeagueEventPhase::OVERALL),
                6 => ::std::option::Option::Some(ELeagueEventPhase::PLAYOFF),
                7 => ::std::option::Option::Some(ELeagueEventPhase::RESULTS),
                8 => ::std::option::Option::Some(ELeagueEventPhase::DPC_POINT_STANDINGS),
                9 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_C),
                10 => ::std::option::Option::Some(ELeagueEventPhase::GROUP_D),
                11 => ::std::option::Option::Some(ELeagueEventPhase::PLACEMENT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ELeagueEventPhase> {
            match str {
                "PHASE_INVALID" => ::std::option::Option::Some(ELeagueEventPhase::PHASE_INVALID),
                "WILD_CARD" => ::std::option::Option::Some(ELeagueEventPhase::WILD_CARD),
                "GROUP_STAGE" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_STAGE),
                "GROUP_A" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_A),
                "GROUP_B" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_B),
                "OVERALL" => ::std::option::Option::Some(ELeagueEventPhase::OVERALL),
                "PLAYOFF" => ::std::option::Option::Some(ELeagueEventPhase::PLAYOFF),
                "RESULTS" => ::std::option::Option::Some(ELeagueEventPhase::RESULTS),
                "DPC_POINT_STANDINGS" => ::std::option::Option::Some(ELeagueEventPhase::DPC_POINT_STANDINGS),
                "GROUP_C" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_C),
                "GROUP_D" => ::std::option::Option::Some(ELeagueEventPhase::GROUP_D),
                "PLACEMENT" => ::std::option::Option::Some(ELeagueEventPhase::PLACEMENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ELeagueEventPhase] = &[
            ELeagueEventPhase::PHASE_INVALID,
            ELeagueEventPhase::WILD_CARD,
            ELeagueEventPhase::GROUP_STAGE,
            ELeagueEventPhase::GROUP_A,
            ELeagueEventPhase::GROUP_B,
            ELeagueEventPhase::OVERALL,
            ELeagueEventPhase::PLAYOFF,
            ELeagueEventPhase::RESULTS,
            ELeagueEventPhase::DPC_POINT_STANDINGS,
            ELeagueEventPhase::GROUP_C,
            ELeagueEventPhase::GROUP_D,
            ELeagueEventPhase::PLACEMENT,
        ];
    }

    impl ::std::default::Default for ELeagueEventPhase {
        fn default() -> Self {
            ELeagueEventPhase::PHASE_INVALID
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDPCEvent.ELeagueEventType)
    pub enum ELeagueEventType {
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventType.LEAGUE)
        LEAGUE = 1,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventType.MAJOR)
        MAJOR = 2,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventType.INTERNATIONAL_QUALIFIERS)
        INTERNATIONAL_QUALIFIERS = 3,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventType.INTERNATIONAL)
        INTERNATIONAL = 4,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventType.LEAGUE_FINALS)
        LEAGUE_FINALS = 5,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ELeagueEventType.EXTERNAL)
        EXTERNAL = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ELeagueEventType {
        const NAME: &'static str = "ELeagueEventType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ELeagueEventType> {
            match value {
                0 => ::std::option::Option::Some(ELeagueEventType::UNKNOWN),
                1 => ::std::option::Option::Some(ELeagueEventType::LEAGUE),
                2 => ::std::option::Option::Some(ELeagueEventType::MAJOR),
                3 => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL_QUALIFIERS),
                4 => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL),
                5 => ::std::option::Option::Some(ELeagueEventType::LEAGUE_FINALS),
                6 => ::std::option::Option::Some(ELeagueEventType::EXTERNAL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ELeagueEventType> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(ELeagueEventType::UNKNOWN),
                "LEAGUE" => ::std::option::Option::Some(ELeagueEventType::LEAGUE),
                "MAJOR" => ::std::option::Option::Some(ELeagueEventType::MAJOR),
                "INTERNATIONAL_QUALIFIERS" => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL_QUALIFIERS),
                "INTERNATIONAL" => ::std::option::Option::Some(ELeagueEventType::INTERNATIONAL),
                "LEAGUE_FINALS" => ::std::option::Option::Some(ELeagueEventType::LEAGUE_FINALS),
                "EXTERNAL" => ::std::option::Option::Some(ELeagueEventType::EXTERNAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ELeagueEventType] = &[
            ELeagueEventType::UNKNOWN,
            ELeagueEventType::LEAGUE,
            ELeagueEventType::MAJOR,
            ELeagueEventType::INTERNATIONAL_QUALIFIERS,
            ELeagueEventType::INTERNATIONAL,
            ELeagueEventType::LEAGUE_FINALS,
            ELeagueEventType::EXTERNAL,
        ];
    }

    impl ::std::default::Default for ELeagueEventType {
        fn default() -> Self {
            ELeagueEventType::UNKNOWN
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDPCEvent.ETour)
    pub enum ETour {
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ETour.TOUR_NONE)
        TOUR_NONE = 0,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ETour.TOUR_1)
        TOUR_1 = 1,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ETour.TOUR_2)
        TOUR_2 = 2,
        // @@protoc_insertion_point(enum_value:CMsgDPCEvent.ETour.TOUR_3)
        TOUR_3 = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ETour {
        const NAME: &'static str = "ETour";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETour> {
            match value {
                0 => ::std::option::Option::Some(ETour::TOUR_NONE),
                1 => ::std::option::Option::Some(ETour::TOUR_1),
                2 => ::std::option::Option::Some(ETour::TOUR_2),
                3 => ::std::option::Option::Some(ETour::TOUR_3),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETour> {
            match str {
                "TOUR_NONE" => ::std::option::Option::Some(ETour::TOUR_NONE),
                "TOUR_1" => ::std::option::Option::Some(ETour::TOUR_1),
                "TOUR_2" => ::std::option::Option::Some(ETour::TOUR_2),
                "TOUR_3" => ::std::option::Option::Some(ETour::TOUR_3),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETour] = &[
            ETour::TOUR_NONE,
            ETour::TOUR_1,
            ETour::TOUR_2,
            ETour::TOUR_3,
        ];
    }

    impl ::std::default::Default for ETour {
        fn default() -> Self {
            ETour::TOUR_NONE
        }
    }

}

// @@protoc_insertion_point(message:CMsgDPCEventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDPCEventList {
    // message fields
    // @@protoc_insertion_point(field:CMsgDPCEventList.events)
    pub events: ::std::vec::Vec<CMsgDPCEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDPCEventList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDPCEventList {
    fn default() -> &'a CMsgDPCEventList {
        <CMsgDPCEventList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDPCEventList {
    pub fn new() -> CMsgDPCEventList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDPCEventList {
    const NAME: &'static str = "CMsgDPCEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDPCEventList {
        CMsgDPCEventList::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDPCEventList {
        static instance: CMsgDPCEventList = CMsgDPCEventList {
            events: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAFantasyCardLineup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyCardLineup {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.periods)
    pub periods: ::std::vec::Vec<cmsg_dotafantasy_card_lineup::Period>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardLineup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyCardLineup {
    fn default() -> &'a CMsgDOTAFantasyCardLineup {
        <CMsgDOTAFantasyCardLineup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyCardLineup {
    pub fn new() -> CMsgDOTAFantasyCardLineup {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAFantasyCardLineup {
    const NAME: &'static str = "CMsgDOTAFantasyCardLineup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.periods.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.periods {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.periods {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyCardLineup {
        CMsgDOTAFantasyCardLineup::new()
    }

    fn clear(&mut self) {
        self.periods.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyCardLineup {
        static instance: CMsgDOTAFantasyCardLineup = CMsgDOTAFantasyCardLineup {
            periods: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAFantasyCardLineup`
pub mod cmsg_dotafantasy_card_lineup {
    // @@protoc_insertion_point(message:CMsgDOTAFantasyCardLineup.CardBonus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CardBonus {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.CardBonus.bonus_stat)
        pub bonus_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.CardBonus.bonus_value)
        pub bonus_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardLineup.CardBonus.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CardBonus {
        fn default() -> &'a CardBonus {
            <CardBonus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CardBonus {
        pub fn new() -> CardBonus {
            ::std::default::Default::default()
        }

        // optional uint32 bonus_stat = 1;

        pub fn bonus_stat(&self) -> u32 {
            self.bonus_stat.unwrap_or(0)
        }

        pub fn clear_bonus_stat(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
        }

        pub fn has_bonus_stat(&self) -> bool {
            self.bonus_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_stat(&mut self, v: u32) {
            self.bonus_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 bonus_value = 2;

        pub fn bonus_value(&self) -> u32 {
            self.bonus_value.unwrap_or(0)
        }

        pub fn clear_bonus_value(&mut self) {
            self.bonus_value = ::std::option::Option::None;
        }

        pub fn has_bonus_value(&self) -> bool {
            self.bonus_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_value(&mut self, v: u32) {
            self.bonus_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CardBonus {
        const NAME: &'static str = "CardBonus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.bonus_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.bonus_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.bonus_stat {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.bonus_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.bonus_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.bonus_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CardBonus {
            CardBonus::new()
        }

        fn clear(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
            self.bonus_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CardBonus {
            static instance: CardBonus = CardBonus {
                bonus_stat: ::std::option::Option::None,
                bonus_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAFantasyCardLineup.Card)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Card {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.player_account_id)
        pub player_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.bonuses)
        pub bonuses: ::std::vec::Vec<CardBonus>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.score)
        pub score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.finalized)
        pub finalized: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Card.item_id)
        pub item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardLineup.Card.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Card {
        fn default() -> &'a Card {
            <Card as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Card {
        pub fn new() -> Card {
            ::std::default::Default::default()
        }

        // optional uint32 player_account_id = 1;

        pub fn player_account_id(&self) -> u32 {
            self.player_account_id.unwrap_or(0)
        }

        pub fn clear_player_account_id(&mut self) {
            self.player_account_id = ::std::option::Option::None;
        }

        pub fn has_player_account_id(&self) -> bool {
            self.player_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_account_id(&mut self, v: u32) {
            self.player_account_id = ::std::option::Option::Some(v);
        }

        // optional string player_name = 2;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 3;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 4;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 role = 5;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional float score = 7;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional bool finalized = 8;

        pub fn finalized(&self) -> bool {
            self.finalized.unwrap_or(false)
        }

        pub fn clear_finalized(&mut self) {
            self.finalized = ::std::option::Option::None;
        }

        pub fn has_finalized(&self) -> bool {
            self.finalized.is_some()
        }

        // Param is passed by value, moved
        pub fn set_finalized(&mut self, v: bool) {
            self.finalized = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 9;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Card {
        const NAME: &'static str = "Card";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.bonuses.push(is.read_message()?);
                    },
                    61 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    64 => {
                        self.finalized = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.role {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            for value in &self.bonuses {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.finalized {
                my_size += 1 + 1;
            }
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(5, v)?;
            }
            for v in &self.bonuses {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.score {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.finalized {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Card {
            Card::new()
        }

        fn clear(&mut self) {
            self.player_account_id = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.bonuses.clear();
            self.score = ::std::option::Option::None;
            self.finalized = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Card {
            static instance: Card = Card {
                player_account_id: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                role: ::std::option::Option::None,
                bonuses: ::std::vec::Vec::new(),
                score: ::std::option::Option::None,
                finalized: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAFantasyCardLineup.League)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct League {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.League.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.League.cards)
        pub cards: ::std::vec::Vec<Card>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.League.score)
        pub score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardLineup.League.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a League {
        fn default() -> &'a League {
            <League as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl League {
        pub fn new() -> League {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional float score = 3;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for League {
        const NAME: &'static str = "League";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.cards.push(is.read_message()?);
                    },
                    29 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.cards {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.cards {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.score {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> League {
            League::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.cards.clear();
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static League {
            static instance: League = League {
                league_id: ::std::option::Option::None,
                cards: ::std::vec::Vec::new(),
                score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAFantasyCardLineup.Period)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Period {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Period.fantasy_period)
        pub fantasy_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Period.timestamp_start)
        pub timestamp_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Period.timestamp_end)
        pub timestamp_end: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardLineup.Period.leagues)
        pub leagues: ::std::vec::Vec<League>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardLineup.Period.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Period {
        fn default() -> &'a Period {
            <Period as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Period {
        pub fn new() -> Period {
            ::std::default::Default::default()
        }

        // optional uint32 fantasy_period = 1;

        pub fn fantasy_period(&self) -> u32 {
            self.fantasy_period.unwrap_or(4294967295u32)
        }

        pub fn clear_fantasy_period(&mut self) {
            self.fantasy_period = ::std::option::Option::None;
        }

        pub fn has_fantasy_period(&self) -> bool {
            self.fantasy_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fantasy_period(&mut self, v: u32) {
            self.fantasy_period = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp_start = 2;

        pub fn timestamp_start(&self) -> u32 {
            self.timestamp_start.unwrap_or(0)
        }

        pub fn clear_timestamp_start(&mut self) {
            self.timestamp_start = ::std::option::Option::None;
        }

        pub fn has_timestamp_start(&self) -> bool {
            self.timestamp_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_start(&mut self, v: u32) {
            self.timestamp_start = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp_end = 3;

        pub fn timestamp_end(&self) -> u32 {
            self.timestamp_end.unwrap_or(0)
        }

        pub fn clear_timestamp_end(&mut self) {
            self.timestamp_end = ::std::option::Option::None;
        }

        pub fn has_timestamp_end(&self) -> bool {
            self.timestamp_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_end(&mut self, v: u32) {
            self.timestamp_end = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Period {
        const NAME: &'static str = "Period";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fantasy_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.timestamp_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.leagues.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.fantasy_period {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp_start {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.timestamp_end {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.leagues {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.fantasy_period {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp_start {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.timestamp_end {
                os.write_uint32(3, v)?;
            }
            for v in &self.leagues {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Period {
            Period::new()
        }

        fn clear(&mut self) {
            self.fantasy_period = ::std::option::Option::None;
            self.timestamp_start = ::std::option::Option::None;
            self.timestamp_end = ::std::option::Option::None;
            self.leagues.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Period {
            static instance: Period = Period {
                fantasy_period: ::std::option::Option::None,
                timestamp_start: ::std::option::Option::None,
                timestamp_end: ::std::option::Option::None,
                leagues: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAFantasyCardList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyCardList {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.cards)
    pub cards: ::std::vec::Vec<cmsg_dotafantasy_card_list::Card>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyCardList {
    fn default() -> &'a CMsgDOTAFantasyCardList {
        <CMsgDOTAFantasyCardList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyCardList {
    pub fn new() -> CMsgDOTAFantasyCardList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAFantasyCardList {
    const NAME: &'static str = "CMsgDOTAFantasyCardList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cards.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cards {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.cards {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyCardList {
        CMsgDOTAFantasyCardList::new()
    }

    fn clear(&mut self) {
        self.cards.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyCardList {
        static instance: CMsgDOTAFantasyCardList = CMsgDOTAFantasyCardList {
            cards: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAFantasyCardList`
pub mod cmsg_dotafantasy_card_list {
    // @@protoc_insertion_point(message:CMsgDOTAFantasyCardList.CardBonus)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CardBonus {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.CardBonus.bonus_stat)
        pub bonus_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.CardBonus.bonus_value)
        pub bonus_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardList.CardBonus.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CardBonus {
        fn default() -> &'a CardBonus {
            <CardBonus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CardBonus {
        pub fn new() -> CardBonus {
            ::std::default::Default::default()
        }

        // optional uint32 bonus_stat = 1;

        pub fn bonus_stat(&self) -> u32 {
            self.bonus_stat.unwrap_or(0)
        }

        pub fn clear_bonus_stat(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
        }

        pub fn has_bonus_stat(&self) -> bool {
            self.bonus_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_stat(&mut self, v: u32) {
            self.bonus_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 bonus_value = 2;

        pub fn bonus_value(&self) -> u32 {
            self.bonus_value.unwrap_or(0)
        }

        pub fn clear_bonus_value(&mut self) {
            self.bonus_value = ::std::option::Option::None;
        }

        pub fn has_bonus_value(&self) -> bool {
            self.bonus_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bonus_value(&mut self, v: u32) {
            self.bonus_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CardBonus {
        const NAME: &'static str = "CardBonus";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.bonus_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.bonus_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.bonus_stat {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.bonus_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.bonus_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.bonus_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CardBonus {
            CardBonus::new()
        }

        fn clear(&mut self) {
            self.bonus_stat = ::std::option::Option::None;
            self.bonus_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CardBonus {
            static instance: CardBonus = CardBonus {
                bonus_stat: ::std::option::Option::None,
                bonus_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAFantasyCardList.Card)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Card {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.Card.player_account_id)
        pub player_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.Card.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.Card.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.Card.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.Card.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.Card.bonuses)
        pub bonuses: ::std::vec::Vec<CardBonus>,
        // @@protoc_insertion_point(field:CMsgDOTAFantasyCardList.Card.item_id)
        pub item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAFantasyCardList.Card.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Card {
        fn default() -> &'a Card {
            <Card as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Card {
        pub fn new() -> Card {
            ::std::default::Default::default()
        }

        // optional uint32 player_account_id = 1;

        pub fn player_account_id(&self) -> u32 {
            self.player_account_id.unwrap_or(0)
        }

        pub fn clear_player_account_id(&mut self) {
            self.player_account_id = ::std::option::Option::None;
        }

        pub fn has_player_account_id(&self) -> bool {
            self.player_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_account_id(&mut self, v: u32) {
            self.player_account_id = ::std::option::Option::Some(v);
        }

        // optional string player_name = 2;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 3;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 4;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 role = 5;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 8;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Card {
        const NAME: &'static str = "Card";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.bonuses.push(is.read_message()?);
                    },
                    64 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.role {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            for value in &self.bonuses {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(5, v)?;
            }
            for v in &self.bonuses {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.item_id {
                os.write_uint64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Card {
            Card::new()
        }

        fn clear(&mut self) {
            self.player_account_id = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.bonuses.clear();
            self.item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Card {
            static instance: Card = Card {
                player_account_id: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                role: ::std::option::Option::None,
                bonuses: ::std::vec::Vec::new(),
                item_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgChatToxicityToxicPlayerMatchesReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgChatToxicityToxicPlayerMatchesReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgChatToxicityToxicPlayerMatchesReport.rows)
    pub rows: ::std::vec::Vec<cmsg_chat_toxicity_toxic_player_matches_report::IndividualRow>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgChatToxicityToxicPlayerMatchesReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgChatToxicityToxicPlayerMatchesReport {
    fn default() -> &'a CMsgChatToxicityToxicPlayerMatchesReport {
        <CMsgChatToxicityToxicPlayerMatchesReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgChatToxicityToxicPlayerMatchesReport {
    pub fn new() -> CMsgChatToxicityToxicPlayerMatchesReport {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgChatToxicityToxicPlayerMatchesReport {
    const NAME: &'static str = "CMsgChatToxicityToxicPlayerMatchesReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rows.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.rows {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgChatToxicityToxicPlayerMatchesReport {
        CMsgChatToxicityToxicPlayerMatchesReport::new()
    }

    fn clear(&mut self) {
        self.rows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgChatToxicityToxicPlayerMatchesReport {
        static instance: CMsgChatToxicityToxicPlayerMatchesReport = CMsgChatToxicityToxicPlayerMatchesReport {
            rows: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgChatToxicityToxicPlayerMatchesReport`
pub mod cmsg_chat_toxicity_toxic_player_matches_report {
    // @@protoc_insertion_point(message:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct IndividualRow {
        // message fields
        // @@protoc_insertion_point(field:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow.player_account_id)
        pub player_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow.num_matches_seen)
        pub num_matches_seen: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow.num_messages)
        pub num_messages: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow.num_messages_toxic)
        pub num_messages_toxic: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow.first_match_seen)
        pub first_match_seen: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow.last_match_seen)
        pub last_match_seen: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgChatToxicityToxicPlayerMatchesReport.IndividualRow.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IndividualRow {
        fn default() -> &'a IndividualRow {
            <IndividualRow as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl IndividualRow {
        pub fn new() -> IndividualRow {
            ::std::default::Default::default()
        }

        // optional uint32 player_account_id = 1;

        pub fn player_account_id(&self) -> u32 {
            self.player_account_id.unwrap_or(0)
        }

        pub fn clear_player_account_id(&mut self) {
            self.player_account_id = ::std::option::Option::None;
        }

        pub fn has_player_account_id(&self) -> bool {
            self.player_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_account_id(&mut self, v: u32) {
            self.player_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 num_matches_seen = 2;

        pub fn num_matches_seen(&self) -> u32 {
            self.num_matches_seen.unwrap_or(0)
        }

        pub fn clear_num_matches_seen(&mut self) {
            self.num_matches_seen = ::std::option::Option::None;
        }

        pub fn has_num_matches_seen(&self) -> bool {
            self.num_matches_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_matches_seen(&mut self, v: u32) {
            self.num_matches_seen = ::std::option::Option::Some(v);
        }

        // optional uint32 num_messages = 3;

        pub fn num_messages(&self) -> u32 {
            self.num_messages.unwrap_or(0)
        }

        pub fn clear_num_messages(&mut self) {
            self.num_messages = ::std::option::Option::None;
        }

        pub fn has_num_messages(&self) -> bool {
            self.num_messages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_messages(&mut self, v: u32) {
            self.num_messages = ::std::option::Option::Some(v);
        }

        // optional uint32 num_messages_toxic = 4;

        pub fn num_messages_toxic(&self) -> u32 {
            self.num_messages_toxic.unwrap_or(0)
        }

        pub fn clear_num_messages_toxic(&mut self) {
            self.num_messages_toxic = ::std::option::Option::None;
        }

        pub fn has_num_messages_toxic(&self) -> bool {
            self.num_messages_toxic.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_messages_toxic(&mut self, v: u32) {
            self.num_messages_toxic = ::std::option::Option::Some(v);
        }

        // optional uint64 first_match_seen = 5;

        pub fn first_match_seen(&self) -> u64 {
            self.first_match_seen.unwrap_or(0)
        }

        pub fn clear_first_match_seen(&mut self) {
            self.first_match_seen = ::std::option::Option::None;
        }

        pub fn has_first_match_seen(&self) -> bool {
            self.first_match_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_match_seen(&mut self, v: u64) {
            self.first_match_seen = ::std::option::Option::Some(v);
        }

        // optional uint64 last_match_seen = 6;

        pub fn last_match_seen(&self) -> u64 {
            self.last_match_seen.unwrap_or(0)
        }

        pub fn clear_last_match_seen(&mut self) {
            self.last_match_seen = ::std::option::Option::None;
        }

        pub fn has_last_match_seen(&self) -> bool {
            self.last_match_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_match_seen(&mut self, v: u64) {
            self.last_match_seen = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for IndividualRow {
        const NAME: &'static str = "IndividualRow";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.num_matches_seen = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.num_messages = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.num_messages_toxic = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.first_match_seen = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.last_match_seen = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.num_matches_seen {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.num_messages {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.num_messages_toxic {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.first_match_seen {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.last_match_seen {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.num_matches_seen {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.num_messages {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.num_messages_toxic {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.first_match_seen {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.last_match_seen {
                os.write_uint64(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IndividualRow {
            IndividualRow::new()
        }

        fn clear(&mut self) {
            self.player_account_id = ::std::option::Option::None;
            self.num_matches_seen = ::std::option::Option::None;
            self.num_messages = ::std::option::Option::None;
            self.num_messages_toxic = ::std::option::Option::None;
            self.first_match_seen = ::std::option::Option::None;
            self.last_match_seen = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IndividualRow {
            static instance: IndividualRow = IndividualRow {
                player_account_id: ::std::option::Option::None,
                num_matches_seen: ::std::option::Option::None,
                num_messages: ::std::option::Option::None,
                num_messages_toxic: ::std::option::Option::None,
                first_match_seen: ::std::option::Option::None,
                last_match_seen: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgChatToxicityReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgChatToxicityReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgChatToxicityReport.num_matches_seen)
    pub num_matches_seen: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgChatToxicityReport.num_messages)
    pub num_messages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgChatToxicityReport.num_messages_ml_thinks_toxic)
    pub num_messages_ml_thinks_toxic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgChatToxicityReport.status)
    pub status: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgChatToxicityReport.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgChatToxicityReport.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgChatToxicityReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgChatToxicityReport {
    fn default() -> &'a CMsgChatToxicityReport {
        <CMsgChatToxicityReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgChatToxicityReport {
    pub fn new() -> CMsgChatToxicityReport {
        ::std::default::Default::default()
    }

    // optional uint32 num_matches_seen = 1;

    pub fn num_matches_seen(&self) -> u32 {
        self.num_matches_seen.unwrap_or(0)
    }

    pub fn clear_num_matches_seen(&mut self) {
        self.num_matches_seen = ::std::option::Option::None;
    }

    pub fn has_num_matches_seen(&self) -> bool {
        self.num_matches_seen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_matches_seen(&mut self, v: u32) {
        self.num_matches_seen = ::std::option::Option::Some(v);
    }

    // optional uint32 num_messages = 2;

    pub fn num_messages(&self) -> u32 {
        self.num_messages.unwrap_or(0)
    }

    pub fn clear_num_messages(&mut self) {
        self.num_messages = ::std::option::Option::None;
    }

    pub fn has_num_messages(&self) -> bool {
        self.num_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u32) {
        self.num_messages = ::std::option::Option::Some(v);
    }

    // optional uint32 num_messages_ml_thinks_toxic = 4;

    pub fn num_messages_ml_thinks_toxic(&self) -> u32 {
        self.num_messages_ml_thinks_toxic.unwrap_or(0)
    }

    pub fn clear_num_messages_ml_thinks_toxic(&mut self) {
        self.num_messages_ml_thinks_toxic = ::std::option::Option::None;
    }

    pub fn has_num_messages_ml_thinks_toxic(&self) -> bool {
        self.num_messages_ml_thinks_toxic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages_ml_thinks_toxic(&mut self, v: u32) {
        self.num_messages_ml_thinks_toxic = ::std::option::Option::Some(v);
    }

    // optional string status = 5;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 result = 6;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 7;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgChatToxicityReport {
    const NAME: &'static str = "CMsgChatToxicityReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_matches_seen = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_messages = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.num_messages_ml_thinks_toxic = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_matches_seen {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_messages {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_messages_ml_thinks_toxic {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.num_matches_seen {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_messages {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_messages_ml_thinks_toxic {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgChatToxicityReport {
        CMsgChatToxicityReport::new()
    }

    fn clear(&mut self) {
        self.num_matches_seen = ::std::option::Option::None;
        self.num_messages = ::std::option::Option::None;
        self.num_messages_ml_thinks_toxic = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgChatToxicityReport {
        static instance: CMsgChatToxicityReport = CMsgChatToxicityReport {
            num_matches_seen: ::std::option::Option::None,
            num_messages: ::std::option::Option::None,
            num_messages_ml_thinks_toxic: ::std::option::Option::None,
            status: ::std::option::Option::None,
            result: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGetTeamAuditInformation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGetTeamAuditInformation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.team_name)
    pub team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.actions)
    pub actions: ::std::vec::Vec<cmsg_get_team_audit_information::Action>,
    // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.last_updated)
    pub last_updated: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGetTeamAuditInformation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGetTeamAuditInformation {
    fn default() -> &'a CMsgGetTeamAuditInformation {
        <CMsgGetTeamAuditInformation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGetTeamAuditInformation {
    pub fn new() -> CMsgGetTeamAuditInformation {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional string team_name = 2;

    pub fn team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_name(&mut self) {
        self.team_name = ::std::option::Option::None;
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 last_updated = 4;

    pub fn last_updated(&self) -> u32 {
        self.last_updated.unwrap_or(0)
    }

    pub fn clear_last_updated(&mut self) {
        self.last_updated = ::std::option::Option::None;
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: u32) {
        self.last_updated = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGetTeamAuditInformation {
    const NAME: &'static str = "CMsgGetTeamAuditInformation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.team_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.actions.push(is.read_message()?);
                },
                32 => {
                    self.last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.team_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.last_updated {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.actions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.last_updated {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGetTeamAuditInformation {
        CMsgGetTeamAuditInformation::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.team_name = ::std::option::Option::None;
        self.actions.clear();
        self.last_updated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGetTeamAuditInformation {
        static instance: CMsgGetTeamAuditInformation = CMsgGetTeamAuditInformation {
            team_id: ::std::option::Option::None,
            team_name: ::std::option::Option::None,
            actions: ::std::vec::Vec::new(),
            last_updated: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGetTeamAuditInformation`
pub mod cmsg_get_team_audit_information {
    // @@protoc_insertion_point(message:CMsgGetTeamAuditInformation.Action)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Action {
        // message fields
        // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.Action.registration_period)
        pub registration_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.Action.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.Action.action)
        pub action: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.Action.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.Action.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGetTeamAuditInformation.Action.player_real_name)
        pub player_real_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGetTeamAuditInformation.Action.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Action {
        fn default() -> &'a Action {
            <Action as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Action {
        pub fn new() -> Action {
            ::std::default::Default::default()
        }

        // optional uint32 registration_period = 1;

        pub fn registration_period(&self) -> u32 {
            self.registration_period.unwrap_or(0)
        }

        pub fn clear_registration_period(&mut self) {
            self.registration_period = ::std::option::Option::None;
        }

        pub fn has_registration_period(&self) -> bool {
            self.registration_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_registration_period(&mut self, v: u32) {
            self.registration_period = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 action = 3;

        pub fn action(&self) -> u32 {
            self.action.unwrap_or(0)
        }

        pub fn clear_action(&mut self) {
            self.action = ::std::option::Option::None;
        }

        pub fn has_action(&self) -> bool {
            self.action.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action(&mut self, v: u32) {
            self.action = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string player_name = 5;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string player_real_name = 6;

        pub fn player_real_name(&self) -> &str {
            match self.player_real_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_real_name(&mut self) {
            self.player_real_name = ::std::option::Option::None;
        }

        pub fn has_player_real_name(&self) -> bool {
            self.player_real_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_real_name(&mut self, v: ::std::string::String) {
            self.player_real_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_real_name(&mut self) -> &mut ::std::string::String {
            if self.player_real_name.is_none() {
                self.player_real_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_real_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_real_name(&mut self) -> ::std::string::String {
            self.player_real_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Action {
        const NAME: &'static str = "Action";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.registration_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.action = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.player_real_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.registration_period {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.action {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.player_real_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.registration_period {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.action {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.player_real_name.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Action {
            Action::new()
        }

        fn clear(&mut self) {
            self.registration_period = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.action = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.player_real_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Action {
            static instance: Action = Action {
                registration_period: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                action: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                player_real_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTADPCMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADPCMatch.match)
    pub match_: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    // @@protoc_insertion_point(field:CMsgDOTADPCMatch.metadata)
    pub metadata: ::steam_vent_proto_common::protobuf::MessageField<super::dota_match_metadata::CDOTAMatchMetadata>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADPCMatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCMatch {
    fn default() -> &'a CMsgDOTADPCMatch {
        <CMsgDOTADPCMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCMatch {
    pub fn new() -> CMsgDOTADPCMatch {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADPCMatch {
    const NAME: &'static str = "CMsgDOTADPCMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCMatch {
        CMsgDOTADPCMatch::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCMatch {
        static instance: CMsgDOTADPCMatch = CMsgDOTADPCMatch {
            match_: ::steam_vent_proto_common::protobuf::MessageField::none(),
            metadata: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETeamFanContentStatus)
pub enum ETeamFanContentStatus {
    // @@protoc_insertion_point(enum_value:ETeamFanContentStatus.TEAM_FAN_CONTENT_STATUS_INVALID)
    TEAM_FAN_CONTENT_STATUS_INVALID = 0,
    // @@protoc_insertion_point(enum_value:ETeamFanContentStatus.TEAM_FAN_CONTENT_STATUS_PENDING)
    TEAM_FAN_CONTENT_STATUS_PENDING = 1,
    // @@protoc_insertion_point(enum_value:ETeamFanContentStatus.TEAM_FAN_CONTENT_STATUS_EVALUATED)
    TEAM_FAN_CONTENT_STATUS_EVALUATED = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETeamFanContentStatus {
    const NAME: &'static str = "ETeamFanContentStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeamFanContentStatus> {
        match value {
            0 => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID),
            1 => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_PENDING),
            2 => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_EVALUATED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeamFanContentStatus> {
        match str {
            "TEAM_FAN_CONTENT_STATUS_INVALID" => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID),
            "TEAM_FAN_CONTENT_STATUS_PENDING" => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_PENDING),
            "TEAM_FAN_CONTENT_STATUS_EVALUATED" => ::std::option::Option::Some(ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_EVALUATED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeamFanContentStatus] = &[
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID,
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_PENDING,
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_EVALUATED,
    ];
}

impl ::std::default::Default for ETeamFanContentStatus {
    fn default() -> Self {
        ETeamFanContentStatus::TEAM_FAN_CONTENT_STATUS_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETeamFanContentAssetType)
pub enum ETeamFanContentAssetType {
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_LogoPNG)
    k_eFanContentAssetType_LogoPNG = 1,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_LogoSVG)
    k_eFanContentAssetType_LogoSVG = 2,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_Logo3D)
    k_eFanContentAssetType_Logo3D = 3,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_Players)
    k_eFanContentAssetType_Players = 4,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_Sprays)
    k_eFanContentAssetType_Sprays = 5,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_Wallpapers)
    k_eFanContentAssetType_Wallpapers = 6,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_Emoticons)
    k_eFanContentAssetType_Emoticons = 7,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_VoiceLines)
    k_eFanContentAssetType_VoiceLines = 8,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetType.k_eFanContentAssetType_Localization)
    k_eFanContentAssetType_Localization = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETeamFanContentAssetType {
    const NAME: &'static str = "ETeamFanContentAssetType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeamFanContentAssetType> {
        match value {
            1 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG),
            2 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoSVG),
            3 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Logo3D),
            4 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Players),
            5 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Sprays),
            6 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Wallpapers),
            7 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Emoticons),
            8 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_VoiceLines),
            9 => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Localization),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeamFanContentAssetType> {
        match str {
            "k_eFanContentAssetType_LogoPNG" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG),
            "k_eFanContentAssetType_LogoSVG" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_LogoSVG),
            "k_eFanContentAssetType_Logo3D" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Logo3D),
            "k_eFanContentAssetType_Players" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Players),
            "k_eFanContentAssetType_Sprays" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Sprays),
            "k_eFanContentAssetType_Wallpapers" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Wallpapers),
            "k_eFanContentAssetType_Emoticons" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Emoticons),
            "k_eFanContentAssetType_VoiceLines" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_VoiceLines),
            "k_eFanContentAssetType_Localization" => ::std::option::Option::Some(ETeamFanContentAssetType::k_eFanContentAssetType_Localization),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeamFanContentAssetType] = &[
        ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG,
        ETeamFanContentAssetType::k_eFanContentAssetType_LogoSVG,
        ETeamFanContentAssetType::k_eFanContentAssetType_Logo3D,
        ETeamFanContentAssetType::k_eFanContentAssetType_Players,
        ETeamFanContentAssetType::k_eFanContentAssetType_Sprays,
        ETeamFanContentAssetType::k_eFanContentAssetType_Wallpapers,
        ETeamFanContentAssetType::k_eFanContentAssetType_Emoticons,
        ETeamFanContentAssetType::k_eFanContentAssetType_VoiceLines,
        ETeamFanContentAssetType::k_eFanContentAssetType_Localization,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETeamFanContentAssetType {
    fn default() -> Self {
        ETeamFanContentAssetType::k_eFanContentAssetType_LogoPNG
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETeamFanContentAssetStatus)
pub enum ETeamFanContentAssetStatus {
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetStatus.k_eFanContentAssetStatus_None)
    k_eFanContentAssetStatus_None = 0,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetStatus.k_eFanContentAssetStatus_Approved)
    k_eFanContentAssetStatus_Approved = 1,
    // @@protoc_insertion_point(enum_value:ETeamFanContentAssetStatus.k_eFanContentAssetStatus_Rejected)
    k_eFanContentAssetStatus_Rejected = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETeamFanContentAssetStatus {
    const NAME: &'static str = "ETeamFanContentAssetStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeamFanContentAssetStatus> {
        match value {
            0 => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None),
            1 => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Approved),
            2 => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Rejected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeamFanContentAssetStatus> {
        match str {
            "k_eFanContentAssetStatus_None" => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None),
            "k_eFanContentAssetStatus_Approved" => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Approved),
            "k_eFanContentAssetStatus_Rejected" => ::std::option::Option::Some(ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Rejected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeamFanContentAssetStatus] = &[
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None,
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Approved,
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_Rejected,
    ];
}

impl ::std::default::Default for ETeamFanContentAssetStatus {
    fn default() -> Self {
        ETeamFanContentAssetStatus::k_eFanContentAssetStatus_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETalentContentStatus)
pub enum ETalentContentStatus {
    // @@protoc_insertion_point(enum_value:ETalentContentStatus.TALENT_CONTENT_STATUS_INVALID)
    TALENT_CONTENT_STATUS_INVALID = 0,
    // @@protoc_insertion_point(enum_value:ETalentContentStatus.TALENT_CONTENT_STATUS_PENDING)
    TALENT_CONTENT_STATUS_PENDING = 1,
    // @@protoc_insertion_point(enum_value:ETalentContentStatus.TALENT_CONTENT_STATUS_EVALUATED)
    TALENT_CONTENT_STATUS_EVALUATED = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETalentContentStatus {
    const NAME: &'static str = "ETalentContentStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETalentContentStatus> {
        match value {
            0 => ::std::option::Option::Some(ETalentContentStatus::TALENT_CONTENT_STATUS_INVALID),
            1 => ::std::option::Option::Some(ETalentContentStatus::TALENT_CONTENT_STATUS_PENDING),
            2 => ::std::option::Option::Some(ETalentContentStatus::TALENT_CONTENT_STATUS_EVALUATED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETalentContentStatus> {
        match str {
            "TALENT_CONTENT_STATUS_INVALID" => ::std::option::Option::Some(ETalentContentStatus::TALENT_CONTENT_STATUS_INVALID),
            "TALENT_CONTENT_STATUS_PENDING" => ::std::option::Option::Some(ETalentContentStatus::TALENT_CONTENT_STATUS_PENDING),
            "TALENT_CONTENT_STATUS_EVALUATED" => ::std::option::Option::Some(ETalentContentStatus::TALENT_CONTENT_STATUS_EVALUATED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETalentContentStatus] = &[
        ETalentContentStatus::TALENT_CONTENT_STATUS_INVALID,
        ETalentContentStatus::TALENT_CONTENT_STATUS_PENDING,
        ETalentContentStatus::TALENT_CONTENT_STATUS_EVALUATED,
    ];
}

impl ::std::default::Default for ETalentContentStatus {
    fn default() -> Self {
        ETalentContentStatus::TALENT_CONTENT_STATUS_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETalentContentAssetType)
pub enum ETalentContentAssetType {
    // @@protoc_insertion_point(enum_value:ETalentContentAssetType.k_eTalentContentAssetType_Photo)
    k_eTalentContentAssetType_Photo = 1,
    // @@protoc_insertion_point(enum_value:ETalentContentAssetType.k_eTalentContentAssetType_Autograph)
    k_eTalentContentAssetType_Autograph = 2,
    // @@protoc_insertion_point(enum_value:ETalentContentAssetType.k_eTalentContentAssetType_Voicelines)
    k_eTalentContentAssetType_Voicelines = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETalentContentAssetType {
    const NAME: &'static str = "ETalentContentAssetType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETalentContentAssetType> {
        match value {
            1 => ::std::option::Option::Some(ETalentContentAssetType::k_eTalentContentAssetType_Photo),
            2 => ::std::option::Option::Some(ETalentContentAssetType::k_eTalentContentAssetType_Autograph),
            3 => ::std::option::Option::Some(ETalentContentAssetType::k_eTalentContentAssetType_Voicelines),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETalentContentAssetType> {
        match str {
            "k_eTalentContentAssetType_Photo" => ::std::option::Option::Some(ETalentContentAssetType::k_eTalentContentAssetType_Photo),
            "k_eTalentContentAssetType_Autograph" => ::std::option::Option::Some(ETalentContentAssetType::k_eTalentContentAssetType_Autograph),
            "k_eTalentContentAssetType_Voicelines" => ::std::option::Option::Some(ETalentContentAssetType::k_eTalentContentAssetType_Voicelines),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETalentContentAssetType] = &[
        ETalentContentAssetType::k_eTalentContentAssetType_Photo,
        ETalentContentAssetType::k_eTalentContentAssetType_Autograph,
        ETalentContentAssetType::k_eTalentContentAssetType_Voicelines,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETalentContentAssetType {
    fn default() -> Self {
        ETalentContentAssetType::k_eTalentContentAssetType_Photo
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETalentContentAssetStatus)
pub enum ETalentContentAssetStatus {
    // @@protoc_insertion_point(enum_value:ETalentContentAssetStatus.k_eTalentContentAssetStatus_None)
    k_eTalentContentAssetStatus_None = 0,
    // @@protoc_insertion_point(enum_value:ETalentContentAssetStatus.k_eTalentContentAssetStatus_Approved)
    k_eTalentContentAssetStatus_Approved = 1,
    // @@protoc_insertion_point(enum_value:ETalentContentAssetStatus.k_eTalentContentAssetStatus_Rejected)
    k_eTalentContentAssetStatus_Rejected = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETalentContentAssetStatus {
    const NAME: &'static str = "ETalentContentAssetStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETalentContentAssetStatus> {
        match value {
            0 => ::std::option::Option::Some(ETalentContentAssetStatus::k_eTalentContentAssetStatus_None),
            1 => ::std::option::Option::Some(ETalentContentAssetStatus::k_eTalentContentAssetStatus_Approved),
            2 => ::std::option::Option::Some(ETalentContentAssetStatus::k_eTalentContentAssetStatus_Rejected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETalentContentAssetStatus> {
        match str {
            "k_eTalentContentAssetStatus_None" => ::std::option::Option::Some(ETalentContentAssetStatus::k_eTalentContentAssetStatus_None),
            "k_eTalentContentAssetStatus_Approved" => ::std::option::Option::Some(ETalentContentAssetStatus::k_eTalentContentAssetStatus_Approved),
            "k_eTalentContentAssetStatus_Rejected" => ::std::option::Option::Some(ETalentContentAssetStatus::k_eTalentContentAssetStatus_Rejected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETalentContentAssetStatus] = &[
        ETalentContentAssetStatus::k_eTalentContentAssetStatus_None,
        ETalentContentAssetStatus::k_eTalentContentAssetStatus_Approved,
        ETalentContentAssetStatus::k_eTalentContentAssetStatus_Rejected,
    ];
}

impl ::std::default::Default for ETalentContentAssetStatus {
    fn default() -> Self {
        ETalentContentAssetStatus::k_eTalentContentAssetStatus_None
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common::*;
#[allow(unused_imports)]
use crate::dota_match_metadata::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgArcanaVotes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADPCFeed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADPCUserInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDraftTrivia {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTeamFanContentAssetStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTeamFanContentAssetStatusResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTeamFanContentStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTeamFanContentAutographStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTalentContentAssetStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTalentContentStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetTalentContentResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDPCEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDPCEventList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAFantasyCardLineup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAFantasyCardList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgChatToxicityToxicPlayerMatchesReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgChatToxicityReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGetTeamAuditInformation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADPCMatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
