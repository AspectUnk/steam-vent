// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_messages_mlbot.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgMLBotMatchMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMLBotMatchMetadata {
    // message fields
    // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.players)
    pub players: ::std::vec::Vec<cmsg_mlbot_match_metadata::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMLBotMatchMetadata.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMLBotMatchMetadata {
    fn default() -> &'a CMsgMLBotMatchMetadata {
        <CMsgMLBotMatchMetadata as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMLBotMatchMetadata {
    pub fn new() -> CMsgMLBotMatchMetadata {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 2;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 3;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(-1i32)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 4;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMLBotMatchMetadata {
    const NAME: &'static str = "CMsgMLBotMatchMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(4, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMLBotMatchMetadata {
        CMsgMLBotMatchMetadata::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMLBotMatchMetadata {
        static instance: CMsgMLBotMatchMetadata = CMsgMLBotMatchMetadata {
            match_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMLBotMatchMetadata`
pub mod cmsg_mlbot_match_metadata {
    // @@protoc_insertion_point(message:CMsgMLBotMatchMetadata.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.Player.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.Player.team_id)
        pub team_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.Player.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgMLBotMatchMetadata.Player.rank)
        pub rank: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMLBotMatchMetadata.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 team_id = 2;

        pub fn team_id(&self) -> i32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: i32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 3;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional int32 rank = 4;

        pub fn rank(&self) -> i32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: i32) {
            self.rank = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.rank = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.rank {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.rank = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                player_id: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgMLBotTickBoundary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMLBotTickBoundary {
    // message fields
    // @@protoc_insertion_point(field:CMsgMLBotTickBoundary.tick_number)
    pub tick_number: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMLBotTickBoundary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMLBotTickBoundary {
    fn default() -> &'a CMsgMLBotTickBoundary {
        <CMsgMLBotTickBoundary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMLBotTickBoundary {
    pub fn new() -> CMsgMLBotTickBoundary {
        ::std::default::Default::default()
    }

    // optional uint32 tick_number = 1;

    pub fn tick_number(&self) -> u32 {
        self.tick_number.unwrap_or(0)
    }

    pub fn clear_tick_number(&mut self) {
        self.tick_number = ::std::option::Option::None;
    }

    pub fn has_tick_number(&self) -> bool {
        self.tick_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_number(&mut self, v: u32) {
        self.tick_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMLBotTickBoundary {
    const NAME: &'static str = "CMsgMLBotTickBoundary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tick_number {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMLBotTickBoundary {
        CMsgMLBotTickBoundary::new()
    }

    fn clear(&mut self) {
        self.tick_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMLBotTickBoundary {
        static instance: CMsgMLBotTickBoundary = CMsgMLBotTickBoundary {
            tick_number: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMLBot_PlayerOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMLBot_PlayerOrder {
    // message fields
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.team_id)
    pub team_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.order_type)
    pub order_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.selected_unit_handles)
    pub selected_unit_handles: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.target_index)
    pub target_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.target_handle)
    pub target_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.ability_index)
    pub ability_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.ability_handle)
    pub ability_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgMLBot_PlayerOrder.queue)
    pub queue: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMLBot_PlayerOrder.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMLBot_PlayerOrder {
    fn default() -> &'a CMsgMLBot_PlayerOrder {
        <CMsgMLBot_PlayerOrder as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMLBot_PlayerOrder {
    pub fn new() -> CMsgMLBot_PlayerOrder {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id = 2;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional int32 order_type = 3;

    pub fn order_type(&self) -> i32 {
        self.order_type.unwrap_or(0)
    }

    pub fn clear_order_type(&mut self) {
        self.order_type = ::std::option::Option::None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = ::std::option::Option::Some(v);
    }

    // optional int32 target_index = 5;

    pub fn target_index(&self) -> i32 {
        self.target_index.unwrap_or(-1i32)
    }

    pub fn clear_target_index(&mut self) {
        self.target_index = ::std::option::Option::None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = ::std::option::Option::Some(v);
    }

    // optional uint32 target_handle = 6;

    pub fn target_handle(&self) -> u32 {
        self.target_handle.unwrap_or(4294967295u32)
    }

    pub fn clear_target_handle(&mut self) {
        self.target_handle = ::std::option::Option::None;
    }

    pub fn has_target_handle(&self) -> bool {
        self.target_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_handle(&mut self, v: u32) {
        self.target_handle = ::std::option::Option::Some(v);
    }

    // optional int32 ability_index = 7;

    pub fn ability_index(&self) -> i32 {
        self.ability_index.unwrap_or(-1i32)
    }

    pub fn clear_ability_index(&mut self) {
        self.ability_index = ::std::option::Option::None;
    }

    pub fn has_ability_index(&self) -> bool {
        self.ability_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_index(&mut self, v: i32) {
        self.ability_index = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_handle = 8;

    pub fn ability_handle(&self) -> u32 {
        self.ability_handle.unwrap_or(4294967295u32)
    }

    pub fn clear_ability_handle(&mut self) {
        self.ability_handle = ::std::option::Option::None;
    }

    pub fn has_ability_handle(&self) -> bool {
        self.ability_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_handle(&mut self, v: u32) {
        self.ability_handle = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 9;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 10;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 11;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional bool queue = 12;

    pub fn queue(&self) -> bool {
        self.queue.unwrap_or(false)
    }

    pub fn clear_queue(&mut self) {
        self.queue = ::std::option::Option::None;
    }

    pub fn has_queue(&self) -> bool {
        self.queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue(&mut self, v: bool) {
        self.queue = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMLBot_PlayerOrder {
    const NAME: &'static str = "CMsgMLBot_PlayerOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.order_type = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.selected_unit_handles)?;
                },
                32 => {
                    self.selected_unit_handles.push(is.read_uint32()?);
                },
                40 => {
                    self.target_index = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.target_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ability_index = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.ability_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                96 => {
                    self.queue = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.order_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        for value in &self.selected_unit_handles {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.target_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.target_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ability_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.ability_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.queue {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.order_type {
            os.write_int32(3, v)?;
        }
        for v in &self.selected_unit_handles {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.target_index {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.target_handle {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ability_index {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.ability_handle {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.queue {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMLBot_PlayerOrder {
        CMsgMLBot_PlayerOrder::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.order_type = ::std::option::Option::None;
        self.selected_unit_handles.clear();
        self.target_index = ::std::option::Option::None;
        self.target_handle = ::std::option::Option::None;
        self.ability_index = ::std::option::Option::None;
        self.ability_handle = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.queue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMLBot_PlayerOrder {
        static instance: CMsgMLBot_PlayerOrder = CMsgMLBot_PlayerOrder {
            player_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            order_type: ::std::option::Option::None,
            selected_unit_handles: ::std::vec::Vec::new(),
            target_index: ::std::option::Option::None,
            target_handle: ::std::option::Option::None,
            ability_index: ::std::option::Option::None,
            ability_handle: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            queue: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMLBot_TeamInference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMLBot_TeamInference {
    // message fields
    // @@protoc_insertion_point(field:CMsgMLBot_TeamInference.team_id)
    pub team_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMLBot_TeamInference.bot_player_ids)
    pub bot_player_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgMLBot_TeamInference.world_state)
    pub world_state: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common_bot_script::CMsgBotWorldState>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMLBot_TeamInference.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMLBot_TeamInference {
    fn default() -> &'a CMsgMLBot_TeamInference {
        <CMsgMLBot_TeamInference as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMLBot_TeamInference {
    pub fn new() -> CMsgMLBot_TeamInference {
        ::std::default::Default::default()
    }

    // optional int32 team_id = 1;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMLBot_TeamInference {
    const NAME: &'static str = "CMsgMLBot_TeamInference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.bot_player_ids)?;
                },
                16 => {
                    self.bot_player_ids.push(is.read_int32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.world_state)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.bot_player_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.world_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        for v in &self.bot_player_ids {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.world_state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMLBot_TeamInference {
        CMsgMLBot_TeamInference::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.bot_player_ids.clear();
        self.world_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMLBot_TeamInference {
        static instance: CMsgMLBot_TeamInference = CMsgMLBot_TeamInference {
            team_id: ::std::option::Option::None,
            bot_player_ids: ::std::vec::Vec::new(),
            world_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMLBot_TeamInferenceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMLBot_TeamInferenceResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgMLBot_TeamInferenceResponse.orders)
    pub orders: ::std::vec::Vec<CMsgMLBot_PlayerOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMLBot_TeamInferenceResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMLBot_TeamInferenceResponse {
    fn default() -> &'a CMsgMLBot_TeamInferenceResponse {
        <CMsgMLBot_TeamInferenceResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMLBot_TeamInferenceResponse {
    pub fn new() -> CMsgMLBot_TeamInferenceResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMLBot_TeamInferenceResponse {
    const NAME: &'static str = "CMsgMLBot_TeamInferenceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orders.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.orders {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMLBot_TeamInferenceResponse {
        CMsgMLBot_TeamInferenceResponse::new()
    }

    fn clear(&mut self) {
        self.orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMLBot_TeamInferenceResponse {
        static instance: CMsgMLBot_TeamInferenceResponse = CMsgMLBot_TeamInferenceResponse {
            orders: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMLBot_TeamInferenceList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMLBot_TeamInferenceList {
    // message fields
    // @@protoc_insertion_point(field:CMsgMLBot_TeamInferenceList.messages)
    pub messages: ::std::vec::Vec<CMsgMLBot_TeamInference>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMLBot_TeamInferenceList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMLBot_TeamInferenceList {
    fn default() -> &'a CMsgMLBot_TeamInferenceList {
        <CMsgMLBot_TeamInferenceList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMLBot_TeamInferenceList {
    pub fn new() -> CMsgMLBot_TeamInferenceList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMLBot_TeamInferenceList {
    const NAME: &'static str = "CMsgMLBot_TeamInferenceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMLBot_TeamInferenceList {
        CMsgMLBot_TeamInferenceList::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMLBot_TeamInferenceList {
        static instance: CMsgMLBot_TeamInferenceList = CMsgMLBot_TeamInferenceList {
            messages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MLBot_MessageId)
pub enum MLBot_MessageId {
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_MatchMetadata)
    mlbot_MatchMetadata = 1,
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_TickBoundary)
    mlbot_TickBoundary = 2,
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_TeamState_Radiant)
    mlbot_TeamState_Radiant = 3,
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_TeamState_Radiant_Delta)
    mlbot_TeamState_Radiant_Delta = 4,
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_TeamState_Dire)
    mlbot_TeamState_Dire = 5,
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_TeamState_Dire_Delta)
    mlbot_TeamState_Dire_Delta = 6,
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_PlayerCommand)
    mlbot_PlayerCommand = 7,
    // @@protoc_insertion_point(enum_value:MLBot_MessageId.mlbot_PlayerOrder)
    mlbot_PlayerOrder = 8,
}

impl ::steam_vent_proto_common::protobuf::Enum for MLBot_MessageId {
    const NAME: &'static str = "MLBot_MessageId";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MLBot_MessageId> {
        match value {
            1 => ::std::option::Option::Some(MLBot_MessageId::mlbot_MatchMetadata),
            2 => ::std::option::Option::Some(MLBot_MessageId::mlbot_TickBoundary),
            3 => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Radiant),
            4 => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Radiant_Delta),
            5 => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Dire),
            6 => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Dire_Delta),
            7 => ::std::option::Option::Some(MLBot_MessageId::mlbot_PlayerCommand),
            8 => ::std::option::Option::Some(MLBot_MessageId::mlbot_PlayerOrder),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MLBot_MessageId> {
        match str {
            "mlbot_MatchMetadata" => ::std::option::Option::Some(MLBot_MessageId::mlbot_MatchMetadata),
            "mlbot_TickBoundary" => ::std::option::Option::Some(MLBot_MessageId::mlbot_TickBoundary),
            "mlbot_TeamState_Radiant" => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Radiant),
            "mlbot_TeamState_Radiant_Delta" => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Radiant_Delta),
            "mlbot_TeamState_Dire" => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Dire),
            "mlbot_TeamState_Dire_Delta" => ::std::option::Option::Some(MLBot_MessageId::mlbot_TeamState_Dire_Delta),
            "mlbot_PlayerCommand" => ::std::option::Option::Some(MLBot_MessageId::mlbot_PlayerCommand),
            "mlbot_PlayerOrder" => ::std::option::Option::Some(MLBot_MessageId::mlbot_PlayerOrder),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MLBot_MessageId] = &[
        MLBot_MessageId::mlbot_MatchMetadata,
        MLBot_MessageId::mlbot_TickBoundary,
        MLBot_MessageId::mlbot_TeamState_Radiant,
        MLBot_MessageId::mlbot_TeamState_Radiant_Delta,
        MLBot_MessageId::mlbot_TeamState_Dire,
        MLBot_MessageId::mlbot_TeamState_Dire_Delta,
        MLBot_MessageId::mlbot_PlayerCommand,
        MLBot_MessageId::mlbot_PlayerOrder,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MLBot_MessageId {
    fn default() -> Self {
        MLBot_MessageId::mlbot_MatchMetadata
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::dota_gcmessages_common_bot_script::*;
#[allow(unused_imports)]
use crate::dota_commonmessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgMLBotMatchMetadata {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMLBotTickBoundary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMLBot_PlayerOrder {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMLBot_TeamInference {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMLBot_TeamInferenceResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMLBot_TeamInferenceList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
