// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_match_metadata.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CDOTAMatchMetadataFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAMatchMetadataFile {
    // message fields
    // @@protoc_insertion_point(field:CDOTAMatchMetadataFile.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadataFile.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadataFile.metadata)
    pub metadata: ::steam_vent_proto_common::protobuf::MessageField<CDOTAMatchMetadata>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadataFile.private_metadata)
    pub private_metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAMatchMetadataFile.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAMatchMetadataFile {
    fn default() -> &'a CDOTAMatchMetadataFile {
        <CDOTAMatchMetadataFile as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAMatchMetadataFile {
    pub fn new() -> CDOTAMatchMetadataFile {
        ::std::default::Default::default()
    }

    // required int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // required uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bytes private_metadata = 5;

    pub fn private_metadata(&self) -> &[u8] {
        match self.private_metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_private_metadata(&mut self) {
        self.private_metadata = ::std::option::Option::None;
    }

    pub fn has_private_metadata(&self) -> bool {
        self.private_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.private_metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.private_metadata.is_none() {
            self.private_metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.private_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_private_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.private_metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAMatchMetadataFile {
    const NAME: &'static str = "CDOTAMatchMetadataFile";

    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        if self.match_id.is_none() {
            return false;
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                42 => {
                    self.private_metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.private_metadata.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.private_metadata.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAMatchMetadataFile {
        CDOTAMatchMetadataFile::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.metadata.clear();
        self.private_metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAMatchMetadataFile {
        static instance: CDOTAMatchMetadataFile = CDOTAMatchMetadataFile {
            version: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            metadata: ::steam_vent_proto_common::protobuf::MessageField::none(),
            private_metadata: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAMatchMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAMatchMetadata {
    // message fields
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.teams)
    pub teams: ::std::vec::Vec<cdotamatch_metadata::Team>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.report_until_time)
    pub report_until_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.event_game_custom_table)
    pub event_game_custom_table: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.primary_event_id)
    pub primary_event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.matchmaking_stats)
    pub matchmaking_stats: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMsgMatchMatchmakingStats>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.mvp_data)
    pub mvp_data: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMvpData>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.guild_challenge_progress)
    pub guild_challenge_progress: ::std::vec::Vec<cdotamatch_metadata::GuildChallengeProgress>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.custom_post_game_table)
    pub custom_post_game_table: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.match_tips)
    pub match_tips: ::std::vec::Vec<cdotamatch_metadata::Tip>,
    // @@protoc_insertion_point(field:CDOTAMatchMetadata.match_tracked_stats)
    pub match_tracked_stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgTrackedStat>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAMatchMetadata {
    fn default() -> &'a CDOTAMatchMetadata {
        <CDOTAMatchMetadata as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAMatchMetadata {
    pub fn new() -> CDOTAMatchMetadata {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 report_until_time = 4;

    pub fn report_until_time(&self) -> u64 {
        self.report_until_time.unwrap_or(0)
    }

    pub fn clear_report_until_time(&mut self) {
        self.report_until_time = ::std::option::Option::None;
    }

    pub fn has_report_until_time(&self) -> bool {
        self.report_until_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_until_time(&mut self, v: u64) {
        self.report_until_time = ::std::option::Option::Some(v);
    }

    // optional bytes event_game_custom_table = 5;

    pub fn event_game_custom_table(&self) -> &[u8] {
        match self.event_game_custom_table.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_event_game_custom_table(&mut self) {
        self.event_game_custom_table = ::std::option::Option::None;
    }

    pub fn has_event_game_custom_table(&self) -> bool {
        self.event_game_custom_table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_custom_table(&mut self, v: ::std::vec::Vec<u8>) {
        self.event_game_custom_table = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_custom_table(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.event_game_custom_table.is_none() {
            self.event_game_custom_table = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.event_game_custom_table.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_custom_table(&mut self) -> ::std::vec::Vec<u8> {
        self.event_game_custom_table.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 primary_event_id = 6;

    pub fn primary_event_id(&self) -> u32 {
        self.primary_event_id.unwrap_or(0)
    }

    pub fn clear_primary_event_id(&mut self) {
        self.primary_event_id = ::std::option::Option::None;
    }

    pub fn has_primary_event_id(&self) -> bool {
        self.primary_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_event_id(&mut self, v: u32) {
        self.primary_event_id = ::std::option::Option::Some(v);
    }

    // optional bytes custom_post_game_table = 11;

    pub fn custom_post_game_table(&self) -> &[u8] {
        match self.custom_post_game_table.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_custom_post_game_table(&mut self) {
        self.custom_post_game_table = ::std::option::Option::None;
    }

    pub fn has_custom_post_game_table(&self) -> bool {
        self.custom_post_game_table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_post_game_table(&mut self, v: ::std::vec::Vec<u8>) {
        self.custom_post_game_table = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_post_game_table(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.custom_post_game_table.is_none() {
            self.custom_post_game_table = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.custom_post_game_table.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_post_game_table(&mut self) -> ::std::vec::Vec<u8> {
        self.custom_post_game_table.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAMatchMetadata {
    const NAME: &'static str = "CDOTAMatchMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.teams.push(is.read_message()?);
                },
                25 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.report_until_time = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    self.event_game_custom_table = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.primary_event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.matchmaking_stats)?;
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.mvp_data)?;
                },
                82 => {
                    self.guild_challenge_progress.push(is.read_message()?);
                },
                90 => {
                    self.custom_post_game_table = ::std::option::Option::Some(is.read_bytes()?);
                },
                98 => {
                    self.match_tips.push(is.read_message()?);
                },
                106 => {
                    self.match_tracked_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.report_until_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_game_custom_table.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.primary_event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.matchmaking_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mvp_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.guild_challenge_progress {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.custom_post_game_table.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(11, &v);
        }
        for value in &self.match_tips {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.match_tracked_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.teams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.lobby_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.report_until_time {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.event_game_custom_table.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.primary_event_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.matchmaking_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.mvp_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.guild_challenge_progress {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.custom_post_game_table.as_ref() {
            os.write_bytes(11, v)?;
        }
        for v in &self.match_tips {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.match_tracked_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAMatchMetadata {
        CDOTAMatchMetadata::new()
    }

    fn clear(&mut self) {
        self.teams.clear();
        self.lobby_id = ::std::option::Option::None;
        self.report_until_time = ::std::option::Option::None;
        self.event_game_custom_table = ::std::option::Option::None;
        self.primary_event_id = ::std::option::Option::None;
        self.matchmaking_stats.clear();
        self.mvp_data.clear();
        self.guild_challenge_progress.clear();
        self.custom_post_game_table = ::std::option::Option::None;
        self.match_tips.clear();
        self.match_tracked_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAMatchMetadata {
        static instance: CDOTAMatchMetadata = CDOTAMatchMetadata {
            teams: ::std::vec::Vec::new(),
            lobby_id: ::std::option::Option::None,
            report_until_time: ::std::option::Option::None,
            event_game_custom_table: ::std::option::Option::None,
            primary_event_id: ::std::option::Option::None,
            matchmaking_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            mvp_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            guild_challenge_progress: ::std::vec::Vec::new(),
            custom_post_game_table: ::std::option::Option::None,
            match_tips: ::std::vec::Vec::new(),
            match_tracked_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAMatchMetadata`
pub mod cdotamatch_metadata {
    // @@protoc_insertion_point(message:CDOTAMatchMetadata.EconItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EconItem {
        // message fields
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.EconItem.def_index)
        pub def_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.EconItem.quality)
        pub quality: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.EconItem.attribute)
        pub attribute: ::std::vec::Vec<super::super::base_gcmessages::CSOEconItemAttribute>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.EconItem.style)
        pub style: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.EconItem.equipped_state)
        pub equipped_state: ::std::vec::Vec<super::super::base_gcmessages::CSOEconItemEquipped>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.EconItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EconItem {
        fn default() -> &'a EconItem {
            <EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl EconItem {
        pub fn new() -> EconItem {
            ::std::default::Default::default()
        }

        // optional uint32 def_index = 1;

        pub fn def_index(&self) -> u32 {
            self.def_index.unwrap_or(0)
        }

        pub fn clear_def_index(&mut self) {
            self.def_index = ::std::option::Option::None;
        }

        pub fn has_def_index(&self) -> bool {
            self.def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_def_index(&mut self, v: u32) {
            self.def_index = ::std::option::Option::Some(v);
        }

        // optional uint32 quality = 2;

        pub fn quality(&self) -> u32 {
            self.quality.unwrap_or(4u32)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: u32) {
            self.quality = ::std::option::Option::Some(v);
        }

        // optional uint32 style = 4;

        pub fn style(&self) -> u32 {
            self.style.unwrap_or(0u32)
        }

        pub fn clear_style(&mut self) {
            self.style = ::std::option::Option::None;
        }

        pub fn has_style(&self) -> bool {
            self.style.is_some()
        }

        // Param is passed by value, moved
        pub fn set_style(&mut self, v: u32) {
            self.style = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for EconItem {
        const NAME: &'static str = "EconItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.attribute.push(is.read_message()?);
                    },
                    32 => {
                        self.style = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.equipped_state.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.def_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.attribute {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.style {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.equipped_state {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.def_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quality {
                os.write_uint32(2, v)?;
            }
            for v in &self.attribute {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.style {
                os.write_uint32(4, v)?;
            }
            for v in &self.equipped_state {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EconItem {
            EconItem::new()
        }

        fn clear(&mut self) {
            self.def_index = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.attribute.clear();
            self.style = ::std::option::Option::None;
            self.equipped_state.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EconItem {
            static instance: EconItem = EconItem {
                def_index: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                attribute: ::std::vec::Vec::new(),
                style: ::std::option::Option::None,
                equipped_state: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.dota_team)
        pub dota_team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.players)
        pub players: ::std::vec::Vec<team::Player>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.graph_experience)
        pub graph_experience: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.graph_gold_earned)
        pub graph_gold_earned: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.graph_net_worth)
        pub graph_net_worth: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.cm_first_pick)
        pub cm_first_pick: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.cm_captain_player_id)
        pub cm_captain_player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.cm_penalty)
        pub cm_penalty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.team_tracked_stats)
        pub team_tracked_stats: ::std::vec::Vec<super::super::dota_gcmessages_common::CMsgTrackedStat>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 dota_team = 1;

        pub fn dota_team(&self) -> u32 {
            self.dota_team.unwrap_or(0)
        }

        pub fn clear_dota_team(&mut self) {
            self.dota_team = ::std::option::Option::None;
        }

        pub fn has_dota_team(&self) -> bool {
            self.dota_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dota_team(&mut self, v: u32) {
            self.dota_team = ::std::option::Option::Some(v);
        }

        // optional bool cm_first_pick = 6;

        pub fn cm_first_pick(&self) -> bool {
            self.cm_first_pick.unwrap_or(false)
        }

        pub fn clear_cm_first_pick(&mut self) {
            self.cm_first_pick = ::std::option::Option::None;
        }

        pub fn has_cm_first_pick(&self) -> bool {
            self.cm_first_pick.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cm_first_pick(&mut self, v: bool) {
            self.cm_first_pick = ::std::option::Option::Some(v);
        }

        // optional int32 cm_captain_player_id = 7;

        pub fn cm_captain_player_id(&self) -> i32 {
            self.cm_captain_player_id.unwrap_or(-1i32)
        }

        pub fn clear_cm_captain_player_id(&mut self) {
            self.cm_captain_player_id = ::std::option::Option::None;
        }

        pub fn has_cm_captain_player_id(&self) -> bool {
            self.cm_captain_player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cm_captain_player_id(&mut self, v: i32) {
            self.cm_captain_player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 cm_penalty = 10;

        pub fn cm_penalty(&self) -> u32 {
            self.cm_penalty.unwrap_or(0)
        }

        pub fn clear_cm_penalty(&mut self) {
            self.cm_penalty = ::std::option::Option::None;
        }

        pub fn has_cm_penalty(&self) -> bool {
            self.cm_penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cm_penalty(&mut self, v: u32) {
            self.cm_penalty = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.players.push(is.read_message()?);
                    },
                    26 => {
                        is.read_repeated_packed_float_into(&mut self.graph_experience)?;
                    },
                    29 => {
                        self.graph_experience.push(is.read_float()?);
                    },
                    34 => {
                        is.read_repeated_packed_float_into(&mut self.graph_gold_earned)?;
                    },
                    37 => {
                        self.graph_gold_earned.push(is.read_float()?);
                    },
                    42 => {
                        is.read_repeated_packed_float_into(&mut self.graph_net_worth)?;
                    },
                    45 => {
                        self.graph_net_worth.push(is.read_float()?);
                    },
                    48 => {
                        self.cm_first_pick = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.cm_captain_player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.cm_penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.team_tracked_stats.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dota_team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += 5 * self.graph_experience.len() as u64;
            my_size += 5 * self.graph_gold_earned.len() as u64;
            my_size += 5 * self.graph_net_worth.len() as u64;
            if let Some(v) = self.cm_first_pick {
                my_size += 1 + 1;
            }
            if let Some(v) = self.cm_captain_player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.cm_penalty {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            for value in &self.team_tracked_stats {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.dota_team {
                os.write_uint32(1, v)?;
            }
            for v in &self.players {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.graph_experience {
                os.write_float(3, *v)?;
            };
            for v in &self.graph_gold_earned {
                os.write_float(4, *v)?;
            };
            for v in &self.graph_net_worth {
                os.write_float(5, *v)?;
            };
            if let Some(v) = self.cm_first_pick {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.cm_captain_player_id {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.cm_penalty {
                os.write_uint32(10, v)?;
            }
            for v in &self.team_tracked_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.dota_team = ::std::option::Option::None;
            self.players.clear();
            self.graph_experience.clear();
            self.graph_gold_earned.clear();
            self.graph_net_worth.clear();
            self.cm_first_pick = ::std::option::Option::None;
            self.cm_captain_player_id = ::std::option::Option::None;
            self.cm_penalty = ::std::option::Option::None;
            self.team_tracked_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                dota_team: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                graph_experience: ::std::vec::Vec::new(),
                graph_gold_earned: ::std::vec::Vec::new(),
                graph_net_worth: ::std::vec::Vec::new(),
                cm_first_pick: ::std::option::Option::None,
                cm_captain_player_id: ::std::option::Option::None,
                cm_penalty: ::std::option::Option::None,
                team_tracked_stats: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Team`
    pub mod team {
        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.PlayerKill)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PlayerKill {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.PlayerKill.victim_slot)
            pub victim_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.PlayerKill.count)
            pub count: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.PlayerKill.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PlayerKill {
            fn default() -> &'a PlayerKill {
                <PlayerKill as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl PlayerKill {
            pub fn new() -> PlayerKill {
                ::std::default::Default::default()
            }

            // optional uint32 victim_slot = 1;

            pub fn victim_slot(&self) -> u32 {
                self.victim_slot.unwrap_or(0)
            }

            pub fn clear_victim_slot(&mut self) {
                self.victim_slot = ::std::option::Option::None;
            }

            pub fn has_victim_slot(&self) -> bool {
                self.victim_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_victim_slot(&mut self, v: u32) {
                self.victim_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 count = 2;

            pub fn count(&self) -> u32 {
                self.count.unwrap_or(0)
            }

            pub fn clear_count(&mut self) {
                self.count = ::std::option::Option::None;
            }

            pub fn has_count(&self) -> bool {
                self.count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_count(&mut self, v: u32) {
                self.count = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for PlayerKill {
            const NAME: &'static str = "PlayerKill";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.victim_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.victim_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.count {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.victim_slot {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.count {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PlayerKill {
                PlayerKill::new()
            }

            fn clear(&mut self) {
                self.victim_slot = ::std::option::Option::None;
                self.count = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PlayerKill {
                static instance: PlayerKill = PlayerKill {
                    victim_slot: ::std::option::Option::None,
                    count: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.ItemPurchase)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ItemPurchase {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.ItemPurchase.item_id)
            pub item_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.ItemPurchase.purchase_time)
            pub purchase_time: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.ItemPurchase.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ItemPurchase {
            fn default() -> &'a ItemPurchase {
                <ItemPurchase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl ItemPurchase {
            pub fn new() -> ItemPurchase {
                ::std::default::Default::default()
            }

            // optional int32 item_id = 1;

            pub fn item_id(&self) -> i32 {
                self.item_id.unwrap_or(-1i32)
            }

            pub fn clear_item_id(&mut self) {
                self.item_id = ::std::option::Option::None;
            }

            pub fn has_item_id(&self) -> bool {
                self.item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_id(&mut self, v: i32) {
                self.item_id = ::std::option::Option::Some(v);
            }

            // optional int32 purchase_time = 2;

            pub fn purchase_time(&self) -> i32 {
                self.purchase_time.unwrap_or(0)
            }

            pub fn clear_purchase_time(&mut self) {
                self.purchase_time = ::std::option::Option::None;
            }

            pub fn has_purchase_time(&self) -> bool {
                self.purchase_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_purchase_time(&mut self, v: i32) {
                self.purchase_time = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for ItemPurchase {
            const NAME: &'static str = "ItemPurchase";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.item_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.purchase_time = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.item_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.purchase_time {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.item_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.purchase_time {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ItemPurchase {
                ItemPurchase::new()
            }

            fn clear(&mut self) {
                self.item_id = ::std::option::Option::None;
                self.purchase_time = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ItemPurchase {
                static instance: ItemPurchase = ItemPurchase {
                    item_id: ::std::option::Option::None,
                    purchase_time: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.InventorySnapshot)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct InventorySnapshot {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.item_id)
            pub item_id: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.game_time)
            pub game_time: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.kills)
            pub kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.deaths)
            pub deaths: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.assists)
            pub assists: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.level)
            pub level: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.backpack_item_id)
            pub backpack_item_id: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.InventorySnapshot.neutral_item_id)
            pub neutral_item_id: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.InventorySnapshot.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a InventorySnapshot {
            fn default() -> &'a InventorySnapshot {
                <InventorySnapshot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl InventorySnapshot {
            pub fn new() -> InventorySnapshot {
                ::std::default::Default::default()
            }

            // optional int32 game_time = 2;

            pub fn game_time(&self) -> i32 {
                self.game_time.unwrap_or(0)
            }

            pub fn clear_game_time(&mut self) {
                self.game_time = ::std::option::Option::None;
            }

            pub fn has_game_time(&self) -> bool {
                self.game_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_time(&mut self, v: i32) {
                self.game_time = ::std::option::Option::Some(v);
            }

            // optional uint32 kills = 3;

            pub fn kills(&self) -> u32 {
                self.kills.unwrap_or(0)
            }

            pub fn clear_kills(&mut self) {
                self.kills = ::std::option::Option::None;
            }

            pub fn has_kills(&self) -> bool {
                self.kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kills(&mut self, v: u32) {
                self.kills = ::std::option::Option::Some(v);
            }

            // optional uint32 deaths = 4;

            pub fn deaths(&self) -> u32 {
                self.deaths.unwrap_or(0)
            }

            pub fn clear_deaths(&mut self) {
                self.deaths = ::std::option::Option::None;
            }

            pub fn has_deaths(&self) -> bool {
                self.deaths.is_some()
            }

            // Param is passed by value, moved
            pub fn set_deaths(&mut self, v: u32) {
                self.deaths = ::std::option::Option::Some(v);
            }

            // optional uint32 assists = 5;

            pub fn assists(&self) -> u32 {
                self.assists.unwrap_or(0)
            }

            pub fn clear_assists(&mut self) {
                self.assists = ::std::option::Option::None;
            }

            pub fn has_assists(&self) -> bool {
                self.assists.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assists(&mut self, v: u32) {
                self.assists = ::std::option::Option::Some(v);
            }

            // optional uint32 level = 6;

            pub fn level(&self) -> u32 {
                self.level.unwrap_or(0)
            }

            pub fn clear_level(&mut self) {
                self.level = ::std::option::Option::None;
            }

            pub fn has_level(&self) -> bool {
                self.level.is_some()
            }

            // Param is passed by value, moved
            pub fn set_level(&mut self, v: u32) {
                self.level = ::std::option::Option::Some(v);
            }

            // optional int32 neutral_item_id = 8;

            pub fn neutral_item_id(&self) -> i32 {
                self.neutral_item_id.unwrap_or(-1i32)
            }

            pub fn clear_neutral_item_id(&mut self) {
                self.neutral_item_id = ::std::option::Option::None;
            }

            pub fn has_neutral_item_id(&self) -> bool {
                self.neutral_item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_neutral_item_id(&mut self, v: i32) {
                self.neutral_item_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for InventorySnapshot {
            const NAME: &'static str = "InventorySnapshot";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            is.read_repeated_packed_int32_into(&mut self.item_id)?;
                        },
                        8 => {
                            self.item_id.push(is.read_int32()?);
                        },
                        16 => {
                            self.game_time = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.assists = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.level = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        58 => {
                            is.read_repeated_packed_int32_into(&mut self.backpack_item_id)?;
                        },
                        56 => {
                            self.backpack_item_id.push(is.read_int32()?);
                        },
                        64 => {
                            self.neutral_item_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.item_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
                };
                if let Some(v) = self.game_time {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
                }
                if let Some(v) = self.kills {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.deaths {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.assists {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.level {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                }
                for value in &self.backpack_item_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, *value);
                };
                if let Some(v) = self.neutral_item_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                for v in &self.item_id {
                    os.write_int32(1, *v)?;
                };
                if let Some(v) = self.game_time {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.kills {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.deaths {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.assists {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.level {
                    os.write_uint32(6, v)?;
                }
                for v in &self.backpack_item_id {
                    os.write_int32(7, *v)?;
                };
                if let Some(v) = self.neutral_item_id {
                    os.write_int32(8, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> InventorySnapshot {
                InventorySnapshot::new()
            }

            fn clear(&mut self) {
                self.item_id.clear();
                self.game_time = ::std::option::Option::None;
                self.kills = ::std::option::Option::None;
                self.deaths = ::std::option::Option::None;
                self.assists = ::std::option::Option::None;
                self.level = ::std::option::Option::None;
                self.backpack_item_id.clear();
                self.neutral_item_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static InventorySnapshot {
                static instance: InventorySnapshot = InventorySnapshot {
                    item_id: ::std::vec::Vec::new(),
                    game_time: ::std::option::Option::None,
                    kills: ::std::option::Option::None,
                    deaths: ::std::option::Option::None,
                    assists: ::std::option::Option::None,
                    level: ::std::option::Option::None,
                    backpack_item_id: ::std::vec::Vec::new(),
                    neutral_item_id: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.AutoStyleCriteria)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AutoStyleCriteria {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.AutoStyleCriteria.name_token)
            pub name_token: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.AutoStyleCriteria.value)
            pub value: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.AutoStyleCriteria.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AutoStyleCriteria {
            fn default() -> &'a AutoStyleCriteria {
                <AutoStyleCriteria as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl AutoStyleCriteria {
            pub fn new() -> AutoStyleCriteria {
                ::std::default::Default::default()
            }

            // optional uint32 name_token = 1;

            pub fn name_token(&self) -> u32 {
                self.name_token.unwrap_or(0)
            }

            pub fn clear_name_token(&mut self) {
                self.name_token = ::std::option::Option::None;
            }

            pub fn has_name_token(&self) -> bool {
                self.name_token.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name_token(&mut self, v: u32) {
                self.name_token = ::std::option::Option::Some(v);
            }

            // optional float value = 2;

            pub fn value(&self) -> f32 {
                self.value.unwrap_or(0.)
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: f32) {
                self.value = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for AutoStyleCriteria {
            const NAME: &'static str = "AutoStyleCriteria";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.name_token = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        21 => {
                            self.value = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name_token {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value {
                    my_size += 1 + 4;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.name_token {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value {
                    os.write_float(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AutoStyleCriteria {
                AutoStyleCriteria::new()
            }

            fn clear(&mut self) {
                self.name_token = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AutoStyleCriteria {
                static instance: AutoStyleCriteria = AutoStyleCriteria {
                    name_token: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.StrangeGemProgress)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct StrangeGemProgress {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.StrangeGemProgress.kill_eater_type)
            pub kill_eater_type: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.StrangeGemProgress.gem_item_def_index)
            pub gem_item_def_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.StrangeGemProgress.required_hero_id)
            pub required_hero_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.StrangeGemProgress.starting_value)
            pub starting_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.StrangeGemProgress.ending_value)
            pub ending_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.StrangeGemProgress.owner_item_def_index)
            pub owner_item_def_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.StrangeGemProgress.owner_item_id)
            pub owner_item_id: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.StrangeGemProgress.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StrangeGemProgress {
            fn default() -> &'a StrangeGemProgress {
                <StrangeGemProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl StrangeGemProgress {
            pub fn new() -> StrangeGemProgress {
                ::std::default::Default::default()
            }

            // optional uint32 kill_eater_type = 1;

            pub fn kill_eater_type(&self) -> u32 {
                self.kill_eater_type.unwrap_or(0)
            }

            pub fn clear_kill_eater_type(&mut self) {
                self.kill_eater_type = ::std::option::Option::None;
            }

            pub fn has_kill_eater_type(&self) -> bool {
                self.kill_eater_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kill_eater_type(&mut self, v: u32) {
                self.kill_eater_type = ::std::option::Option::Some(v);
            }

            // optional uint32 gem_item_def_index = 2;

            pub fn gem_item_def_index(&self) -> u32 {
                self.gem_item_def_index.unwrap_or(0)
            }

            pub fn clear_gem_item_def_index(&mut self) {
                self.gem_item_def_index = ::std::option::Option::None;
            }

            pub fn has_gem_item_def_index(&self) -> bool {
                self.gem_item_def_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gem_item_def_index(&mut self, v: u32) {
                self.gem_item_def_index = ::std::option::Option::Some(v);
            }

            // optional int32 required_hero_id = 3;

            pub fn required_hero_id(&self) -> i32 {
                self.required_hero_id.unwrap_or(0)
            }

            pub fn clear_required_hero_id(&mut self) {
                self.required_hero_id = ::std::option::Option::None;
            }

            pub fn has_required_hero_id(&self) -> bool {
                self.required_hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_required_hero_id(&mut self, v: i32) {
                self.required_hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 starting_value = 4;

            pub fn starting_value(&self) -> u32 {
                self.starting_value.unwrap_or(0)
            }

            pub fn clear_starting_value(&mut self) {
                self.starting_value = ::std::option::Option::None;
            }

            pub fn has_starting_value(&self) -> bool {
                self.starting_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_starting_value(&mut self, v: u32) {
                self.starting_value = ::std::option::Option::Some(v);
            }

            // optional uint32 ending_value = 5;

            pub fn ending_value(&self) -> u32 {
                self.ending_value.unwrap_or(0)
            }

            pub fn clear_ending_value(&mut self) {
                self.ending_value = ::std::option::Option::None;
            }

            pub fn has_ending_value(&self) -> bool {
                self.ending_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ending_value(&mut self, v: u32) {
                self.ending_value = ::std::option::Option::Some(v);
            }

            // optional uint32 owner_item_def_index = 6;

            pub fn owner_item_def_index(&self) -> u32 {
                self.owner_item_def_index.unwrap_or(0)
            }

            pub fn clear_owner_item_def_index(&mut self) {
                self.owner_item_def_index = ::std::option::Option::None;
            }

            pub fn has_owner_item_def_index(&self) -> bool {
                self.owner_item_def_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_owner_item_def_index(&mut self, v: u32) {
                self.owner_item_def_index = ::std::option::Option::Some(v);
            }

            // optional uint64 owner_item_id = 7;

            pub fn owner_item_id(&self) -> u64 {
                self.owner_item_id.unwrap_or(0)
            }

            pub fn clear_owner_item_id(&mut self) {
                self.owner_item_id = ::std::option::Option::None;
            }

            pub fn has_owner_item_id(&self) -> bool {
                self.owner_item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_owner_item_id(&mut self, v: u64) {
                self.owner_item_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for StrangeGemProgress {
            const NAME: &'static str = "StrangeGemProgress";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.kill_eater_type = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.gem_item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.required_hero_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        32 => {
                            self.starting_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.ending_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.owner_item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        56 => {
                            self.owner_item_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.kill_eater_type {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.gem_item_def_index {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.required_hero_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
                }
                if let Some(v) = self.starting_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.ending_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.owner_item_def_index {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                }
                if let Some(v) = self.owner_item_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.kill_eater_type {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.gem_item_def_index {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.required_hero_id {
                    os.write_int32(3, v)?;
                }
                if let Some(v) = self.starting_value {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.ending_value {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.owner_item_def_index {
                    os.write_uint32(6, v)?;
                }
                if let Some(v) = self.owner_item_id {
                    os.write_uint64(7, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StrangeGemProgress {
                StrangeGemProgress::new()
            }

            fn clear(&mut self) {
                self.kill_eater_type = ::std::option::Option::None;
                self.gem_item_def_index = ::std::option::Option::None;
                self.required_hero_id = ::std::option::Option::None;
                self.starting_value = ::std::option::Option::None;
                self.ending_value = ::std::option::Option::None;
                self.owner_item_def_index = ::std::option::Option::None;
                self.owner_item_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StrangeGemProgress {
                static instance: StrangeGemProgress = StrangeGemProgress {
                    kill_eater_type: ::std::option::Option::None,
                    gem_item_def_index: ::std::option::Option::None,
                    required_hero_id: ::std::option::Option::None,
                    starting_value: ::std::option::Option::None,
                    ending_value: ::std::option::Option::None,
                    owner_item_def_index: ::std::option::Option::None,
                    owner_item_id: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.VictoryPrediction)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VictoryPrediction {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.VictoryPrediction.item_id)
            pub item_id: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.VictoryPrediction.item_def_index)
            pub item_def_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.VictoryPrediction.starting_value)
            pub starting_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.VictoryPrediction.is_victory)
            pub is_victory: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.VictoryPrediction.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VictoryPrediction {
            fn default() -> &'a VictoryPrediction {
                <VictoryPrediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl VictoryPrediction {
            pub fn new() -> VictoryPrediction {
                ::std::default::Default::default()
            }

            // optional uint64 item_id = 1;

            pub fn item_id(&self) -> u64 {
                self.item_id.unwrap_or(0)
            }

            pub fn clear_item_id(&mut self) {
                self.item_id = ::std::option::Option::None;
            }

            pub fn has_item_id(&self) -> bool {
                self.item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_id(&mut self, v: u64) {
                self.item_id = ::std::option::Option::Some(v);
            }

            // optional uint32 item_def_index = 2;

            pub fn item_def_index(&self) -> u32 {
                self.item_def_index.unwrap_or(0)
            }

            pub fn clear_item_def_index(&mut self) {
                self.item_def_index = ::std::option::Option::None;
            }

            pub fn has_item_def_index(&self) -> bool {
                self.item_def_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_def_index(&mut self, v: u32) {
                self.item_def_index = ::std::option::Option::Some(v);
            }

            // optional uint32 starting_value = 3;

            pub fn starting_value(&self) -> u32 {
                self.starting_value.unwrap_or(0)
            }

            pub fn clear_starting_value(&mut self) {
                self.starting_value = ::std::option::Option::None;
            }

            pub fn has_starting_value(&self) -> bool {
                self.starting_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_starting_value(&mut self, v: u32) {
                self.starting_value = ::std::option::Option::Some(v);
            }

            // optional bool is_victory = 4;

            pub fn is_victory(&self) -> bool {
                self.is_victory.unwrap_or(false)
            }

            pub fn clear_is_victory(&mut self) {
                self.is_victory = ::std::option::Option::None;
            }

            pub fn has_is_victory(&self) -> bool {
                self.is_victory.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_victory(&mut self, v: bool) {
                self.is_victory = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for VictoryPrediction {
            const NAME: &'static str = "VictoryPrediction";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        16 => {
                            self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.starting_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.is_victory = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.item_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
                }
                if let Some(v) = self.item_def_index {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.starting_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.is_victory {
                    my_size += 1 + 1;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.item_id {
                    os.write_uint64(1, v)?;
                }
                if let Some(v) = self.item_def_index {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.starting_value {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.is_victory {
                    os.write_bool(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VictoryPrediction {
                VictoryPrediction::new()
            }

            fn clear(&mut self) {
                self.item_id = ::std::option::Option::None;
                self.item_def_index = ::std::option::Option::None;
                self.starting_value = ::std::option::Option::None;
                self.is_victory = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VictoryPrediction {
                static instance: VictoryPrediction = VictoryPrediction {
                    item_id: ::std::option::Option::None,
                    item_def_index: ::std::option::Option::None,
                    starting_value: ::std::option::Option::None,
                    is_victory: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.SubChallenge)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SubChallenge {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.SubChallenge.slot_id)
            pub slot_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.SubChallenge.start_value)
            pub start_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.SubChallenge.end_value)
            pub end_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.SubChallenge.completed)
            pub completed: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.SubChallenge.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SubChallenge {
            fn default() -> &'a SubChallenge {
                <SubChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl SubChallenge {
            pub fn new() -> SubChallenge {
                ::std::default::Default::default()
            }

            // optional uint32 slot_id = 1;

            pub fn slot_id(&self) -> u32 {
                self.slot_id.unwrap_or(0)
            }

            pub fn clear_slot_id(&mut self) {
                self.slot_id = ::std::option::Option::None;
            }

            pub fn has_slot_id(&self) -> bool {
                self.slot_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_slot_id(&mut self, v: u32) {
                self.slot_id = ::std::option::Option::Some(v);
            }

            // optional uint32 start_value = 2;

            pub fn start_value(&self) -> u32 {
                self.start_value.unwrap_or(0)
            }

            pub fn clear_start_value(&mut self) {
                self.start_value = ::std::option::Option::None;
            }

            pub fn has_start_value(&self) -> bool {
                self.start_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_start_value(&mut self, v: u32) {
                self.start_value = ::std::option::Option::Some(v);
            }

            // optional uint32 end_value = 3;

            pub fn end_value(&self) -> u32 {
                self.end_value.unwrap_or(0)
            }

            pub fn clear_end_value(&mut self) {
                self.end_value = ::std::option::Option::None;
            }

            pub fn has_end_value(&self) -> bool {
                self.end_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_end_value(&mut self, v: u32) {
                self.end_value = ::std::option::Option::Some(v);
            }

            // optional bool completed = 4;

            pub fn completed(&self) -> bool {
                self.completed.unwrap_or(false)
            }

            pub fn clear_completed(&mut self) {
                self.completed = ::std::option::Option::None;
            }

            pub fn has_completed(&self) -> bool {
                self.completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_completed(&mut self, v: bool) {
                self.completed = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for SubChallenge {
            const NAME: &'static str = "SubChallenge";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.start_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.end_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.completed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.slot_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.start_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.end_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.completed {
                    my_size += 1 + 1;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.slot_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.start_value {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.end_value {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.completed {
                    os.write_bool(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SubChallenge {
                SubChallenge::new()
            }

            fn clear(&mut self) {
                self.slot_id = ::std::option::Option::None;
                self.start_value = ::std::option::Option::None;
                self.end_value = ::std::option::Option::None;
                self.completed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SubChallenge {
                static instance: SubChallenge = SubChallenge {
                    slot_id: ::std::option::Option::None,
                    start_value: ::std::option::Option::None,
                    end_value: ::std::option::Option::None,
                    completed: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.CavernChallengeResult)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CavernChallengeResult {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.CavernChallengeResult.completed_path_id)
            pub completed_path_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.CavernChallengeResult.claimed_room_id)
            pub claimed_room_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.CavernChallengeResult.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CavernChallengeResult {
            fn default() -> &'a CavernChallengeResult {
                <CavernChallengeResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl CavernChallengeResult {
            pub fn new() -> CavernChallengeResult {
                ::std::default::Default::default()
            }

            // optional uint32 completed_path_id = 1;

            pub fn completed_path_id(&self) -> u32 {
                self.completed_path_id.unwrap_or(255u32)
            }

            pub fn clear_completed_path_id(&mut self) {
                self.completed_path_id = ::std::option::Option::None;
            }

            pub fn has_completed_path_id(&self) -> bool {
                self.completed_path_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_completed_path_id(&mut self, v: u32) {
                self.completed_path_id = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_room_id = 2;

            pub fn claimed_room_id(&self) -> u32 {
                self.claimed_room_id.unwrap_or(255u32)
            }

            pub fn clear_claimed_room_id(&mut self) {
                self.claimed_room_id = ::std::option::Option::None;
            }

            pub fn has_claimed_room_id(&self) -> bool {
                self.claimed_room_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_room_id(&mut self, v: u32) {
                self.claimed_room_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for CavernChallengeResult {
            const NAME: &'static str = "CavernChallengeResult";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.completed_path_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.claimed_room_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.completed_path_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.claimed_room_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.completed_path_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.claimed_room_id {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CavernChallengeResult {
                CavernChallengeResult::new()
            }

            fn clear(&mut self) {
                self.completed_path_id = ::std::option::Option::None;
                self.claimed_room_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CavernChallengeResult {
                static instance: CavernChallengeResult = CavernChallengeResult {
                    completed_path_id: ::std::option::Option::None,
                    claimed_room_id: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.ActionGrant)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionGrant {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.ActionGrant.action_id)
            pub action_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.ActionGrant.quantity)
            pub quantity: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.ActionGrant.audit)
            pub audit: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.ActionGrant.audit_data)
            pub audit_data: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.ActionGrant.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionGrant {
            fn default() -> &'a ActionGrant {
                <ActionGrant as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl ActionGrant {
            pub fn new() -> ActionGrant {
                ::std::default::Default::default()
            }

            // optional uint32 action_id = 1;

            pub fn action_id(&self) -> u32 {
                self.action_id.unwrap_or(0)
            }

            pub fn clear_action_id(&mut self) {
                self.action_id = ::std::option::Option::None;
            }

            pub fn has_action_id(&self) -> bool {
                self.action_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_action_id(&mut self, v: u32) {
                self.action_id = ::std::option::Option::Some(v);
            }

            // optional uint32 quantity = 2;

            pub fn quantity(&self) -> u32 {
                self.quantity.unwrap_or(0)
            }

            pub fn clear_quantity(&mut self) {
                self.quantity = ::std::option::Option::None;
            }

            pub fn has_quantity(&self) -> bool {
                self.quantity.is_some()
            }

            // Param is passed by value, moved
            pub fn set_quantity(&mut self, v: u32) {
                self.quantity = ::std::option::Option::Some(v);
            }

            // optional uint32 audit = 3;

            pub fn audit(&self) -> u32 {
                self.audit.unwrap_or(0)
            }

            pub fn clear_audit(&mut self) {
                self.audit = ::std::option::Option::None;
            }

            pub fn has_audit(&self) -> bool {
                self.audit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit(&mut self, v: u32) {
                self.audit = ::std::option::Option::Some(v);
            }

            // optional uint64 audit_data = 5;

            pub fn audit_data(&self) -> u64 {
                self.audit_data.unwrap_or(0)
            }

            pub fn clear_audit_data(&mut self) {
                self.audit_data = ::std::option::Option::None;
            }

            pub fn has_audit_data(&self) -> bool {
                self.audit_data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit_data(&mut self, v: u64) {
                self.audit_data = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for ActionGrant {
            const NAME: &'static str = "ActionGrant";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.audit = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.action_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.quantity {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.audit {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.audit_data {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.action_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.quantity {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.audit {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.audit_data {
                    os.write_uint64(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionGrant {
                ActionGrant::new()
            }

            fn clear(&mut self) {
                self.action_id = ::std::option::Option::None;
                self.quantity = ::std::option::Option::None;
                self.audit = ::std::option::Option::None;
                self.audit_data = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionGrant {
                static instance: ActionGrant = ActionGrant {
                    action_id: ::std::option::Option::None,
                    quantity: ::std::option::Option::None,
                    audit: ::std::option::Option::None,
                    audit_data: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.CandyGrant)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CandyGrant {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.CandyGrant.points)
            pub points: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.CandyGrant.reason)
            pub reason: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.CandyGrant.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CandyGrant {
            fn default() -> &'a CandyGrant {
                <CandyGrant as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl CandyGrant {
            pub fn new() -> CandyGrant {
                ::std::default::Default::default()
            }

            // optional uint32 points = 1;

            pub fn points(&self) -> u32 {
                self.points.unwrap_or(0)
            }

            pub fn clear_points(&mut self) {
                self.points = ::std::option::Option::None;
            }

            pub fn has_points(&self) -> bool {
                self.points.is_some()
            }

            // Param is passed by value, moved
            pub fn set_points(&mut self, v: u32) {
                self.points = ::std::option::Option::Some(v);
            }

            // optional uint32 reason = 2;

            pub fn reason(&self) -> u32 {
                self.reason.unwrap_or(0)
            }

            pub fn clear_reason(&mut self) {
                self.reason = ::std::option::Option::None;
            }

            pub fn has_reason(&self) -> bool {
                self.reason.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reason(&mut self, v: u32) {
                self.reason = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for CandyGrant {
            const NAME: &'static str = "CandyGrant";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.points = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.reason = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.points {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.reason {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.points {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.reason {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CandyGrant {
                CandyGrant::new()
            }

            fn clear(&mut self) {
                self.points = ::std::option::Option::None;
                self.reason = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CandyGrant {
                static instance: CandyGrant = CandyGrant {
                    points: ::std::option::Option::None,
                    reason: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.PeriodicResourceData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PeriodicResourceData {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.PeriodicResourceData.periodic_resource_id)
            pub periodic_resource_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.PeriodicResourceData.remaining)
            pub remaining: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.PeriodicResourceData.max)
            pub max: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.PeriodicResourceData.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PeriodicResourceData {
            fn default() -> &'a PeriodicResourceData {
                <PeriodicResourceData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl PeriodicResourceData {
            pub fn new() -> PeriodicResourceData {
                ::std::default::Default::default()
            }

            // optional uint32 periodic_resource_id = 1;

            pub fn periodic_resource_id(&self) -> u32 {
                self.periodic_resource_id.unwrap_or(0)
            }

            pub fn clear_periodic_resource_id(&mut self) {
                self.periodic_resource_id = ::std::option::Option::None;
            }

            pub fn has_periodic_resource_id(&self) -> bool {
                self.periodic_resource_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_periodic_resource_id(&mut self, v: u32) {
                self.periodic_resource_id = ::std::option::Option::Some(v);
            }

            // optional uint32 remaining = 2;

            pub fn remaining(&self) -> u32 {
                self.remaining.unwrap_or(0)
            }

            pub fn clear_remaining(&mut self) {
                self.remaining = ::std::option::Option::None;
            }

            pub fn has_remaining(&self) -> bool {
                self.remaining.is_some()
            }

            // Param is passed by value, moved
            pub fn set_remaining(&mut self, v: u32) {
                self.remaining = ::std::option::Option::Some(v);
            }

            // optional uint32 max = 3;

            pub fn max(&self) -> u32 {
                self.max.unwrap_or(0)
            }

            pub fn clear_max(&mut self) {
                self.max = ::std::option::Option::None;
            }

            pub fn has_max(&self) -> bool {
                self.max.is_some()
            }

            // Param is passed by value, moved
            pub fn set_max(&mut self, v: u32) {
                self.max = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for PeriodicResourceData {
            const NAME: &'static str = "PeriodicResourceData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.remaining = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.max = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.periodic_resource_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.remaining {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.max {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.periodic_resource_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.remaining {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.max {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PeriodicResourceData {
                PeriodicResourceData::new()
            }

            fn clear(&mut self) {
                self.periodic_resource_id = ::std::option::Option::None;
                self.remaining = ::std::option::Option::None;
                self.max = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PeriodicResourceData {
                static instance: PeriodicResourceData = PeriodicResourceData {
                    periodic_resource_id: ::std::option::Option::None,
                    remaining: ::std::option::Option::None,
                    max: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.EventData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct EventData {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.event_id)
            pub event_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.event_points)
            pub event_points: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.challenge_instance_id)
            pub challenge_instance_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.challenge_quest_id)
            pub challenge_quest_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.challenge_quest_challenge_id)
            pub challenge_quest_challenge_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.challenge_completed)
            pub challenge_completed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.challenge_rank_completed)
            pub challenge_rank_completed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.challenge_rank_previously_completed)
            pub challenge_rank_previously_completed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.event_owned)
            pub event_owned: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.sub_challenges_with_progress)
            pub sub_challenges_with_progress: ::std::vec::Vec<SubChallenge>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.wager_winnings)
            pub wager_winnings: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.cavern_challenge_active)
            pub cavern_challenge_active: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.cavern_challenge_winnings)
            pub cavern_challenge_winnings: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.amount_wagered)
            pub amount_wagered: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.periodic_point_adjustments)
            pub periodic_point_adjustments: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.cavern_challenge_map_results)
            pub cavern_challenge_map_results: ::std::vec::Vec<CavernChallengeResult>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.cavern_challenge_plus_shard_winnings)
            pub cavern_challenge_plus_shard_winnings: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.actions_granted)
            pub actions_granted: ::std::vec::Vec<ActionGrant>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.cavern_crawl_map_variant)
            pub cavern_crawl_map_variant: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.team_wager_bonus_pct)
            pub team_wager_bonus_pct: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.wager_streak_pct)
            pub wager_streak_pct: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.candy_points_granted)
            pub candy_points_granted: ::std::vec::Vec<CandyGrant>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.active_season_id)
            pub active_season_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.cavern_crawl_half_credit)
            pub cavern_crawl_half_credit: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.periodic_resources)
            pub periodic_resources: ::std::vec::Vec<PeriodicResourceData>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.EventData.extra_event_messages)
            pub extra_event_messages: ::std::vec::Vec<super::super::super::gcsdk_gcmessages::CExtraMsgBlock>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.EventData.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a EventData {
            fn default() -> &'a EventData {
                <EventData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl EventData {
            pub fn new() -> EventData {
                ::std::default::Default::default()
            }

            // optional uint32 event_id = 1;

            pub fn event_id(&self) -> u32 {
                self.event_id.unwrap_or(0)
            }

            pub fn clear_event_id(&mut self) {
                self.event_id = ::std::option::Option::None;
            }

            pub fn has_event_id(&self) -> bool {
                self.event_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_id(&mut self, v: u32) {
                self.event_id = ::std::option::Option::Some(v);
            }

            // optional uint32 event_points = 2;

            pub fn event_points(&self) -> u32 {
                self.event_points.unwrap_or(0)
            }

            pub fn clear_event_points(&mut self) {
                self.event_points = ::std::option::Option::None;
            }

            pub fn has_event_points(&self) -> bool {
                self.event_points.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_points(&mut self, v: u32) {
                self.event_points = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_instance_id = 3;

            pub fn challenge_instance_id(&self) -> u32 {
                self.challenge_instance_id.unwrap_or(0)
            }

            pub fn clear_challenge_instance_id(&mut self) {
                self.challenge_instance_id = ::std::option::Option::None;
            }

            pub fn has_challenge_instance_id(&self) -> bool {
                self.challenge_instance_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_instance_id(&mut self, v: u32) {
                self.challenge_instance_id = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_quest_id = 4;

            pub fn challenge_quest_id(&self) -> u32 {
                self.challenge_quest_id.unwrap_or(0)
            }

            pub fn clear_challenge_quest_id(&mut self) {
                self.challenge_quest_id = ::std::option::Option::None;
            }

            pub fn has_challenge_quest_id(&self) -> bool {
                self.challenge_quest_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_quest_id(&mut self, v: u32) {
                self.challenge_quest_id = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_quest_challenge_id = 5;

            pub fn challenge_quest_challenge_id(&self) -> u32 {
                self.challenge_quest_challenge_id.unwrap_or(0)
            }

            pub fn clear_challenge_quest_challenge_id(&mut self) {
                self.challenge_quest_challenge_id = ::std::option::Option::None;
            }

            pub fn has_challenge_quest_challenge_id(&self) -> bool {
                self.challenge_quest_challenge_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_quest_challenge_id(&mut self, v: u32) {
                self.challenge_quest_challenge_id = ::std::option::Option::Some(v);
            }

            // optional bool challenge_completed = 6;

            pub fn challenge_completed(&self) -> bool {
                self.challenge_completed.unwrap_or(false)
            }

            pub fn clear_challenge_completed(&mut self) {
                self.challenge_completed = ::std::option::Option::None;
            }

            pub fn has_challenge_completed(&self) -> bool {
                self.challenge_completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_completed(&mut self, v: bool) {
                self.challenge_completed = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_rank_completed = 7;

            pub fn challenge_rank_completed(&self) -> u32 {
                self.challenge_rank_completed.unwrap_or(0)
            }

            pub fn clear_challenge_rank_completed(&mut self) {
                self.challenge_rank_completed = ::std::option::Option::None;
            }

            pub fn has_challenge_rank_completed(&self) -> bool {
                self.challenge_rank_completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_rank_completed(&mut self, v: u32) {
                self.challenge_rank_completed = ::std::option::Option::Some(v);
            }

            // optional uint32 challenge_rank_previously_completed = 8;

            pub fn challenge_rank_previously_completed(&self) -> u32 {
                self.challenge_rank_previously_completed.unwrap_or(0)
            }

            pub fn clear_challenge_rank_previously_completed(&mut self) {
                self.challenge_rank_previously_completed = ::std::option::Option::None;
            }

            pub fn has_challenge_rank_previously_completed(&self) -> bool {
                self.challenge_rank_previously_completed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_challenge_rank_previously_completed(&mut self, v: u32) {
                self.challenge_rank_previously_completed = ::std::option::Option::Some(v);
            }

            // optional bool event_owned = 9;

            pub fn event_owned(&self) -> bool {
                self.event_owned.unwrap_or(false)
            }

            pub fn clear_event_owned(&mut self) {
                self.event_owned = ::std::option::Option::None;
            }

            pub fn has_event_owned(&self) -> bool {
                self.event_owned.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_owned(&mut self, v: bool) {
                self.event_owned = ::std::option::Option::Some(v);
            }

            // optional uint32 wager_winnings = 11;

            pub fn wager_winnings(&self) -> u32 {
                self.wager_winnings.unwrap_or(0)
            }

            pub fn clear_wager_winnings(&mut self) {
                self.wager_winnings = ::std::option::Option::None;
            }

            pub fn has_wager_winnings(&self) -> bool {
                self.wager_winnings.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wager_winnings(&mut self, v: u32) {
                self.wager_winnings = ::std::option::Option::Some(v);
            }

            // optional bool cavern_challenge_active = 12;

            pub fn cavern_challenge_active(&self) -> bool {
                self.cavern_challenge_active.unwrap_or(false)
            }

            pub fn clear_cavern_challenge_active(&mut self) {
                self.cavern_challenge_active = ::std::option::Option::None;
            }

            pub fn has_cavern_challenge_active(&self) -> bool {
                self.cavern_challenge_active.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_challenge_active(&mut self, v: bool) {
                self.cavern_challenge_active = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_challenge_winnings = 13;

            pub fn cavern_challenge_winnings(&self) -> u32 {
                self.cavern_challenge_winnings.unwrap_or(0)
            }

            pub fn clear_cavern_challenge_winnings(&mut self) {
                self.cavern_challenge_winnings = ::std::option::Option::None;
            }

            pub fn has_cavern_challenge_winnings(&self) -> bool {
                self.cavern_challenge_winnings.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_challenge_winnings(&mut self, v: u32) {
                self.cavern_challenge_winnings = ::std::option::Option::Some(v);
            }

            // optional uint32 amount_wagered = 14;

            pub fn amount_wagered(&self) -> u32 {
                self.amount_wagered.unwrap_or(0)
            }

            pub fn clear_amount_wagered(&mut self) {
                self.amount_wagered = ::std::option::Option::None;
            }

            pub fn has_amount_wagered(&self) -> bool {
                self.amount_wagered.is_some()
            }

            // Param is passed by value, moved
            pub fn set_amount_wagered(&mut self, v: u32) {
                self.amount_wagered = ::std::option::Option::Some(v);
            }

            // optional uint32 periodic_point_adjustments = 16;

            pub fn periodic_point_adjustments(&self) -> u32 {
                self.periodic_point_adjustments.unwrap_or(0)
            }

            pub fn clear_periodic_point_adjustments(&mut self) {
                self.periodic_point_adjustments = ::std::option::Option::None;
            }

            pub fn has_periodic_point_adjustments(&self) -> bool {
                self.periodic_point_adjustments.is_some()
            }

            // Param is passed by value, moved
            pub fn set_periodic_point_adjustments(&mut self, v: u32) {
                self.periodic_point_adjustments = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_challenge_plus_shard_winnings = 18;

            pub fn cavern_challenge_plus_shard_winnings(&self) -> u32 {
                self.cavern_challenge_plus_shard_winnings.unwrap_or(0)
            }

            pub fn clear_cavern_challenge_plus_shard_winnings(&mut self) {
                self.cavern_challenge_plus_shard_winnings = ::std::option::Option::None;
            }

            pub fn has_cavern_challenge_plus_shard_winnings(&self) -> bool {
                self.cavern_challenge_plus_shard_winnings.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_challenge_plus_shard_winnings(&mut self, v: u32) {
                self.cavern_challenge_plus_shard_winnings = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_crawl_map_variant = 20;

            pub fn cavern_crawl_map_variant(&self) -> u32 {
                self.cavern_crawl_map_variant.unwrap_or(255u32)
            }

            pub fn clear_cavern_crawl_map_variant(&mut self) {
                self.cavern_crawl_map_variant = ::std::option::Option::None;
            }

            pub fn has_cavern_crawl_map_variant(&self) -> bool {
                self.cavern_crawl_map_variant.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_crawl_map_variant(&mut self, v: u32) {
                self.cavern_crawl_map_variant = ::std::option::Option::Some(v);
            }

            // optional uint32 team_wager_bonus_pct = 21;

            pub fn team_wager_bonus_pct(&self) -> u32 {
                self.team_wager_bonus_pct.unwrap_or(0)
            }

            pub fn clear_team_wager_bonus_pct(&mut self) {
                self.team_wager_bonus_pct = ::std::option::Option::None;
            }

            pub fn has_team_wager_bonus_pct(&self) -> bool {
                self.team_wager_bonus_pct.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_wager_bonus_pct(&mut self, v: u32) {
                self.team_wager_bonus_pct = ::std::option::Option::Some(v);
            }

            // optional uint32 wager_streak_pct = 22;

            pub fn wager_streak_pct(&self) -> u32 {
                self.wager_streak_pct.unwrap_or(0)
            }

            pub fn clear_wager_streak_pct(&mut self) {
                self.wager_streak_pct = ::std::option::Option::None;
            }

            pub fn has_wager_streak_pct(&self) -> bool {
                self.wager_streak_pct.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wager_streak_pct(&mut self, v: u32) {
                self.wager_streak_pct = ::std::option::Option::Some(v);
            }

            // optional uint32 active_season_id = 24;

            pub fn active_season_id(&self) -> u32 {
                self.active_season_id.unwrap_or(0)
            }

            pub fn clear_active_season_id(&mut self) {
                self.active_season_id = ::std::option::Option::None;
            }

            pub fn has_active_season_id(&self) -> bool {
                self.active_season_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_active_season_id(&mut self, v: u32) {
                self.active_season_id = ::std::option::Option::Some(v);
            }

            // optional bool cavern_crawl_half_credit = 25;

            pub fn cavern_crawl_half_credit(&self) -> bool {
                self.cavern_crawl_half_credit.unwrap_or(false)
            }

            pub fn clear_cavern_crawl_half_credit(&mut self) {
                self.cavern_crawl_half_credit = ::std::option::Option::None;
            }

            pub fn has_cavern_crawl_half_credit(&self) -> bool {
                self.cavern_crawl_half_credit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_crawl_half_credit(&mut self, v: bool) {
                self.cavern_crawl_half_credit = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for EventData {
            const NAME: &'static str = "EventData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.event_points = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.challenge_quest_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.challenge_quest_challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.challenge_completed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        56 => {
                            self.challenge_rank_completed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.challenge_rank_previously_completed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.event_owned = ::std::option::Option::Some(is.read_bool()?);
                        },
                        82 => {
                            self.sub_challenges_with_progress.push(is.read_message()?);
                        },
                        88 => {
                            self.wager_winnings = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        96 => {
                            self.cavern_challenge_active = ::std::option::Option::Some(is.read_bool()?);
                        },
                        104 => {
                            self.cavern_challenge_winnings = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        112 => {
                            self.amount_wagered = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        128 => {
                            self.periodic_point_adjustments = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        138 => {
                            self.cavern_challenge_map_results.push(is.read_message()?);
                        },
                        144 => {
                            self.cavern_challenge_plus_shard_winnings = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        154 => {
                            self.actions_granted.push(is.read_message()?);
                        },
                        160 => {
                            self.cavern_crawl_map_variant = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        168 => {
                            self.team_wager_bonus_pct = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        176 => {
                            self.wager_streak_pct = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        186 => {
                            self.candy_points_granted.push(is.read_message()?);
                        },
                        192 => {
                            self.active_season_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        200 => {
                            self.cavern_crawl_half_credit = ::std::option::Option::Some(is.read_bool()?);
                        },
                        210 => {
                            self.periodic_resources.push(is.read_message()?);
                        },
                        218 => {
                            self.extra_event_messages.push(is.read_message()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.event_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.event_points {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.challenge_instance_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.challenge_quest_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.challenge_quest_challenge_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.challenge_completed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.challenge_rank_completed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.challenge_rank_previously_completed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.event_owned {
                    my_size += 1 + 1;
                }
                for value in &self.sub_challenges_with_progress {
                    let len = value.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.wager_winnings {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.cavern_challenge_active {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.cavern_challenge_winnings {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
                }
                if let Some(v) = self.amount_wagered {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
                }
                if let Some(v) = self.periodic_point_adjustments {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
                }
                for value in &self.cavern_challenge_map_results {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.cavern_challenge_plus_shard_winnings {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
                }
                for value in &self.actions_granted {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.cavern_crawl_map_variant {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
                }
                if let Some(v) = self.team_wager_bonus_pct {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
                }
                if let Some(v) = self.wager_streak_pct {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
                }
                for value in &self.candy_points_granted {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.active_season_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
                }
                if let Some(v) = self.cavern_crawl_half_credit {
                    my_size += 2 + 1;
                }
                for value in &self.periodic_resources {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.extra_event_messages {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.event_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.event_points {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.challenge_instance_id {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.challenge_quest_id {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.challenge_quest_challenge_id {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.challenge_completed {
                    os.write_bool(6, v)?;
                }
                if let Some(v) = self.challenge_rank_completed {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.challenge_rank_previously_completed {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.event_owned {
                    os.write_bool(9, v)?;
                }
                for v in &self.sub_challenges_with_progress {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                };
                if let Some(v) = self.wager_winnings {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.cavern_challenge_active {
                    os.write_bool(12, v)?;
                }
                if let Some(v) = self.cavern_challenge_winnings {
                    os.write_uint32(13, v)?;
                }
                if let Some(v) = self.amount_wagered {
                    os.write_uint32(14, v)?;
                }
                if let Some(v) = self.periodic_point_adjustments {
                    os.write_uint32(16, v)?;
                }
                for v in &self.cavern_challenge_map_results {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                };
                if let Some(v) = self.cavern_challenge_plus_shard_winnings {
                    os.write_uint32(18, v)?;
                }
                for v in &self.actions_granted {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                };
                if let Some(v) = self.cavern_crawl_map_variant {
                    os.write_uint32(20, v)?;
                }
                if let Some(v) = self.team_wager_bonus_pct {
                    os.write_uint32(21, v)?;
                }
                if let Some(v) = self.wager_streak_pct {
                    os.write_uint32(22, v)?;
                }
                for v in &self.candy_points_granted {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
                };
                if let Some(v) = self.active_season_id {
                    os.write_uint32(24, v)?;
                }
                if let Some(v) = self.cavern_crawl_half_credit {
                    os.write_bool(25, v)?;
                }
                for v in &self.periodic_resources {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                };
                for v in &self.extra_event_messages {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> EventData {
                EventData::new()
            }

            fn clear(&mut self) {
                self.event_id = ::std::option::Option::None;
                self.event_points = ::std::option::Option::None;
                self.challenge_instance_id = ::std::option::Option::None;
                self.challenge_quest_id = ::std::option::Option::None;
                self.challenge_quest_challenge_id = ::std::option::Option::None;
                self.challenge_completed = ::std::option::Option::None;
                self.challenge_rank_completed = ::std::option::Option::None;
                self.challenge_rank_previously_completed = ::std::option::Option::None;
                self.event_owned = ::std::option::Option::None;
                self.sub_challenges_with_progress.clear();
                self.wager_winnings = ::std::option::Option::None;
                self.cavern_challenge_active = ::std::option::Option::None;
                self.cavern_challenge_winnings = ::std::option::Option::None;
                self.amount_wagered = ::std::option::Option::None;
                self.periodic_point_adjustments = ::std::option::Option::None;
                self.cavern_challenge_map_results.clear();
                self.cavern_challenge_plus_shard_winnings = ::std::option::Option::None;
                self.actions_granted.clear();
                self.cavern_crawl_map_variant = ::std::option::Option::None;
                self.team_wager_bonus_pct = ::std::option::Option::None;
                self.wager_streak_pct = ::std::option::Option::None;
                self.candy_points_granted.clear();
                self.active_season_id = ::std::option::Option::None;
                self.cavern_crawl_half_credit = ::std::option::Option::None;
                self.periodic_resources.clear();
                self.extra_event_messages.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static EventData {
                static instance: EventData = EventData {
                    event_id: ::std::option::Option::None,
                    event_points: ::std::option::Option::None,
                    challenge_instance_id: ::std::option::Option::None,
                    challenge_quest_id: ::std::option::Option::None,
                    challenge_quest_challenge_id: ::std::option::Option::None,
                    challenge_completed: ::std::option::Option::None,
                    challenge_rank_completed: ::std::option::Option::None,
                    challenge_rank_previously_completed: ::std::option::Option::None,
                    event_owned: ::std::option::Option::None,
                    sub_challenges_with_progress: ::std::vec::Vec::new(),
                    wager_winnings: ::std::option::Option::None,
                    cavern_challenge_active: ::std::option::Option::None,
                    cavern_challenge_winnings: ::std::option::Option::None,
                    amount_wagered: ::std::option::Option::None,
                    periodic_point_adjustments: ::std::option::Option::None,
                    cavern_challenge_map_results: ::std::vec::Vec::new(),
                    cavern_challenge_plus_shard_winnings: ::std::option::Option::None,
                    actions_granted: ::std::vec::Vec::new(),
                    cavern_crawl_map_variant: ::std::option::Option::None,
                    team_wager_bonus_pct: ::std::option::Option::None,
                    wager_streak_pct: ::std::option::Option::None,
                    candy_points_granted: ::std::vec::Vec::new(),
                    active_season_id: ::std::option::Option::None,
                    cavern_crawl_half_credit: ::std::option::Option::None,
                    periodic_resources: ::std::vec::Vec::new(),
                    extra_event_messages: ::std::vec::Vec::new(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.FeaturedGamemodeProgress)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FeaturedGamemodeProgress {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.start_value)
            pub start_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.end_value)
            pub end_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.max_value)
            pub max_value: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.FeaturedGamemodeProgress.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FeaturedGamemodeProgress {
            fn default() -> &'a FeaturedGamemodeProgress {
                <FeaturedGamemodeProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl FeaturedGamemodeProgress {
            pub fn new() -> FeaturedGamemodeProgress {
                ::std::default::Default::default()
            }

            // optional uint32 start_value = 1;

            pub fn start_value(&self) -> u32 {
                self.start_value.unwrap_or(0)
            }

            pub fn clear_start_value(&mut self) {
                self.start_value = ::std::option::Option::None;
            }

            pub fn has_start_value(&self) -> bool {
                self.start_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_start_value(&mut self, v: u32) {
                self.start_value = ::std::option::Option::Some(v);
            }

            // optional uint32 end_value = 2;

            pub fn end_value(&self) -> u32 {
                self.end_value.unwrap_or(0)
            }

            pub fn clear_end_value(&mut self) {
                self.end_value = ::std::option::Option::None;
            }

            pub fn has_end_value(&self) -> bool {
                self.end_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_end_value(&mut self, v: u32) {
                self.end_value = ::std::option::Option::Some(v);
            }

            // optional uint32 max_value = 3;

            pub fn max_value(&self) -> u32 {
                self.max_value.unwrap_or(0)
            }

            pub fn clear_max_value(&mut self) {
                self.max_value = ::std::option::Option::None;
            }

            pub fn has_max_value(&self) -> bool {
                self.max_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_max_value(&mut self, v: u32) {
                self.max_value = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for FeaturedGamemodeProgress {
            const NAME: &'static str = "FeaturedGamemodeProgress";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.start_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.end_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.max_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.start_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.end_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.max_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.start_value {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.end_value {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.max_value {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FeaturedGamemodeProgress {
                FeaturedGamemodeProgress::new()
            }

            fn clear(&mut self) {
                self.start_value = ::std::option::Option::None;
                self.end_value = ::std::option::Option::None;
                self.max_value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FeaturedGamemodeProgress {
                static instance: FeaturedGamemodeProgress = FeaturedGamemodeProgress {
                    start_value: ::std::option::Option::None,
                    end_value: ::std::option::Option::None,
                    max_value: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.Player)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Player {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ability_upgrades)
            pub ability_upgrades: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.kills)
            pub kills: ::std::vec::Vec<PlayerKill>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.items)
            pub items: ::std::vec::Vec<ItemPurchase>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.avg_kills_x16)
            pub avg_kills_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.avg_deaths_x16)
            pub avg_deaths_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.avg_assists_x16)
            pub avg_assists_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.avg_gpm_x16)
            pub avg_gpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.avg_xpm_x16)
            pub avg_xpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.best_kills_x16)
            pub best_kills_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.best_assists_x16)
            pub best_assists_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.best_gpm_x16)
            pub best_gpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.best_xpm_x16)
            pub best_xpm_x16: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.win_streak)
            pub win_streak: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.best_win_streak)
            pub best_win_streak: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.fight_score)
            pub fight_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.farm_score)
            pub farm_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.support_score)
            pub support_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.push_score)
            pub push_score: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.level_up_times)
            pub level_up_times: ::std::vec::Vec<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.graph_net_worth)
            pub graph_net_worth: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.inventory_snapshot)
            pub inventory_snapshot: ::std::vec::Vec<InventorySnapshot>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.avg_stats_calibrated)
            pub avg_stats_calibrated: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.auto_style_criteria)
            pub auto_style_criteria: ::std::vec::Vec<AutoStyleCriteria>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.event_data)
            pub event_data: ::std::vec::Vec<EventData>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.strange_gem_progress)
            pub strange_gem_progress: ::std::vec::Vec<StrangeGemProgress>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.hero_xp)
            pub hero_xp: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.camps_stacked)
            pub camps_stacked: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.victory_prediction)
            pub victory_prediction: ::std::vec::Vec<VictoryPrediction>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.lane_selection_flags)
            pub lane_selection_flags: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.rampages)
            pub rampages: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.triple_kills)
            pub triple_kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.aegis_snatched)
            pub aegis_snatched: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.rapiers_purchased)
            pub rapiers_purchased: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.couriers_killed)
            pub couriers_killed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.net_worth_rank)
            pub net_worth_rank: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.support_gold_spent)
            pub support_gold_spent: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.observer_wards_placed)
            pub observer_wards_placed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.sentry_wards_placed)
            pub sentry_wards_placed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.wards_dewarded)
            pub wards_dewarded: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.stun_duration)
            pub stun_duration: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.rank_mmr_boost_type)
            pub rank_mmr_boost_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::EDOTAMMRBoostType>>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.contract_progress)
            pub contract_progress: ::std::vec::Vec<player::ContractProgress>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.guild_ids)
            pub guild_ids: ::std::vec::Vec<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.graph_hero_damage)
            pub graph_hero_damage: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.team_number)
            pub team_number: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::DOTA_GC_TEAM>>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.team_slot)
            pub team_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.featured_gamemode_progress)
            pub featured_gamemode_progress: ::steam_vent_proto_common::protobuf::MessageField<FeaturedGamemodeProgress>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.featured_hero_sticker_index)
            pub featured_hero_sticker_index: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.featured_hero_sticker_quality)
            pub featured_hero_sticker_quality: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.equipped_econ_items)
            pub equipped_econ_items: ::std::vec::Vec<super::EconItem>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.game_player_id)
            pub game_player_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.player_tracked_stats)
            pub player_tracked_stats: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMsgTrackedStat>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.overworld_rewards)
            pub overworld_rewards: ::steam_vent_proto_common::protobuf::MessageField<player::OverworldRewards>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.Player.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Player {
            fn default() -> &'a Player {
                <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Player {
            pub fn new() -> Player {
                ::std::default::Default::default()
            }

            // optional uint32 player_slot = 3;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_kills_x16 = 7;

            pub fn avg_kills_x16(&self) -> u32 {
                self.avg_kills_x16.unwrap_or(0)
            }

            pub fn clear_avg_kills_x16(&mut self) {
                self.avg_kills_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_kills_x16(&self) -> bool {
                self.avg_kills_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_kills_x16(&mut self, v: u32) {
                self.avg_kills_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_deaths_x16 = 8;

            pub fn avg_deaths_x16(&self) -> u32 {
                self.avg_deaths_x16.unwrap_or(0)
            }

            pub fn clear_avg_deaths_x16(&mut self) {
                self.avg_deaths_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_deaths_x16(&self) -> bool {
                self.avg_deaths_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_deaths_x16(&mut self, v: u32) {
                self.avg_deaths_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_assists_x16 = 9;

            pub fn avg_assists_x16(&self) -> u32 {
                self.avg_assists_x16.unwrap_or(0)
            }

            pub fn clear_avg_assists_x16(&mut self) {
                self.avg_assists_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_assists_x16(&self) -> bool {
                self.avg_assists_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_assists_x16(&mut self, v: u32) {
                self.avg_assists_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_gpm_x16 = 10;

            pub fn avg_gpm_x16(&self) -> u32 {
                self.avg_gpm_x16.unwrap_or(0)
            }

            pub fn clear_avg_gpm_x16(&mut self) {
                self.avg_gpm_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_gpm_x16(&self) -> bool {
                self.avg_gpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_gpm_x16(&mut self, v: u32) {
                self.avg_gpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 avg_xpm_x16 = 11;

            pub fn avg_xpm_x16(&self) -> u32 {
                self.avg_xpm_x16.unwrap_or(0)
            }

            pub fn clear_avg_xpm_x16(&mut self) {
                self.avg_xpm_x16 = ::std::option::Option::None;
            }

            pub fn has_avg_xpm_x16(&self) -> bool {
                self.avg_xpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_xpm_x16(&mut self, v: u32) {
                self.avg_xpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_kills_x16 = 12;

            pub fn best_kills_x16(&self) -> u32 {
                self.best_kills_x16.unwrap_or(0)
            }

            pub fn clear_best_kills_x16(&mut self) {
                self.best_kills_x16 = ::std::option::Option::None;
            }

            pub fn has_best_kills_x16(&self) -> bool {
                self.best_kills_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_kills_x16(&mut self, v: u32) {
                self.best_kills_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_assists_x16 = 13;

            pub fn best_assists_x16(&self) -> u32 {
                self.best_assists_x16.unwrap_or(0)
            }

            pub fn clear_best_assists_x16(&mut self) {
                self.best_assists_x16 = ::std::option::Option::None;
            }

            pub fn has_best_assists_x16(&self) -> bool {
                self.best_assists_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_assists_x16(&mut self, v: u32) {
                self.best_assists_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_gpm_x16 = 14;

            pub fn best_gpm_x16(&self) -> u32 {
                self.best_gpm_x16.unwrap_or(0)
            }

            pub fn clear_best_gpm_x16(&mut self) {
                self.best_gpm_x16 = ::std::option::Option::None;
            }

            pub fn has_best_gpm_x16(&self) -> bool {
                self.best_gpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_gpm_x16(&mut self, v: u32) {
                self.best_gpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 best_xpm_x16 = 15;

            pub fn best_xpm_x16(&self) -> u32 {
                self.best_xpm_x16.unwrap_or(0)
            }

            pub fn clear_best_xpm_x16(&mut self) {
                self.best_xpm_x16 = ::std::option::Option::None;
            }

            pub fn has_best_xpm_x16(&self) -> bool {
                self.best_xpm_x16.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_xpm_x16(&mut self, v: u32) {
                self.best_xpm_x16 = ::std::option::Option::Some(v);
            }

            // optional uint32 win_streak = 16;

            pub fn win_streak(&self) -> u32 {
                self.win_streak.unwrap_or(0)
            }

            pub fn clear_win_streak(&mut self) {
                self.win_streak = ::std::option::Option::None;
            }

            pub fn has_win_streak(&self) -> bool {
                self.win_streak.is_some()
            }

            // Param is passed by value, moved
            pub fn set_win_streak(&mut self, v: u32) {
                self.win_streak = ::std::option::Option::Some(v);
            }

            // optional uint32 best_win_streak = 17;

            pub fn best_win_streak(&self) -> u32 {
                self.best_win_streak.unwrap_or(0)
            }

            pub fn clear_best_win_streak(&mut self) {
                self.best_win_streak = ::std::option::Option::None;
            }

            pub fn has_best_win_streak(&self) -> bool {
                self.best_win_streak.is_some()
            }

            // Param is passed by value, moved
            pub fn set_best_win_streak(&mut self, v: u32) {
                self.best_win_streak = ::std::option::Option::Some(v);
            }

            // optional float fight_score = 18;

            pub fn fight_score(&self) -> f32 {
                self.fight_score.unwrap_or(0.)
            }

            pub fn clear_fight_score(&mut self) {
                self.fight_score = ::std::option::Option::None;
            }

            pub fn has_fight_score(&self) -> bool {
                self.fight_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_fight_score(&mut self, v: f32) {
                self.fight_score = ::std::option::Option::Some(v);
            }

            // optional float farm_score = 19;

            pub fn farm_score(&self) -> f32 {
                self.farm_score.unwrap_or(0.)
            }

            pub fn clear_farm_score(&mut self) {
                self.farm_score = ::std::option::Option::None;
            }

            pub fn has_farm_score(&self) -> bool {
                self.farm_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_farm_score(&mut self, v: f32) {
                self.farm_score = ::std::option::Option::Some(v);
            }

            // optional float support_score = 20;

            pub fn support_score(&self) -> f32 {
                self.support_score.unwrap_or(0.)
            }

            pub fn clear_support_score(&mut self) {
                self.support_score = ::std::option::Option::None;
            }

            pub fn has_support_score(&self) -> bool {
                self.support_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_score(&mut self, v: f32) {
                self.support_score = ::std::option::Option::Some(v);
            }

            // optional float push_score = 21;

            pub fn push_score(&self) -> f32 {
                self.push_score.unwrap_or(0.)
            }

            pub fn clear_push_score(&mut self) {
                self.push_score = ::std::option::Option::None;
            }

            pub fn has_push_score(&self) -> bool {
                self.push_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_push_score(&mut self, v: f32) {
                self.push_score = ::std::option::Option::Some(v);
            }

            // optional bool avg_stats_calibrated = 25;

            pub fn avg_stats_calibrated(&self) -> bool {
                self.avg_stats_calibrated.unwrap_or(false)
            }

            pub fn clear_avg_stats_calibrated(&mut self) {
                self.avg_stats_calibrated = ::std::option::Option::None;
            }

            pub fn has_avg_stats_calibrated(&self) -> bool {
                self.avg_stats_calibrated.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avg_stats_calibrated(&mut self, v: bool) {
                self.avg_stats_calibrated = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_xp = 31;

            pub fn hero_xp(&self) -> u32 {
                self.hero_xp.unwrap_or(0)
            }

            pub fn clear_hero_xp(&mut self) {
                self.hero_xp = ::std::option::Option::None;
            }

            pub fn has_hero_xp(&self) -> bool {
                self.hero_xp.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_xp(&mut self, v: u32) {
                self.hero_xp = ::std::option::Option::Some(v);
            }

            // optional uint32 camps_stacked = 32;

            pub fn camps_stacked(&self) -> u32 {
                self.camps_stacked.unwrap_or(0)
            }

            pub fn clear_camps_stacked(&mut self) {
                self.camps_stacked = ::std::option::Option::None;
            }

            pub fn has_camps_stacked(&self) -> bool {
                self.camps_stacked.is_some()
            }

            // Param is passed by value, moved
            pub fn set_camps_stacked(&mut self, v: u32) {
                self.camps_stacked = ::std::option::Option::Some(v);
            }

            // optional uint32 lane_selection_flags = 34;

            pub fn lane_selection_flags(&self) -> u32 {
                self.lane_selection_flags.unwrap_or(0)
            }

            pub fn clear_lane_selection_flags(&mut self) {
                self.lane_selection_flags = ::std::option::Option::None;
            }

            pub fn has_lane_selection_flags(&self) -> bool {
                self.lane_selection_flags.is_some()
            }

            // Param is passed by value, moved
            pub fn set_lane_selection_flags(&mut self, v: u32) {
                self.lane_selection_flags = ::std::option::Option::Some(v);
            }

            // optional uint32 rampages = 35;

            pub fn rampages(&self) -> u32 {
                self.rampages.unwrap_or(0)
            }

            pub fn clear_rampages(&mut self) {
                self.rampages = ::std::option::Option::None;
            }

            pub fn has_rampages(&self) -> bool {
                self.rampages.is_some()
            }

            // Param is passed by value, moved
            pub fn set_rampages(&mut self, v: u32) {
                self.rampages = ::std::option::Option::Some(v);
            }

            // optional uint32 triple_kills = 36;

            pub fn triple_kills(&self) -> u32 {
                self.triple_kills.unwrap_or(0)
            }

            pub fn clear_triple_kills(&mut self) {
                self.triple_kills = ::std::option::Option::None;
            }

            pub fn has_triple_kills(&self) -> bool {
                self.triple_kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_triple_kills(&mut self, v: u32) {
                self.triple_kills = ::std::option::Option::Some(v);
            }

            // optional uint32 aegis_snatched = 37;

            pub fn aegis_snatched(&self) -> u32 {
                self.aegis_snatched.unwrap_or(0)
            }

            pub fn clear_aegis_snatched(&mut self) {
                self.aegis_snatched = ::std::option::Option::None;
            }

            pub fn has_aegis_snatched(&self) -> bool {
                self.aegis_snatched.is_some()
            }

            // Param is passed by value, moved
            pub fn set_aegis_snatched(&mut self, v: u32) {
                self.aegis_snatched = ::std::option::Option::Some(v);
            }

            // optional uint32 rapiers_purchased = 38;

            pub fn rapiers_purchased(&self) -> u32 {
                self.rapiers_purchased.unwrap_or(0)
            }

            pub fn clear_rapiers_purchased(&mut self) {
                self.rapiers_purchased = ::std::option::Option::None;
            }

            pub fn has_rapiers_purchased(&self) -> bool {
                self.rapiers_purchased.is_some()
            }

            // Param is passed by value, moved
            pub fn set_rapiers_purchased(&mut self, v: u32) {
                self.rapiers_purchased = ::std::option::Option::Some(v);
            }

            // optional uint32 couriers_killed = 39;

            pub fn couriers_killed(&self) -> u32 {
                self.couriers_killed.unwrap_or(0)
            }

            pub fn clear_couriers_killed(&mut self) {
                self.couriers_killed = ::std::option::Option::None;
            }

            pub fn has_couriers_killed(&self) -> bool {
                self.couriers_killed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_couriers_killed(&mut self, v: u32) {
                self.couriers_killed = ::std::option::Option::Some(v);
            }

            // optional uint32 net_worth_rank = 40;

            pub fn net_worth_rank(&self) -> u32 {
                self.net_worth_rank.unwrap_or(0)
            }

            pub fn clear_net_worth_rank(&mut self) {
                self.net_worth_rank = ::std::option::Option::None;
            }

            pub fn has_net_worth_rank(&self) -> bool {
                self.net_worth_rank.is_some()
            }

            // Param is passed by value, moved
            pub fn set_net_worth_rank(&mut self, v: u32) {
                self.net_worth_rank = ::std::option::Option::Some(v);
            }

            // optional uint32 support_gold_spent = 41;

            pub fn support_gold_spent(&self) -> u32 {
                self.support_gold_spent.unwrap_or(0)
            }

            pub fn clear_support_gold_spent(&mut self) {
                self.support_gold_spent = ::std::option::Option::None;
            }

            pub fn has_support_gold_spent(&self) -> bool {
                self.support_gold_spent.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_gold_spent(&mut self, v: u32) {
                self.support_gold_spent = ::std::option::Option::Some(v);
            }

            // optional uint32 observer_wards_placed = 42;

            pub fn observer_wards_placed(&self) -> u32 {
                self.observer_wards_placed.unwrap_or(0)
            }

            pub fn clear_observer_wards_placed(&mut self) {
                self.observer_wards_placed = ::std::option::Option::None;
            }

            pub fn has_observer_wards_placed(&self) -> bool {
                self.observer_wards_placed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_observer_wards_placed(&mut self, v: u32) {
                self.observer_wards_placed = ::std::option::Option::Some(v);
            }

            // optional uint32 sentry_wards_placed = 43;

            pub fn sentry_wards_placed(&self) -> u32 {
                self.sentry_wards_placed.unwrap_or(0)
            }

            pub fn clear_sentry_wards_placed(&mut self) {
                self.sentry_wards_placed = ::std::option::Option::None;
            }

            pub fn has_sentry_wards_placed(&self) -> bool {
                self.sentry_wards_placed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sentry_wards_placed(&mut self, v: u32) {
                self.sentry_wards_placed = ::std::option::Option::Some(v);
            }

            // optional uint32 wards_dewarded = 44;

            pub fn wards_dewarded(&self) -> u32 {
                self.wards_dewarded.unwrap_or(0)
            }

            pub fn clear_wards_dewarded(&mut self) {
                self.wards_dewarded = ::std::option::Option::None;
            }

            pub fn has_wards_dewarded(&self) -> bool {
                self.wards_dewarded.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wards_dewarded(&mut self, v: u32) {
                self.wards_dewarded = ::std::option::Option::Some(v);
            }

            // optional float stun_duration = 45;

            pub fn stun_duration(&self) -> f32 {
                self.stun_duration.unwrap_or(0.)
            }

            pub fn clear_stun_duration(&mut self) {
                self.stun_duration = ::std::option::Option::None;
            }

            pub fn has_stun_duration(&self) -> bool {
                self.stun_duration.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stun_duration(&mut self, v: f32) {
                self.stun_duration = ::std::option::Option::Some(v);
            }

            // optional .EDOTAMMRBoostType rank_mmr_boost_type = 46;

            pub fn rank_mmr_boost_type(&self) -> super::super::super::dota_shared_enums::EDOTAMMRBoostType {
                match self.rank_mmr_boost_type {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
                    None => super::super::super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None,
                }
            }

            pub fn clear_rank_mmr_boost_type(&mut self) {
                self.rank_mmr_boost_type = ::std::option::Option::None;
            }

            pub fn has_rank_mmr_boost_type(&self) -> bool {
                self.rank_mmr_boost_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_rank_mmr_boost_type(&mut self, v: super::super::super::dota_shared_enums::EDOTAMMRBoostType) {
                self.rank_mmr_boost_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
            }

            // optional .DOTA_GC_TEAM team_number = 51;

            pub fn team_number(&self) -> super::super::super::dota_shared_enums::DOTA_GC_TEAM {
                match self.team_number {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                    None => super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
                }
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: super::super::super::dota_shared_enums::DOTA_GC_TEAM) {
                self.team_number = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 team_slot = 52;

            pub fn team_slot(&self) -> u32 {
                self.team_slot.unwrap_or(0)
            }

            pub fn clear_team_slot(&mut self) {
                self.team_slot = ::std::option::Option::None;
            }

            pub fn has_team_slot(&self) -> bool {
                self.team_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_slot(&mut self, v: u32) {
                self.team_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 featured_hero_sticker_index = 54;

            pub fn featured_hero_sticker_index(&self) -> u32 {
                self.featured_hero_sticker_index.unwrap_or(0)
            }

            pub fn clear_featured_hero_sticker_index(&mut self) {
                self.featured_hero_sticker_index = ::std::option::Option::None;
            }

            pub fn has_featured_hero_sticker_index(&self) -> bool {
                self.featured_hero_sticker_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_featured_hero_sticker_index(&mut self, v: u32) {
                self.featured_hero_sticker_index = ::std::option::Option::Some(v);
            }

            // optional uint32 featured_hero_sticker_quality = 55;

            pub fn featured_hero_sticker_quality(&self) -> u32 {
                self.featured_hero_sticker_quality.unwrap_or(0)
            }

            pub fn clear_featured_hero_sticker_quality(&mut self) {
                self.featured_hero_sticker_quality = ::std::option::Option::None;
            }

            pub fn has_featured_hero_sticker_quality(&self) -> bool {
                self.featured_hero_sticker_quality.is_some()
            }

            // Param is passed by value, moved
            pub fn set_featured_hero_sticker_quality(&mut self, v: u32) {
                self.featured_hero_sticker_quality = ::std::option::Option::Some(v);
            }

            // optional int32 game_player_id = 57;

            pub fn game_player_id(&self) -> i32 {
                self.game_player_id.unwrap_or(-1i32)
            }

            pub fn clear_game_player_id(&mut self) {
                self.game_player_id = ::std::option::Option::None;
            }

            pub fn has_game_player_id(&self) -> bool {
                self.game_player_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_player_id(&mut self, v: i32) {
                self.game_player_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Player {
            const NAME: &'static str = "Player";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        18 => {
                            is.read_repeated_packed_int32_into(&mut self.ability_upgrades)?;
                        },
                        16 => {
                            self.ability_upgrades.push(is.read_int32()?);
                        },
                        24 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        42 => {
                            self.kills.push(is.read_message()?);
                        },
                        50 => {
                            self.items.push(is.read_message()?);
                        },
                        56 => {
                            self.avg_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.avg_deaths_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.avg_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        80 => {
                            self.avg_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        88 => {
                            self.avg_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        96 => {
                            self.best_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        104 => {
                            self.best_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        112 => {
                            self.best_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        120 => {
                            self.best_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        128 => {
                            self.win_streak = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        136 => {
                            self.best_win_streak = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        149 => {
                            self.fight_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        157 => {
                            self.farm_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        165 => {
                            self.support_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        173 => {
                            self.push_score = ::std::option::Option::Some(is.read_float()?);
                        },
                        178 => {
                            is.read_repeated_packed_uint32_into(&mut self.level_up_times)?;
                        },
                        176 => {
                            self.level_up_times.push(is.read_uint32()?);
                        },
                        186 => {
                            is.read_repeated_packed_float_into(&mut self.graph_net_worth)?;
                        },
                        189 => {
                            self.graph_net_worth.push(is.read_float()?);
                        },
                        194 => {
                            self.inventory_snapshot.push(is.read_message()?);
                        },
                        200 => {
                            self.avg_stats_calibrated = ::std::option::Option::Some(is.read_bool()?);
                        },
                        210 => {
                            self.auto_style_criteria.push(is.read_message()?);
                        },
                        234 => {
                            self.event_data.push(is.read_message()?);
                        },
                        242 => {
                            self.strange_gem_progress.push(is.read_message()?);
                        },
                        248 => {
                            self.hero_xp = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        256 => {
                            self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        266 => {
                            self.victory_prediction.push(is.read_message()?);
                        },
                        272 => {
                            self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        280 => {
                            self.rampages = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        288 => {
                            self.triple_kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        296 => {
                            self.aegis_snatched = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        304 => {
                            self.rapiers_purchased = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        312 => {
                            self.couriers_killed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        320 => {
                            self.net_worth_rank = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        328 => {
                            self.support_gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        336 => {
                            self.observer_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        344 => {
                            self.sentry_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        352 => {
                            self.wards_dewarded = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        365 => {
                            self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                        },
                        368 => {
                            self.rank_mmr_boost_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        386 => {
                            self.contract_progress.push(is.read_message()?);
                        },
                        394 => {
                            is.read_repeated_packed_uint32_into(&mut self.guild_ids)?;
                        },
                        392 => {
                            self.guild_ids.push(is.read_uint32()?);
                        },
                        402 => {
                            is.read_repeated_packed_float_into(&mut self.graph_hero_damage)?;
                        },
                        405 => {
                            self.graph_hero_damage.push(is.read_float()?);
                        },
                        408 => {
                            self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        416 => {
                            self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        426 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.featured_gamemode_progress)?;
                        },
                        432 => {
                            self.featured_hero_sticker_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        440 => {
                            self.featured_hero_sticker_quality = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        450 => {
                            self.equipped_econ_items.push(is.read_message()?);
                        },
                        456 => {
                            self.game_player_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        466 => {
                            self.player_tracked_stats.push(is.read_message()?);
                        },
                        474 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.overworld_rewards)?;
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.ability_upgrades {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
                };
                if let Some(v) = self.player_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                for value in &self.kills {
                    let len = value.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.items {
                    let len = value.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.avg_kills_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.avg_deaths_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.avg_assists_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
                }
                if let Some(v) = self.avg_gpm_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
                }
                if let Some(v) = self.avg_xpm_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.best_kills_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
                }
                if let Some(v) = self.best_assists_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
                }
                if let Some(v) = self.best_gpm_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
                }
                if let Some(v) = self.best_xpm_x16 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
                }
                if let Some(v) = self.win_streak {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
                }
                if let Some(v) = self.best_win_streak {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
                }
                if let Some(v) = self.fight_score {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.farm_score {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.support_score {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.push_score {
                    my_size += 2 + 4;
                }
                for value in &self.level_up_times {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, *value);
                };
                my_size += 6 * self.graph_net_worth.len() as u64;
                for value in &self.inventory_snapshot {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.avg_stats_calibrated {
                    my_size += 2 + 1;
                }
                for value in &self.auto_style_criteria {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.event_data {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.strange_gem_progress {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.hero_xp {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
                }
                if let Some(v) = self.camps_stacked {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(32, v);
                }
                for value in &self.victory_prediction {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.lane_selection_flags {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
                }
                if let Some(v) = self.rampages {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
                }
                if let Some(v) = self.triple_kills {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, v);
                }
                if let Some(v) = self.aegis_snatched {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, v);
                }
                if let Some(v) = self.rapiers_purchased {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
                }
                if let Some(v) = self.couriers_killed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, v);
                }
                if let Some(v) = self.net_worth_rank {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(40, v);
                }
                if let Some(v) = self.support_gold_spent {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
                }
                if let Some(v) = self.observer_wards_placed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
                }
                if let Some(v) = self.sentry_wards_placed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(43, v);
                }
                if let Some(v) = self.wards_dewarded {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(44, v);
                }
                if let Some(v) = self.stun_duration {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.rank_mmr_boost_type {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(46, v.value());
                }
                for value in &self.contract_progress {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.guild_ids {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(49, *value);
                };
                my_size += 6 * self.graph_hero_damage.len() as u64;
                if let Some(v) = self.team_number {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(51, v.value());
                }
                if let Some(v) = self.team_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(52, v);
                }
                if let Some(v) = self.featured_gamemode_progress.as_ref() {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.featured_hero_sticker_index {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(54, v);
                }
                if let Some(v) = self.featured_hero_sticker_quality {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(55, v);
                }
                for value in &self.equipped_econ_items {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.game_player_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(57, v);
                }
                for value in &self.player_tracked_stats {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.overworld_rewards.as_ref() {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                for v in &self.ability_upgrades {
                    os.write_int32(2, *v)?;
                };
                if let Some(v) = self.player_slot {
                    os.write_uint32(3, v)?;
                }
                for v in &self.kills {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                };
                for v in &self.items {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                };
                if let Some(v) = self.avg_kills_x16 {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.avg_deaths_x16 {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.avg_assists_x16 {
                    os.write_uint32(9, v)?;
                }
                if let Some(v) = self.avg_gpm_x16 {
                    os.write_uint32(10, v)?;
                }
                if let Some(v) = self.avg_xpm_x16 {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.best_kills_x16 {
                    os.write_uint32(12, v)?;
                }
                if let Some(v) = self.best_assists_x16 {
                    os.write_uint32(13, v)?;
                }
                if let Some(v) = self.best_gpm_x16 {
                    os.write_uint32(14, v)?;
                }
                if let Some(v) = self.best_xpm_x16 {
                    os.write_uint32(15, v)?;
                }
                if let Some(v) = self.win_streak {
                    os.write_uint32(16, v)?;
                }
                if let Some(v) = self.best_win_streak {
                    os.write_uint32(17, v)?;
                }
                if let Some(v) = self.fight_score {
                    os.write_float(18, v)?;
                }
                if let Some(v) = self.farm_score {
                    os.write_float(19, v)?;
                }
                if let Some(v) = self.support_score {
                    os.write_float(20, v)?;
                }
                if let Some(v) = self.push_score {
                    os.write_float(21, v)?;
                }
                for v in &self.level_up_times {
                    os.write_uint32(22, *v)?;
                };
                for v in &self.graph_net_worth {
                    os.write_float(23, *v)?;
                };
                for v in &self.inventory_snapshot {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                };
                if let Some(v) = self.avg_stats_calibrated {
                    os.write_bool(25, v)?;
                }
                for v in &self.auto_style_criteria {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                };
                for v in &self.event_data {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
                };
                for v in &self.strange_gem_progress {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
                };
                if let Some(v) = self.hero_xp {
                    os.write_uint32(31, v)?;
                }
                if let Some(v) = self.camps_stacked {
                    os.write_uint32(32, v)?;
                }
                for v in &self.victory_prediction {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
                };
                if let Some(v) = self.lane_selection_flags {
                    os.write_uint32(34, v)?;
                }
                if let Some(v) = self.rampages {
                    os.write_uint32(35, v)?;
                }
                if let Some(v) = self.triple_kills {
                    os.write_uint32(36, v)?;
                }
                if let Some(v) = self.aegis_snatched {
                    os.write_uint32(37, v)?;
                }
                if let Some(v) = self.rapiers_purchased {
                    os.write_uint32(38, v)?;
                }
                if let Some(v) = self.couriers_killed {
                    os.write_uint32(39, v)?;
                }
                if let Some(v) = self.net_worth_rank {
                    os.write_uint32(40, v)?;
                }
                if let Some(v) = self.support_gold_spent {
                    os.write_uint32(41, v)?;
                }
                if let Some(v) = self.observer_wards_placed {
                    os.write_uint32(42, v)?;
                }
                if let Some(v) = self.sentry_wards_placed {
                    os.write_uint32(43, v)?;
                }
                if let Some(v) = self.wards_dewarded {
                    os.write_uint32(44, v)?;
                }
                if let Some(v) = self.stun_duration {
                    os.write_float(45, v)?;
                }
                if let Some(v) = self.rank_mmr_boost_type {
                    os.write_enum(46, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                }
                for v in &self.contract_progress {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
                };
                for v in &self.guild_ids {
                    os.write_uint32(49, *v)?;
                };
                for v in &self.graph_hero_damage {
                    os.write_float(50, *v)?;
                };
                if let Some(v) = self.team_number {
                    os.write_enum(51, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.team_slot {
                    os.write_uint32(52, v)?;
                }
                if let Some(v) = self.featured_gamemode_progress.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
                }
                if let Some(v) = self.featured_hero_sticker_index {
                    os.write_uint32(54, v)?;
                }
                if let Some(v) = self.featured_hero_sticker_quality {
                    os.write_uint32(55, v)?;
                }
                for v in &self.equipped_econ_items {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(56, v, os)?;
                };
                if let Some(v) = self.game_player_id {
                    os.write_int32(57, v)?;
                }
                for v in &self.player_tracked_stats {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(58, v, os)?;
                };
                if let Some(v) = self.overworld_rewards.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(59, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Player {
                Player::new()
            }

            fn clear(&mut self) {
                self.ability_upgrades.clear();
                self.player_slot = ::std::option::Option::None;
                self.kills.clear();
                self.items.clear();
                self.avg_kills_x16 = ::std::option::Option::None;
                self.avg_deaths_x16 = ::std::option::Option::None;
                self.avg_assists_x16 = ::std::option::Option::None;
                self.avg_gpm_x16 = ::std::option::Option::None;
                self.avg_xpm_x16 = ::std::option::Option::None;
                self.best_kills_x16 = ::std::option::Option::None;
                self.best_assists_x16 = ::std::option::Option::None;
                self.best_gpm_x16 = ::std::option::Option::None;
                self.best_xpm_x16 = ::std::option::Option::None;
                self.win_streak = ::std::option::Option::None;
                self.best_win_streak = ::std::option::Option::None;
                self.fight_score = ::std::option::Option::None;
                self.farm_score = ::std::option::Option::None;
                self.support_score = ::std::option::Option::None;
                self.push_score = ::std::option::Option::None;
                self.level_up_times.clear();
                self.graph_net_worth.clear();
                self.inventory_snapshot.clear();
                self.avg_stats_calibrated = ::std::option::Option::None;
                self.auto_style_criteria.clear();
                self.event_data.clear();
                self.strange_gem_progress.clear();
                self.hero_xp = ::std::option::Option::None;
                self.camps_stacked = ::std::option::Option::None;
                self.victory_prediction.clear();
                self.lane_selection_flags = ::std::option::Option::None;
                self.rampages = ::std::option::Option::None;
                self.triple_kills = ::std::option::Option::None;
                self.aegis_snatched = ::std::option::Option::None;
                self.rapiers_purchased = ::std::option::Option::None;
                self.couriers_killed = ::std::option::Option::None;
                self.net_worth_rank = ::std::option::Option::None;
                self.support_gold_spent = ::std::option::Option::None;
                self.observer_wards_placed = ::std::option::Option::None;
                self.sentry_wards_placed = ::std::option::Option::None;
                self.wards_dewarded = ::std::option::Option::None;
                self.stun_duration = ::std::option::Option::None;
                self.rank_mmr_boost_type = ::std::option::Option::None;
                self.contract_progress.clear();
                self.guild_ids.clear();
                self.graph_hero_damage.clear();
                self.team_number = ::std::option::Option::None;
                self.team_slot = ::std::option::Option::None;
                self.featured_gamemode_progress.clear();
                self.featured_hero_sticker_index = ::std::option::Option::None;
                self.featured_hero_sticker_quality = ::std::option::Option::None;
                self.equipped_econ_items.clear();
                self.game_player_id = ::std::option::Option::None;
                self.player_tracked_stats.clear();
                self.overworld_rewards.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Player {
                static instance: Player = Player {
                    ability_upgrades: ::std::vec::Vec::new(),
                    player_slot: ::std::option::Option::None,
                    kills: ::std::vec::Vec::new(),
                    items: ::std::vec::Vec::new(),
                    avg_kills_x16: ::std::option::Option::None,
                    avg_deaths_x16: ::std::option::Option::None,
                    avg_assists_x16: ::std::option::Option::None,
                    avg_gpm_x16: ::std::option::Option::None,
                    avg_xpm_x16: ::std::option::Option::None,
                    best_kills_x16: ::std::option::Option::None,
                    best_assists_x16: ::std::option::Option::None,
                    best_gpm_x16: ::std::option::Option::None,
                    best_xpm_x16: ::std::option::Option::None,
                    win_streak: ::std::option::Option::None,
                    best_win_streak: ::std::option::Option::None,
                    fight_score: ::std::option::Option::None,
                    farm_score: ::std::option::Option::None,
                    support_score: ::std::option::Option::None,
                    push_score: ::std::option::Option::None,
                    level_up_times: ::std::vec::Vec::new(),
                    graph_net_worth: ::std::vec::Vec::new(),
                    inventory_snapshot: ::std::vec::Vec::new(),
                    avg_stats_calibrated: ::std::option::Option::None,
                    auto_style_criteria: ::std::vec::Vec::new(),
                    event_data: ::std::vec::Vec::new(),
                    strange_gem_progress: ::std::vec::Vec::new(),
                    hero_xp: ::std::option::Option::None,
                    camps_stacked: ::std::option::Option::None,
                    victory_prediction: ::std::vec::Vec::new(),
                    lane_selection_flags: ::std::option::Option::None,
                    rampages: ::std::option::Option::None,
                    triple_kills: ::std::option::Option::None,
                    aegis_snatched: ::std::option::Option::None,
                    rapiers_purchased: ::std::option::Option::None,
                    couriers_killed: ::std::option::Option::None,
                    net_worth_rank: ::std::option::Option::None,
                    support_gold_spent: ::std::option::Option::None,
                    observer_wards_placed: ::std::option::Option::None,
                    sentry_wards_placed: ::std::option::Option::None,
                    wards_dewarded: ::std::option::Option::None,
                    stun_duration: ::std::option::Option::None,
                    rank_mmr_boost_type: ::std::option::Option::None,
                    contract_progress: ::std::vec::Vec::new(),
                    guild_ids: ::std::vec::Vec::new(),
                    graph_hero_damage: ::std::vec::Vec::new(),
                    team_number: ::std::option::Option::None,
                    team_slot: ::std::option::Option::None,
                    featured_gamemode_progress: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    featured_hero_sticker_index: ::std::option::Option::None,
                    featured_hero_sticker_quality: ::std::option::Option::None,
                    equipped_econ_items: ::std::vec::Vec::new(),
                    game_player_id: ::std::option::Option::None,
                    player_tracked_stats: ::std::vec::Vec::new(),
                    overworld_rewards: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        /// Nested message and enums of message `Player`
        pub mod player {
            // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.Player.ContractProgress)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct ContractProgress {
                // message fields
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ContractProgress.guild_id)
                pub guild_id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ContractProgress.event_id)
                pub event_id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ContractProgress.challenge_instance_id)
                pub challenge_instance_id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ContractProgress.challenge_parameter)
                pub challenge_parameter: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ContractProgress.contract_stars)
                pub contract_stars: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ContractProgress.contract_slot)
                pub contract_slot: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.ContractProgress.completed)
                pub completed: ::std::option::Option<bool>,
                // special fields
                // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.Player.ContractProgress.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a ContractProgress {
                fn default() -> &'a ContractProgress {
                    <ContractProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl ContractProgress {
                pub fn new() -> ContractProgress {
                    ::std::default::Default::default()
                }

                // optional uint32 guild_id = 1;

                pub fn guild_id(&self) -> u32 {
                    self.guild_id.unwrap_or(0)
                }

                pub fn clear_guild_id(&mut self) {
                    self.guild_id = ::std::option::Option::None;
                }

                pub fn has_guild_id(&self) -> bool {
                    self.guild_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_guild_id(&mut self, v: u32) {
                    self.guild_id = ::std::option::Option::Some(v);
                }

                // optional uint32 event_id = 2;

                pub fn event_id(&self) -> u32 {
                    self.event_id.unwrap_or(0)
                }

                pub fn clear_event_id(&mut self) {
                    self.event_id = ::std::option::Option::None;
                }

                pub fn has_event_id(&self) -> bool {
                    self.event_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_event_id(&mut self, v: u32) {
                    self.event_id = ::std::option::Option::Some(v);
                }

                // optional uint32 challenge_instance_id = 3;

                pub fn challenge_instance_id(&self) -> u32 {
                    self.challenge_instance_id.unwrap_or(0)
                }

                pub fn clear_challenge_instance_id(&mut self) {
                    self.challenge_instance_id = ::std::option::Option::None;
                }

                pub fn has_challenge_instance_id(&self) -> bool {
                    self.challenge_instance_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_challenge_instance_id(&mut self, v: u32) {
                    self.challenge_instance_id = ::std::option::Option::Some(v);
                }

                // optional uint32 challenge_parameter = 4;

                pub fn challenge_parameter(&self) -> u32 {
                    self.challenge_parameter.unwrap_or(0)
                }

                pub fn clear_challenge_parameter(&mut self) {
                    self.challenge_parameter = ::std::option::Option::None;
                }

                pub fn has_challenge_parameter(&self) -> bool {
                    self.challenge_parameter.is_some()
                }

                // Param is passed by value, moved
                pub fn set_challenge_parameter(&mut self, v: u32) {
                    self.challenge_parameter = ::std::option::Option::Some(v);
                }

                // optional uint32 contract_stars = 5;

                pub fn contract_stars(&self) -> u32 {
                    self.contract_stars.unwrap_or(0)
                }

                pub fn clear_contract_stars(&mut self) {
                    self.contract_stars = ::std::option::Option::None;
                }

                pub fn has_contract_stars(&self) -> bool {
                    self.contract_stars.is_some()
                }

                // Param is passed by value, moved
                pub fn set_contract_stars(&mut self, v: u32) {
                    self.contract_stars = ::std::option::Option::Some(v);
                }

                // optional uint32 contract_slot = 6;

                pub fn contract_slot(&self) -> u32 {
                    self.contract_slot.unwrap_or(0)
                }

                pub fn clear_contract_slot(&mut self) {
                    self.contract_slot = ::std::option::Option::None;
                }

                pub fn has_contract_slot(&self) -> bool {
                    self.contract_slot.is_some()
                }

                // Param is passed by value, moved
                pub fn set_contract_slot(&mut self, v: u32) {
                    self.contract_slot = ::std::option::Option::Some(v);
                }

                // optional bool completed = 7;

                pub fn completed(&self) -> bool {
                    self.completed.unwrap_or(false)
                }

                pub fn clear_completed(&mut self) {
                    self.completed = ::std::option::Option::None;
                }

                pub fn has_completed(&self) -> bool {
                    self.completed.is_some()
                }

                // Param is passed by value, moved
                pub fn set_completed(&mut self, v: bool) {
                    self.completed = ::std::option::Option::Some(v);
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for ContractProgress {
                const NAME: &'static str = "ContractProgress";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            32 => {
                                self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            40 => {
                                self.contract_stars = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            48 => {
                                self.contract_slot = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            56 => {
                                self.completed = ::std::option::Option::Some(is.read_bool()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.guild_id {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.event_id {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.challenge_instance_id {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                    }
                    if let Some(v) = self.challenge_parameter {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                    }
                    if let Some(v) = self.contract_stars {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                    }
                    if let Some(v) = self.contract_slot {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                    }
                    if let Some(v) = self.completed {
                        my_size += 1 + 1;
                    }
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.guild_id {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.event_id {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.challenge_instance_id {
                        os.write_uint32(3, v)?;
                    }
                    if let Some(v) = self.challenge_parameter {
                        os.write_uint32(4, v)?;
                    }
                    if let Some(v) = self.contract_stars {
                        os.write_uint32(5, v)?;
                    }
                    if let Some(v) = self.contract_slot {
                        os.write_uint32(6, v)?;
                    }
                    if let Some(v) = self.completed {
                        os.write_bool(7, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> ContractProgress {
                    ContractProgress::new()
                }

                fn clear(&mut self) {
                    self.guild_id = ::std::option::Option::None;
                    self.event_id = ::std::option::Option::None;
                    self.challenge_instance_id = ::std::option::Option::None;
                    self.challenge_parameter = ::std::option::Option::None;
                    self.contract_stars = ::std::option::Option::None;
                    self.contract_slot = ::std::option::Option::None;
                    self.completed = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static ContractProgress {
                    static instance: ContractProgress = ContractProgress {
                        guild_id: ::std::option::Option::None,
                        event_id: ::std::option::Option::None,
                        challenge_instance_id: ::std::option::Option::None,
                        challenge_parameter: ::std::option::Option::None,
                        contract_stars: ::std::option::Option::None,
                        contract_slot: ::std::option::Option::None,
                        completed: ::std::option::Option::None,
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            // @@protoc_insertion_point(message:CDOTAMatchMetadata.Team.Player.OverworldRewards)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct OverworldRewards {
                // message fields
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.OverworldRewards.overworld_id)
                pub overworld_id: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchMetadata.Team.Player.OverworldRewards.tokens)
                pub tokens: ::steam_vent_proto_common::protobuf::MessageField<super::super::super::super::dota_gcmessages_common_overworld::CMsgOverworldTokenQuantity>,
                // special fields
                // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Team.Player.OverworldRewards.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a OverworldRewards {
                fn default() -> &'a OverworldRewards {
                    <OverworldRewards as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl OverworldRewards {
                pub fn new() -> OverworldRewards {
                    ::std::default::Default::default()
                }

                // optional uint32 overworld_id = 1;

                pub fn overworld_id(&self) -> u32 {
                    self.overworld_id.unwrap_or(0)
                }

                pub fn clear_overworld_id(&mut self) {
                    self.overworld_id = ::std::option::Option::None;
                }

                pub fn has_overworld_id(&self) -> bool {
                    self.overworld_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_overworld_id(&mut self, v: u32) {
                    self.overworld_id = ::std::option::Option::Some(v);
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for OverworldRewards {
                const NAME: &'static str = "OverworldRewards";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            18 => {
                                ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tokens)?;
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.overworld_id {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.tokens.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.overworld_id {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.tokens.as_ref() {
                        ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> OverworldRewards {
                    OverworldRewards::new()
                }

                fn clear(&mut self) {
                    self.overworld_id = ::std::option::Option::None;
                    self.tokens.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static OverworldRewards {
                    static instance: OverworldRewards = OverworldRewards {
                        overworld_id: ::std::option::Option::None,
                        tokens: ::steam_vent_proto_common::protobuf::MessageField::none(),
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }
        }
    }

    // @@protoc_insertion_point(message:CDOTAMatchMetadata.GuildChallengeProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GuildChallengeProgress {
        // message fields
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.event_id)
        pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.challenge_instance_id)
        pub challenge_instance_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.challenge_parameter)
        pub challenge_parameter: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.challenge_timestamp)
        pub challenge_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.challenge_progress_at_start)
        pub challenge_progress_at_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.challenge_progress_accumulated)
        pub challenge_progress_accumulated: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.individual_progress)
        pub individual_progress: ::std::vec::Vec<guild_challenge_progress::IndividualProgress>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.GuildChallengeProgress.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GuildChallengeProgress {
        fn default() -> &'a GuildChallengeProgress {
            <GuildChallengeProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GuildChallengeProgress {
        pub fn new() -> GuildChallengeProgress {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional .EEvent event_id = 2;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 challenge_instance_id = 3;

        pub fn challenge_instance_id(&self) -> u32 {
            self.challenge_instance_id.unwrap_or(0)
        }

        pub fn clear_challenge_instance_id(&mut self) {
            self.challenge_instance_id = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_id(&self) -> bool {
            self.challenge_instance_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_id(&mut self, v: u32) {
            self.challenge_instance_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_parameter = 4;

        pub fn challenge_parameter(&self) -> u32 {
            self.challenge_parameter.unwrap_or(0)
        }

        pub fn clear_challenge_parameter(&mut self) {
            self.challenge_parameter = ::std::option::Option::None;
        }

        pub fn has_challenge_parameter(&self) -> bool {
            self.challenge_parameter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_parameter(&mut self, v: u32) {
            self.challenge_parameter = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_timestamp = 5;

        pub fn challenge_timestamp(&self) -> u32 {
            self.challenge_timestamp.unwrap_or(0)
        }

        pub fn clear_challenge_timestamp(&mut self) {
            self.challenge_timestamp = ::std::option::Option::None;
        }

        pub fn has_challenge_timestamp(&self) -> bool {
            self.challenge_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_timestamp(&mut self, v: u32) {
            self.challenge_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_progress_at_start = 6;

        pub fn challenge_progress_at_start(&self) -> u32 {
            self.challenge_progress_at_start.unwrap_or(0)
        }

        pub fn clear_challenge_progress_at_start(&mut self) {
            self.challenge_progress_at_start = ::std::option::Option::None;
        }

        pub fn has_challenge_progress_at_start(&self) -> bool {
            self.challenge_progress_at_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_progress_at_start(&mut self, v: u32) {
            self.challenge_progress_at_start = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_progress_accumulated = 7;

        pub fn challenge_progress_accumulated(&self) -> u32 {
            self.challenge_progress_accumulated.unwrap_or(0)
        }

        pub fn clear_challenge_progress_accumulated(&mut self) {
            self.challenge_progress_accumulated = ::std::option::Option::None;
        }

        pub fn has_challenge_progress_accumulated(&self) -> bool {
            self.challenge_progress_accumulated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_progress_accumulated(&mut self, v: u32) {
            self.challenge_progress_accumulated = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GuildChallengeProgress {
        const NAME: &'static str = "GuildChallengeProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.challenge_progress_at_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.challenge_progress_accumulated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.individual_progress.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.challenge_instance_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.challenge_parameter {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.challenge_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.challenge_progress_at_start {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.challenge_progress_accumulated {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            for value in &self.individual_progress {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.challenge_instance_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.challenge_parameter {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.challenge_timestamp {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.challenge_progress_at_start {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.challenge_progress_accumulated {
                os.write_uint32(7, v)?;
            }
            for v in &self.individual_progress {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GuildChallengeProgress {
            GuildChallengeProgress::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.challenge_instance_id = ::std::option::Option::None;
            self.challenge_parameter = ::std::option::Option::None;
            self.challenge_timestamp = ::std::option::Option::None;
            self.challenge_progress_at_start = ::std::option::Option::None;
            self.challenge_progress_accumulated = ::std::option::Option::None;
            self.individual_progress.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GuildChallengeProgress {
            static instance: GuildChallengeProgress = GuildChallengeProgress {
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                challenge_instance_id: ::std::option::Option::None,
                challenge_parameter: ::std::option::Option::None,
                challenge_timestamp: ::std::option::Option::None,
                challenge_progress_at_start: ::std::option::Option::None,
                challenge_progress_accumulated: ::std::option::Option::None,
                individual_progress: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `GuildChallengeProgress`
    pub mod guild_challenge_progress {
        // @@protoc_insertion_point(message:CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct IndividualProgress {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress.progress)
            pub progress: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.GuildChallengeProgress.IndividualProgress.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a IndividualProgress {
            fn default() -> &'a IndividualProgress {
                <IndividualProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl IndividualProgress {
            pub fn new() -> IndividualProgress {
                ::std::default::Default::default()
            }

            // optional uint32 progress = 2;

            pub fn progress(&self) -> u32 {
                self.progress.unwrap_or(0)
            }

            pub fn clear_progress(&mut self) {
                self.progress = ::std::option::Option::None;
            }

            pub fn has_progress(&self) -> bool {
                self.progress.is_some()
            }

            // Param is passed by value, moved
            pub fn set_progress(&mut self, v: u32) {
                self.progress = ::std::option::Option::Some(v);
            }

            // optional uint32 player_slot = 3;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for IndividualProgress {
            const NAME: &'static str = "IndividualProgress";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        16 => {
                            self.progress = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.progress {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.player_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.progress {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.player_slot {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> IndividualProgress {
                IndividualProgress::new()
            }

            fn clear(&mut self) {
                self.progress = ::std::option::Option::None;
                self.player_slot = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static IndividualProgress {
                static instance: IndividualProgress = IndividualProgress {
                    progress: ::std::option::Option::None,
                    player_slot: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:CDOTAMatchMetadata.Tip)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tip {
        // message fields
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Tip.source_player_slot)
        pub source_player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Tip.target_player_slot)
        pub target_player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Tip.tip_amount)
        pub tip_amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchMetadata.Tip.event_id)
        pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAMatchMetadata.Tip.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tip {
        fn default() -> &'a Tip {
            <Tip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Tip {
        pub fn new() -> Tip {
            ::std::default::Default::default()
        }

        // optional uint32 source_player_slot = 1;

        pub fn source_player_slot(&self) -> u32 {
            self.source_player_slot.unwrap_or(0)
        }

        pub fn clear_source_player_slot(&mut self) {
            self.source_player_slot = ::std::option::Option::None;
        }

        pub fn has_source_player_slot(&self) -> bool {
            self.source_player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_player_slot(&mut self, v: u32) {
            self.source_player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 target_player_slot = 2;

        pub fn target_player_slot(&self) -> u32 {
            self.target_player_slot.unwrap_or(0)
        }

        pub fn clear_target_player_slot(&mut self) {
            self.target_player_slot = ::std::option::Option::None;
        }

        pub fn has_target_player_slot(&self) -> bool {
            self.target_player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_player_slot(&mut self, v: u32) {
            self.target_player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 tip_amount = 3;

        pub fn tip_amount(&self) -> u32 {
            self.tip_amount.unwrap_or(0)
        }

        pub fn clear_tip_amount(&mut self) {
            self.tip_amount = ::std::option::Option::None;
        }

        pub fn has_tip_amount(&self) -> bool {
            self.tip_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tip_amount(&mut self, v: u32) {
            self.tip_amount = ::std::option::Option::Some(v);
        }

        // optional .EEvent event_id = 4;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Tip {
        const NAME: &'static str = "Tip";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.target_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tip_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.target_player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tip_amount {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.source_player_slot {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.target_player_slot {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tip_amount {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tip {
            Tip::new()
        }

        fn clear(&mut self) {
            self.source_player_slot = ::std::option::Option::None;
            self.target_player_slot = ::std::option::Option::None;
            self.tip_amount = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tip {
            static instance: Tip = Tip {
                source_player_slot: ::std::option::Option::None,
                target_player_slot: ::std::option::Option::None,
                tip_amount: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAMatchPrivateMetadata {
    // message fields
    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.teams)
    pub teams: ::std::vec::Vec<cdotamatch_private_metadata::Team>,
    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.graph_win_probability)
    pub graph_win_probability: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.string_names)
    pub string_names: ::std::vec::Vec<cdotamatch_private_metadata::StringName>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAMatchPrivateMetadata {
    fn default() -> &'a CDOTAMatchPrivateMetadata {
        <CDOTAMatchPrivateMetadata as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAMatchPrivateMetadata {
    pub fn new() -> CDOTAMatchPrivateMetadata {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAMatchPrivateMetadata {
    const NAME: &'static str = "CDOTAMatchPrivateMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.teams.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.graph_win_probability)?;
                },
                21 => {
                    self.graph_win_probability.push(is.read_float()?);
                },
                26 => {
                    self.string_names.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 5 * self.graph_win_probability.len() as u64;
        for value in &self.string_names {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.teams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.graph_win_probability {
            os.write_float(2, *v)?;
        };
        for v in &self.string_names {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAMatchPrivateMetadata {
        CDOTAMatchPrivateMetadata::new()
    }

    fn clear(&mut self) {
        self.teams.clear();
        self.graph_win_probability.clear();
        self.string_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAMatchPrivateMetadata {
        static instance: CDOTAMatchPrivateMetadata = CDOTAMatchPrivateMetadata {
            teams: ::std::vec::Vec::new(),
            graph_win_probability: ::std::vec::Vec::new(),
            string_names: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAMatchPrivateMetadata`
pub mod cdotamatch_private_metadata {
    // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.StringName)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StringName {
        // message fields
        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.StringName.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.StringName.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.StringName.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StringName {
        fn default() -> &'a StringName {
            <StringName as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl StringName {
        pub fn new() -> StringName {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for StringName {
        const NAME: &'static str = "StringName";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StringName {
            StringName::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StringName {
            static instance: StringName = StringName {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.dota_team)
        pub dota_team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.players)
        pub players: ::std::vec::Vec<team::Player>,
        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.buildings)
        pub buildings: ::std::vec::Vec<team::Building>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 dota_team = 1;

        pub fn dota_team(&self) -> u32 {
            self.dota_team.unwrap_or(0)
        }

        pub fn clear_dota_team(&mut self) {
            self.dota_team = ::std::option::Option::None;
        }

        pub fn has_dota_team(&self) -> bool {
            self.dota_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dota_team(&mut self, v: u32) {
            self.dota_team = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.players.push(is.read_message()?);
                    },
                    26 => {
                        self.buildings.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dota_team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.buildings {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.dota_team {
                os.write_uint32(1, v)?;
            }
            for v in &self.players {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.buildings {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.dota_team = ::std::option::Option::None;
            self.players.clear();
            self.buildings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                dota_team: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                buildings: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Team`
    pub mod team {
        // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Player {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.position_stream)
            pub position_stream: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.combat_segments)
            pub combat_segments: ::std::vec::Vec<player::CombatSegment>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.damage_unit_names)
            pub damage_unit_names: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.buff_records)
            pub buff_records: ::std::vec::Vec<player::BuffRecord>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.graph_kills)
            pub graph_kills: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.graph_deaths)
            pub graph_deaths: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.graph_assists)
            pub graph_assists: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.graph_lasthits)
            pub graph_lasthits: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.graph_denies)
            pub graph_denies: ::std::vec::Vec<f32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.gold_received)
            pub gold_received: ::steam_vent_proto_common::protobuf::MessageField<player::GoldReceived>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.xp_received)
            pub xp_received: ::steam_vent_proto_common::protobuf::MessageField<player::XPReceived>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.team_number)
            pub team_number: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::DOTA_GC_TEAM>>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.team_slot)
            pub team_slot: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Player {
            fn default() -> &'a Player {
                <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Player {
            pub fn new() -> Player {
                ::std::default::Default::default()
            }

            // optional uint32 player_slot = 2;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional bytes position_stream = 3;

            pub fn position_stream(&self) -> &[u8] {
                match self.position_stream.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_position_stream(&mut self) {
                self.position_stream = ::std::option::Option::None;
            }

            pub fn has_position_stream(&self) -> bool {
                self.position_stream.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_stream(&mut self, v: ::std::vec::Vec<u8>) {
                self.position_stream = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_position_stream(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.position_stream.is_none() {
                    self.position_stream = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.position_stream.as_mut().unwrap()
            }

            // Take field
            pub fn take_position_stream(&mut self) -> ::std::vec::Vec<u8> {
                self.position_stream.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional .DOTA_GC_TEAM team_number = 14;

            pub fn team_number(&self) -> super::super::super::dota_shared_enums::DOTA_GC_TEAM {
                match self.team_number {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                    None => super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
                }
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: super::super::super::dota_shared_enums::DOTA_GC_TEAM) {
                self.team_number = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 team_slot = 15;

            pub fn team_slot(&self) -> u32 {
                self.team_slot.unwrap_or(0)
            }

            pub fn clear_team_slot(&mut self) {
                self.team_slot = ::std::option::Option::None;
            }

            pub fn has_team_slot(&self) -> bool {
                self.team_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_slot(&mut self, v: u32) {
                self.team_slot = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Player {
            const NAME: &'static str = "Player";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        16 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        26 => {
                            self.position_stream = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        34 => {
                            self.combat_segments.push(is.read_message()?);
                        },
                        42 => {
                            self.damage_unit_names.push(is.read_string()?);
                        },
                        50 => {
                            self.buff_records.push(is.read_message()?);
                        },
                        58 => {
                            is.read_repeated_packed_float_into(&mut self.graph_kills)?;
                        },
                        61 => {
                            self.graph_kills.push(is.read_float()?);
                        },
                        66 => {
                            is.read_repeated_packed_float_into(&mut self.graph_deaths)?;
                        },
                        69 => {
                            self.graph_deaths.push(is.read_float()?);
                        },
                        74 => {
                            is.read_repeated_packed_float_into(&mut self.graph_assists)?;
                        },
                        77 => {
                            self.graph_assists.push(is.read_float()?);
                        },
                        82 => {
                            is.read_repeated_packed_float_into(&mut self.graph_lasthits)?;
                        },
                        85 => {
                            self.graph_lasthits.push(is.read_float()?);
                        },
                        90 => {
                            is.read_repeated_packed_float_into(&mut self.graph_denies)?;
                        },
                        93 => {
                            self.graph_denies.push(is.read_float()?);
                        },
                        98 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gold_received)?;
                        },
                        106 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.xp_received)?;
                        },
                        112 => {
                            self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        120 => {
                            self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.player_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.position_stream.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
                }
                for value in &self.combat_segments {
                    let len = value.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.damage_unit_names {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &value);
                };
                for value in &self.buff_records {
                    let len = value.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += 5 * self.graph_kills.len() as u64;
                my_size += 5 * self.graph_deaths.len() as u64;
                my_size += 5 * self.graph_assists.len() as u64;
                my_size += 5 * self.graph_lasthits.len() as u64;
                my_size += 5 * self.graph_denies.len() as u64;
                if let Some(v) = self.gold_received.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.xp_received.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.team_number {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v.value());
                }
                if let Some(v) = self.team_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.player_slot {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.position_stream.as_ref() {
                    os.write_bytes(3, v)?;
                }
                for v in &self.combat_segments {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                for v in &self.damage_unit_names {
                    os.write_string(5, &v)?;
                };
                for v in &self.buff_records {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                };
                for v in &self.graph_kills {
                    os.write_float(7, *v)?;
                };
                for v in &self.graph_deaths {
                    os.write_float(8, *v)?;
                };
                for v in &self.graph_assists {
                    os.write_float(9, *v)?;
                };
                for v in &self.graph_lasthits {
                    os.write_float(10, *v)?;
                };
                for v in &self.graph_denies {
                    os.write_float(11, *v)?;
                };
                if let Some(v) = self.gold_received.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                }
                if let Some(v) = self.xp_received.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                }
                if let Some(v) = self.team_number {
                    os.write_enum(14, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.team_slot {
                    os.write_uint32(15, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Player {
                Player::new()
            }

            fn clear(&mut self) {
                self.player_slot = ::std::option::Option::None;
                self.position_stream = ::std::option::Option::None;
                self.combat_segments.clear();
                self.damage_unit_names.clear();
                self.buff_records.clear();
                self.graph_kills.clear();
                self.graph_deaths.clear();
                self.graph_assists.clear();
                self.graph_lasthits.clear();
                self.graph_denies.clear();
                self.gold_received.clear();
                self.xp_received.clear();
                self.team_number = ::std::option::Option::None;
                self.team_slot = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Player {
                static instance: Player = Player {
                    player_slot: ::std::option::Option::None,
                    position_stream: ::std::option::Option::None,
                    combat_segments: ::std::vec::Vec::new(),
                    damage_unit_names: ::std::vec::Vec::new(),
                    buff_records: ::std::vec::Vec::new(),
                    graph_kills: ::std::vec::Vec::new(),
                    graph_deaths: ::std::vec::Vec::new(),
                    graph_assists: ::std::vec::Vec::new(),
                    graph_lasthits: ::std::vec::Vec::new(),
                    graph_denies: ::std::vec::Vec::new(),
                    gold_received: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    xp_received: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    team_number: ::std::option::Option::None,
                    team_slot: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        /// Nested message and enums of message `Player`
        pub mod player {
            // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct CombatSegment {
                // message fields
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.game_time)
                pub game_time: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.damage_by_ability)
                pub damage_by_ability: ::std::vec::Vec<combat_segment::DamageByAbility>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.healing_by_ability)
                pub healing_by_ability: ::std::vec::Vec<combat_segment::HealingByAbility>,
                // special fields
                // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a CombatSegment {
                fn default() -> &'a CombatSegment {
                    <CombatSegment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl CombatSegment {
                pub fn new() -> CombatSegment {
                    ::std::default::Default::default()
                }

                // optional int32 game_time = 1;

                pub fn game_time(&self) -> i32 {
                    self.game_time.unwrap_or(0)
                }

                pub fn clear_game_time(&mut self) {
                    self.game_time = ::std::option::Option::None;
                }

                pub fn has_game_time(&self) -> bool {
                    self.game_time.is_some()
                }

                // Param is passed by value, moved
                pub fn set_game_time(&mut self, v: i32) {
                    self.game_time = ::std::option::Option::Some(v);
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for CombatSegment {
                const NAME: &'static str = "CombatSegment";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.game_time = ::std::option::Option::Some(is.read_int32()?);
                            },
                            18 => {
                                self.damage_by_ability.push(is.read_message()?);
                            },
                            26 => {
                                self.healing_by_ability.push(is.read_message()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.game_time {
                        my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                    }
                    for value in &self.damage_by_ability {
                        let len = value.compute_size();
                        my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    for value in &self.healing_by_ability {
                        let len = value.compute_size();
                        my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.game_time {
                        os.write_int32(1, v)?;
                    }
                    for v in &self.damage_by_ability {
                        ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    };
                    for v in &self.healing_by_ability {
                        ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    };
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> CombatSegment {
                    CombatSegment::new()
                }

                fn clear(&mut self) {
                    self.game_time = ::std::option::Option::None;
                    self.damage_by_ability.clear();
                    self.healing_by_ability.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static CombatSegment {
                    static instance: CombatSegment = CombatSegment {
                        game_time: ::std::option::Option::None,
                        damage_by_ability: ::std::vec::Vec::new(),
                        healing_by_ability: ::std::vec::Vec::new(),
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            /// Nested message and enums of message `CombatSegment`
            pub mod combat_segment {
                // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct DamageByAbility {
                    // message fields
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.source_unit_index)
                    pub source_unit_index: ::std::option::Option<u32>,
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ability_id)
                    pub ability_id: ::std::option::Option<i32>,
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.by_hero_targets)
                    pub by_hero_targets: ::std::vec::Vec<damage_by_ability::ByHeroTarget>,
                    // special fields
                    // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.special_fields)
                    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a DamageByAbility {
                    fn default() -> &'a DamageByAbility {
                        <DamageByAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                    }
                }

                impl DamageByAbility {
                    pub fn new() -> DamageByAbility {
                        ::std::default::Default::default()
                    }

                    // optional uint32 source_unit_index = 3;

                    pub fn source_unit_index(&self) -> u32 {
                        self.source_unit_index.unwrap_or(0)
                    }

                    pub fn clear_source_unit_index(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                    }

                    pub fn has_source_unit_index(&self) -> bool {
                        self.source_unit_index.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_source_unit_index(&mut self, v: u32) {
                        self.source_unit_index = ::std::option::Option::Some(v);
                    }

                    // optional int32 ability_id = 1;

                    pub fn ability_id(&self) -> i32 {
                        self.ability_id.unwrap_or(-1i32)
                    }

                    pub fn clear_ability_id(&mut self) {
                        self.ability_id = ::std::option::Option::None;
                    }

                    pub fn has_ability_id(&self) -> bool {
                        self.ability_id.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_ability_id(&mut self, v: i32) {
                        self.ability_id = ::std::option::Option::Some(v);
                    }
                }

                impl ::steam_vent_proto_common::protobuf::Message for DamageByAbility {
                    const NAME: &'static str = "DamageByAbility";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                24 => {
                                    self.source_unit_index = ::std::option::Option::Some(is.read_uint32()?);
                                },
                                8 => {
                                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                                },
                                18 => {
                                    self.by_hero_targets.push(is.read_message()?);
                                },
                                tag => {
                                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let Some(v) = self.source_unit_index {
                            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                        }
                        if let Some(v) = self.ability_id {
                            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                        }
                        for value in &self.by_hero_targets {
                            let len = value.compute_size();
                            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                        };
                        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                        if let Some(v) = self.source_unit_index {
                            os.write_uint32(3, v)?;
                        }
                        if let Some(v) = self.ability_id {
                            os.write_int32(1, v)?;
                        }
                        for v in &self.by_hero_targets {
                            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        };
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> DamageByAbility {
                        DamageByAbility::new()
                    }

                    fn clear(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                        self.ability_id = ::std::option::Option::None;
                        self.by_hero_targets.clear();
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static DamageByAbility {
                        static instance: DamageByAbility = DamageByAbility {
                            source_unit_index: ::std::option::Option::None,
                            ability_id: ::std::option::Option::None,
                            by_hero_targets: ::std::vec::Vec::new(),
                            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                /// Nested message and enums of message `DamageByAbility`
                pub mod damage_by_ability {
                    // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget)
                    #[derive(PartialEq,Clone,Default,Debug)]
                    pub struct ByHeroTarget {
                        // message fields
                        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget.hero_id)
                        pub hero_id: ::std::option::Option<i32>,
                        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget.damage)
                        pub damage: ::std::option::Option<u32>,
                        // special fields
                        // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.DamageByAbility.ByHeroTarget.special_fields)
                        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
                    }

                    impl<'a> ::std::default::Default for &'a ByHeroTarget {
                        fn default() -> &'a ByHeroTarget {
                            <ByHeroTarget as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                        }
                    }

                    impl ByHeroTarget {
                        pub fn new() -> ByHeroTarget {
                            ::std::default::Default::default()
                        }

                        // optional int32 hero_id = 1;

                        pub fn hero_id(&self) -> i32 {
                            self.hero_id.unwrap_or(0)
                        }

                        pub fn clear_hero_id(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                        }

                        pub fn has_hero_id(&self) -> bool {
                            self.hero_id.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_hero_id(&mut self, v: i32) {
                            self.hero_id = ::std::option::Option::Some(v);
                        }

                        // optional uint32 damage = 2;

                        pub fn damage(&self) -> u32 {
                            self.damage.unwrap_or(0)
                        }

                        pub fn clear_damage(&mut self) {
                            self.damage = ::std::option::Option::None;
                        }

                        pub fn has_damage(&self) -> bool {
                            self.damage.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_damage(&mut self, v: u32) {
                            self.damage = ::std::option::Option::Some(v);
                        }
                    }

                    impl ::steam_vent_proto_common::protobuf::Message for ByHeroTarget {
                        const NAME: &'static str = "ByHeroTarget";

                        fn is_initialized(&self) -> bool {
                            true
                        }

                        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    8 => {
                                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                                    },
                                    16 => {
                                        self.damage = ::std::option::Option::Some(is.read_uint32()?);
                                    },
                                    tag => {
                                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                    },
                                };
                            }
                            ::std::result::Result::Ok(())
                        }

                        // Compute sizes of nested messages
                        #[allow(unused_variables)]
                        fn compute_size(&self) -> u64 {
                            let mut my_size = 0;
                            if let Some(v) = self.hero_id {
                                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                            }
                            if let Some(v) = self.damage {
                                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                            }
                            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                            self.special_fields.cached_size().set(my_size as u32);
                            my_size
                        }

                        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                            if let Some(v) = self.hero_id {
                                os.write_int32(1, v)?;
                            }
                            if let Some(v) = self.damage {
                                os.write_uint32(2, v)?;
                            }
                            os.write_unknown_fields(self.special_fields.unknown_fields())?;
                            ::std::result::Result::Ok(())
                        }

                        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                            &self.special_fields
                        }

                        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                            &mut self.special_fields
                        }

                        fn new() -> ByHeroTarget {
                            ByHeroTarget::new()
                        }

                        fn clear(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                            self.damage = ::std::option::Option::None;
                            self.special_fields.clear();
                        }

                        fn default_instance() -> &'static ByHeroTarget {
                            static instance: ByHeroTarget = ByHeroTarget {
                                hero_id: ::std::option::Option::None,
                                damage: ::std::option::Option::None,
                                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                            };
                            &instance
                        }
                    }
                }

                // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct HealingByAbility {
                    // message fields
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.source_unit_index)
                    pub source_unit_index: ::std::option::Option<u32>,
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ability_id)
                    pub ability_id: ::std::option::Option<i32>,
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.by_hero_targets)
                    pub by_hero_targets: ::std::vec::Vec<healing_by_ability::ByHeroTarget>,
                    // special fields
                    // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.special_fields)
                    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a HealingByAbility {
                    fn default() -> &'a HealingByAbility {
                        <HealingByAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                    }
                }

                impl HealingByAbility {
                    pub fn new() -> HealingByAbility {
                        ::std::default::Default::default()
                    }

                    // optional uint32 source_unit_index = 3;

                    pub fn source_unit_index(&self) -> u32 {
                        self.source_unit_index.unwrap_or(0)
                    }

                    pub fn clear_source_unit_index(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                    }

                    pub fn has_source_unit_index(&self) -> bool {
                        self.source_unit_index.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_source_unit_index(&mut self, v: u32) {
                        self.source_unit_index = ::std::option::Option::Some(v);
                    }

                    // optional int32 ability_id = 1;

                    pub fn ability_id(&self) -> i32 {
                        self.ability_id.unwrap_or(-1i32)
                    }

                    pub fn clear_ability_id(&mut self) {
                        self.ability_id = ::std::option::Option::None;
                    }

                    pub fn has_ability_id(&self) -> bool {
                        self.ability_id.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_ability_id(&mut self, v: i32) {
                        self.ability_id = ::std::option::Option::Some(v);
                    }
                }

                impl ::steam_vent_proto_common::protobuf::Message for HealingByAbility {
                    const NAME: &'static str = "HealingByAbility";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                24 => {
                                    self.source_unit_index = ::std::option::Option::Some(is.read_uint32()?);
                                },
                                8 => {
                                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                                },
                                18 => {
                                    self.by_hero_targets.push(is.read_message()?);
                                },
                                tag => {
                                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let Some(v) = self.source_unit_index {
                            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                        }
                        if let Some(v) = self.ability_id {
                            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                        }
                        for value in &self.by_hero_targets {
                            let len = value.compute_size();
                            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                        };
                        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                        if let Some(v) = self.source_unit_index {
                            os.write_uint32(3, v)?;
                        }
                        if let Some(v) = self.ability_id {
                            os.write_int32(1, v)?;
                        }
                        for v in &self.by_hero_targets {
                            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        };
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> HealingByAbility {
                        HealingByAbility::new()
                    }

                    fn clear(&mut self) {
                        self.source_unit_index = ::std::option::Option::None;
                        self.ability_id = ::std::option::Option::None;
                        self.by_hero_targets.clear();
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static HealingByAbility {
                        static instance: HealingByAbility = HealingByAbility {
                            source_unit_index: ::std::option::Option::None,
                            ability_id: ::std::option::Option::None,
                            by_hero_targets: ::std::vec::Vec::new(),
                            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                /// Nested message and enums of message `HealingByAbility`
                pub mod healing_by_ability {
                    // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget)
                    #[derive(PartialEq,Clone,Default,Debug)]
                    pub struct ByHeroTarget {
                        // message fields
                        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget.hero_id)
                        pub hero_id: ::std::option::Option<i32>,
                        // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget.healing)
                        pub healing: ::std::option::Option<u32>,
                        // special fields
                        // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.CombatSegment.HealingByAbility.ByHeroTarget.special_fields)
                        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
                    }

                    impl<'a> ::std::default::Default for &'a ByHeroTarget {
                        fn default() -> &'a ByHeroTarget {
                            <ByHeroTarget as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                        }
                    }

                    impl ByHeroTarget {
                        pub fn new() -> ByHeroTarget {
                            ::std::default::Default::default()
                        }

                        // optional int32 hero_id = 1;

                        pub fn hero_id(&self) -> i32 {
                            self.hero_id.unwrap_or(0)
                        }

                        pub fn clear_hero_id(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                        }

                        pub fn has_hero_id(&self) -> bool {
                            self.hero_id.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_hero_id(&mut self, v: i32) {
                            self.hero_id = ::std::option::Option::Some(v);
                        }

                        // optional uint32 healing = 2;

                        pub fn healing(&self) -> u32 {
                            self.healing.unwrap_or(0)
                        }

                        pub fn clear_healing(&mut self) {
                            self.healing = ::std::option::Option::None;
                        }

                        pub fn has_healing(&self) -> bool {
                            self.healing.is_some()
                        }

                        // Param is passed by value, moved
                        pub fn set_healing(&mut self, v: u32) {
                            self.healing = ::std::option::Option::Some(v);
                        }
                    }

                    impl ::steam_vent_proto_common::protobuf::Message for ByHeroTarget {
                        const NAME: &'static str = "ByHeroTarget";

                        fn is_initialized(&self) -> bool {
                            true
                        }

                        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    8 => {
                                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                                    },
                                    16 => {
                                        self.healing = ::std::option::Option::Some(is.read_uint32()?);
                                    },
                                    tag => {
                                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                    },
                                };
                            }
                            ::std::result::Result::Ok(())
                        }

                        // Compute sizes of nested messages
                        #[allow(unused_variables)]
                        fn compute_size(&self) -> u64 {
                            let mut my_size = 0;
                            if let Some(v) = self.hero_id {
                                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                            }
                            if let Some(v) = self.healing {
                                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                            }
                            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                            self.special_fields.cached_size().set(my_size as u32);
                            my_size
                        }

                        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                            if let Some(v) = self.hero_id {
                                os.write_int32(1, v)?;
                            }
                            if let Some(v) = self.healing {
                                os.write_uint32(2, v)?;
                            }
                            os.write_unknown_fields(self.special_fields.unknown_fields())?;
                            ::std::result::Result::Ok(())
                        }

                        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                            &self.special_fields
                        }

                        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                            &mut self.special_fields
                        }

                        fn new() -> ByHeroTarget {
                            ByHeroTarget::new()
                        }

                        fn clear(&mut self) {
                            self.hero_id = ::std::option::Option::None;
                            self.healing = ::std::option::Option::None;
                            self.special_fields.clear();
                        }

                        fn default_instance() -> &'static ByHeroTarget {
                            static instance: ByHeroTarget = ByHeroTarget {
                                hero_id: ::std::option::Option::None,
                                healing: ::std::option::Option::None,
                                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                            };
                            &instance
                        }
                    }
                }
            }

            // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct BuffRecord {
                // message fields
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.buff_ability_id)
                pub buff_ability_id: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.buff_modifier_name)
                pub buff_modifier_name: ::std::option::Option<::std::string::String>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.by_hero_targets)
                pub by_hero_targets: ::std::vec::Vec<buff_record::ByHeroTarget>,
                // special fields
                // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a BuffRecord {
                fn default() -> &'a BuffRecord {
                    <BuffRecord as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl BuffRecord {
                pub fn new() -> BuffRecord {
                    ::std::default::Default::default()
                }

                // optional int32 buff_ability_id = 1;

                pub fn buff_ability_id(&self) -> i32 {
                    self.buff_ability_id.unwrap_or(-1i32)
                }

                pub fn clear_buff_ability_id(&mut self) {
                    self.buff_ability_id = ::std::option::Option::None;
                }

                pub fn has_buff_ability_id(&self) -> bool {
                    self.buff_ability_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_buff_ability_id(&mut self, v: i32) {
                    self.buff_ability_id = ::std::option::Option::Some(v);
                }

                // optional string buff_modifier_name = 3;

                pub fn buff_modifier_name(&self) -> &str {
                    match self.buff_modifier_name.as_ref() {
                        Some(v) => v,
                        None => "",
                    }
                }

                pub fn clear_buff_modifier_name(&mut self) {
                    self.buff_modifier_name = ::std::option::Option::None;
                }

                pub fn has_buff_modifier_name(&self) -> bool {
                    self.buff_modifier_name.is_some()
                }

                // Param is passed by value, moved
                pub fn set_buff_modifier_name(&mut self, v: ::std::string::String) {
                    self.buff_modifier_name = ::std::option::Option::Some(v);
                }

                // Mutable pointer to the field.
                // If field is not initialized, it is initialized with default value first.
                pub fn mut_buff_modifier_name(&mut self) -> &mut ::std::string::String {
                    if self.buff_modifier_name.is_none() {
                        self.buff_modifier_name = ::std::option::Option::Some(::std::string::String::new());
                    }
                    self.buff_modifier_name.as_mut().unwrap()
                }

                // Take field
                pub fn take_buff_modifier_name(&mut self) -> ::std::string::String {
                    self.buff_modifier_name.take().unwrap_or_else(|| ::std::string::String::new())
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for BuffRecord {
                const NAME: &'static str = "BuffRecord";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.buff_ability_id = ::std::option::Option::Some(is.read_int32()?);
                            },
                            26 => {
                                self.buff_modifier_name = ::std::option::Option::Some(is.read_string()?);
                            },
                            18 => {
                                self.by_hero_targets.push(is.read_message()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.buff_ability_id {
                        my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                    }
                    if let Some(v) = self.buff_modifier_name.as_ref() {
                        my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
                    }
                    for value in &self.by_hero_targets {
                        let len = value.compute_size();
                        my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.buff_ability_id {
                        os.write_int32(1, v)?;
                    }
                    if let Some(v) = self.buff_modifier_name.as_ref() {
                        os.write_string(3, v)?;
                    }
                    for v in &self.by_hero_targets {
                        ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    };
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> BuffRecord {
                    BuffRecord::new()
                }

                fn clear(&mut self) {
                    self.buff_ability_id = ::std::option::Option::None;
                    self.buff_modifier_name = ::std::option::Option::None;
                    self.by_hero_targets.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static BuffRecord {
                    static instance: BuffRecord = BuffRecord {
                        buff_ability_id: ::std::option::Option::None,
                        buff_modifier_name: ::std::option::Option::None,
                        by_hero_targets: ::std::vec::Vec::new(),
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            /// Nested message and enums of message `BuffRecord`
            pub mod buff_record {
                // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct ByHeroTarget {
                    // message fields
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.hero_id)
                    pub hero_id: ::std::option::Option<i32>,
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.elapsed_duration)
                    pub elapsed_duration: ::std::option::Option<f32>,
                    // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.is_hidden)
                    pub is_hidden: ::std::option::Option<bool>,
                    // special fields
                    // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.BuffRecord.ByHeroTarget.special_fields)
                    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a ByHeroTarget {
                    fn default() -> &'a ByHeroTarget {
                        <ByHeroTarget as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                    }
                }

                impl ByHeroTarget {
                    pub fn new() -> ByHeroTarget {
                        ::std::default::Default::default()
                    }

                    // optional int32 hero_id = 1;

                    pub fn hero_id(&self) -> i32 {
                        self.hero_id.unwrap_or(0)
                    }

                    pub fn clear_hero_id(&mut self) {
                        self.hero_id = ::std::option::Option::None;
                    }

                    pub fn has_hero_id(&self) -> bool {
                        self.hero_id.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_hero_id(&mut self, v: i32) {
                        self.hero_id = ::std::option::Option::Some(v);
                    }

                    // optional float elapsed_duration = 2;

                    pub fn elapsed_duration(&self) -> f32 {
                        self.elapsed_duration.unwrap_or(0.)
                    }

                    pub fn clear_elapsed_duration(&mut self) {
                        self.elapsed_duration = ::std::option::Option::None;
                    }

                    pub fn has_elapsed_duration(&self) -> bool {
                        self.elapsed_duration.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_elapsed_duration(&mut self, v: f32) {
                        self.elapsed_duration = ::std::option::Option::Some(v);
                    }

                    // optional bool is_hidden = 3;

                    pub fn is_hidden(&self) -> bool {
                        self.is_hidden.unwrap_or(false)
                    }

                    pub fn clear_is_hidden(&mut self) {
                        self.is_hidden = ::std::option::Option::None;
                    }

                    pub fn has_is_hidden(&self) -> bool {
                        self.is_hidden.is_some()
                    }

                    // Param is passed by value, moved
                    pub fn set_is_hidden(&mut self, v: bool) {
                        self.is_hidden = ::std::option::Option::Some(v);
                    }
                }

                impl ::steam_vent_proto_common::protobuf::Message for ByHeroTarget {
                    const NAME: &'static str = "ByHeroTarget";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                8 => {
                                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                                },
                                21 => {
                                    self.elapsed_duration = ::std::option::Option::Some(is.read_float()?);
                                },
                                24 => {
                                    self.is_hidden = ::std::option::Option::Some(is.read_bool()?);
                                },
                                tag => {
                                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let Some(v) = self.hero_id {
                            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                        }
                        if let Some(v) = self.elapsed_duration {
                            my_size += 1 + 4;
                        }
                        if let Some(v) = self.is_hidden {
                            my_size += 1 + 1;
                        }
                        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                        if let Some(v) = self.hero_id {
                            os.write_int32(1, v)?;
                        }
                        if let Some(v) = self.elapsed_duration {
                            os.write_float(2, v)?;
                        }
                        if let Some(v) = self.is_hidden {
                            os.write_bool(3, v)?;
                        }
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> ByHeroTarget {
                        ByHeroTarget::new()
                    }

                    fn clear(&mut self) {
                        self.hero_id = ::std::option::Option::None;
                        self.elapsed_duration = ::std::option::Option::None;
                        self.is_hidden = ::std::option::Option::None;
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static ByHeroTarget {
                        static instance: ByHeroTarget = ByHeroTarget {
                            hero_id: ::std::option::Option::None,
                            elapsed_duration: ::std::option::Option::None,
                            is_hidden: ::std::option::Option::None,
                            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }
            }

            // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct GoldReceived {
                // message fields
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.creep)
                pub creep: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.heroes)
                pub heroes: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.bounty_runes)
                pub bounty_runes: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.passive)
                pub passive: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.buildings)
                pub buildings: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.abilities)
                pub abilities: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.wards)
                pub wards: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.other)
                pub other: ::std::option::Option<u32>,
                // special fields
                // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.GoldReceived.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a GoldReceived {
                fn default() -> &'a GoldReceived {
                    <GoldReceived as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl GoldReceived {
                pub fn new() -> GoldReceived {
                    ::std::default::Default::default()
                }

                // optional uint32 creep = 1;

                pub fn creep(&self) -> u32 {
                    self.creep.unwrap_or(0)
                }

                pub fn clear_creep(&mut self) {
                    self.creep = ::std::option::Option::None;
                }

                pub fn has_creep(&self) -> bool {
                    self.creep.is_some()
                }

                // Param is passed by value, moved
                pub fn set_creep(&mut self, v: u32) {
                    self.creep = ::std::option::Option::Some(v);
                }

                // optional uint32 heroes = 2;

                pub fn heroes(&self) -> u32 {
                    self.heroes.unwrap_or(0)
                }

                pub fn clear_heroes(&mut self) {
                    self.heroes = ::std::option::Option::None;
                }

                pub fn has_heroes(&self) -> bool {
                    self.heroes.is_some()
                }

                // Param is passed by value, moved
                pub fn set_heroes(&mut self, v: u32) {
                    self.heroes = ::std::option::Option::Some(v);
                }

                // optional uint32 bounty_runes = 3;

                pub fn bounty_runes(&self) -> u32 {
                    self.bounty_runes.unwrap_or(0)
                }

                pub fn clear_bounty_runes(&mut self) {
                    self.bounty_runes = ::std::option::Option::None;
                }

                pub fn has_bounty_runes(&self) -> bool {
                    self.bounty_runes.is_some()
                }

                // Param is passed by value, moved
                pub fn set_bounty_runes(&mut self, v: u32) {
                    self.bounty_runes = ::std::option::Option::Some(v);
                }

                // optional uint32 passive = 4;

                pub fn passive(&self) -> u32 {
                    self.passive.unwrap_or(0)
                }

                pub fn clear_passive(&mut self) {
                    self.passive = ::std::option::Option::None;
                }

                pub fn has_passive(&self) -> bool {
                    self.passive.is_some()
                }

                // Param is passed by value, moved
                pub fn set_passive(&mut self, v: u32) {
                    self.passive = ::std::option::Option::Some(v);
                }

                // optional uint32 buildings = 5;

                pub fn buildings(&self) -> u32 {
                    self.buildings.unwrap_or(0)
                }

                pub fn clear_buildings(&mut self) {
                    self.buildings = ::std::option::Option::None;
                }

                pub fn has_buildings(&self) -> bool {
                    self.buildings.is_some()
                }

                // Param is passed by value, moved
                pub fn set_buildings(&mut self, v: u32) {
                    self.buildings = ::std::option::Option::Some(v);
                }

                // optional uint32 abilities = 6;

                pub fn abilities(&self) -> u32 {
                    self.abilities.unwrap_or(0)
                }

                pub fn clear_abilities(&mut self) {
                    self.abilities = ::std::option::Option::None;
                }

                pub fn has_abilities(&self) -> bool {
                    self.abilities.is_some()
                }

                // Param is passed by value, moved
                pub fn set_abilities(&mut self, v: u32) {
                    self.abilities = ::std::option::Option::Some(v);
                }

                // optional uint32 wards = 7;

                pub fn wards(&self) -> u32 {
                    self.wards.unwrap_or(0)
                }

                pub fn clear_wards(&mut self) {
                    self.wards = ::std::option::Option::None;
                }

                pub fn has_wards(&self) -> bool {
                    self.wards.is_some()
                }

                // Param is passed by value, moved
                pub fn set_wards(&mut self, v: u32) {
                    self.wards = ::std::option::Option::Some(v);
                }

                // optional uint32 other = 8;

                pub fn other(&self) -> u32 {
                    self.other.unwrap_or(0)
                }

                pub fn clear_other(&mut self) {
                    self.other = ::std::option::Option::None;
                }

                pub fn has_other(&self) -> bool {
                    self.other.is_some()
                }

                // Param is passed by value, moved
                pub fn set_other(&mut self, v: u32) {
                    self.other = ::std::option::Option::Some(v);
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for GoldReceived {
                const NAME: &'static str = "GoldReceived";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.creep = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.heroes = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            32 => {
                                self.passive = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            40 => {
                                self.buildings = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            48 => {
                                self.abilities = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            56 => {
                                self.wards = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            64 => {
                                self.other = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.creep {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.heroes {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.bounty_runes {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                    }
                    if let Some(v) = self.passive {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                    }
                    if let Some(v) = self.buildings {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                    }
                    if let Some(v) = self.abilities {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                    }
                    if let Some(v) = self.wards {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
                    }
                    if let Some(v) = self.other {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
                    }
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.creep {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.heroes {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.bounty_runes {
                        os.write_uint32(3, v)?;
                    }
                    if let Some(v) = self.passive {
                        os.write_uint32(4, v)?;
                    }
                    if let Some(v) = self.buildings {
                        os.write_uint32(5, v)?;
                    }
                    if let Some(v) = self.abilities {
                        os.write_uint32(6, v)?;
                    }
                    if let Some(v) = self.wards {
                        os.write_uint32(7, v)?;
                    }
                    if let Some(v) = self.other {
                        os.write_uint32(8, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> GoldReceived {
                    GoldReceived::new()
                }

                fn clear(&mut self) {
                    self.creep = ::std::option::Option::None;
                    self.heroes = ::std::option::Option::None;
                    self.bounty_runes = ::std::option::Option::None;
                    self.passive = ::std::option::Option::None;
                    self.buildings = ::std::option::Option::None;
                    self.abilities = ::std::option::Option::None;
                    self.wards = ::std::option::Option::None;
                    self.other = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static GoldReceived {
                    static instance: GoldReceived = GoldReceived {
                        creep: ::std::option::Option::None,
                        heroes: ::std::option::Option::None,
                        bounty_runes: ::std::option::Option::None,
                        passive: ::std::option::Option::None,
                        buildings: ::std::option::Option::None,
                        abilities: ::std::option::Option::None,
                        wards: ::std::option::Option::None,
                        other: ::std::option::Option::None,
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Player.XPReceived)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct XPReceived {
                // message fields
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.creep)
                pub creep: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.heroes)
                pub heroes: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.roshan)
                pub roshan: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.tome_of_knowledge)
                pub tome_of_knowledge: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.outpost)
                pub outpost: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.other)
                pub other: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.abilities)
                pub abilities: ::std::option::Option<u32>,
                // special fields
                // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Player.XPReceived.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a XPReceived {
                fn default() -> &'a XPReceived {
                    <XPReceived as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl XPReceived {
                pub fn new() -> XPReceived {
                    ::std::default::Default::default()
                }

                // optional uint32 creep = 1;

                pub fn creep(&self) -> u32 {
                    self.creep.unwrap_or(0)
                }

                pub fn clear_creep(&mut self) {
                    self.creep = ::std::option::Option::None;
                }

                pub fn has_creep(&self) -> bool {
                    self.creep.is_some()
                }

                // Param is passed by value, moved
                pub fn set_creep(&mut self, v: u32) {
                    self.creep = ::std::option::Option::Some(v);
                }

                // optional uint32 heroes = 2;

                pub fn heroes(&self) -> u32 {
                    self.heroes.unwrap_or(0)
                }

                pub fn clear_heroes(&mut self) {
                    self.heroes = ::std::option::Option::None;
                }

                pub fn has_heroes(&self) -> bool {
                    self.heroes.is_some()
                }

                // Param is passed by value, moved
                pub fn set_heroes(&mut self, v: u32) {
                    self.heroes = ::std::option::Option::Some(v);
                }

                // optional uint32 roshan = 3;

                pub fn roshan(&self) -> u32 {
                    self.roshan.unwrap_or(0)
                }

                pub fn clear_roshan(&mut self) {
                    self.roshan = ::std::option::Option::None;
                }

                pub fn has_roshan(&self) -> bool {
                    self.roshan.is_some()
                }

                // Param is passed by value, moved
                pub fn set_roshan(&mut self, v: u32) {
                    self.roshan = ::std::option::Option::Some(v);
                }

                // optional uint32 tome_of_knowledge = 4;

                pub fn tome_of_knowledge(&self) -> u32 {
                    self.tome_of_knowledge.unwrap_or(0)
                }

                pub fn clear_tome_of_knowledge(&mut self) {
                    self.tome_of_knowledge = ::std::option::Option::None;
                }

                pub fn has_tome_of_knowledge(&self) -> bool {
                    self.tome_of_knowledge.is_some()
                }

                // Param is passed by value, moved
                pub fn set_tome_of_knowledge(&mut self, v: u32) {
                    self.tome_of_knowledge = ::std::option::Option::Some(v);
                }

                // optional uint32 outpost = 5;

                pub fn outpost(&self) -> u32 {
                    self.outpost.unwrap_or(0)
                }

                pub fn clear_outpost(&mut self) {
                    self.outpost = ::std::option::Option::None;
                }

                pub fn has_outpost(&self) -> bool {
                    self.outpost.is_some()
                }

                // Param is passed by value, moved
                pub fn set_outpost(&mut self, v: u32) {
                    self.outpost = ::std::option::Option::Some(v);
                }

                // optional uint32 other = 6;

                pub fn other(&self) -> u32 {
                    self.other.unwrap_or(0)
                }

                pub fn clear_other(&mut self) {
                    self.other = ::std::option::Option::None;
                }

                pub fn has_other(&self) -> bool {
                    self.other.is_some()
                }

                // Param is passed by value, moved
                pub fn set_other(&mut self, v: u32) {
                    self.other = ::std::option::Option::Some(v);
                }

                // optional uint32 abilities = 7;

                pub fn abilities(&self) -> u32 {
                    self.abilities.unwrap_or(0)
                }

                pub fn clear_abilities(&mut self) {
                    self.abilities = ::std::option::Option::None;
                }

                pub fn has_abilities(&self) -> bool {
                    self.abilities.is_some()
                }

                // Param is passed by value, moved
                pub fn set_abilities(&mut self, v: u32) {
                    self.abilities = ::std::option::Option::Some(v);
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for XPReceived {
                const NAME: &'static str = "XPReceived";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.creep = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.heroes = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.roshan = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            32 => {
                                self.tome_of_knowledge = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            40 => {
                                self.outpost = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            48 => {
                                self.other = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            56 => {
                                self.abilities = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.creep {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.heroes {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.roshan {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                    }
                    if let Some(v) = self.tome_of_knowledge {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                    }
                    if let Some(v) = self.outpost {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                    }
                    if let Some(v) = self.other {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                    }
                    if let Some(v) = self.abilities {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
                    }
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.creep {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.heroes {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.roshan {
                        os.write_uint32(3, v)?;
                    }
                    if let Some(v) = self.tome_of_knowledge {
                        os.write_uint32(4, v)?;
                    }
                    if let Some(v) = self.outpost {
                        os.write_uint32(5, v)?;
                    }
                    if let Some(v) = self.other {
                        os.write_uint32(6, v)?;
                    }
                    if let Some(v) = self.abilities {
                        os.write_uint32(7, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> XPReceived {
                    XPReceived::new()
                }

                fn clear(&mut self) {
                    self.creep = ::std::option::Option::None;
                    self.heroes = ::std::option::Option::None;
                    self.roshan = ::std::option::Option::None;
                    self.tome_of_knowledge = ::std::option::Option::None;
                    self.outpost = ::std::option::Option::None;
                    self.other = ::std::option::Option::None;
                    self.abilities = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static XPReceived {
                    static instance: XPReceived = XPReceived {
                        creep: ::std::option::Option::None,
                        heroes: ::std::option::Option::None,
                        roshan: ::std::option::Option::None,
                        tome_of_knowledge: ::std::option::Option::None,
                        outpost: ::std::option::Option::None,
                        other: ::std::option::Option::None,
                        abilities: ::std::option::Option::None,
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }
        }

        // @@protoc_insertion_point(message:CDOTAMatchPrivateMetadata.Team.Building)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Building {
            // message fields
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Building.unit_name)
            pub unit_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Building.position_quant_x)
            pub position_quant_x: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Building.position_quant_y)
            pub position_quant_y: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CDOTAMatchPrivateMetadata.Team.Building.death_time)
            pub death_time: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAMatchPrivateMetadata.Team.Building.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Building {
            fn default() -> &'a Building {
                <Building as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Building {
            pub fn new() -> Building {
                ::std::default::Default::default()
            }

            // optional string unit_name = 1;

            pub fn unit_name(&self) -> &str {
                match self.unit_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_unit_name(&mut self) {
                self.unit_name = ::std::option::Option::None;
            }

            pub fn has_unit_name(&self) -> bool {
                self.unit_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_unit_name(&mut self, v: ::std::string::String) {
                self.unit_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_unit_name(&mut self) -> &mut ::std::string::String {
                if self.unit_name.is_none() {
                    self.unit_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.unit_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_unit_name(&mut self) -> ::std::string::String {
                self.unit_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 position_quant_x = 2;

            pub fn position_quant_x(&self) -> u32 {
                self.position_quant_x.unwrap_or(0)
            }

            pub fn clear_position_quant_x(&mut self) {
                self.position_quant_x = ::std::option::Option::None;
            }

            pub fn has_position_quant_x(&self) -> bool {
                self.position_quant_x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_quant_x(&mut self, v: u32) {
                self.position_quant_x = ::std::option::Option::Some(v);
            }

            // optional uint32 position_quant_y = 3;

            pub fn position_quant_y(&self) -> u32 {
                self.position_quant_y.unwrap_or(0)
            }

            pub fn clear_position_quant_y(&mut self) {
                self.position_quant_y = ::std::option::Option::None;
            }

            pub fn has_position_quant_y(&self) -> bool {
                self.position_quant_y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_quant_y(&mut self, v: u32) {
                self.position_quant_y = ::std::option::Option::Some(v);
            }

            // optional float death_time = 4;

            pub fn death_time(&self) -> f32 {
                self.death_time.unwrap_or(0.)
            }

            pub fn clear_death_time(&mut self) {
                self.death_time = ::std::option::Option::None;
            }

            pub fn has_death_time(&self) -> bool {
                self.death_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_death_time(&mut self, v: f32) {
                self.death_time = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Building {
            const NAME: &'static str = "Building";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.unit_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.position_quant_x = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.position_quant_y = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        37 => {
                            self.death_time = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.unit_name.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.position_quant_x {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.position_quant_y {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.death_time {
                    my_size += 1 + 4;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.unit_name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.position_quant_x {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.position_quant_y {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.death_time {
                    os.write_float(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Building {
                Building::new()
            }

            fn clear(&mut self) {
                self.unit_name = ::std::option::Option::None;
                self.position_quant_x = ::std::option::Option::None;
                self.position_quant_y = ::std::option::Option::None;
                self.death_time = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Building {
                static instance: Building = Building {
                    unit_name: ::std::option::Option::None,
                    position_quant_x: ::std::option::Option::None,
                    position_quant_y: ::std::option::Option::None,
                    death_time: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}


const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::base_gcmessages::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_match_management::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_lobby::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_overworld::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CDOTAMatchMetadataFile {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAMatchMetadata {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAMatchPrivateMetadata {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
