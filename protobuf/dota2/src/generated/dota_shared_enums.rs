// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_shared_enums.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CDOTAClientHardwareSpecs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientHardwareSpecs {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientHardwareSpecs.logical_processors)
    pub logical_processors: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientHardwareSpecs.cpu_cycles_per_second)
    pub cpu_cycles_per_second: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAClientHardwareSpecs.total_physical_memory)
    pub total_physical_memory: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAClientHardwareSpecs.is_64_bit_os)
    pub is_64_bit_os: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAClientHardwareSpecs.upload_measurement)
    pub upload_measurement: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAClientHardwareSpecs.prefer_not_host)
    pub prefer_not_host: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAClientHardwareSpecs.crc)
    pub crc: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientHardwareSpecs.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientHardwareSpecs {
    fn default() -> &'a CDOTAClientHardwareSpecs {
        <CDOTAClientHardwareSpecs as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientHardwareSpecs {
    pub fn new() -> CDOTAClientHardwareSpecs {
        ::std::default::Default::default()
    }

    // optional uint32 logical_processors = 1;

    pub fn logical_processors(&self) -> u32 {
        self.logical_processors.unwrap_or(0)
    }

    pub fn clear_logical_processors(&mut self) {
        self.logical_processors = ::std::option::Option::None;
    }

    pub fn has_logical_processors(&self) -> bool {
        self.logical_processors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logical_processors(&mut self, v: u32) {
        self.logical_processors = ::std::option::Option::Some(v);
    }

    // optional fixed64 cpu_cycles_per_second = 2;

    pub fn cpu_cycles_per_second(&self) -> u64 {
        self.cpu_cycles_per_second.unwrap_or(0)
    }

    pub fn clear_cpu_cycles_per_second(&mut self) {
        self.cpu_cycles_per_second = ::std::option::Option::None;
    }

    pub fn has_cpu_cycles_per_second(&self) -> bool {
        self.cpu_cycles_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cycles_per_second(&mut self, v: u64) {
        self.cpu_cycles_per_second = ::std::option::Option::Some(v);
    }

    // optional fixed64 total_physical_memory = 3;

    pub fn total_physical_memory(&self) -> u64 {
        self.total_physical_memory.unwrap_or(0)
    }

    pub fn clear_total_physical_memory(&mut self) {
        self.total_physical_memory = ::std::option::Option::None;
    }

    pub fn has_total_physical_memory(&self) -> bool {
        self.total_physical_memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_physical_memory(&mut self, v: u64) {
        self.total_physical_memory = ::std::option::Option::Some(v);
    }

    // optional bool is_64_bit_os = 4;

    pub fn is_64_bit_os(&self) -> bool {
        self.is_64_bit_os.unwrap_or(false)
    }

    pub fn clear_is_64_bit_os(&mut self) {
        self.is_64_bit_os = ::std::option::Option::None;
    }

    pub fn has_is_64_bit_os(&self) -> bool {
        self.is_64_bit_os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_64_bit_os(&mut self, v: bool) {
        self.is_64_bit_os = ::std::option::Option::Some(v);
    }

    // optional uint64 upload_measurement = 5;

    pub fn upload_measurement(&self) -> u64 {
        self.upload_measurement.unwrap_or(0)
    }

    pub fn clear_upload_measurement(&mut self) {
        self.upload_measurement = ::std::option::Option::None;
    }

    pub fn has_upload_measurement(&self) -> bool {
        self.upload_measurement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_measurement(&mut self, v: u64) {
        self.upload_measurement = ::std::option::Option::Some(v);
    }

    // optional bool prefer_not_host = 6;

    pub fn prefer_not_host(&self) -> bool {
        self.prefer_not_host.unwrap_or(false)
    }

    pub fn clear_prefer_not_host(&mut self) {
        self.prefer_not_host = ::std::option::Option::None;
    }

    pub fn has_prefer_not_host(&self) -> bool {
        self.prefer_not_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefer_not_host(&mut self, v: bool) {
        self.prefer_not_host = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientHardwareSpecs {
    const NAME: &'static str = "CDOTAClientHardwareSpecs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.logical_processors = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.cpu_cycles_per_second = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.total_physical_memory = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.is_64_bit_os = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.upload_measurement = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.prefer_not_host = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.crc)?;
                },
                56 => {
                    self.crc.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.logical_processors {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cpu_cycles_per_second {
            my_size += 1 + 8;
        }
        if let Some(v) = self.total_physical_memory {
            my_size += 1 + 8;
        }
        if let Some(v) = self.is_64_bit_os {
            my_size += 1 + 1;
        }
        if let Some(v) = self.upload_measurement {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.prefer_not_host {
            my_size += 1 + 1;
        }
        for value in &self.crc {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.logical_processors {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cpu_cycles_per_second {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.total_physical_memory {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.is_64_bit_os {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.upload_measurement {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.prefer_not_host {
            os.write_bool(6, v)?;
        }
        for v in &self.crc {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientHardwareSpecs {
        CDOTAClientHardwareSpecs::new()
    }

    fn clear(&mut self) {
        self.logical_processors = ::std::option::Option::None;
        self.cpu_cycles_per_second = ::std::option::Option::None;
        self.total_physical_memory = ::std::option::Option::None;
        self.is_64_bit_os = ::std::option::Option::None;
        self.upload_measurement = ::std::option::Option::None;
        self.prefer_not_host = ::std::option::Option::None;
        self.crc.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientHardwareSpecs {
        static instance: CDOTAClientHardwareSpecs = CDOTAClientHardwareSpecs {
            logical_processors: ::std::option::Option::None,
            cpu_cycles_per_second: ::std::option::Option::None,
            total_physical_memory: ::std::option::Option::None,
            is_64_bit_os: ::std::option::Option::None,
            upload_measurement: ::std::option::Option::None,
            prefer_not_host: ::std::option::Option::None,
            crc: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTASaveGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTASaveGame {
    // message fields
    // @@protoc_insertion_point(field:CDOTASaveGame.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTASaveGame.save_time)
    pub save_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTASaveGame.players)
    pub players: ::std::vec::Vec<cdotasave_game::Player>,
    // @@protoc_insertion_point(field:CDOTASaveGame.save_instances)
    pub save_instances: ::std::vec::Vec<cdotasave_game::SaveInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTASaveGame.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTASaveGame {
    fn default() -> &'a CDOTASaveGame {
        <CDOTASaveGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTASaveGame {
    pub fn new() -> CDOTASaveGame {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 save_time = 2;

    pub fn save_time(&self) -> u32 {
        self.save_time.unwrap_or(0)
    }

    pub fn clear_save_time(&mut self) {
        self.save_time = ::std::option::Option::None;
    }

    pub fn has_save_time(&self) -> bool {
        self.save_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_time(&mut self, v: u32) {
        self.save_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTASaveGame {
    const NAME: &'static str = "CDOTASaveGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.save_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.players.push(is.read_message()?);
                },
                34 => {
                    self.save_instances.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.save_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.save_instances {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.save_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.save_instances {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTASaveGame {
        CDOTASaveGame::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.save_time = ::std::option::Option::None;
        self.players.clear();
        self.save_instances.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTASaveGame {
        static instance: CDOTASaveGame = CDOTASaveGame {
            match_id: ::std::option::Option::None,
            save_time: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            save_instances: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTASaveGame`
pub mod cdotasave_game {
    // @@protoc_insertion_point(message:CDOTASaveGame.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CDOTASaveGame.Player.team)
        pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::DOTA_GC_TEAM>>,
        // @@protoc_insertion_point(field:CDOTASaveGame.Player.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CDOTASaveGame.Player.hero)
        pub hero: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTASaveGame.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional .DOTA_GC_TEAM team = 1;

        pub fn team(&self) -> super::DOTA_GC_TEAM {
            match self.team {
                Some(e) => e.enum_value_or(super::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: super::DOTA_GC_TEAM) {
            self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hero = 3;

        pub fn hero(&self) -> &str {
            match self.hero.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: ::std::string::String) {
            self.hero = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero(&mut self) -> &mut ::std::string::String {
            if self.hero.is_none() {
                self.hero = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero(&mut self) -> ::std::string::String {
            self.hero.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.hero = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.hero.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.hero.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.hero = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                team: ::std::option::Option::None,
                name: ::std::option::Option::None,
                hero: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTASaveGame.SaveInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SaveInstance {
        // message fields
        // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.team1_score)
        pub team1_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.team2_score)
        pub team2_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.player_positions)
        pub player_positions: ::std::vec::Vec<save_instance::PlayerPositions>,
        // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.save_id)
        pub save_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.save_time)
        pub save_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTASaveGame.SaveInstance.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SaveInstance {
        fn default() -> &'a SaveInstance {
            <SaveInstance as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SaveInstance {
        pub fn new() -> SaveInstance {
            ::std::default::Default::default()
        }

        // optional uint32 game_time = 2;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 team1_score = 3;

        pub fn team1_score(&self) -> u32 {
            self.team1_score.unwrap_or(0)
        }

        pub fn clear_team1_score(&mut self) {
            self.team1_score = ::std::option::Option::None;
        }

        pub fn has_team1_score(&self) -> bool {
            self.team1_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team1_score(&mut self, v: u32) {
            self.team1_score = ::std::option::Option::Some(v);
        }

        // optional uint32 team2_score = 4;

        pub fn team2_score(&self) -> u32 {
            self.team2_score.unwrap_or(0)
        }

        pub fn clear_team2_score(&mut self) {
            self.team2_score = ::std::option::Option::None;
        }

        pub fn has_team2_score(&self) -> bool {
            self.team2_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team2_score(&mut self, v: u32) {
            self.team2_score = ::std::option::Option::Some(v);
        }

        // optional uint32 save_id = 6;

        pub fn save_id(&self) -> u32 {
            self.save_id.unwrap_or(0)
        }

        pub fn clear_save_id(&mut self) {
            self.save_id = ::std::option::Option::None;
        }

        pub fn has_save_id(&self) -> bool {
            self.save_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_save_id(&mut self, v: u32) {
            self.save_id = ::std::option::Option::Some(v);
        }

        // optional uint32 save_time = 7;

        pub fn save_time(&self) -> u32 {
            self.save_time.unwrap_or(0)
        }

        pub fn clear_save_time(&mut self) {
            self.save_time = ::std::option::Option::None;
        }

        pub fn has_save_time(&self) -> bool {
            self.save_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_save_time(&mut self, v: u32) {
            self.save_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SaveInstance {
        const NAME: &'static str = "SaveInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.team1_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.team2_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.player_positions.push(is.read_message()?);
                    },
                    48 => {
                        self.save_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.save_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team1_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team2_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.player_positions {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.save_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.save_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.game_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team1_score {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team2_score {
                os.write_uint32(4, v)?;
            }
            for v in &self.player_positions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            if let Some(v) = self.save_id {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.save_time {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SaveInstance {
            SaveInstance::new()
        }

        fn clear(&mut self) {
            self.game_time = ::std::option::Option::None;
            self.team1_score = ::std::option::Option::None;
            self.team2_score = ::std::option::Option::None;
            self.player_positions.clear();
            self.save_id = ::std::option::Option::None;
            self.save_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SaveInstance {
            static instance: SaveInstance = SaveInstance {
                game_time: ::std::option::Option::None,
                team1_score: ::std::option::Option::None,
                team2_score: ::std::option::Option::None,
                player_positions: ::std::vec::Vec::new(),
                save_id: ::std::option::Option::None,
                save_time: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `SaveInstance`
    pub mod save_instance {
        // @@protoc_insertion_point(message:CDOTASaveGame.SaveInstance.PlayerPositions)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PlayerPositions {
            // message fields
            // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.PlayerPositions.x)
            pub x: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CDOTASaveGame.SaveInstance.PlayerPositions.y)
            pub y: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTASaveGame.SaveInstance.PlayerPositions.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PlayerPositions {
            fn default() -> &'a PlayerPositions {
                <PlayerPositions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl PlayerPositions {
            pub fn new() -> PlayerPositions {
                ::std::default::Default::default()
            }

            // optional float x = 1;

            pub fn x(&self) -> f32 {
                self.x.unwrap_or(0.)
            }

            pub fn clear_x(&mut self) {
                self.x = ::std::option::Option::None;
            }

            pub fn has_x(&self) -> bool {
                self.x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_x(&mut self, v: f32) {
                self.x = ::std::option::Option::Some(v);
            }

            // optional float y = 2;

            pub fn y(&self) -> f32 {
                self.y.unwrap_or(0.)
            }

            pub fn clear_y(&mut self) {
                self.y = ::std::option::Option::None;
            }

            pub fn has_y(&self) -> bool {
                self.y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_y(&mut self, v: f32) {
                self.y = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for PlayerPositions {
            const NAME: &'static str = "PlayerPositions";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.x = ::std::option::Option::Some(is.read_float()?);
                        },
                        21 => {
                            self.y = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.x {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.y {
                    my_size += 1 + 4;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.x {
                    os.write_float(1, v)?;
                }
                if let Some(v) = self.y {
                    os.write_float(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PlayerPositions {
                PlayerPositions::new()
            }

            fn clear(&mut self) {
                self.x = ::std::option::Option::None;
                self.y = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PlayerPositions {
                static instance: PlayerPositions = PlayerPositions {
                    x: ::std::option::Option::None,
                    y: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTACombatLogEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACombatLogEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<DOTA_COMBATLOG_TYPES>>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.target_name)
    pub target_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.target_source_name)
    pub target_source_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.attacker_name)
    pub attacker_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.damage_source_name)
    pub damage_source_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.inflictor_name)
    pub inflictor_name: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_attacker_illusion)
    pub is_attacker_illusion: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_attacker_hero)
    pub is_attacker_hero: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_target_illusion)
    pub is_target_illusion: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_target_hero)
    pub is_target_hero: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_visible_radiant)
    pub is_visible_radiant: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_visible_dire)
    pub is_visible_dire: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.health)
    pub health: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.stun_duration)
    pub stun_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.slow_duration)
    pub slow_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_ability_toggle_on)
    pub is_ability_toggle_on: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_ability_toggle_off)
    pub is_ability_toggle_off: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.ability_level)
    pub ability_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.location_x)
    pub location_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.location_y)
    pub location_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.gold_reason)
    pub gold_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.timestamp_raw)
    pub timestamp_raw: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.modifier_duration)
    pub modifier_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.xp_reason)
    pub xp_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.attacker_team)
    pub attacker_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.target_team)
    pub target_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.obs_wards_placed)
    pub obs_wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.assist_player0)
    pub assist_player0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.assist_player1)
    pub assist_player1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.assist_player2)
    pub assist_player2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.assist_player3)
    pub assist_player3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.stack_count)
    pub stack_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.hidden_modifier)
    pub hidden_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_target_building)
    pub is_target_building: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.neutral_camp_type)
    pub neutral_camp_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.rune_type)
    pub rune_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.assist_players)
    pub assist_players: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_heal_save)
    pub is_heal_save: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.is_ultimate_ability)
    pub is_ultimate_ability: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.attacker_hero_level)
    pub attacker_hero_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.target_hero_level)
    pub target_hero_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.xpm)
    pub xpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.gpm)
    pub gpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.event_location)
    pub event_location: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.target_is_self)
    pub target_is_self: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.damage_type)
    pub damage_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.invisibility_modifier)
    pub invisibility_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.damage_category)
    pub damage_category: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.networth)
    pub networth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.building_type)
    pub building_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.modifier_elapsed_duration)
    pub modifier_elapsed_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.silence_modifier)
    pub silence_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.heal_from_lifesteal)
    pub heal_from_lifesteal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.modifier_purged)
    pub modifier_purged: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.spell_evaded)
    pub spell_evaded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.motion_controller_modifier)
    pub motion_controller_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.long_range_kill)
    pub long_range_kill: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.modifier_purge_ability)
    pub modifier_purge_ability: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.modifier_purge_npc)
    pub modifier_purge_npc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.root_modifier)
    pub root_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.total_unit_death_count)
    pub total_unit_death_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.aura_modifier)
    pub aura_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.armor_debuff_modifier)
    pub armor_debuff_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.no_physical_damage_modifier)
    pub no_physical_damage_modifier: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.modifier_ability)
    pub modifier_ability: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.modifier_hidden)
    pub modifier_hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.inflictor_is_stolen_ability)
    pub inflictor_is_stolen_ability: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.kill_eater_event)
    pub kill_eater_event: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.unit_status_label)
    pub unit_status_label: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.spell_generated_attack)
    pub spell_generated_attack: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.at_night_time)
    pub at_night_time: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.attacker_has_scepter)
    pub attacker_has_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.neutral_camp_team)
    pub neutral_camp_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.regenerated_health)
    pub regenerated_health: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.will_reincarnate)
    pub will_reincarnate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTACombatLogEntry.uses_charges)
    pub uses_charges: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACombatLogEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACombatLogEntry {
    fn default() -> &'a CMsgDOTACombatLogEntry {
        <CMsgDOTACombatLogEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACombatLogEntry {
    pub fn new() -> CMsgDOTACombatLogEntry {
        ::std::default::Default::default()
    }

    // optional .DOTA_COMBATLOG_TYPES type = 1;

    pub fn type_(&self) -> DOTA_COMBATLOG_TYPES {
        match self.type_ {
            Some(e) => e.enum_value_or(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID),
            None => DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: DOTA_COMBATLOG_TYPES) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 target_name = 2;

    pub fn target_name(&self) -> u32 {
        self.target_name.unwrap_or(0)
    }

    pub fn clear_target_name(&mut self) {
        self.target_name = ::std::option::Option::None;
    }

    pub fn has_target_name(&self) -> bool {
        self.target_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_name(&mut self, v: u32) {
        self.target_name = ::std::option::Option::Some(v);
    }

    // optional uint32 target_source_name = 3;

    pub fn target_source_name(&self) -> u32 {
        self.target_source_name.unwrap_or(0)
    }

    pub fn clear_target_source_name(&mut self) {
        self.target_source_name = ::std::option::Option::None;
    }

    pub fn has_target_source_name(&self) -> bool {
        self.target_source_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_source_name(&mut self, v: u32) {
        self.target_source_name = ::std::option::Option::Some(v);
    }

    // optional uint32 attacker_name = 4;

    pub fn attacker_name(&self) -> u32 {
        self.attacker_name.unwrap_or(0)
    }

    pub fn clear_attacker_name(&mut self) {
        self.attacker_name = ::std::option::Option::None;
    }

    pub fn has_attacker_name(&self) -> bool {
        self.attacker_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_name(&mut self, v: u32) {
        self.attacker_name = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_source_name = 5;

    pub fn damage_source_name(&self) -> u32 {
        self.damage_source_name.unwrap_or(0)
    }

    pub fn clear_damage_source_name(&mut self) {
        self.damage_source_name = ::std::option::Option::None;
    }

    pub fn has_damage_source_name(&self) -> bool {
        self.damage_source_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_source_name(&mut self, v: u32) {
        self.damage_source_name = ::std::option::Option::Some(v);
    }

    // optional uint32 inflictor_name = 6;

    pub fn inflictor_name(&self) -> u32 {
        self.inflictor_name.unwrap_or(0)
    }

    pub fn clear_inflictor_name(&mut self) {
        self.inflictor_name = ::std::option::Option::None;
    }

    pub fn has_inflictor_name(&self) -> bool {
        self.inflictor_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_name(&mut self, v: u32) {
        self.inflictor_name = ::std::option::Option::Some(v);
    }

    // optional bool is_attacker_illusion = 7;

    pub fn is_attacker_illusion(&self) -> bool {
        self.is_attacker_illusion.unwrap_or(false)
    }

    pub fn clear_is_attacker_illusion(&mut self) {
        self.is_attacker_illusion = ::std::option::Option::None;
    }

    pub fn has_is_attacker_illusion(&self) -> bool {
        self.is_attacker_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attacker_illusion(&mut self, v: bool) {
        self.is_attacker_illusion = ::std::option::Option::Some(v);
    }

    // optional bool is_attacker_hero = 8;

    pub fn is_attacker_hero(&self) -> bool {
        self.is_attacker_hero.unwrap_or(false)
    }

    pub fn clear_is_attacker_hero(&mut self) {
        self.is_attacker_hero = ::std::option::Option::None;
    }

    pub fn has_is_attacker_hero(&self) -> bool {
        self.is_attacker_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attacker_hero(&mut self, v: bool) {
        self.is_attacker_hero = ::std::option::Option::Some(v);
    }

    // optional bool is_target_illusion = 9;

    pub fn is_target_illusion(&self) -> bool {
        self.is_target_illusion.unwrap_or(false)
    }

    pub fn clear_is_target_illusion(&mut self) {
        self.is_target_illusion = ::std::option::Option::None;
    }

    pub fn has_is_target_illusion(&self) -> bool {
        self.is_target_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_illusion(&mut self, v: bool) {
        self.is_target_illusion = ::std::option::Option::Some(v);
    }

    // optional bool is_target_hero = 10;

    pub fn is_target_hero(&self) -> bool {
        self.is_target_hero.unwrap_or(false)
    }

    pub fn clear_is_target_hero(&mut self) {
        self.is_target_hero = ::std::option::Option::None;
    }

    pub fn has_is_target_hero(&self) -> bool {
        self.is_target_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_hero(&mut self, v: bool) {
        self.is_target_hero = ::std::option::Option::Some(v);
    }

    // optional bool is_visible_radiant = 11;

    pub fn is_visible_radiant(&self) -> bool {
        self.is_visible_radiant.unwrap_or(false)
    }

    pub fn clear_is_visible_radiant(&mut self) {
        self.is_visible_radiant = ::std::option::Option::None;
    }

    pub fn has_is_visible_radiant(&self) -> bool {
        self.is_visible_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_radiant(&mut self, v: bool) {
        self.is_visible_radiant = ::std::option::Option::Some(v);
    }

    // optional bool is_visible_dire = 12;

    pub fn is_visible_dire(&self) -> bool {
        self.is_visible_dire.unwrap_or(false)
    }

    pub fn clear_is_visible_dire(&mut self) {
        self.is_visible_dire = ::std::option::Option::None;
    }

    pub fn has_is_visible_dire(&self) -> bool {
        self.is_visible_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_dire(&mut self, v: bool) {
        self.is_visible_dire = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 13;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional int32 health = 14;

    pub fn health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional float timestamp = 15;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float stun_duration = 16;

    pub fn stun_duration(&self) -> f32 {
        self.stun_duration.unwrap_or(0.)
    }

    pub fn clear_stun_duration(&mut self) {
        self.stun_duration = ::std::option::Option::None;
    }

    pub fn has_stun_duration(&self) -> bool {
        self.stun_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_duration(&mut self, v: f32) {
        self.stun_duration = ::std::option::Option::Some(v);
    }

    // optional float slow_duration = 17;

    pub fn slow_duration(&self) -> f32 {
        self.slow_duration.unwrap_or(0.)
    }

    pub fn clear_slow_duration(&mut self) {
        self.slow_duration = ::std::option::Option::None;
    }

    pub fn has_slow_duration(&self) -> bool {
        self.slow_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slow_duration(&mut self, v: f32) {
        self.slow_duration = ::std::option::Option::Some(v);
    }

    // optional bool is_ability_toggle_on = 18;

    pub fn is_ability_toggle_on(&self) -> bool {
        self.is_ability_toggle_on.unwrap_or(false)
    }

    pub fn clear_is_ability_toggle_on(&mut self) {
        self.is_ability_toggle_on = ::std::option::Option::None;
    }

    pub fn has_is_ability_toggle_on(&self) -> bool {
        self.is_ability_toggle_on.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ability_toggle_on(&mut self, v: bool) {
        self.is_ability_toggle_on = ::std::option::Option::Some(v);
    }

    // optional bool is_ability_toggle_off = 19;

    pub fn is_ability_toggle_off(&self) -> bool {
        self.is_ability_toggle_off.unwrap_or(false)
    }

    pub fn clear_is_ability_toggle_off(&mut self) {
        self.is_ability_toggle_off = ::std::option::Option::None;
    }

    pub fn has_is_ability_toggle_off(&self) -> bool {
        self.is_ability_toggle_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ability_toggle_off(&mut self, v: bool) {
        self.is_ability_toggle_off = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_level = 20;

    pub fn ability_level(&self) -> u32 {
        self.ability_level.unwrap_or(0)
    }

    pub fn clear_ability_level(&mut self) {
        self.ability_level = ::std::option::Option::None;
    }

    pub fn has_ability_level(&self) -> bool {
        self.ability_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_level(&mut self, v: u32) {
        self.ability_level = ::std::option::Option::Some(v);
    }

    // optional float location_x = 21;

    pub fn location_x(&self) -> f32 {
        self.location_x.unwrap_or(0.)
    }

    pub fn clear_location_x(&mut self) {
        self.location_x = ::std::option::Option::None;
    }

    pub fn has_location_x(&self) -> bool {
        self.location_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_x(&mut self, v: f32) {
        self.location_x = ::std::option::Option::Some(v);
    }

    // optional float location_y = 22;

    pub fn location_y(&self) -> f32 {
        self.location_y.unwrap_or(0.)
    }

    pub fn clear_location_y(&mut self) {
        self.location_y = ::std::option::Option::None;
    }

    pub fn has_location_y(&self) -> bool {
        self.location_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_y(&mut self, v: f32) {
        self.location_y = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_reason = 23;

    pub fn gold_reason(&self) -> u32 {
        self.gold_reason.unwrap_or(0)
    }

    pub fn clear_gold_reason(&mut self) {
        self.gold_reason = ::std::option::Option::None;
    }

    pub fn has_gold_reason(&self) -> bool {
        self.gold_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_reason(&mut self, v: u32) {
        self.gold_reason = ::std::option::Option::Some(v);
    }

    // optional float timestamp_raw = 24;

    pub fn timestamp_raw(&self) -> f32 {
        self.timestamp_raw.unwrap_or(0.)
    }

    pub fn clear_timestamp_raw(&mut self) {
        self.timestamp_raw = ::std::option::Option::None;
    }

    pub fn has_timestamp_raw(&self) -> bool {
        self.timestamp_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_raw(&mut self, v: f32) {
        self.timestamp_raw = ::std::option::Option::Some(v);
    }

    // optional float modifier_duration = 25;

    pub fn modifier_duration(&self) -> f32 {
        self.modifier_duration.unwrap_or(0.)
    }

    pub fn clear_modifier_duration(&mut self) {
        self.modifier_duration = ::std::option::Option::None;
    }

    pub fn has_modifier_duration(&self) -> bool {
        self.modifier_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_duration(&mut self, v: f32) {
        self.modifier_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 xp_reason = 26;

    pub fn xp_reason(&self) -> u32 {
        self.xp_reason.unwrap_or(0)
    }

    pub fn clear_xp_reason(&mut self) {
        self.xp_reason = ::std::option::Option::None;
    }

    pub fn has_xp_reason(&self) -> bool {
        self.xp_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_reason(&mut self, v: u32) {
        self.xp_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 27;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 attacker_team = 28;

    pub fn attacker_team(&self) -> u32 {
        self.attacker_team.unwrap_or(0)
    }

    pub fn clear_attacker_team(&mut self) {
        self.attacker_team = ::std::option::Option::None;
    }

    pub fn has_attacker_team(&self) -> bool {
        self.attacker_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_team(&mut self, v: u32) {
        self.attacker_team = ::std::option::Option::Some(v);
    }

    // optional uint32 target_team = 29;

    pub fn target_team(&self) -> u32 {
        self.target_team.unwrap_or(0)
    }

    pub fn clear_target_team(&mut self) {
        self.target_team = ::std::option::Option::None;
    }

    pub fn has_target_team(&self) -> bool {
        self.target_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_team(&mut self, v: u32) {
        self.target_team = ::std::option::Option::Some(v);
    }

    // optional uint32 obs_wards_placed = 30;

    pub fn obs_wards_placed(&self) -> u32 {
        self.obs_wards_placed.unwrap_or(0)
    }

    pub fn clear_obs_wards_placed(&mut self) {
        self.obs_wards_placed = ::std::option::Option::None;
    }

    pub fn has_obs_wards_placed(&self) -> bool {
        self.obs_wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_wards_placed(&mut self, v: u32) {
        self.obs_wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player0 = 31;

    pub fn assist_player0(&self) -> u32 {
        self.assist_player0.unwrap_or(0)
    }

    pub fn clear_assist_player0(&mut self) {
        self.assist_player0 = ::std::option::Option::None;
    }

    pub fn has_assist_player0(&self) -> bool {
        self.assist_player0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player0(&mut self, v: u32) {
        self.assist_player0 = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player1 = 32;

    pub fn assist_player1(&self) -> u32 {
        self.assist_player1.unwrap_or(0)
    }

    pub fn clear_assist_player1(&mut self) {
        self.assist_player1 = ::std::option::Option::None;
    }

    pub fn has_assist_player1(&self) -> bool {
        self.assist_player1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player1(&mut self, v: u32) {
        self.assist_player1 = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player2 = 33;

    pub fn assist_player2(&self) -> u32 {
        self.assist_player2.unwrap_or(0)
    }

    pub fn clear_assist_player2(&mut self) {
        self.assist_player2 = ::std::option::Option::None;
    }

    pub fn has_assist_player2(&self) -> bool {
        self.assist_player2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player2(&mut self, v: u32) {
        self.assist_player2 = ::std::option::Option::Some(v);
    }

    // optional uint32 assist_player3 = 34;

    pub fn assist_player3(&self) -> u32 {
        self.assist_player3.unwrap_or(0)
    }

    pub fn clear_assist_player3(&mut self) {
        self.assist_player3 = ::std::option::Option::None;
    }

    pub fn has_assist_player3(&self) -> bool {
        self.assist_player3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player3(&mut self, v: u32) {
        self.assist_player3 = ::std::option::Option::Some(v);
    }

    // optional uint32 stack_count = 35;

    pub fn stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional bool hidden_modifier = 36;

    pub fn hidden_modifier(&self) -> bool {
        self.hidden_modifier.unwrap_or(false)
    }

    pub fn clear_hidden_modifier(&mut self) {
        self.hidden_modifier = ::std::option::Option::None;
    }

    pub fn has_hidden_modifier(&self) -> bool {
        self.hidden_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden_modifier(&mut self, v: bool) {
        self.hidden_modifier = ::std::option::Option::Some(v);
    }

    // optional bool is_target_building = 37;

    pub fn is_target_building(&self) -> bool {
        self.is_target_building.unwrap_or(false)
    }

    pub fn clear_is_target_building(&mut self) {
        self.is_target_building = ::std::option::Option::None;
    }

    pub fn has_is_target_building(&self) -> bool {
        self.is_target_building.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_building(&mut self, v: bool) {
        self.is_target_building = ::std::option::Option::Some(v);
    }

    // optional uint32 neutral_camp_type = 38;

    pub fn neutral_camp_type(&self) -> u32 {
        self.neutral_camp_type.unwrap_or(0)
    }

    pub fn clear_neutral_camp_type(&mut self) {
        self.neutral_camp_type = ::std::option::Option::None;
    }

    pub fn has_neutral_camp_type(&self) -> bool {
        self.neutral_camp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_camp_type(&mut self, v: u32) {
        self.neutral_camp_type = ::std::option::Option::Some(v);
    }

    // optional uint32 rune_type = 39;

    pub fn rune_type(&self) -> u32 {
        self.rune_type.unwrap_or(0)
    }

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: u32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    // optional bool is_heal_save = 41;

    pub fn is_heal_save(&self) -> bool {
        self.is_heal_save.unwrap_or(false)
    }

    pub fn clear_is_heal_save(&mut self) {
        self.is_heal_save = ::std::option::Option::None;
    }

    pub fn has_is_heal_save(&self) -> bool {
        self.is_heal_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_heal_save(&mut self, v: bool) {
        self.is_heal_save = ::std::option::Option::Some(v);
    }

    // optional bool is_ultimate_ability = 42;

    pub fn is_ultimate_ability(&self) -> bool {
        self.is_ultimate_ability.unwrap_or(false)
    }

    pub fn clear_is_ultimate_ability(&mut self) {
        self.is_ultimate_ability = ::std::option::Option::None;
    }

    pub fn has_is_ultimate_ability(&self) -> bool {
        self.is_ultimate_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ultimate_ability(&mut self, v: bool) {
        self.is_ultimate_ability = ::std::option::Option::Some(v);
    }

    // optional uint32 attacker_hero_level = 43;

    pub fn attacker_hero_level(&self) -> u32 {
        self.attacker_hero_level.unwrap_or(0)
    }

    pub fn clear_attacker_hero_level(&mut self) {
        self.attacker_hero_level = ::std::option::Option::None;
    }

    pub fn has_attacker_hero_level(&self) -> bool {
        self.attacker_hero_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_hero_level(&mut self, v: u32) {
        self.attacker_hero_level = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hero_level = 44;

    pub fn target_hero_level(&self) -> u32 {
        self.target_hero_level.unwrap_or(0)
    }

    pub fn clear_target_hero_level(&mut self) {
        self.target_hero_level = ::std::option::Option::None;
    }

    pub fn has_target_hero_level(&self) -> bool {
        self.target_hero_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_level(&mut self, v: u32) {
        self.target_hero_level = ::std::option::Option::Some(v);
    }

    // optional uint32 xpm = 45;

    pub fn xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    // optional uint32 gpm = 46;

    pub fn gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 event_location = 47;

    pub fn event_location(&self) -> u32 {
        self.event_location.unwrap_or(0)
    }

    pub fn clear_event_location(&mut self) {
        self.event_location = ::std::option::Option::None;
    }

    pub fn has_event_location(&self) -> bool {
        self.event_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_location(&mut self, v: u32) {
        self.event_location = ::std::option::Option::Some(v);
    }

    // optional bool target_is_self = 48;

    pub fn target_is_self(&self) -> bool {
        self.target_is_self.unwrap_or(false)
    }

    pub fn clear_target_is_self(&mut self) {
        self.target_is_self = ::std::option::Option::None;
    }

    pub fn has_target_is_self(&self) -> bool {
        self.target_is_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_is_self(&mut self, v: bool) {
        self.target_is_self = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_type = 49;

    pub fn damage_type(&self) -> u32 {
        self.damage_type.unwrap_or(0)
    }

    pub fn clear_damage_type(&mut self) {
        self.damage_type = ::std::option::Option::None;
    }

    pub fn has_damage_type(&self) -> bool {
        self.damage_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_type(&mut self, v: u32) {
        self.damage_type = ::std::option::Option::Some(v);
    }

    // optional bool invisibility_modifier = 50;

    pub fn invisibility_modifier(&self) -> bool {
        self.invisibility_modifier.unwrap_or(false)
    }

    pub fn clear_invisibility_modifier(&mut self) {
        self.invisibility_modifier = ::std::option::Option::None;
    }

    pub fn has_invisibility_modifier(&self) -> bool {
        self.invisibility_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invisibility_modifier(&mut self, v: bool) {
        self.invisibility_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_category = 51;

    pub fn damage_category(&self) -> u32 {
        self.damage_category.unwrap_or(0)
    }

    pub fn clear_damage_category(&mut self) {
        self.damage_category = ::std::option::Option::None;
    }

    pub fn has_damage_category(&self) -> bool {
        self.damage_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_category(&mut self, v: u32) {
        self.damage_category = ::std::option::Option::Some(v);
    }

    // optional uint32 networth = 52;

    pub fn networth(&self) -> u32 {
        self.networth.unwrap_or(0)
    }

    pub fn clear_networth(&mut self) {
        self.networth = ::std::option::Option::None;
    }

    pub fn has_networth(&self) -> bool {
        self.networth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networth(&mut self, v: u32) {
        self.networth = ::std::option::Option::Some(v);
    }

    // optional uint32 building_type = 53;

    pub fn building_type(&self) -> u32 {
        self.building_type.unwrap_or(0)
    }

    pub fn clear_building_type(&mut self) {
        self.building_type = ::std::option::Option::None;
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: u32) {
        self.building_type = ::std::option::Option::Some(v);
    }

    // optional float modifier_elapsed_duration = 54;

    pub fn modifier_elapsed_duration(&self) -> f32 {
        self.modifier_elapsed_duration.unwrap_or(0.)
    }

    pub fn clear_modifier_elapsed_duration(&mut self) {
        self.modifier_elapsed_duration = ::std::option::Option::None;
    }

    pub fn has_modifier_elapsed_duration(&self) -> bool {
        self.modifier_elapsed_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_elapsed_duration(&mut self, v: f32) {
        self.modifier_elapsed_duration = ::std::option::Option::Some(v);
    }

    // optional bool silence_modifier = 55;

    pub fn silence_modifier(&self) -> bool {
        self.silence_modifier.unwrap_or(false)
    }

    pub fn clear_silence_modifier(&mut self) {
        self.silence_modifier = ::std::option::Option::None;
    }

    pub fn has_silence_modifier(&self) -> bool {
        self.silence_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_silence_modifier(&mut self, v: bool) {
        self.silence_modifier = ::std::option::Option::Some(v);
    }

    // optional bool heal_from_lifesteal = 56;

    pub fn heal_from_lifesteal(&self) -> bool {
        self.heal_from_lifesteal.unwrap_or(false)
    }

    pub fn clear_heal_from_lifesteal(&mut self) {
        self.heal_from_lifesteal = ::std::option::Option::None;
    }

    pub fn has_heal_from_lifesteal(&self) -> bool {
        self.heal_from_lifesteal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heal_from_lifesteal(&mut self, v: bool) {
        self.heal_from_lifesteal = ::std::option::Option::Some(v);
    }

    // optional bool modifier_purged = 57;

    pub fn modifier_purged(&self) -> bool {
        self.modifier_purged.unwrap_or(false)
    }

    pub fn clear_modifier_purged(&mut self) {
        self.modifier_purged = ::std::option::Option::None;
    }

    pub fn has_modifier_purged(&self) -> bool {
        self.modifier_purged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purged(&mut self, v: bool) {
        self.modifier_purged = ::std::option::Option::Some(v);
    }

    // optional bool spell_evaded = 58;

    pub fn spell_evaded(&self) -> bool {
        self.spell_evaded.unwrap_or(false)
    }

    pub fn clear_spell_evaded(&mut self) {
        self.spell_evaded = ::std::option::Option::None;
    }

    pub fn has_spell_evaded(&self) -> bool {
        self.spell_evaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spell_evaded(&mut self, v: bool) {
        self.spell_evaded = ::std::option::Option::Some(v);
    }

    // optional bool motion_controller_modifier = 59;

    pub fn motion_controller_modifier(&self) -> bool {
        self.motion_controller_modifier.unwrap_or(false)
    }

    pub fn clear_motion_controller_modifier(&mut self) {
        self.motion_controller_modifier = ::std::option::Option::None;
    }

    pub fn has_motion_controller_modifier(&self) -> bool {
        self.motion_controller_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motion_controller_modifier(&mut self, v: bool) {
        self.motion_controller_modifier = ::std::option::Option::Some(v);
    }

    // optional bool long_range_kill = 60;

    pub fn long_range_kill(&self) -> bool {
        self.long_range_kill.unwrap_or(false)
    }

    pub fn clear_long_range_kill(&mut self) {
        self.long_range_kill = ::std::option::Option::None;
    }

    pub fn has_long_range_kill(&self) -> bool {
        self.long_range_kill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_range_kill(&mut self, v: bool) {
        self.long_range_kill = ::std::option::Option::Some(v);
    }

    // optional uint32 modifier_purge_ability = 61;

    pub fn modifier_purge_ability(&self) -> u32 {
        self.modifier_purge_ability.unwrap_or(0)
    }

    pub fn clear_modifier_purge_ability(&mut self) {
        self.modifier_purge_ability = ::std::option::Option::None;
    }

    pub fn has_modifier_purge_ability(&self) -> bool {
        self.modifier_purge_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purge_ability(&mut self, v: u32) {
        self.modifier_purge_ability = ::std::option::Option::Some(v);
    }

    // optional uint32 modifier_purge_npc = 62;

    pub fn modifier_purge_npc(&self) -> u32 {
        self.modifier_purge_npc.unwrap_or(0)
    }

    pub fn clear_modifier_purge_npc(&mut self) {
        self.modifier_purge_npc = ::std::option::Option::None;
    }

    pub fn has_modifier_purge_npc(&self) -> bool {
        self.modifier_purge_npc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purge_npc(&mut self, v: u32) {
        self.modifier_purge_npc = ::std::option::Option::Some(v);
    }

    // optional bool root_modifier = 63;

    pub fn root_modifier(&self) -> bool {
        self.root_modifier.unwrap_or(false)
    }

    pub fn clear_root_modifier(&mut self) {
        self.root_modifier = ::std::option::Option::None;
    }

    pub fn has_root_modifier(&self) -> bool {
        self.root_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root_modifier(&mut self, v: bool) {
        self.root_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 total_unit_death_count = 64;

    pub fn total_unit_death_count(&self) -> u32 {
        self.total_unit_death_count.unwrap_or(0)
    }

    pub fn clear_total_unit_death_count(&mut self) {
        self.total_unit_death_count = ::std::option::Option::None;
    }

    pub fn has_total_unit_death_count(&self) -> bool {
        self.total_unit_death_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_unit_death_count(&mut self, v: u32) {
        self.total_unit_death_count = ::std::option::Option::Some(v);
    }

    // optional bool aura_modifier = 65;

    pub fn aura_modifier(&self) -> bool {
        self.aura_modifier.unwrap_or(false)
    }

    pub fn clear_aura_modifier(&mut self) {
        self.aura_modifier = ::std::option::Option::None;
    }

    pub fn has_aura_modifier(&self) -> bool {
        self.aura_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aura_modifier(&mut self, v: bool) {
        self.aura_modifier = ::std::option::Option::Some(v);
    }

    // optional bool armor_debuff_modifier = 66;

    pub fn armor_debuff_modifier(&self) -> bool {
        self.armor_debuff_modifier.unwrap_or(false)
    }

    pub fn clear_armor_debuff_modifier(&mut self) {
        self.armor_debuff_modifier = ::std::option::Option::None;
    }

    pub fn has_armor_debuff_modifier(&self) -> bool {
        self.armor_debuff_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor_debuff_modifier(&mut self, v: bool) {
        self.armor_debuff_modifier = ::std::option::Option::Some(v);
    }

    // optional bool no_physical_damage_modifier = 67;

    pub fn no_physical_damage_modifier(&self) -> bool {
        self.no_physical_damage_modifier.unwrap_or(false)
    }

    pub fn clear_no_physical_damage_modifier(&mut self) {
        self.no_physical_damage_modifier = ::std::option::Option::None;
    }

    pub fn has_no_physical_damage_modifier(&self) -> bool {
        self.no_physical_damage_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_physical_damage_modifier(&mut self, v: bool) {
        self.no_physical_damage_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 modifier_ability = 68;

    pub fn modifier_ability(&self) -> u32 {
        self.modifier_ability.unwrap_or(0)
    }

    pub fn clear_modifier_ability(&mut self) {
        self.modifier_ability = ::std::option::Option::None;
    }

    pub fn has_modifier_ability(&self) -> bool {
        self.modifier_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_ability(&mut self, v: u32) {
        self.modifier_ability = ::std::option::Option::Some(v);
    }

    // optional bool modifier_hidden = 69;

    pub fn modifier_hidden(&self) -> bool {
        self.modifier_hidden.unwrap_or(false)
    }

    pub fn clear_modifier_hidden(&mut self) {
        self.modifier_hidden = ::std::option::Option::None;
    }

    pub fn has_modifier_hidden(&self) -> bool {
        self.modifier_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_hidden(&mut self, v: bool) {
        self.modifier_hidden = ::std::option::Option::Some(v);
    }

    // optional bool inflictor_is_stolen_ability = 70;

    pub fn inflictor_is_stolen_ability(&self) -> bool {
        self.inflictor_is_stolen_ability.unwrap_or(false)
    }

    pub fn clear_inflictor_is_stolen_ability(&mut self) {
        self.inflictor_is_stolen_ability = ::std::option::Option::None;
    }

    pub fn has_inflictor_is_stolen_ability(&self) -> bool {
        self.inflictor_is_stolen_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_is_stolen_ability(&mut self, v: bool) {
        self.inflictor_is_stolen_ability = ::std::option::Option::Some(v);
    }

    // optional uint32 kill_eater_event = 71;

    pub fn kill_eater_event(&self) -> u32 {
        self.kill_eater_event.unwrap_or(0)
    }

    pub fn clear_kill_eater_event(&mut self) {
        self.kill_eater_event = ::std::option::Option::None;
    }

    pub fn has_kill_eater_event(&self) -> bool {
        self.kill_eater_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_eater_event(&mut self, v: u32) {
        self.kill_eater_event = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_status_label = 72;

    pub fn unit_status_label(&self) -> u32 {
        self.unit_status_label.unwrap_or(0)
    }

    pub fn clear_unit_status_label(&mut self) {
        self.unit_status_label = ::std::option::Option::None;
    }

    pub fn has_unit_status_label(&self) -> bool {
        self.unit_status_label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_status_label(&mut self, v: u32) {
        self.unit_status_label = ::std::option::Option::Some(v);
    }

    // optional bool spell_generated_attack = 73;

    pub fn spell_generated_attack(&self) -> bool {
        self.spell_generated_attack.unwrap_or(false)
    }

    pub fn clear_spell_generated_attack(&mut self) {
        self.spell_generated_attack = ::std::option::Option::None;
    }

    pub fn has_spell_generated_attack(&self) -> bool {
        self.spell_generated_attack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spell_generated_attack(&mut self, v: bool) {
        self.spell_generated_attack = ::std::option::Option::Some(v);
    }

    // optional bool at_night_time = 74;

    pub fn at_night_time(&self) -> bool {
        self.at_night_time.unwrap_or(false)
    }

    pub fn clear_at_night_time(&mut self) {
        self.at_night_time = ::std::option::Option::None;
    }

    pub fn has_at_night_time(&self) -> bool {
        self.at_night_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_at_night_time(&mut self, v: bool) {
        self.at_night_time = ::std::option::Option::Some(v);
    }

    // optional bool attacker_has_scepter = 75;

    pub fn attacker_has_scepter(&self) -> bool {
        self.attacker_has_scepter.unwrap_or(false)
    }

    pub fn clear_attacker_has_scepter(&mut self) {
        self.attacker_has_scepter = ::std::option::Option::None;
    }

    pub fn has_attacker_has_scepter(&self) -> bool {
        self.attacker_has_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_has_scepter(&mut self, v: bool) {
        self.attacker_has_scepter = ::std::option::Option::Some(v);
    }

    // optional uint32 neutral_camp_team = 76;

    pub fn neutral_camp_team(&self) -> u32 {
        self.neutral_camp_team.unwrap_or(0)
    }

    pub fn clear_neutral_camp_team(&mut self) {
        self.neutral_camp_team = ::std::option::Option::None;
    }

    pub fn has_neutral_camp_team(&self) -> bool {
        self.neutral_camp_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_camp_team(&mut self, v: u32) {
        self.neutral_camp_team = ::std::option::Option::Some(v);
    }

    // optional float regenerated_health = 77;

    pub fn regenerated_health(&self) -> f32 {
        self.regenerated_health.unwrap_or(0.)
    }

    pub fn clear_regenerated_health(&mut self) {
        self.regenerated_health = ::std::option::Option::None;
    }

    pub fn has_regenerated_health(&self) -> bool {
        self.regenerated_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_regenerated_health(&mut self, v: f32) {
        self.regenerated_health = ::std::option::Option::Some(v);
    }

    // optional bool will_reincarnate = 78;

    pub fn will_reincarnate(&self) -> bool {
        self.will_reincarnate.unwrap_or(false)
    }

    pub fn clear_will_reincarnate(&mut self) {
        self.will_reincarnate = ::std::option::Option::None;
    }

    pub fn has_will_reincarnate(&self) -> bool {
        self.will_reincarnate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_will_reincarnate(&mut self, v: bool) {
        self.will_reincarnate = ::std::option::Option::Some(v);
    }

    // optional bool uses_charges = 79;

    pub fn uses_charges(&self) -> bool {
        self.uses_charges.unwrap_or(false)
    }

    pub fn clear_uses_charges(&mut self) {
        self.uses_charges = ::std::option::Option::None;
    }

    pub fn has_uses_charges(&self) -> bool {
        self.uses_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uses_charges(&mut self, v: bool) {
        self.uses_charges = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACombatLogEntry {
    const NAME: &'static str = "CMsgDOTACombatLogEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.target_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.target_source_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.attacker_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.damage_source_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.inflictor_name = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.is_attacker_illusion = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.is_attacker_hero = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_target_illusion = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.is_target_hero = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.is_visible_radiant = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_visible_dire = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.health = ::std::option::Option::Some(is.read_int32()?);
                },
                125 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                },
                141 => {
                    self.slow_duration = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.is_ability_toggle_on = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.is_ability_toggle_off = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.ability_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.location_x = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.location_y = ::std::option::Option::Some(is.read_float()?);
                },
                184 => {
                    self.gold_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                197 => {
                    self.timestamp_raw = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.modifier_duration = ::std::option::Option::Some(is.read_float()?);
                },
                208 => {
                    self.xp_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.attacker_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.target_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.obs_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.assist_player0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.assist_player1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.assist_player2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.assist_player3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.stack_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.hidden_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                296 => {
                    self.is_target_building = ::std::option::Option::Some(is.read_bool()?);
                },
                304 => {
                    self.neutral_camp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.rune_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                322 => {
                    is.read_repeated_packed_int32_into(&mut self.assist_players)?;
                },
                320 => {
                    self.assist_players.push(is.read_int32()?);
                },
                328 => {
                    self.is_heal_save = ::std::option::Option::Some(is.read_bool()?);
                },
                336 => {
                    self.is_ultimate_ability = ::std::option::Option::Some(is.read_bool()?);
                },
                344 => {
                    self.attacker_hero_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.target_hero_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.xpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.gpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.event_location = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.target_is_self = ::std::option::Option::Some(is.read_bool()?);
                },
                392 => {
                    self.damage_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.invisibility_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                408 => {
                    self.damage_category = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.networth = ::std::option::Option::Some(is.read_uint32()?);
                },
                424 => {
                    self.building_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                437 => {
                    self.modifier_elapsed_duration = ::std::option::Option::Some(is.read_float()?);
                },
                440 => {
                    self.silence_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                448 => {
                    self.heal_from_lifesteal = ::std::option::Option::Some(is.read_bool()?);
                },
                456 => {
                    self.modifier_purged = ::std::option::Option::Some(is.read_bool()?);
                },
                464 => {
                    self.spell_evaded = ::std::option::Option::Some(is.read_bool()?);
                },
                472 => {
                    self.motion_controller_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                480 => {
                    self.long_range_kill = ::std::option::Option::Some(is.read_bool()?);
                },
                488 => {
                    self.modifier_purge_ability = ::std::option::Option::Some(is.read_uint32()?);
                },
                496 => {
                    self.modifier_purge_npc = ::std::option::Option::Some(is.read_uint32()?);
                },
                504 => {
                    self.root_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                512 => {
                    self.total_unit_death_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                520 => {
                    self.aura_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                528 => {
                    self.armor_debuff_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                536 => {
                    self.no_physical_damage_modifier = ::std::option::Option::Some(is.read_bool()?);
                },
                544 => {
                    self.modifier_ability = ::std::option::Option::Some(is.read_uint32()?);
                },
                552 => {
                    self.modifier_hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                560 => {
                    self.inflictor_is_stolen_ability = ::std::option::Option::Some(is.read_bool()?);
                },
                568 => {
                    self.kill_eater_event = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.unit_status_label = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.spell_generated_attack = ::std::option::Option::Some(is.read_bool()?);
                },
                592 => {
                    self.at_night_time = ::std::option::Option::Some(is.read_bool()?);
                },
                600 => {
                    self.attacker_has_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                608 => {
                    self.neutral_camp_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                621 => {
                    self.regenerated_health = ::std::option::Option::Some(is.read_float()?);
                },
                624 => {
                    self.will_reincarnate = ::std::option::Option::Some(is.read_bool()?);
                },
                632 => {
                    self.uses_charges = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.target_name {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.target_source_name {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.attacker_name {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.damage_source_name {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.inflictor_name {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.is_attacker_illusion {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_attacker_hero {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_target_illusion {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_target_hero {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_visible_radiant {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_visible_dire {
            my_size += 1 + 1;
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.health {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stun_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.slow_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.is_ability_toggle_on {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_ability_toggle_off {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.location_x {
            my_size += 2 + 4;
        }
        if let Some(v) = self.location_y {
            my_size += 2 + 4;
        }
        if let Some(v) = self.gold_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.timestamp_raw {
            my_size += 2 + 4;
        }
        if let Some(v) = self.modifier_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.xp_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.attacker_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.target_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.obs_wards_placed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.assist_player0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.assist_player1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.assist_player2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.assist_player3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.hidden_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_target_building {
            my_size += 2 + 1;
        }
        if let Some(v) = self.neutral_camp_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.rune_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, v);
        }
        for value in &self.assist_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(40, *value);
        };
        if let Some(v) = self.is_heal_save {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_ultimate_ability {
            my_size += 2 + 1;
        }
        if let Some(v) = self.attacker_hero_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.target_hero_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.xpm {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.gpm {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.event_location {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.target_is_self {
            my_size += 2 + 1;
        }
        if let Some(v) = self.damage_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.invisibility_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.damage_category {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.networth {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.building_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(53, v);
        }
        if let Some(v) = self.modifier_elapsed_duration {
            my_size += 2 + 4;
        }
        if let Some(v) = self.silence_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.heal_from_lifesteal {
            my_size += 2 + 1;
        }
        if let Some(v) = self.modifier_purged {
            my_size += 2 + 1;
        }
        if let Some(v) = self.spell_evaded {
            my_size += 2 + 1;
        }
        if let Some(v) = self.motion_controller_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.long_range_kill {
            my_size += 2 + 1;
        }
        if let Some(v) = self.modifier_purge_ability {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(61, v);
        }
        if let Some(v) = self.modifier_purge_npc {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(62, v);
        }
        if let Some(v) = self.root_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.total_unit_death_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(64, v);
        }
        if let Some(v) = self.aura_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.armor_debuff_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.no_physical_damage_modifier {
            my_size += 2 + 1;
        }
        if let Some(v) = self.modifier_ability {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(68, v);
        }
        if let Some(v) = self.modifier_hidden {
            my_size += 2 + 1;
        }
        if let Some(v) = self.inflictor_is_stolen_ability {
            my_size += 2 + 1;
        }
        if let Some(v) = self.kill_eater_event {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.unit_status_label {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.spell_generated_attack {
            my_size += 2 + 1;
        }
        if let Some(v) = self.at_night_time {
            my_size += 2 + 1;
        }
        if let Some(v) = self.attacker_has_scepter {
            my_size += 2 + 1;
        }
        if let Some(v) = self.neutral_camp_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(76, v);
        }
        if let Some(v) = self.regenerated_health {
            my_size += 2 + 4;
        }
        if let Some(v) = self.will_reincarnate {
            my_size += 2 + 1;
        }
        if let Some(v) = self.uses_charges {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.target_name {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.target_source_name {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.attacker_name {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.damage_source_name {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.inflictor_name {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_attacker_illusion {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_attacker_hero {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_target_illusion {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_target_hero {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_visible_radiant {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_visible_dire {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.health {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.stun_duration {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.slow_duration {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.is_ability_toggle_on {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.is_ability_toggle_off {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.ability_level {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.location_x {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.location_y {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.gold_reason {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.timestamp_raw {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.modifier_duration {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.xp_reason {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.attacker_team {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.target_team {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.obs_wards_placed {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.assist_player0 {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.assist_player1 {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.assist_player2 {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.assist_player3 {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.hidden_modifier {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.is_target_building {
            os.write_bool(37, v)?;
        }
        if let Some(v) = self.neutral_camp_type {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_uint32(39, v)?;
        }
        for v in &self.assist_players {
            os.write_int32(40, *v)?;
        };
        if let Some(v) = self.is_heal_save {
            os.write_bool(41, v)?;
        }
        if let Some(v) = self.is_ultimate_ability {
            os.write_bool(42, v)?;
        }
        if let Some(v) = self.attacker_hero_level {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.target_hero_level {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.event_location {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.target_is_self {
            os.write_bool(48, v)?;
        }
        if let Some(v) = self.damage_type {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.invisibility_modifier {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.damage_category {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.networth {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.building_type {
            os.write_uint32(53, v)?;
        }
        if let Some(v) = self.modifier_elapsed_duration {
            os.write_float(54, v)?;
        }
        if let Some(v) = self.silence_modifier {
            os.write_bool(55, v)?;
        }
        if let Some(v) = self.heal_from_lifesteal {
            os.write_bool(56, v)?;
        }
        if let Some(v) = self.modifier_purged {
            os.write_bool(57, v)?;
        }
        if let Some(v) = self.spell_evaded {
            os.write_bool(58, v)?;
        }
        if let Some(v) = self.motion_controller_modifier {
            os.write_bool(59, v)?;
        }
        if let Some(v) = self.long_range_kill {
            os.write_bool(60, v)?;
        }
        if let Some(v) = self.modifier_purge_ability {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.modifier_purge_npc {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.root_modifier {
            os.write_bool(63, v)?;
        }
        if let Some(v) = self.total_unit_death_count {
            os.write_uint32(64, v)?;
        }
        if let Some(v) = self.aura_modifier {
            os.write_bool(65, v)?;
        }
        if let Some(v) = self.armor_debuff_modifier {
            os.write_bool(66, v)?;
        }
        if let Some(v) = self.no_physical_damage_modifier {
            os.write_bool(67, v)?;
        }
        if let Some(v) = self.modifier_ability {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.modifier_hidden {
            os.write_bool(69, v)?;
        }
        if let Some(v) = self.inflictor_is_stolen_ability {
            os.write_bool(70, v)?;
        }
        if let Some(v) = self.kill_eater_event {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.unit_status_label {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.spell_generated_attack {
            os.write_bool(73, v)?;
        }
        if let Some(v) = self.at_night_time {
            os.write_bool(74, v)?;
        }
        if let Some(v) = self.attacker_has_scepter {
            os.write_bool(75, v)?;
        }
        if let Some(v) = self.neutral_camp_team {
            os.write_uint32(76, v)?;
        }
        if let Some(v) = self.regenerated_health {
            os.write_float(77, v)?;
        }
        if let Some(v) = self.will_reincarnate {
            os.write_bool(78, v)?;
        }
        if let Some(v) = self.uses_charges {
            os.write_bool(79, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACombatLogEntry {
        CMsgDOTACombatLogEntry::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.target_name = ::std::option::Option::None;
        self.target_source_name = ::std::option::Option::None;
        self.attacker_name = ::std::option::Option::None;
        self.damage_source_name = ::std::option::Option::None;
        self.inflictor_name = ::std::option::Option::None;
        self.is_attacker_illusion = ::std::option::Option::None;
        self.is_attacker_hero = ::std::option::Option::None;
        self.is_target_illusion = ::std::option::Option::None;
        self.is_target_hero = ::std::option::Option::None;
        self.is_visible_radiant = ::std::option::Option::None;
        self.is_visible_dire = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.stun_duration = ::std::option::Option::None;
        self.slow_duration = ::std::option::Option::None;
        self.is_ability_toggle_on = ::std::option::Option::None;
        self.is_ability_toggle_off = ::std::option::Option::None;
        self.ability_level = ::std::option::Option::None;
        self.location_x = ::std::option::Option::None;
        self.location_y = ::std::option::Option::None;
        self.gold_reason = ::std::option::Option::None;
        self.timestamp_raw = ::std::option::Option::None;
        self.modifier_duration = ::std::option::Option::None;
        self.xp_reason = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.attacker_team = ::std::option::Option::None;
        self.target_team = ::std::option::Option::None;
        self.obs_wards_placed = ::std::option::Option::None;
        self.assist_player0 = ::std::option::Option::None;
        self.assist_player1 = ::std::option::Option::None;
        self.assist_player2 = ::std::option::Option::None;
        self.assist_player3 = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.hidden_modifier = ::std::option::Option::None;
        self.is_target_building = ::std::option::Option::None;
        self.neutral_camp_type = ::std::option::Option::None;
        self.rune_type = ::std::option::Option::None;
        self.assist_players.clear();
        self.is_heal_save = ::std::option::Option::None;
        self.is_ultimate_ability = ::std::option::Option::None;
        self.attacker_hero_level = ::std::option::Option::None;
        self.target_hero_level = ::std::option::Option::None;
        self.xpm = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.event_location = ::std::option::Option::None;
        self.target_is_self = ::std::option::Option::None;
        self.damage_type = ::std::option::Option::None;
        self.invisibility_modifier = ::std::option::Option::None;
        self.damage_category = ::std::option::Option::None;
        self.networth = ::std::option::Option::None;
        self.building_type = ::std::option::Option::None;
        self.modifier_elapsed_duration = ::std::option::Option::None;
        self.silence_modifier = ::std::option::Option::None;
        self.heal_from_lifesteal = ::std::option::Option::None;
        self.modifier_purged = ::std::option::Option::None;
        self.spell_evaded = ::std::option::Option::None;
        self.motion_controller_modifier = ::std::option::Option::None;
        self.long_range_kill = ::std::option::Option::None;
        self.modifier_purge_ability = ::std::option::Option::None;
        self.modifier_purge_npc = ::std::option::Option::None;
        self.root_modifier = ::std::option::Option::None;
        self.total_unit_death_count = ::std::option::Option::None;
        self.aura_modifier = ::std::option::Option::None;
        self.armor_debuff_modifier = ::std::option::Option::None;
        self.no_physical_damage_modifier = ::std::option::Option::None;
        self.modifier_ability = ::std::option::Option::None;
        self.modifier_hidden = ::std::option::Option::None;
        self.inflictor_is_stolen_ability = ::std::option::Option::None;
        self.kill_eater_event = ::std::option::Option::None;
        self.unit_status_label = ::std::option::Option::None;
        self.spell_generated_attack = ::std::option::Option::None;
        self.at_night_time = ::std::option::Option::None;
        self.attacker_has_scepter = ::std::option::Option::None;
        self.neutral_camp_team = ::std::option::Option::None;
        self.regenerated_health = ::std::option::Option::None;
        self.will_reincarnate = ::std::option::Option::None;
        self.uses_charges = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACombatLogEntry {
        static instance: CMsgDOTACombatLogEntry = CMsgDOTACombatLogEntry {
            type_: ::std::option::Option::None,
            target_name: ::std::option::Option::None,
            target_source_name: ::std::option::Option::None,
            attacker_name: ::std::option::Option::None,
            damage_source_name: ::std::option::Option::None,
            inflictor_name: ::std::option::Option::None,
            is_attacker_illusion: ::std::option::Option::None,
            is_attacker_hero: ::std::option::Option::None,
            is_target_illusion: ::std::option::Option::None,
            is_target_hero: ::std::option::Option::None,
            is_visible_radiant: ::std::option::Option::None,
            is_visible_dire: ::std::option::Option::None,
            value: ::std::option::Option::None,
            health: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            stun_duration: ::std::option::Option::None,
            slow_duration: ::std::option::Option::None,
            is_ability_toggle_on: ::std::option::Option::None,
            is_ability_toggle_off: ::std::option::Option::None,
            ability_level: ::std::option::Option::None,
            location_x: ::std::option::Option::None,
            location_y: ::std::option::Option::None,
            gold_reason: ::std::option::Option::None,
            timestamp_raw: ::std::option::Option::None,
            modifier_duration: ::std::option::Option::None,
            xp_reason: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            attacker_team: ::std::option::Option::None,
            target_team: ::std::option::Option::None,
            obs_wards_placed: ::std::option::Option::None,
            assist_player0: ::std::option::Option::None,
            assist_player1: ::std::option::Option::None,
            assist_player2: ::std::option::Option::None,
            assist_player3: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            hidden_modifier: ::std::option::Option::None,
            is_target_building: ::std::option::Option::None,
            neutral_camp_type: ::std::option::Option::None,
            rune_type: ::std::option::Option::None,
            assist_players: ::std::vec::Vec::new(),
            is_heal_save: ::std::option::Option::None,
            is_ultimate_ability: ::std::option::Option::None,
            attacker_hero_level: ::std::option::Option::None,
            target_hero_level: ::std::option::Option::None,
            xpm: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            event_location: ::std::option::Option::None,
            target_is_self: ::std::option::Option::None,
            damage_type: ::std::option::Option::None,
            invisibility_modifier: ::std::option::Option::None,
            damage_category: ::std::option::Option::None,
            networth: ::std::option::Option::None,
            building_type: ::std::option::Option::None,
            modifier_elapsed_duration: ::std::option::Option::None,
            silence_modifier: ::std::option::Option::None,
            heal_from_lifesteal: ::std::option::Option::None,
            modifier_purged: ::std::option::Option::None,
            spell_evaded: ::std::option::Option::None,
            motion_controller_modifier: ::std::option::Option::None,
            long_range_kill: ::std::option::Option::None,
            modifier_purge_ability: ::std::option::Option::None,
            modifier_purge_npc: ::std::option::Option::None,
            root_modifier: ::std::option::Option::None,
            total_unit_death_count: ::std::option::Option::None,
            aura_modifier: ::std::option::Option::None,
            armor_debuff_modifier: ::std::option::Option::None,
            no_physical_damage_modifier: ::std::option::Option::None,
            modifier_ability: ::std::option::Option::None,
            modifier_hidden: ::std::option::Option::None,
            inflictor_is_stolen_ability: ::std::option::Option::None,
            kill_eater_event: ::std::option::Option::None,
            unit_status_label: ::std::option::Option::None,
            spell_generated_attack: ::std::option::Option::None,
            at_night_time: ::std::option::Option::None,
            attacker_has_scepter: ::std::option::Option::None,
            neutral_camp_team: ::std::option::Option::None,
            regenerated_health: ::std::option::Option::None,
            will_reincarnate: ::std::option::Option::None,
            uses_charges: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPendingEventAward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPendingEventAward {
    // message fields
    // @@protoc_insertion_point(field:CMsgPendingEventAward.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EEvent>>,
    // @@protoc_insertion_point(field:CMsgPendingEventAward.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPendingEventAward.num_to_grant)
    pub num_to_grant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPendingEventAward.score_mode)
    pub score_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EEventActionScoreMode>>,
    // @@protoc_insertion_point(field:CMsgPendingEventAward.audit_action)
    pub audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPendingEventAward.audit_data)
    pub audit_data: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPendingEventAward.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPendingEventAward {
    fn default() -> &'a CMsgPendingEventAward {
        <CMsgPendingEventAward as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPendingEventAward {
    pub fn new() -> CMsgPendingEventAward {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(EEvent::EVENT_ID_NONE),
            None => EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_to_grant = 3;

    pub fn num_to_grant(&self) -> u32 {
        self.num_to_grant.unwrap_or(0)
    }

    pub fn clear_num_to_grant(&mut self) {
        self.num_to_grant = ::std::option::Option::None;
    }

    pub fn has_num_to_grant(&self) -> bool {
        self.num_to_grant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_to_grant(&mut self, v: u32) {
        self.num_to_grant = ::std::option::Option::Some(v);
    }

    // optional .EEventActionScoreMode score_mode = 4;

    pub fn score_mode(&self) -> EEventActionScoreMode {
        match self.score_mode {
            Some(e) => e.enum_value_or(EEventActionScoreMode::k_eEventActionScoreMode_Add),
            None => EEventActionScoreMode::k_eEventActionScoreMode_Add,
        }
    }

    pub fn clear_score_mode(&mut self) {
        self.score_mode = ::std::option::Option::None;
    }

    pub fn has_score_mode(&self) -> bool {
        self.score_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_mode(&mut self, v: EEventActionScoreMode) {
        self.score_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 audit_action = 5;

    pub fn audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    // optional uint64 audit_data = 6;

    pub fn audit_data(&self) -> u64 {
        self.audit_data.unwrap_or(0)
    }

    pub fn clear_audit_data(&mut self) {
        self.audit_data = ::std::option::Option::None;
    }

    pub fn has_audit_data(&self) -> bool {
        self.audit_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_data(&mut self, v: u64) {
        self.audit_data = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPendingEventAward {
    const NAME: &'static str = "CMsgPendingEventAward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_to_grant = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.score_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_to_grant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.score_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.audit_data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_to_grant {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.score_mode {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.audit_data {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPendingEventAward {
        CMsgPendingEventAward::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.num_to_grant = ::std::option::Option::None;
        self.score_mode = ::std::option::Option::None;
        self.audit_action = ::std::option::Option::None;
        self.audit_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPendingEventAward {
        static instance: CMsgPendingEventAward = CMsgPendingEventAward {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            num_to_grant: ::std::option::Option::None,
            score_mode: ::std::option::Option::None,
            audit_action: ::std::option::Option::None,
            audit_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_GameMode)
pub enum DOTA_GameMode {
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_NONE)
    DOTA_GAMEMODE_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_AP)
    DOTA_GAMEMODE_AP = 1,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_CM)
    DOTA_GAMEMODE_CM = 2,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_RD)
    DOTA_GAMEMODE_RD = 3,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_SD)
    DOTA_GAMEMODE_SD = 4,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_AR)
    DOTA_GAMEMODE_AR = 5,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_INTRO)
    DOTA_GAMEMODE_INTRO = 6,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_HW)
    DOTA_GAMEMODE_HW = 7,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_REVERSE_CM)
    DOTA_GAMEMODE_REVERSE_CM = 8,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_XMAS)
    DOTA_GAMEMODE_XMAS = 9,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_TUTORIAL)
    DOTA_GAMEMODE_TUTORIAL = 10,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_MO)
    DOTA_GAMEMODE_MO = 11,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_LP)
    DOTA_GAMEMODE_LP = 12,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_POOL1)
    DOTA_GAMEMODE_POOL1 = 13,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_FH)
    DOTA_GAMEMODE_FH = 14,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_CUSTOM)
    DOTA_GAMEMODE_CUSTOM = 15,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_CD)
    DOTA_GAMEMODE_CD = 16,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_BD)
    DOTA_GAMEMODE_BD = 17,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_ABILITY_DRAFT)
    DOTA_GAMEMODE_ABILITY_DRAFT = 18,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_EVENT)
    DOTA_GAMEMODE_EVENT = 19,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_ARDM)
    DOTA_GAMEMODE_ARDM = 20,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_1V1MID)
    DOTA_GAMEMODE_1V1MID = 21,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_ALL_DRAFT)
    DOTA_GAMEMODE_ALL_DRAFT = 22,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_TURBO)
    DOTA_GAMEMODE_TURBO = 23,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_MUTATION)
    DOTA_GAMEMODE_MUTATION = 24,
    // @@protoc_insertion_point(enum_value:DOTA_GameMode.DOTA_GAMEMODE_COACHES_CHALLENGE)
    DOTA_GAMEMODE_COACHES_CHALLENGE = 25,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_GameMode {
    const NAME: &'static str = "DOTA_GameMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_GameMode> {
        match value {
            0 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_NONE),
            1 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AP),
            2 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CM),
            3 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_RD),
            4 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_SD),
            5 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AR),
            6 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_INTRO),
            7 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_HW),
            8 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_REVERSE_CM),
            9 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_XMAS),
            10 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TUTORIAL),
            11 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MO),
            12 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_LP),
            13 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_POOL1),
            14 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_FH),
            15 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CUSTOM),
            16 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CD),
            17 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_BD),
            18 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ABILITY_DRAFT),
            19 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_EVENT),
            20 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ARDM),
            21 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_1V1MID),
            22 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ALL_DRAFT),
            23 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TURBO),
            24 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MUTATION),
            25 => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_COACHES_CHALLENGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_GameMode> {
        match str {
            "DOTA_GAMEMODE_NONE" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_NONE),
            "DOTA_GAMEMODE_AP" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AP),
            "DOTA_GAMEMODE_CM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CM),
            "DOTA_GAMEMODE_RD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_RD),
            "DOTA_GAMEMODE_SD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_SD),
            "DOTA_GAMEMODE_AR" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_AR),
            "DOTA_GAMEMODE_INTRO" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_INTRO),
            "DOTA_GAMEMODE_HW" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_HW),
            "DOTA_GAMEMODE_REVERSE_CM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_REVERSE_CM),
            "DOTA_GAMEMODE_XMAS" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_XMAS),
            "DOTA_GAMEMODE_TUTORIAL" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TUTORIAL),
            "DOTA_GAMEMODE_MO" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MO),
            "DOTA_GAMEMODE_LP" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_LP),
            "DOTA_GAMEMODE_POOL1" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_POOL1),
            "DOTA_GAMEMODE_FH" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_FH),
            "DOTA_GAMEMODE_CUSTOM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CUSTOM),
            "DOTA_GAMEMODE_CD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_CD),
            "DOTA_GAMEMODE_BD" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_BD),
            "DOTA_GAMEMODE_ABILITY_DRAFT" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ABILITY_DRAFT),
            "DOTA_GAMEMODE_EVENT" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_EVENT),
            "DOTA_GAMEMODE_ARDM" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ARDM),
            "DOTA_GAMEMODE_1V1MID" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_1V1MID),
            "DOTA_GAMEMODE_ALL_DRAFT" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_ALL_DRAFT),
            "DOTA_GAMEMODE_TURBO" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_TURBO),
            "DOTA_GAMEMODE_MUTATION" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_MUTATION),
            "DOTA_GAMEMODE_COACHES_CHALLENGE" => ::std::option::Option::Some(DOTA_GameMode::DOTA_GAMEMODE_COACHES_CHALLENGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_GameMode] = &[
        DOTA_GameMode::DOTA_GAMEMODE_NONE,
        DOTA_GameMode::DOTA_GAMEMODE_AP,
        DOTA_GameMode::DOTA_GAMEMODE_CM,
        DOTA_GameMode::DOTA_GAMEMODE_RD,
        DOTA_GameMode::DOTA_GAMEMODE_SD,
        DOTA_GameMode::DOTA_GAMEMODE_AR,
        DOTA_GameMode::DOTA_GAMEMODE_INTRO,
        DOTA_GameMode::DOTA_GAMEMODE_HW,
        DOTA_GameMode::DOTA_GAMEMODE_REVERSE_CM,
        DOTA_GameMode::DOTA_GAMEMODE_XMAS,
        DOTA_GameMode::DOTA_GAMEMODE_TUTORIAL,
        DOTA_GameMode::DOTA_GAMEMODE_MO,
        DOTA_GameMode::DOTA_GAMEMODE_LP,
        DOTA_GameMode::DOTA_GAMEMODE_POOL1,
        DOTA_GameMode::DOTA_GAMEMODE_FH,
        DOTA_GameMode::DOTA_GAMEMODE_CUSTOM,
        DOTA_GameMode::DOTA_GAMEMODE_CD,
        DOTA_GameMode::DOTA_GAMEMODE_BD,
        DOTA_GameMode::DOTA_GAMEMODE_ABILITY_DRAFT,
        DOTA_GameMode::DOTA_GAMEMODE_EVENT,
        DOTA_GameMode::DOTA_GAMEMODE_ARDM,
        DOTA_GameMode::DOTA_GAMEMODE_1V1MID,
        DOTA_GameMode::DOTA_GAMEMODE_ALL_DRAFT,
        DOTA_GameMode::DOTA_GAMEMODE_TURBO,
        DOTA_GameMode::DOTA_GAMEMODE_MUTATION,
        DOTA_GameMode::DOTA_GAMEMODE_COACHES_CHALLENGE,
    ];
}

impl ::std::default::Default for DOTA_GameMode {
    fn default() -> Self {
        DOTA_GameMode::DOTA_GAMEMODE_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_GameState)
pub enum DOTA_GameState {
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_INIT)
    DOTA_GAMERULES_STATE_INIT = 0,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD)
    DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD = 1,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_HERO_SELECTION)
    DOTA_GAMERULES_STATE_HERO_SELECTION = 2,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_STRATEGY_TIME)
    DOTA_GAMERULES_STATE_STRATEGY_TIME = 3,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_PRE_GAME)
    DOTA_GAMERULES_STATE_PRE_GAME = 4,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_GAME_IN_PROGRESS)
    DOTA_GAMERULES_STATE_GAME_IN_PROGRESS = 5,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_POST_GAME)
    DOTA_GAMERULES_STATE_POST_GAME = 6,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_DISCONNECT)
    DOTA_GAMERULES_STATE_DISCONNECT = 7,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_TEAM_SHOWCASE)
    DOTA_GAMERULES_STATE_TEAM_SHOWCASE = 8,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP)
    DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP = 9,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD)
    DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD = 10,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_SCENARIO_SETUP)
    DOTA_GAMERULES_STATE_SCENARIO_SETUP = 11,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_PLAYER_DRAFT)
    DOTA_GAMERULES_STATE_PLAYER_DRAFT = 12,
    // @@protoc_insertion_point(enum_value:DOTA_GameState.DOTA_GAMERULES_STATE_LAST)
    DOTA_GAMERULES_STATE_LAST = 13,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_GameState {
    const NAME: &'static str = "DOTA_GameState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_GameState> {
        match value {
            0 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            1 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD),
            2 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_HERO_SELECTION),
            3 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_STRATEGY_TIME),
            4 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PRE_GAME),
            5 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_GAME_IN_PROGRESS),
            6 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_POST_GAME),
            7 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_DISCONNECT),
            8 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_TEAM_SHOWCASE),
            9 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP),
            10 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD),
            11 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_SCENARIO_SETUP),
            12 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PLAYER_DRAFT),
            13 => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_GameState> {
        match str {
            "DOTA_GAMERULES_STATE_INIT" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            "DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD),
            "DOTA_GAMERULES_STATE_HERO_SELECTION" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_HERO_SELECTION),
            "DOTA_GAMERULES_STATE_STRATEGY_TIME" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_STRATEGY_TIME),
            "DOTA_GAMERULES_STATE_PRE_GAME" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PRE_GAME),
            "DOTA_GAMERULES_STATE_GAME_IN_PROGRESS" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_GAME_IN_PROGRESS),
            "DOTA_GAMERULES_STATE_POST_GAME" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_POST_GAME),
            "DOTA_GAMERULES_STATE_DISCONNECT" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_DISCONNECT),
            "DOTA_GAMERULES_STATE_TEAM_SHOWCASE" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_TEAM_SHOWCASE),
            "DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP),
            "DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD),
            "DOTA_GAMERULES_STATE_SCENARIO_SETUP" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_SCENARIO_SETUP),
            "DOTA_GAMERULES_STATE_PLAYER_DRAFT" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_PLAYER_DRAFT),
            "DOTA_GAMERULES_STATE_LAST" => ::std::option::Option::Some(DOTA_GameState::DOTA_GAMERULES_STATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_GameState] = &[
        DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD,
        DOTA_GameState::DOTA_GAMERULES_STATE_HERO_SELECTION,
        DOTA_GameState::DOTA_GAMERULES_STATE_STRATEGY_TIME,
        DOTA_GameState::DOTA_GAMERULES_STATE_PRE_GAME,
        DOTA_GameState::DOTA_GAMERULES_STATE_GAME_IN_PROGRESS,
        DOTA_GameState::DOTA_GAMERULES_STATE_POST_GAME,
        DOTA_GameState::DOTA_GAMERULES_STATE_DISCONNECT,
        DOTA_GameState::DOTA_GAMERULES_STATE_TEAM_SHOWCASE,
        DOTA_GameState::DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP,
        DOTA_GameState::DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD,
        DOTA_GameState::DOTA_GAMERULES_STATE_SCENARIO_SETUP,
        DOTA_GameState::DOTA_GAMERULES_STATE_PLAYER_DRAFT,
        DOTA_GameState::DOTA_GAMERULES_STATE_LAST,
    ];
}

impl ::std::default::Default for DOTA_GameState {
    fn default() -> Self {
        DOTA_GameState::DOTA_GAMERULES_STATE_INIT
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_GC_TEAM)
pub enum DOTA_GC_TEAM {
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_GOOD_GUYS)
    DOTA_GC_TEAM_GOOD_GUYS = 0,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_BAD_GUYS)
    DOTA_GC_TEAM_BAD_GUYS = 1,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_BROADCASTER)
    DOTA_GC_TEAM_BROADCASTER = 2,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_SPECTATOR)
    DOTA_GC_TEAM_SPECTATOR = 3,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_PLAYER_POOL)
    DOTA_GC_TEAM_PLAYER_POOL = 4,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_NOTEAM)
    DOTA_GC_TEAM_NOTEAM = 5,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_1)
    DOTA_GC_TEAM_CUSTOM_1 = 6,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_2)
    DOTA_GC_TEAM_CUSTOM_2 = 7,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_3)
    DOTA_GC_TEAM_CUSTOM_3 = 8,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_4)
    DOTA_GC_TEAM_CUSTOM_4 = 9,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_5)
    DOTA_GC_TEAM_CUSTOM_5 = 10,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_6)
    DOTA_GC_TEAM_CUSTOM_6 = 11,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_7)
    DOTA_GC_TEAM_CUSTOM_7 = 12,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_CUSTOM_8)
    DOTA_GC_TEAM_CUSTOM_8 = 13,
    // @@protoc_insertion_point(enum_value:DOTA_GC_TEAM.DOTA_GC_TEAM_NEUTRALS)
    DOTA_GC_TEAM_NEUTRALS = 14,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_GC_TEAM {
    const NAME: &'static str = "DOTA_GC_TEAM";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_GC_TEAM> {
        match value {
            0 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            1 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BAD_GUYS),
            2 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BROADCASTER),
            3 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_SPECTATOR),
            4 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_PLAYER_POOL),
            5 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM),
            6 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_1),
            7 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_2),
            8 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_3),
            9 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_4),
            10 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_5),
            11 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_6),
            12 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_7),
            13 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_8),
            14 => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NEUTRALS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_GC_TEAM> {
        match str {
            "DOTA_GC_TEAM_GOOD_GUYS" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            "DOTA_GC_TEAM_BAD_GUYS" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BAD_GUYS),
            "DOTA_GC_TEAM_BROADCASTER" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_BROADCASTER),
            "DOTA_GC_TEAM_SPECTATOR" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_SPECTATOR),
            "DOTA_GC_TEAM_PLAYER_POOL" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_PLAYER_POOL),
            "DOTA_GC_TEAM_NOTEAM" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM),
            "DOTA_GC_TEAM_CUSTOM_1" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_1),
            "DOTA_GC_TEAM_CUSTOM_2" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_2),
            "DOTA_GC_TEAM_CUSTOM_3" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_3),
            "DOTA_GC_TEAM_CUSTOM_4" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_4),
            "DOTA_GC_TEAM_CUSTOM_5" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_5),
            "DOTA_GC_TEAM_CUSTOM_6" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_6),
            "DOTA_GC_TEAM_CUSTOM_7" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_7),
            "DOTA_GC_TEAM_CUSTOM_8" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_8),
            "DOTA_GC_TEAM_NEUTRALS" => ::std::option::Option::Some(DOTA_GC_TEAM::DOTA_GC_TEAM_NEUTRALS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_GC_TEAM] = &[
        DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        DOTA_GC_TEAM::DOTA_GC_TEAM_BAD_GUYS,
        DOTA_GC_TEAM::DOTA_GC_TEAM_BROADCASTER,
        DOTA_GC_TEAM::DOTA_GC_TEAM_SPECTATOR,
        DOTA_GC_TEAM::DOTA_GC_TEAM_PLAYER_POOL,
        DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_1,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_2,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_3,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_4,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_5,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_6,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_7,
        DOTA_GC_TEAM::DOTA_GC_TEAM_CUSTOM_8,
        DOTA_GC_TEAM::DOTA_GC_TEAM_NEUTRALS,
    ];
}

impl ::std::default::Default for DOTA_GC_TEAM {
    fn default() -> Self {
        DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EEvent)
pub enum EEvent {
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NONE)
    EVENT_ID_NONE = 0,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_DIRETIDE)
    EVENT_ID_DIRETIDE = 1,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_SPRING_FESTIVAL)
    EVENT_ID_SPRING_FESTIVAL = 2,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FROSTIVUS_2013)
    EVENT_ID_FROSTIVUS_2013 = 3,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_COMPENDIUM_2014)
    EVENT_ID_COMPENDIUM_2014 = 4,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NEXON_PC_BANG)
    EVENT_ID_NEXON_PC_BANG = 5,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_PWRD_DAC_2015)
    EVENT_ID_PWRD_DAC_2015 = 6,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NEW_BLOOM_2015)
    EVENT_ID_NEW_BLOOM_2015 = 7,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2015)
    EVENT_ID_INTERNATIONAL_2015 = 8,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FALL_MAJOR_2015)
    EVENT_ID_FALL_MAJOR_2015 = 9,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_ORACLE_PA)
    EVENT_ID_ORACLE_PA = 10,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NEW_BLOOM_2015_PREBEAST)
    EVENT_ID_NEW_BLOOM_2015_PREBEAST = 11,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FROSTIVUS)
    EVENT_ID_FROSTIVUS = 12,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_WINTER_MAJOR_2016)
    EVENT_ID_WINTER_MAJOR_2016 = 13,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2016)
    EVENT_ID_INTERNATIONAL_2016 = 14,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FALL_MAJOR_2016)
    EVENT_ID_FALL_MAJOR_2016 = 15,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_WINTER_MAJOR_2017)
    EVENT_ID_WINTER_MAJOR_2017 = 16,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NEW_BLOOM_2017)
    EVENT_ID_NEW_BLOOM_2017 = 17,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2017)
    EVENT_ID_INTERNATIONAL_2017 = 18,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_PLUS_SUBSCRIPTION)
    EVENT_ID_PLUS_SUBSCRIPTION = 19,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_SINGLES_DAY_2017)
    EVENT_ID_SINGLES_DAY_2017 = 20,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FROSTIVUS_2017)
    EVENT_ID_FROSTIVUS_2017 = 21,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2018)
    EVENT_ID_INTERNATIONAL_2018 = 22,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FROSTIVUS_2018)
    EVENT_ID_FROSTIVUS_2018 = 23,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NEW_BLOOM_2019)
    EVENT_ID_NEW_BLOOM_2019 = 24,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2019)
    EVENT_ID_INTERNATIONAL_2019 = 25,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NEW_PLAYER_EXPERIENCE)
    EVENT_ID_NEW_PLAYER_EXPERIENCE = 26,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FROSTIVUS_2019)
    EVENT_ID_FROSTIVUS_2019 = 27,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_NEW_BLOOM_2020)
    EVENT_ID_NEW_BLOOM_2020 = 28,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2020)
    EVENT_ID_INTERNATIONAL_2020 = 29,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_FANDOM)
    EVENT_ID_TEAM_FANDOM = 30,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_DIRETIDE_2020)
    EVENT_ID_DIRETIDE_2020 = 31,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_SPRING_2021)
    EVENT_ID_SPRING_2021 = 32,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FALL_2021)
    EVENT_ID_FALL_2021 = 33,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_FANDOM_FALL_2021)
    EVENT_ID_TEAM_FANDOM_FALL_2021 = 34,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_2021_2022_TOUR2)
    EVENT_ID_TEAM_2021_2022_TOUR2 = 35,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2022)
    EVENT_ID_INTERNATIONAL_2022 = 36,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_2021_2022_TOUR3)
    EVENT_ID_TEAM_2021_2022_TOUR3 = 37,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_INTERNATIONAL_2022)
    EVENT_ID_TEAM_INTERNATIONAL_2022 = 38,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_PERMANENT_GRANTS)
    EVENT_ID_PERMANENT_GRANTS = 39,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_MUERTA_RELEASE_SPRING2023)
    EVENT_ID_MUERTA_RELEASE_SPRING2023 = 40,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_2023_TOUR1)
    EVENT_ID_TEAM_2023_TOUR1 = 41,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_2023_TOUR2)
    EVENT_ID_TEAM_2023_TOUR2 = 42,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_TEAM_2023_TOUR3)
    EVENT_ID_TEAM_2023_TOUR3 = 43,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2023)
    EVENT_ID_INTERNATIONAL_2023 = 45,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_10TH_ANNIVERSARY)
    EVENT_ID_10TH_ANNIVERSARY = 46,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_CROWNFALL)
    EVENT_ID_CROWNFALL = 47,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_FROSTIVUS_2023)
    EVENT_ID_FROSTIVUS_2023 = 48,
    // @@protoc_insertion_point(enum_value:EEvent.EVENT_ID_INTERNATIONAL_2024)
    EVENT_ID_INTERNATIONAL_2024 = 49,
}

impl ::steam_vent_proto_common::protobuf::Enum for EEvent {
    const NAME: &'static str = "EEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EEvent> {
        match value {
            0 => ::std::option::Option::Some(EEvent::EVENT_ID_NONE),
            1 => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE),
            2 => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_FESTIVAL),
            3 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2013),
            4 => ::std::option::Option::Some(EEvent::EVENT_ID_COMPENDIUM_2014),
            5 => ::std::option::Option::Some(EEvent::EVENT_ID_NEXON_PC_BANG),
            6 => ::std::option::Option::Some(EEvent::EVENT_ID_PWRD_DAC_2015),
            7 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015),
            8 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2015),
            9 => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2015),
            10 => ::std::option::Option::Some(EEvent::EVENT_ID_ORACLE_PA),
            11 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015_PREBEAST),
            12 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS),
            13 => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2016),
            14 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2016),
            15 => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2016),
            16 => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2017),
            17 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2017),
            18 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2017),
            19 => ::std::option::Option::Some(EEvent::EVENT_ID_PLUS_SUBSCRIPTION),
            20 => ::std::option::Option::Some(EEvent::EVENT_ID_SINGLES_DAY_2017),
            21 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2017),
            22 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2018),
            23 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2018),
            24 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2019),
            25 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2019),
            26 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_PLAYER_EXPERIENCE),
            27 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2019),
            28 => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2020),
            29 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2020),
            30 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM),
            31 => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE_2020),
            32 => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_2021),
            33 => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_2021),
            34 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM_FALL_2021),
            35 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR2),
            36 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2022),
            37 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR3),
            38 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_INTERNATIONAL_2022),
            39 => ::std::option::Option::Some(EEvent::EVENT_ID_PERMANENT_GRANTS),
            40 => ::std::option::Option::Some(EEvent::EVENT_ID_MUERTA_RELEASE_SPRING2023),
            41 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR1),
            42 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR2),
            43 => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR3),
            45 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2023),
            46 => ::std::option::Option::Some(EEvent::EVENT_ID_10TH_ANNIVERSARY),
            47 => ::std::option::Option::Some(EEvent::EVENT_ID_CROWNFALL),
            48 => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2023),
            49 => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2024),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EEvent> {
        match str {
            "EVENT_ID_NONE" => ::std::option::Option::Some(EEvent::EVENT_ID_NONE),
            "EVENT_ID_DIRETIDE" => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE),
            "EVENT_ID_SPRING_FESTIVAL" => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_FESTIVAL),
            "EVENT_ID_FROSTIVUS_2013" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2013),
            "EVENT_ID_COMPENDIUM_2014" => ::std::option::Option::Some(EEvent::EVENT_ID_COMPENDIUM_2014),
            "EVENT_ID_NEXON_PC_BANG" => ::std::option::Option::Some(EEvent::EVENT_ID_NEXON_PC_BANG),
            "EVENT_ID_PWRD_DAC_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_PWRD_DAC_2015),
            "EVENT_ID_NEW_BLOOM_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015),
            "EVENT_ID_INTERNATIONAL_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2015),
            "EVENT_ID_FALL_MAJOR_2015" => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2015),
            "EVENT_ID_ORACLE_PA" => ::std::option::Option::Some(EEvent::EVENT_ID_ORACLE_PA),
            "EVENT_ID_NEW_BLOOM_2015_PREBEAST" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2015_PREBEAST),
            "EVENT_ID_FROSTIVUS" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS),
            "EVENT_ID_WINTER_MAJOR_2016" => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2016),
            "EVENT_ID_INTERNATIONAL_2016" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2016),
            "EVENT_ID_FALL_MAJOR_2016" => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_MAJOR_2016),
            "EVENT_ID_WINTER_MAJOR_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_WINTER_MAJOR_2017),
            "EVENT_ID_NEW_BLOOM_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2017),
            "EVENT_ID_INTERNATIONAL_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2017),
            "EVENT_ID_PLUS_SUBSCRIPTION" => ::std::option::Option::Some(EEvent::EVENT_ID_PLUS_SUBSCRIPTION),
            "EVENT_ID_SINGLES_DAY_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_SINGLES_DAY_2017),
            "EVENT_ID_FROSTIVUS_2017" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2017),
            "EVENT_ID_INTERNATIONAL_2018" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2018),
            "EVENT_ID_FROSTIVUS_2018" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2018),
            "EVENT_ID_NEW_BLOOM_2019" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2019),
            "EVENT_ID_INTERNATIONAL_2019" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2019),
            "EVENT_ID_NEW_PLAYER_EXPERIENCE" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_PLAYER_EXPERIENCE),
            "EVENT_ID_FROSTIVUS_2019" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2019),
            "EVENT_ID_NEW_BLOOM_2020" => ::std::option::Option::Some(EEvent::EVENT_ID_NEW_BLOOM_2020),
            "EVENT_ID_INTERNATIONAL_2020" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2020),
            "EVENT_ID_TEAM_FANDOM" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM),
            "EVENT_ID_DIRETIDE_2020" => ::std::option::Option::Some(EEvent::EVENT_ID_DIRETIDE_2020),
            "EVENT_ID_SPRING_2021" => ::std::option::Option::Some(EEvent::EVENT_ID_SPRING_2021),
            "EVENT_ID_FALL_2021" => ::std::option::Option::Some(EEvent::EVENT_ID_FALL_2021),
            "EVENT_ID_TEAM_FANDOM_FALL_2021" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_FANDOM_FALL_2021),
            "EVENT_ID_TEAM_2021_2022_TOUR2" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR2),
            "EVENT_ID_INTERNATIONAL_2022" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2022),
            "EVENT_ID_TEAM_2021_2022_TOUR3" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2021_2022_TOUR3),
            "EVENT_ID_TEAM_INTERNATIONAL_2022" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_INTERNATIONAL_2022),
            "EVENT_ID_PERMANENT_GRANTS" => ::std::option::Option::Some(EEvent::EVENT_ID_PERMANENT_GRANTS),
            "EVENT_ID_MUERTA_RELEASE_SPRING2023" => ::std::option::Option::Some(EEvent::EVENT_ID_MUERTA_RELEASE_SPRING2023),
            "EVENT_ID_TEAM_2023_TOUR1" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR1),
            "EVENT_ID_TEAM_2023_TOUR2" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR2),
            "EVENT_ID_TEAM_2023_TOUR3" => ::std::option::Option::Some(EEvent::EVENT_ID_TEAM_2023_TOUR3),
            "EVENT_ID_INTERNATIONAL_2023" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2023),
            "EVENT_ID_10TH_ANNIVERSARY" => ::std::option::Option::Some(EEvent::EVENT_ID_10TH_ANNIVERSARY),
            "EVENT_ID_CROWNFALL" => ::std::option::Option::Some(EEvent::EVENT_ID_CROWNFALL),
            "EVENT_ID_FROSTIVUS_2023" => ::std::option::Option::Some(EEvent::EVENT_ID_FROSTIVUS_2023),
            "EVENT_ID_INTERNATIONAL_2024" => ::std::option::Option::Some(EEvent::EVENT_ID_INTERNATIONAL_2024),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EEvent] = &[
        EEvent::EVENT_ID_NONE,
        EEvent::EVENT_ID_DIRETIDE,
        EEvent::EVENT_ID_SPRING_FESTIVAL,
        EEvent::EVENT_ID_FROSTIVUS_2013,
        EEvent::EVENT_ID_COMPENDIUM_2014,
        EEvent::EVENT_ID_NEXON_PC_BANG,
        EEvent::EVENT_ID_PWRD_DAC_2015,
        EEvent::EVENT_ID_NEW_BLOOM_2015,
        EEvent::EVENT_ID_INTERNATIONAL_2015,
        EEvent::EVENT_ID_FALL_MAJOR_2015,
        EEvent::EVENT_ID_ORACLE_PA,
        EEvent::EVENT_ID_NEW_BLOOM_2015_PREBEAST,
        EEvent::EVENT_ID_FROSTIVUS,
        EEvent::EVENT_ID_WINTER_MAJOR_2016,
        EEvent::EVENT_ID_INTERNATIONAL_2016,
        EEvent::EVENT_ID_FALL_MAJOR_2016,
        EEvent::EVENT_ID_WINTER_MAJOR_2017,
        EEvent::EVENT_ID_NEW_BLOOM_2017,
        EEvent::EVENT_ID_INTERNATIONAL_2017,
        EEvent::EVENT_ID_PLUS_SUBSCRIPTION,
        EEvent::EVENT_ID_SINGLES_DAY_2017,
        EEvent::EVENT_ID_FROSTIVUS_2017,
        EEvent::EVENT_ID_INTERNATIONAL_2018,
        EEvent::EVENT_ID_FROSTIVUS_2018,
        EEvent::EVENT_ID_NEW_BLOOM_2019,
        EEvent::EVENT_ID_INTERNATIONAL_2019,
        EEvent::EVENT_ID_NEW_PLAYER_EXPERIENCE,
        EEvent::EVENT_ID_FROSTIVUS_2019,
        EEvent::EVENT_ID_NEW_BLOOM_2020,
        EEvent::EVENT_ID_INTERNATIONAL_2020,
        EEvent::EVENT_ID_TEAM_FANDOM,
        EEvent::EVENT_ID_DIRETIDE_2020,
        EEvent::EVENT_ID_SPRING_2021,
        EEvent::EVENT_ID_FALL_2021,
        EEvent::EVENT_ID_TEAM_FANDOM_FALL_2021,
        EEvent::EVENT_ID_TEAM_2021_2022_TOUR2,
        EEvent::EVENT_ID_INTERNATIONAL_2022,
        EEvent::EVENT_ID_TEAM_2021_2022_TOUR3,
        EEvent::EVENT_ID_TEAM_INTERNATIONAL_2022,
        EEvent::EVENT_ID_PERMANENT_GRANTS,
        EEvent::EVENT_ID_MUERTA_RELEASE_SPRING2023,
        EEvent::EVENT_ID_TEAM_2023_TOUR1,
        EEvent::EVENT_ID_TEAM_2023_TOUR2,
        EEvent::EVENT_ID_TEAM_2023_TOUR3,
        EEvent::EVENT_ID_INTERNATIONAL_2023,
        EEvent::EVENT_ID_10TH_ANNIVERSARY,
        EEvent::EVENT_ID_CROWNFALL,
        EEvent::EVENT_ID_FROSTIVUS_2023,
        EEvent::EVENT_ID_INTERNATIONAL_2024,
    ];
}

impl ::std::default::Default for EEvent {
    fn default() -> Self {
        EEvent::EVENT_ID_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERankType)
pub enum ERankType {
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_Invalid)
    k_ERankType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_Casual)
    k_ERankType_Casual = 1,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_Ranked)
    k_ERankType_Ranked = 2,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_CasualLegacy)
    k_ERankType_CasualLegacy = 3,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_RankedLegacy)
    k_ERankType_RankedLegacy = 4,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_CasualGlicko)
    k_ERankType_CasualGlicko = 5,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_RankedGlicko)
    k_ERankType_RankedGlicko = 6,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_RankMax)
    k_ERankType_RankMax = 7,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_BehaviorPrivate)
    k_ERankType_BehaviorPrivate = 100,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_BehaviorPublic)
    k_ERankType_BehaviorPublic = 101,
    // @@protoc_insertion_point(enum_value:ERankType.k_ERankType_Max)
    k_ERankType_Max = 102,
}

impl ::steam_vent_proto_common::protobuf::Enum for ERankType {
    const NAME: &'static str = "ERankType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERankType> {
        match value {
            0 => ::std::option::Option::Some(ERankType::k_ERankType_Invalid),
            1 => ::std::option::Option::Some(ERankType::k_ERankType_Casual),
            2 => ::std::option::Option::Some(ERankType::k_ERankType_Ranked),
            3 => ::std::option::Option::Some(ERankType::k_ERankType_CasualLegacy),
            4 => ::std::option::Option::Some(ERankType::k_ERankType_RankedLegacy),
            5 => ::std::option::Option::Some(ERankType::k_ERankType_CasualGlicko),
            6 => ::std::option::Option::Some(ERankType::k_ERankType_RankedGlicko),
            7 => ::std::option::Option::Some(ERankType::k_ERankType_RankMax),
            100 => ::std::option::Option::Some(ERankType::k_ERankType_BehaviorPrivate),
            101 => ::std::option::Option::Some(ERankType::k_ERankType_BehaviorPublic),
            102 => ::std::option::Option::Some(ERankType::k_ERankType_Max),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERankType> {
        match str {
            "k_ERankType_Invalid" => ::std::option::Option::Some(ERankType::k_ERankType_Invalid),
            "k_ERankType_Casual" => ::std::option::Option::Some(ERankType::k_ERankType_Casual),
            "k_ERankType_Ranked" => ::std::option::Option::Some(ERankType::k_ERankType_Ranked),
            "k_ERankType_CasualLegacy" => ::std::option::Option::Some(ERankType::k_ERankType_CasualLegacy),
            "k_ERankType_RankedLegacy" => ::std::option::Option::Some(ERankType::k_ERankType_RankedLegacy),
            "k_ERankType_CasualGlicko" => ::std::option::Option::Some(ERankType::k_ERankType_CasualGlicko),
            "k_ERankType_RankedGlicko" => ::std::option::Option::Some(ERankType::k_ERankType_RankedGlicko),
            "k_ERankType_RankMax" => ::std::option::Option::Some(ERankType::k_ERankType_RankMax),
            "k_ERankType_BehaviorPrivate" => ::std::option::Option::Some(ERankType::k_ERankType_BehaviorPrivate),
            "k_ERankType_BehaviorPublic" => ::std::option::Option::Some(ERankType::k_ERankType_BehaviorPublic),
            "k_ERankType_Max" => ::std::option::Option::Some(ERankType::k_ERankType_Max),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERankType] = &[
        ERankType::k_ERankType_Invalid,
        ERankType::k_ERankType_Casual,
        ERankType::k_ERankType_Ranked,
        ERankType::k_ERankType_CasualLegacy,
        ERankType::k_ERankType_RankedLegacy,
        ERankType::k_ERankType_CasualGlicko,
        ERankType::k_ERankType_RankedGlicko,
        ERankType::k_ERankType_RankMax,
        ERankType::k_ERankType_BehaviorPrivate,
        ERankType::k_ERankType_BehaviorPublic,
        ERankType::k_ERankType_Max,
    ];
}

impl ::std::default::Default for ERankType {
    fn default() -> Self {
        ERankType::k_ERankType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTALeaverStatus_t)
pub enum DOTALeaverStatus_t {
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_NONE)
    DOTA_LEAVER_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_DISCONNECTED)
    DOTA_LEAVER_DISCONNECTED = 1,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_DISCONNECTED_TOO_LONG)
    DOTA_LEAVER_DISCONNECTED_TOO_LONG = 2,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_ABANDONED)
    DOTA_LEAVER_ABANDONED = 3,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_AFK)
    DOTA_LEAVER_AFK = 4,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_NEVER_CONNECTED)
    DOTA_LEAVER_NEVER_CONNECTED = 5,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG)
    DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG = 6,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_FAILED_TO_READY_UP)
    DOTA_LEAVER_FAILED_TO_READY_UP = 7,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_DECLINED)
    DOTA_LEAVER_DECLINED = 8,
    // @@protoc_insertion_point(enum_value:DOTALeaverStatus_t.DOTA_LEAVER_DECLINED_REQUEUE)
    DOTA_LEAVER_DECLINED_REQUEUE = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTALeaverStatus_t {
    const NAME: &'static str = "DOTALeaverStatus_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALeaverStatus_t> {
        match value {
            0 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            1 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED),
            2 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED_TOO_LONG),
            3 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_ABANDONED),
            4 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_AFK),
            5 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED),
            6 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG),
            7 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_FAILED_TO_READY_UP),
            8 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DECLINED),
            9 => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DECLINED_REQUEUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALeaverStatus_t> {
        match str {
            "DOTA_LEAVER_NONE" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            "DOTA_LEAVER_DISCONNECTED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED),
            "DOTA_LEAVER_DISCONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED_TOO_LONG),
            "DOTA_LEAVER_ABANDONED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_ABANDONED),
            "DOTA_LEAVER_AFK" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_AFK),
            "DOTA_LEAVER_NEVER_CONNECTED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED),
            "DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG),
            "DOTA_LEAVER_FAILED_TO_READY_UP" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_FAILED_TO_READY_UP),
            "DOTA_LEAVER_DECLINED" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DECLINED),
            "DOTA_LEAVER_DECLINED_REQUEUE" => ::std::option::Option::Some(DOTALeaverStatus_t::DOTA_LEAVER_DECLINED_REQUEUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALeaverStatus_t] = &[
        DOTALeaverStatus_t::DOTA_LEAVER_NONE,
        DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED,
        DOTALeaverStatus_t::DOTA_LEAVER_DISCONNECTED_TOO_LONG,
        DOTALeaverStatus_t::DOTA_LEAVER_ABANDONED,
        DOTALeaverStatus_t::DOTA_LEAVER_AFK,
        DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED,
        DOTALeaverStatus_t::DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG,
        DOTALeaverStatus_t::DOTA_LEAVER_FAILED_TO_READY_UP,
        DOTALeaverStatus_t::DOTA_LEAVER_DECLINED,
        DOTALeaverStatus_t::DOTA_LEAVER_DECLINED_REQUEUE,
    ];
}

impl ::std::default::Default for DOTALeaverStatus_t {
    fn default() -> Self {
        DOTALeaverStatus_t::DOTA_LEAVER_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTAConnectionState_t)
pub enum DOTAConnectionState_t {
    // @@protoc_insertion_point(enum_value:DOTAConnectionState_t.DOTA_CONNECTION_STATE_UNKNOWN)
    DOTA_CONNECTION_STATE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:DOTAConnectionState_t.DOTA_CONNECTION_STATE_NOT_YET_CONNECTED)
    DOTA_CONNECTION_STATE_NOT_YET_CONNECTED = 1,
    // @@protoc_insertion_point(enum_value:DOTAConnectionState_t.DOTA_CONNECTION_STATE_CONNECTED)
    DOTA_CONNECTION_STATE_CONNECTED = 2,
    // @@protoc_insertion_point(enum_value:DOTAConnectionState_t.DOTA_CONNECTION_STATE_DISCONNECTED)
    DOTA_CONNECTION_STATE_DISCONNECTED = 3,
    // @@protoc_insertion_point(enum_value:DOTAConnectionState_t.DOTA_CONNECTION_STATE_ABANDONED)
    DOTA_CONNECTION_STATE_ABANDONED = 4,
    // @@protoc_insertion_point(enum_value:DOTAConnectionState_t.DOTA_CONNECTION_STATE_LOADING)
    DOTA_CONNECTION_STATE_LOADING = 5,
    // @@protoc_insertion_point(enum_value:DOTAConnectionState_t.DOTA_CONNECTION_STATE_FAILED)
    DOTA_CONNECTION_STATE_FAILED = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTAConnectionState_t {
    const NAME: &'static str = "DOTAConnectionState_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAConnectionState_t> {
        match value {
            0 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN),
            1 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_NOT_YET_CONNECTED),
            2 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_CONNECTED),
            3 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_DISCONNECTED),
            4 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_ABANDONED),
            5 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_LOADING),
            6 => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAConnectionState_t> {
        match str {
            "DOTA_CONNECTION_STATE_UNKNOWN" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN),
            "DOTA_CONNECTION_STATE_NOT_YET_CONNECTED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_NOT_YET_CONNECTED),
            "DOTA_CONNECTION_STATE_CONNECTED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_CONNECTED),
            "DOTA_CONNECTION_STATE_DISCONNECTED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_DISCONNECTED),
            "DOTA_CONNECTION_STATE_ABANDONED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_ABANDONED),
            "DOTA_CONNECTION_STATE_LOADING" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_LOADING),
            "DOTA_CONNECTION_STATE_FAILED" => ::std::option::Option::Some(DOTAConnectionState_t::DOTA_CONNECTION_STATE_FAILED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAConnectionState_t] = &[
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_NOT_YET_CONNECTED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_CONNECTED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_DISCONNECTED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_ABANDONED,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_LOADING,
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_FAILED,
    ];
}

impl ::std::default::Default for DOTAConnectionState_t {
    fn default() -> Self {
        DOTAConnectionState_t::DOTA_CONNECTION_STATE_UNKNOWN
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Fantasy_Roles)
pub enum Fantasy_Roles {
    // @@protoc_insertion_point(enum_value:Fantasy_Roles.FANTASY_ROLE_UNDEFINED)
    FANTASY_ROLE_UNDEFINED = 0,
    // @@protoc_insertion_point(enum_value:Fantasy_Roles.FANTASY_ROLE_CORE)
    FANTASY_ROLE_CORE = 1,
    // @@protoc_insertion_point(enum_value:Fantasy_Roles.FANTASY_ROLE_SUPPORT)
    FANTASY_ROLE_SUPPORT = 2,
    // @@protoc_insertion_point(enum_value:Fantasy_Roles.FANTASY_ROLE_OFFLANE)
    FANTASY_ROLE_OFFLANE = 3,
    // @@protoc_insertion_point(enum_value:Fantasy_Roles.FANTASY_ROLE_MID)
    FANTASY_ROLE_MID = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for Fantasy_Roles {
    const NAME: &'static str = "Fantasy_Roles";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Roles> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_UNDEFINED),
            1 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_CORE),
            2 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_SUPPORT),
            3 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_OFFLANE),
            4 => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_MID),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Roles> {
        match str {
            "FANTASY_ROLE_UNDEFINED" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_UNDEFINED),
            "FANTASY_ROLE_CORE" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_CORE),
            "FANTASY_ROLE_SUPPORT" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_SUPPORT),
            "FANTASY_ROLE_OFFLANE" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_OFFLANE),
            "FANTASY_ROLE_MID" => ::std::option::Option::Some(Fantasy_Roles::FANTASY_ROLE_MID),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Roles] = &[
        Fantasy_Roles::FANTASY_ROLE_UNDEFINED,
        Fantasy_Roles::FANTASY_ROLE_CORE,
        Fantasy_Roles::FANTASY_ROLE_SUPPORT,
        Fantasy_Roles::FANTASY_ROLE_OFFLANE,
        Fantasy_Roles::FANTASY_ROLE_MID,
    ];
}

impl ::std::default::Default for Fantasy_Roles {
    fn default() -> Self {
        Fantasy_Roles::FANTASY_ROLE_UNDEFINED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Fantasy_Scoring)
pub enum Fantasy_Scoring {
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_KILLS)
    FANTASY_SCORING_KILLS = 0,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_DEATHS)
    FANTASY_SCORING_DEATHS = 1,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_CS)
    FANTASY_SCORING_CS = 2,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_GPM)
    FANTASY_SCORING_GPM = 3,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_TOWER_KILLS)
    FANTASY_SCORING_TOWER_KILLS = 4,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_ROSHAN_KILLS)
    FANTASY_SCORING_ROSHAN_KILLS = 5,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_TEAMFIGHT_PARTICIPATION)
    FANTASY_SCORING_TEAMFIGHT_PARTICIPATION = 6,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_WARDS_PLANTED)
    FANTASY_SCORING_WARDS_PLANTED = 7,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_CAMPS_STACKED)
    FANTASY_SCORING_CAMPS_STACKED = 8,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_RUNES_GRABBED)
    FANTASY_SCORING_RUNES_GRABBED = 9,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_FIRST_BLOOD)
    FANTASY_SCORING_FIRST_BLOOD = 10,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_STUNS)
    FANTASY_SCORING_STUNS = 11,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_SMOKES_USED)
    FANTASY_SCORING_SMOKES_USED = 12,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_NEUTRAL_TOKENS_FOUND)
    FANTASY_SCORING_NEUTRAL_TOKENS_FOUND = 13,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_WATCHERS_TAKEN)
    FANTASY_SCORING_WATCHERS_TAKEN = 14,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_LOTUSES_GAINED)
    FANTASY_SCORING_LOTUSES_GAINED = 15,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_TORMENTOR_KILLS)
    FANTASY_SCORING_TORMENTOR_KILLS = 16,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_COURIER_KILLS)
    FANTASY_SCORING_COURIER_KILLS = 17,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_TYPES)
    FANTASY_SCORING_TYPES = 18,
    // @@protoc_insertion_point(enum_value:Fantasy_Scoring.FANTASY_SCORING_INVALID)
    FANTASY_SCORING_INVALID = 19,
}

impl ::steam_vent_proto_common::protobuf::Enum for Fantasy_Scoring {
    const NAME: &'static str = "Fantasy_Scoring";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Scoring> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_KILLS),
            1 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_DEATHS),
            2 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_CS),
            3 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_GPM),
            4 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TOWER_KILLS),
            5 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_ROSHAN_KILLS),
            6 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TEAMFIGHT_PARTICIPATION),
            7 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_WARDS_PLANTED),
            8 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_CAMPS_STACKED),
            9 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_RUNES_GRABBED),
            10 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_FIRST_BLOOD),
            11 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_STUNS),
            12 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_SMOKES_USED),
            13 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_NEUTRAL_TOKENS_FOUND),
            14 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_WATCHERS_TAKEN),
            15 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_LOTUSES_GAINED),
            16 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TORMENTOR_KILLS),
            17 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_COURIER_KILLS),
            18 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TYPES),
            19 => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_INVALID),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Scoring> {
        match str {
            "FANTASY_SCORING_KILLS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_KILLS),
            "FANTASY_SCORING_DEATHS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_DEATHS),
            "FANTASY_SCORING_CS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_CS),
            "FANTASY_SCORING_GPM" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_GPM),
            "FANTASY_SCORING_TOWER_KILLS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TOWER_KILLS),
            "FANTASY_SCORING_ROSHAN_KILLS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_ROSHAN_KILLS),
            "FANTASY_SCORING_TEAMFIGHT_PARTICIPATION" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TEAMFIGHT_PARTICIPATION),
            "FANTASY_SCORING_WARDS_PLANTED" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_WARDS_PLANTED),
            "FANTASY_SCORING_CAMPS_STACKED" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_CAMPS_STACKED),
            "FANTASY_SCORING_RUNES_GRABBED" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_RUNES_GRABBED),
            "FANTASY_SCORING_FIRST_BLOOD" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_FIRST_BLOOD),
            "FANTASY_SCORING_STUNS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_STUNS),
            "FANTASY_SCORING_SMOKES_USED" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_SMOKES_USED),
            "FANTASY_SCORING_NEUTRAL_TOKENS_FOUND" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_NEUTRAL_TOKENS_FOUND),
            "FANTASY_SCORING_WATCHERS_TAKEN" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_WATCHERS_TAKEN),
            "FANTASY_SCORING_LOTUSES_GAINED" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_LOTUSES_GAINED),
            "FANTASY_SCORING_TORMENTOR_KILLS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TORMENTOR_KILLS),
            "FANTASY_SCORING_COURIER_KILLS" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_COURIER_KILLS),
            "FANTASY_SCORING_TYPES" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_TYPES),
            "FANTASY_SCORING_INVALID" => ::std::option::Option::Some(Fantasy_Scoring::FANTASY_SCORING_INVALID),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Scoring] = &[
        Fantasy_Scoring::FANTASY_SCORING_KILLS,
        Fantasy_Scoring::FANTASY_SCORING_DEATHS,
        Fantasy_Scoring::FANTASY_SCORING_CS,
        Fantasy_Scoring::FANTASY_SCORING_GPM,
        Fantasy_Scoring::FANTASY_SCORING_TOWER_KILLS,
        Fantasy_Scoring::FANTASY_SCORING_ROSHAN_KILLS,
        Fantasy_Scoring::FANTASY_SCORING_TEAMFIGHT_PARTICIPATION,
        Fantasy_Scoring::FANTASY_SCORING_WARDS_PLANTED,
        Fantasy_Scoring::FANTASY_SCORING_CAMPS_STACKED,
        Fantasy_Scoring::FANTASY_SCORING_RUNES_GRABBED,
        Fantasy_Scoring::FANTASY_SCORING_FIRST_BLOOD,
        Fantasy_Scoring::FANTASY_SCORING_STUNS,
        Fantasy_Scoring::FANTASY_SCORING_SMOKES_USED,
        Fantasy_Scoring::FANTASY_SCORING_NEUTRAL_TOKENS_FOUND,
        Fantasy_Scoring::FANTASY_SCORING_WATCHERS_TAKEN,
        Fantasy_Scoring::FANTASY_SCORING_LOTUSES_GAINED,
        Fantasy_Scoring::FANTASY_SCORING_TORMENTOR_KILLS,
        Fantasy_Scoring::FANTASY_SCORING_COURIER_KILLS,
        Fantasy_Scoring::FANTASY_SCORING_TYPES,
        Fantasy_Scoring::FANTASY_SCORING_INVALID,
    ];
}

impl ::std::default::Default for Fantasy_Scoring {
    fn default() -> Self {
        Fantasy_Scoring::FANTASY_SCORING_KILLS
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Fantasy_Team_Slots)
pub enum Fantasy_Team_Slots {
    // @@protoc_insertion_point(enum_value:Fantasy_Team_Slots.FANTASY_SLOT_NONE)
    FANTASY_SLOT_NONE = 0,
    // @@protoc_insertion_point(enum_value:Fantasy_Team_Slots.FANTASY_SLOT_CORE)
    FANTASY_SLOT_CORE = 1,
    // @@protoc_insertion_point(enum_value:Fantasy_Team_Slots.FANTASY_SLOT_SUPPORT)
    FANTASY_SLOT_SUPPORT = 2,
    // @@protoc_insertion_point(enum_value:Fantasy_Team_Slots.FANTASY_SLOT_ANY)
    FANTASY_SLOT_ANY = 3,
    // @@protoc_insertion_point(enum_value:Fantasy_Team_Slots.FANTASY_SLOT_BENCH)
    FANTASY_SLOT_BENCH = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for Fantasy_Team_Slots {
    const NAME: &'static str = "Fantasy_Team_Slots";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Team_Slots> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_NONE),
            1 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_CORE),
            2 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_SUPPORT),
            3 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_ANY),
            4 => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_BENCH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Team_Slots> {
        match str {
            "FANTASY_SLOT_NONE" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_NONE),
            "FANTASY_SLOT_CORE" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_CORE),
            "FANTASY_SLOT_SUPPORT" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_SUPPORT),
            "FANTASY_SLOT_ANY" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_ANY),
            "FANTASY_SLOT_BENCH" => ::std::option::Option::Some(Fantasy_Team_Slots::FANTASY_SLOT_BENCH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Team_Slots] = &[
        Fantasy_Team_Slots::FANTASY_SLOT_NONE,
        Fantasy_Team_Slots::FANTASY_SLOT_CORE,
        Fantasy_Team_Slots::FANTASY_SLOT_SUPPORT,
        Fantasy_Team_Slots::FANTASY_SLOT_ANY,
        Fantasy_Team_Slots::FANTASY_SLOT_BENCH,
    ];
}

impl ::std::default::Default for Fantasy_Team_Slots {
    fn default() -> Self {
        Fantasy_Team_Slots::FANTASY_SLOT_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Fantasy_Selection_Mode)
pub enum Fantasy_Selection_Mode {
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_INVALID)
    FANTASY_SELECTION_INVALID = 0,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_LOCKED)
    FANTASY_SELECTION_LOCKED = 1,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_SHUFFLE)
    FANTASY_SELECTION_SHUFFLE = 2,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_FREE_PICK)
    FANTASY_SELECTION_FREE_PICK = 3,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_ENDED)
    FANTASY_SELECTION_ENDED = 4,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_PRE_SEASON)
    FANTASY_SELECTION_PRE_SEASON = 5,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_PRE_DRAFT)
    FANTASY_SELECTION_PRE_DRAFT = 6,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_DRAFTING)
    FANTASY_SELECTION_DRAFTING = 7,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_REGULAR_SEASON)
    FANTASY_SELECTION_REGULAR_SEASON = 8,
    // @@protoc_insertion_point(enum_value:Fantasy_Selection_Mode.FANTASY_SELECTION_CARD_BASED)
    FANTASY_SELECTION_CARD_BASED = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for Fantasy_Selection_Mode {
    const NAME: &'static str = "Fantasy_Selection_Mode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Selection_Mode> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID),
            1 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_LOCKED),
            2 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_SHUFFLE),
            3 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_FREE_PICK),
            4 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_ENDED),
            5 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_SEASON),
            6 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_DRAFT),
            7 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_DRAFTING),
            8 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_REGULAR_SEASON),
            9 => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_CARD_BASED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Selection_Mode> {
        match str {
            "FANTASY_SELECTION_INVALID" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID),
            "FANTASY_SELECTION_LOCKED" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_LOCKED),
            "FANTASY_SELECTION_SHUFFLE" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_SHUFFLE),
            "FANTASY_SELECTION_FREE_PICK" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_FREE_PICK),
            "FANTASY_SELECTION_ENDED" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_ENDED),
            "FANTASY_SELECTION_PRE_SEASON" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_SEASON),
            "FANTASY_SELECTION_PRE_DRAFT" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_DRAFT),
            "FANTASY_SELECTION_DRAFTING" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_DRAFTING),
            "FANTASY_SELECTION_REGULAR_SEASON" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_REGULAR_SEASON),
            "FANTASY_SELECTION_CARD_BASED" => ::std::option::Option::Some(Fantasy_Selection_Mode::FANTASY_SELECTION_CARD_BASED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Selection_Mode] = &[
        Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID,
        Fantasy_Selection_Mode::FANTASY_SELECTION_LOCKED,
        Fantasy_Selection_Mode::FANTASY_SELECTION_SHUFFLE,
        Fantasy_Selection_Mode::FANTASY_SELECTION_FREE_PICK,
        Fantasy_Selection_Mode::FANTASY_SELECTION_ENDED,
        Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_SEASON,
        Fantasy_Selection_Mode::FANTASY_SELECTION_PRE_DRAFT,
        Fantasy_Selection_Mode::FANTASY_SELECTION_DRAFTING,
        Fantasy_Selection_Mode::FANTASY_SELECTION_REGULAR_SEASON,
        Fantasy_Selection_Mode::FANTASY_SELECTION_CARD_BASED,
    ];
}

impl ::std::default::Default for Fantasy_Selection_Mode {
    fn default() -> Self {
        Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Fantasy_Gem_Type)
pub enum Fantasy_Gem_Type {
    // @@protoc_insertion_point(enum_value:Fantasy_Gem_Type.FANTASY_GEM_TYPE_RUBY)
    FANTASY_GEM_TYPE_RUBY = 0,
    // @@protoc_insertion_point(enum_value:Fantasy_Gem_Type.FANTASY_GEM_TYPE_SAPPHIRE)
    FANTASY_GEM_TYPE_SAPPHIRE = 1,
    // @@protoc_insertion_point(enum_value:Fantasy_Gem_Type.FANTASY_GEM_TYPE_EMERALD)
    FANTASY_GEM_TYPE_EMERALD = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for Fantasy_Gem_Type {
    const NAME: &'static str = "Fantasy_Gem_Type";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fantasy_Gem_Type> {
        match value {
            0 => ::std::option::Option::Some(Fantasy_Gem_Type::FANTASY_GEM_TYPE_RUBY),
            1 => ::std::option::Option::Some(Fantasy_Gem_Type::FANTASY_GEM_TYPE_SAPPHIRE),
            2 => ::std::option::Option::Some(Fantasy_Gem_Type::FANTASY_GEM_TYPE_EMERALD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fantasy_Gem_Type> {
        match str {
            "FANTASY_GEM_TYPE_RUBY" => ::std::option::Option::Some(Fantasy_Gem_Type::FANTASY_GEM_TYPE_RUBY),
            "FANTASY_GEM_TYPE_SAPPHIRE" => ::std::option::Option::Some(Fantasy_Gem_Type::FANTASY_GEM_TYPE_SAPPHIRE),
            "FANTASY_GEM_TYPE_EMERALD" => ::std::option::Option::Some(Fantasy_Gem_Type::FANTASY_GEM_TYPE_EMERALD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fantasy_Gem_Type] = &[
        Fantasy_Gem_Type::FANTASY_GEM_TYPE_RUBY,
        Fantasy_Gem_Type::FANTASY_GEM_TYPE_SAPPHIRE,
        Fantasy_Gem_Type::FANTASY_GEM_TYPE_EMERALD,
    ];
}

impl ::std::default::Default for Fantasy_Gem_Type {
    fn default() -> Self {
        Fantasy_Gem_Type::FANTASY_GEM_TYPE_RUBY
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTAChatChannelType_t)
pub enum DOTAChatChannelType_t {
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Regional)
    DOTAChannelType_Regional = 0,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Custom)
    DOTAChannelType_Custom = 1,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Party)
    DOTAChannelType_Party = 2,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Lobby)
    DOTAChannelType_Lobby = 3,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Team)
    DOTAChannelType_Team = 4,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Guild)
    DOTAChannelType_Guild = 5,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Fantasy)
    DOTAChannelType_Fantasy = 6,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Whisper)
    DOTAChannelType_Whisper = 7,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Console)
    DOTAChannelType_Console = 8,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Tab)
    DOTAChannelType_Tab = 9,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Invalid)
    DOTAChannelType_Invalid = 10,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_GameAll)
    DOTAChannelType_GameAll = 11,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_GameAllies)
    DOTAChannelType_GameAllies = 12,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_GameSpectator)
    DOTAChannelType_GameSpectator = 13,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_GameCoaching)
    DOTAChannelType_GameCoaching = 14,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Cafe)
    DOTAChannelType_Cafe = 15,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_CustomGame)
    DOTAChannelType_CustomGame = 16,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Private)
    DOTAChannelType_Private = 17,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_PostGame)
    DOTAChannelType_PostGame = 18,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_BattleCup)
    DOTAChannelType_BattleCup = 19,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_HLTVSpectator)
    DOTAChannelType_HLTVSpectator = 20,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_GameEvents)
    DOTAChannelType_GameEvents = 21,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_Trivia)
    DOTAChannelType_Trivia = 22,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_NewPlayer)
    DOTAChannelType_NewPlayer = 23,
    // @@protoc_insertion_point(enum_value:DOTAChatChannelType_t.DOTAChannelType_PrivateCoaching)
    DOTAChannelType_PrivateCoaching = 24,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTAChatChannelType_t {
    const NAME: &'static str = "DOTAChatChannelType_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAChatChannelType_t> {
        match value {
            0 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Regional),
            1 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Custom),
            2 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Party),
            3 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Lobby),
            4 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Team),
            5 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Guild),
            6 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Fantasy),
            7 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Whisper),
            8 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Console),
            9 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Tab),
            10 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Invalid),
            11 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAll),
            12 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAllies),
            13 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameSpectator),
            14 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameCoaching),
            15 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Cafe),
            16 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_CustomGame),
            17 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Private),
            18 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PostGame),
            19 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_BattleCup),
            20 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_HLTVSpectator),
            21 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameEvents),
            22 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Trivia),
            23 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_NewPlayer),
            24 => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PrivateCoaching),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAChatChannelType_t> {
        match str {
            "DOTAChannelType_Regional" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Regional),
            "DOTAChannelType_Custom" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Custom),
            "DOTAChannelType_Party" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Party),
            "DOTAChannelType_Lobby" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Lobby),
            "DOTAChannelType_Team" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Team),
            "DOTAChannelType_Guild" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Guild),
            "DOTAChannelType_Fantasy" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Fantasy),
            "DOTAChannelType_Whisper" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Whisper),
            "DOTAChannelType_Console" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Console),
            "DOTAChannelType_Tab" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Tab),
            "DOTAChannelType_Invalid" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Invalid),
            "DOTAChannelType_GameAll" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAll),
            "DOTAChannelType_GameAllies" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameAllies),
            "DOTAChannelType_GameSpectator" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameSpectator),
            "DOTAChannelType_GameCoaching" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameCoaching),
            "DOTAChannelType_Cafe" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Cafe),
            "DOTAChannelType_CustomGame" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_CustomGame),
            "DOTAChannelType_Private" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Private),
            "DOTAChannelType_PostGame" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PostGame),
            "DOTAChannelType_BattleCup" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_BattleCup),
            "DOTAChannelType_HLTVSpectator" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_HLTVSpectator),
            "DOTAChannelType_GameEvents" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_GameEvents),
            "DOTAChannelType_Trivia" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_Trivia),
            "DOTAChannelType_NewPlayer" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_NewPlayer),
            "DOTAChannelType_PrivateCoaching" => ::std::option::Option::Some(DOTAChatChannelType_t::DOTAChannelType_PrivateCoaching),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAChatChannelType_t] = &[
        DOTAChatChannelType_t::DOTAChannelType_Regional,
        DOTAChatChannelType_t::DOTAChannelType_Custom,
        DOTAChatChannelType_t::DOTAChannelType_Party,
        DOTAChatChannelType_t::DOTAChannelType_Lobby,
        DOTAChatChannelType_t::DOTAChannelType_Team,
        DOTAChatChannelType_t::DOTAChannelType_Guild,
        DOTAChatChannelType_t::DOTAChannelType_Fantasy,
        DOTAChatChannelType_t::DOTAChannelType_Whisper,
        DOTAChatChannelType_t::DOTAChannelType_Console,
        DOTAChatChannelType_t::DOTAChannelType_Tab,
        DOTAChatChannelType_t::DOTAChannelType_Invalid,
        DOTAChatChannelType_t::DOTAChannelType_GameAll,
        DOTAChatChannelType_t::DOTAChannelType_GameAllies,
        DOTAChatChannelType_t::DOTAChannelType_GameSpectator,
        DOTAChatChannelType_t::DOTAChannelType_GameCoaching,
        DOTAChatChannelType_t::DOTAChannelType_Cafe,
        DOTAChatChannelType_t::DOTAChannelType_CustomGame,
        DOTAChatChannelType_t::DOTAChannelType_Private,
        DOTAChatChannelType_t::DOTAChannelType_PostGame,
        DOTAChatChannelType_t::DOTAChannelType_BattleCup,
        DOTAChatChannelType_t::DOTAChannelType_HLTVSpectator,
        DOTAChatChannelType_t::DOTAChannelType_GameEvents,
        DOTAChatChannelType_t::DOTAChannelType_Trivia,
        DOTAChatChannelType_t::DOTAChannelType_NewPlayer,
        DOTAChatChannelType_t::DOTAChannelType_PrivateCoaching,
    ];
}

impl ::std::default::Default for DOTAChatChannelType_t {
    fn default() -> Self {
        DOTAChatChannelType_t::DOTAChannelType_Regional
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatSpecialPrivileges)
pub enum EChatSpecialPrivileges {
    // @@protoc_insertion_point(enum_value:EChatSpecialPrivileges.k_EChatSpecialPrivileges_None)
    k_EChatSpecialPrivileges_None = 0,
    // @@protoc_insertion_point(enum_value:EChatSpecialPrivileges.k_EChatSpecialPrivileges_Moderator)
    k_EChatSpecialPrivileges_Moderator = 1,
    // @@protoc_insertion_point(enum_value:EChatSpecialPrivileges.k_EChatSpecialPrivileges_SuperModerator)
    k_EChatSpecialPrivileges_SuperModerator = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EChatSpecialPrivileges {
    const NAME: &'static str = "EChatSpecialPrivileges";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatSpecialPrivileges> {
        match value {
            0 => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_None),
            1 => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_Moderator),
            2 => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_SuperModerator),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatSpecialPrivileges> {
        match str {
            "k_EChatSpecialPrivileges_None" => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_None),
            "k_EChatSpecialPrivileges_Moderator" => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_Moderator),
            "k_EChatSpecialPrivileges_SuperModerator" => ::std::option::Option::Some(EChatSpecialPrivileges::k_EChatSpecialPrivileges_SuperModerator),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatSpecialPrivileges] = &[
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_None,
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_Moderator,
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_SuperModerator,
    ];
}

impl ::std::default::Default for EChatSpecialPrivileges {
    fn default() -> Self {
        EChatSpecialPrivileges::k_EChatSpecialPrivileges_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTACommType_t)
pub enum DOTACommType_t {
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_NONE)
    DOTA_COMM_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_PING)
    DOTA_COMM_TYPE_PING = 1,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_CHATWHEEL)
    DOTA_COMM_TYPE_CHATWHEEL = 2,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_TIP)
    DOTA_COMM_TYPE_TIP = 3,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_TEXT)
    DOTA_COMM_TYPE_TEXT = 4,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_SHOWCASE)
    DOTA_COMM_TYPE_SHOWCASE = 5,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_VOICE)
    DOTA_COMM_TYPE_VOICE = 6,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_ALLY_ABILITY)
    DOTA_COMM_TYPE_ALLY_ABILITY = 7,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_PAUSE)
    DOTA_COMM_TYPE_PAUSE = 8,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_COACHING)
    DOTA_COMM_TYPE_COACHING = 9,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_NOCOOLDOWN)
    DOTA_COMM_TYPE_NOCOOLDOWN = 10,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_RANKEDMATCHMAKE)
    DOTA_COMM_TYPE_RANKEDMATCHMAKE = 11,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_DROPS)
    DOTA_COMM_TYPE_DROPS = 12,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_NEWPLAYER_EXPERT)
    DOTA_COMM_TYPE_NEWPLAYER_EXPERT = 13,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_COACHED)
    DOTA_COMM_TYPE_COACHED = 14,
    // @@protoc_insertion_point(enum_value:DOTACommType_t.DOTA_COMM_TYPE_MAPDRAWING)
    DOTA_COMM_TYPE_MAPDRAWING = 15,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTACommType_t {
    const NAME: &'static str = "DOTACommType_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTACommType_t> {
        match value {
            0 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_NONE),
            1 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_PING),
            2 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_CHATWHEEL),
            3 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_TIP),
            4 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_TEXT),
            5 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_SHOWCASE),
            6 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_VOICE),
            7 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_ALLY_ABILITY),
            8 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_PAUSE),
            9 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_COACHING),
            10 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_NOCOOLDOWN),
            11 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_RANKEDMATCHMAKE),
            12 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_DROPS),
            13 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_NEWPLAYER_EXPERT),
            14 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_COACHED),
            15 => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_MAPDRAWING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTACommType_t> {
        match str {
            "DOTA_COMM_TYPE_NONE" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_NONE),
            "DOTA_COMM_TYPE_PING" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_PING),
            "DOTA_COMM_TYPE_CHATWHEEL" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_CHATWHEEL),
            "DOTA_COMM_TYPE_TIP" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_TIP),
            "DOTA_COMM_TYPE_TEXT" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_TEXT),
            "DOTA_COMM_TYPE_SHOWCASE" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_SHOWCASE),
            "DOTA_COMM_TYPE_VOICE" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_VOICE),
            "DOTA_COMM_TYPE_ALLY_ABILITY" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_ALLY_ABILITY),
            "DOTA_COMM_TYPE_PAUSE" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_PAUSE),
            "DOTA_COMM_TYPE_COACHING" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_COACHING),
            "DOTA_COMM_TYPE_NOCOOLDOWN" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_NOCOOLDOWN),
            "DOTA_COMM_TYPE_RANKEDMATCHMAKE" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_RANKEDMATCHMAKE),
            "DOTA_COMM_TYPE_DROPS" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_DROPS),
            "DOTA_COMM_TYPE_NEWPLAYER_EXPERT" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_NEWPLAYER_EXPERT),
            "DOTA_COMM_TYPE_COACHED" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_COACHED),
            "DOTA_COMM_TYPE_MAPDRAWING" => ::std::option::Option::Some(DOTACommType_t::DOTA_COMM_TYPE_MAPDRAWING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTACommType_t] = &[
        DOTACommType_t::DOTA_COMM_TYPE_NONE,
        DOTACommType_t::DOTA_COMM_TYPE_PING,
        DOTACommType_t::DOTA_COMM_TYPE_CHATWHEEL,
        DOTACommType_t::DOTA_COMM_TYPE_TIP,
        DOTACommType_t::DOTA_COMM_TYPE_TEXT,
        DOTACommType_t::DOTA_COMM_TYPE_SHOWCASE,
        DOTACommType_t::DOTA_COMM_TYPE_VOICE,
        DOTACommType_t::DOTA_COMM_TYPE_ALLY_ABILITY,
        DOTACommType_t::DOTA_COMM_TYPE_PAUSE,
        DOTACommType_t::DOTA_COMM_TYPE_COACHING,
        DOTACommType_t::DOTA_COMM_TYPE_NOCOOLDOWN,
        DOTACommType_t::DOTA_COMM_TYPE_RANKEDMATCHMAKE,
        DOTACommType_t::DOTA_COMM_TYPE_DROPS,
        DOTACommType_t::DOTA_COMM_TYPE_NEWPLAYER_EXPERT,
        DOTACommType_t::DOTA_COMM_TYPE_COACHED,
        DOTACommType_t::DOTA_COMM_TYPE_MAPDRAWING,
    ];
}

impl ::std::default::Default for DOTACommType_t {
    fn default() -> Self {
        DOTACommType_t::DOTA_COMM_TYPE_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTACommLevel_t)
pub enum DOTACommLevel_t {
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_NONE)
    DOTA_COMM_LEVEL_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_COOLDOWN)
    DOTA_COMM_LEVEL_COOLDOWN = 1,
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_PINGS)
    DOTA_COMM_LEVEL_PINGS = 2,
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_MAPDRAWING)
    DOTA_COMM_LEVEL_MAPDRAWING = 3,
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_CHAT)
    DOTA_COMM_LEVEL_CHAT = 4,
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_TIPPING)
    DOTA_COMM_LEVEL_TIPPING = 5,
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_VOICE)
    DOTA_COMM_LEVEL_VOICE = 6,
    // @@protoc_insertion_point(enum_value:DOTACommLevel_t.DOTA_COMM_LEVEL_ALLIED_ABILITY)
    DOTA_COMM_LEVEL_ALLIED_ABILITY = 7,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTACommLevel_t {
    const NAME: &'static str = "DOTACommLevel_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTACommLevel_t> {
        match value {
            0 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_NONE),
            1 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_COOLDOWN),
            2 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_PINGS),
            3 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_MAPDRAWING),
            4 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_CHAT),
            5 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_TIPPING),
            6 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_VOICE),
            7 => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_ALLIED_ABILITY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTACommLevel_t> {
        match str {
            "DOTA_COMM_LEVEL_NONE" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_NONE),
            "DOTA_COMM_LEVEL_COOLDOWN" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_COOLDOWN),
            "DOTA_COMM_LEVEL_PINGS" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_PINGS),
            "DOTA_COMM_LEVEL_MAPDRAWING" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_MAPDRAWING),
            "DOTA_COMM_LEVEL_CHAT" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_CHAT),
            "DOTA_COMM_LEVEL_TIPPING" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_TIPPING),
            "DOTA_COMM_LEVEL_VOICE" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_VOICE),
            "DOTA_COMM_LEVEL_ALLIED_ABILITY" => ::std::option::Option::Some(DOTACommLevel_t::DOTA_COMM_LEVEL_ALLIED_ABILITY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTACommLevel_t] = &[
        DOTACommLevel_t::DOTA_COMM_LEVEL_NONE,
        DOTACommLevel_t::DOTA_COMM_LEVEL_COOLDOWN,
        DOTACommLevel_t::DOTA_COMM_LEVEL_PINGS,
        DOTACommLevel_t::DOTA_COMM_LEVEL_MAPDRAWING,
        DOTACommLevel_t::DOTA_COMM_LEVEL_CHAT,
        DOTACommLevel_t::DOTA_COMM_LEVEL_TIPPING,
        DOTACommLevel_t::DOTA_COMM_LEVEL_VOICE,
        DOTACommLevel_t::DOTA_COMM_LEVEL_ALLIED_ABILITY,
    ];
}

impl ::std::default::Default for DOTACommLevel_t {
    fn default() -> Self {
        DOTACommLevel_t::DOTA_COMM_LEVEL_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTABehaviorLevel_t)
pub enum DOTABehaviorLevel_t {
    // @@protoc_insertion_point(enum_value:DOTABehaviorLevel_t.DOTA_BEHAVIOR_LEVEL_NONE)
    DOTA_BEHAVIOR_LEVEL_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTABehaviorLevel_t.DOTA_BEHAVIOR_LEVEL_RANKED_ALLOWED)
    DOTA_BEHAVIOR_LEVEL_RANKED_ALLOWED = 1,
    // @@protoc_insertion_point(enum_value:DOTABehaviorLevel_t.DOTA_BEHAVIOR_LEVEL_PAUSING)
    DOTA_BEHAVIOR_LEVEL_PAUSING = 2,
    // @@protoc_insertion_point(enum_value:DOTABehaviorLevel_t.DOTA_BEHAVIOR_LEVEL_DROPS)
    DOTA_BEHAVIOR_LEVEL_DROPS = 3,
    // @@protoc_insertion_point(enum_value:DOTABehaviorLevel_t.DOTA_BEHAVIOR_LEVEL_COACHING)
    DOTA_BEHAVIOR_LEVEL_COACHING = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTABehaviorLevel_t {
    const NAME: &'static str = "DOTABehaviorLevel_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTABehaviorLevel_t> {
        match value {
            0 => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_NONE),
            1 => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_RANKED_ALLOWED),
            2 => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_PAUSING),
            3 => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_DROPS),
            4 => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_COACHING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTABehaviorLevel_t> {
        match str {
            "DOTA_BEHAVIOR_LEVEL_NONE" => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_NONE),
            "DOTA_BEHAVIOR_LEVEL_RANKED_ALLOWED" => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_RANKED_ALLOWED),
            "DOTA_BEHAVIOR_LEVEL_PAUSING" => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_PAUSING),
            "DOTA_BEHAVIOR_LEVEL_DROPS" => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_DROPS),
            "DOTA_BEHAVIOR_LEVEL_COACHING" => ::std::option::Option::Some(DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_COACHING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTABehaviorLevel_t] = &[
        DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_NONE,
        DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_RANKED_ALLOWED,
        DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_PAUSING,
        DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_DROPS,
        DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_COACHING,
    ];
}

impl ::std::default::Default for DOTABehaviorLevel_t {
    fn default() -> Self {
        DOTABehaviorLevel_t::DOTA_BEHAVIOR_LEVEL_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProfileCardSlotType)
pub enum EProfileCardSlotType {
    // @@protoc_insertion_point(enum_value:EProfileCardSlotType.k_EProfileCardSlotType_Empty)
    k_EProfileCardSlotType_Empty = 0,
    // @@protoc_insertion_point(enum_value:EProfileCardSlotType.k_EProfileCardSlotType_Stat)
    k_EProfileCardSlotType_Stat = 1,
    // @@protoc_insertion_point(enum_value:EProfileCardSlotType.k_EProfileCardSlotType_Trophy)
    k_EProfileCardSlotType_Trophy = 2,
    // @@protoc_insertion_point(enum_value:EProfileCardSlotType.k_EProfileCardSlotType_Item)
    k_EProfileCardSlotType_Item = 3,
    // @@protoc_insertion_point(enum_value:EProfileCardSlotType.k_EProfileCardSlotType_Hero)
    k_EProfileCardSlotType_Hero = 4,
    // @@protoc_insertion_point(enum_value:EProfileCardSlotType.k_EProfileCardSlotType_Emoticon)
    k_EProfileCardSlotType_Emoticon = 5,
    // @@protoc_insertion_point(enum_value:EProfileCardSlotType.k_EProfileCardSlotType_Team)
    k_EProfileCardSlotType_Team = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for EProfileCardSlotType {
    const NAME: &'static str = "EProfileCardSlotType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProfileCardSlotType> {
        match value {
            0 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Empty),
            1 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Stat),
            2 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Trophy),
            3 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Item),
            4 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Hero),
            5 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Emoticon),
            6 => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Team),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProfileCardSlotType> {
        match str {
            "k_EProfileCardSlotType_Empty" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Empty),
            "k_EProfileCardSlotType_Stat" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Stat),
            "k_EProfileCardSlotType_Trophy" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Trophy),
            "k_EProfileCardSlotType_Item" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Item),
            "k_EProfileCardSlotType_Hero" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Hero),
            "k_EProfileCardSlotType_Emoticon" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Emoticon),
            "k_EProfileCardSlotType_Team" => ::std::option::Option::Some(EProfileCardSlotType::k_EProfileCardSlotType_Team),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProfileCardSlotType] = &[
        EProfileCardSlotType::k_EProfileCardSlotType_Empty,
        EProfileCardSlotType::k_EProfileCardSlotType_Stat,
        EProfileCardSlotType::k_EProfileCardSlotType_Trophy,
        EProfileCardSlotType::k_EProfileCardSlotType_Item,
        EProfileCardSlotType::k_EProfileCardSlotType_Hero,
        EProfileCardSlotType::k_EProfileCardSlotType_Emoticon,
        EProfileCardSlotType::k_EProfileCardSlotType_Team,
    ];
}

impl ::std::default::Default for EProfileCardSlotType {
    fn default() -> Self {
        EProfileCardSlotType::k_EProfileCardSlotType_Empty
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMatchGroupServerStatus)
pub enum EMatchGroupServerStatus {
    // @@protoc_insertion_point(enum_value:EMatchGroupServerStatus.k_EMatchGroupServerStatus_OK)
    k_EMatchGroupServerStatus_OK = 0,
    // @@protoc_insertion_point(enum_value:EMatchGroupServerStatus.k_EMatchGroupServerStatus_LimitedAvailability)
    k_EMatchGroupServerStatus_LimitedAvailability = 1,
    // @@protoc_insertion_point(enum_value:EMatchGroupServerStatus.k_EMatchGroupServerStatus_Offline)
    k_EMatchGroupServerStatus_Offline = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EMatchGroupServerStatus {
    const NAME: &'static str = "EMatchGroupServerStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMatchGroupServerStatus> {
        match value {
            0 => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK),
            1 => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_LimitedAvailability),
            2 => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_Offline),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMatchGroupServerStatus> {
        match str {
            "k_EMatchGroupServerStatus_OK" => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK),
            "k_EMatchGroupServerStatus_LimitedAvailability" => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_LimitedAvailability),
            "k_EMatchGroupServerStatus_Offline" => ::std::option::Option::Some(EMatchGroupServerStatus::k_EMatchGroupServerStatus_Offline),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMatchGroupServerStatus] = &[
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK,
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_LimitedAvailability,
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_Offline,
    ];
}

impl ::std::default::Default for EMatchGroupServerStatus {
    fn default() -> Self {
        EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_CM_PICK)
pub enum DOTA_CM_PICK {
    // @@protoc_insertion_point(enum_value:DOTA_CM_PICK.DOTA_CM_RANDOM)
    DOTA_CM_RANDOM = 0,
    // @@protoc_insertion_point(enum_value:DOTA_CM_PICK.DOTA_CM_GOOD_GUYS)
    DOTA_CM_GOOD_GUYS = 1,
    // @@protoc_insertion_point(enum_value:DOTA_CM_PICK.DOTA_CM_BAD_GUYS)
    DOTA_CM_BAD_GUYS = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_CM_PICK {
    const NAME: &'static str = "DOTA_CM_PICK";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CM_PICK> {
        match value {
            0 => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_RANDOM),
            1 => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_GOOD_GUYS),
            2 => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_BAD_GUYS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_CM_PICK> {
        match str {
            "DOTA_CM_RANDOM" => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_RANDOM),
            "DOTA_CM_GOOD_GUYS" => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_GOOD_GUYS),
            "DOTA_CM_BAD_GUYS" => ::std::option::Option::Some(DOTA_CM_PICK::DOTA_CM_BAD_GUYS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_CM_PICK] = &[
        DOTA_CM_PICK::DOTA_CM_RANDOM,
        DOTA_CM_PICK::DOTA_CM_GOOD_GUYS,
        DOTA_CM_PICK::DOTA_CM_BAD_GUYS,
    ];
}

impl ::std::default::Default for DOTA_CM_PICK {
    fn default() -> Self {
        DOTA_CM_PICK::DOTA_CM_RANDOM
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTALowPriorityBanType)
pub enum DOTALowPriorityBanType {
    // @@protoc_insertion_point(enum_value:DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_ABANDON)
    DOTA_LOW_PRIORITY_BAN_ABANDON = 0,
    // @@protoc_insertion_point(enum_value:DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_REPORTS)
    DOTA_LOW_PRIORITY_BAN_REPORTS = 1,
    // @@protoc_insertion_point(enum_value:DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON)
    DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON = 2,
    // @@protoc_insertion_point(enum_value:DOTALowPriorityBanType.DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE)
    DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTALowPriorityBanType {
    const NAME: &'static str = "DOTALowPriorityBanType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALowPriorityBanType> {
        match value {
            0 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON),
            1 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_REPORTS),
            2 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON),
            3 => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALowPriorityBanType> {
        match str {
            "DOTA_LOW_PRIORITY_BAN_ABANDON" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON),
            "DOTA_LOW_PRIORITY_BAN_REPORTS" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_REPORTS),
            "DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON),
            "DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE" => ::std::option::Option::Some(DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALowPriorityBanType] = &[
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON,
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_REPORTS,
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON,
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE,
    ];
}

impl ::std::default::Default for DOTALowPriorityBanType {
    fn default() -> Self {
        DOTALowPriorityBanType::DOTA_LOW_PRIORITY_BAN_ABANDON
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTALobbyReadyState)
pub enum DOTALobbyReadyState {
    // @@protoc_insertion_point(enum_value:DOTALobbyReadyState.DOTALobbyReadyState_UNDECLARED)
    DOTALobbyReadyState_UNDECLARED = 0,
    // @@protoc_insertion_point(enum_value:DOTALobbyReadyState.DOTALobbyReadyState_ACCEPTED)
    DOTALobbyReadyState_ACCEPTED = 1,
    // @@protoc_insertion_point(enum_value:DOTALobbyReadyState.DOTALobbyReadyState_DECLINED)
    DOTALobbyReadyState_DECLINED = 2,
    // @@protoc_insertion_point(enum_value:DOTALobbyReadyState.DOTALobbyReadyState_DECLINED_REQUEUE)
    DOTALobbyReadyState_DECLINED_REQUEUE = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTALobbyReadyState {
    const NAME: &'static str = "DOTALobbyReadyState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALobbyReadyState> {
        match value {
            0 => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED),
            1 => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_ACCEPTED),
            2 => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_DECLINED),
            3 => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_DECLINED_REQUEUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALobbyReadyState> {
        match str {
            "DOTALobbyReadyState_UNDECLARED" => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED),
            "DOTALobbyReadyState_ACCEPTED" => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_ACCEPTED),
            "DOTALobbyReadyState_DECLINED" => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_DECLINED),
            "DOTALobbyReadyState_DECLINED_REQUEUE" => ::std::option::Option::Some(DOTALobbyReadyState::DOTALobbyReadyState_DECLINED_REQUEUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALobbyReadyState] = &[
        DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED,
        DOTALobbyReadyState::DOTALobbyReadyState_ACCEPTED,
        DOTALobbyReadyState::DOTALobbyReadyState_DECLINED,
        DOTALobbyReadyState::DOTALobbyReadyState_DECLINED_REQUEUE,
    ];
}

impl ::std::default::Default for DOTALobbyReadyState {
    fn default() -> Self {
        DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTAJoinLobbyResult)
pub enum DOTAJoinLobbyResult {
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_SUCCESS)
    DOTA_JOIN_RESULT_SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_ALREADY_IN_GAME)
    DOTA_JOIN_RESULT_ALREADY_IN_GAME = 1,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_INVALID_LOBBY)
    DOTA_JOIN_RESULT_INVALID_LOBBY = 2,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_INCORRECT_PASSWORD)
    DOTA_JOIN_RESULT_INCORRECT_PASSWORD = 3,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_ACCESS_DENIED)
    DOTA_JOIN_RESULT_ACCESS_DENIED = 4,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_GENERIC_ERROR)
    DOTA_JOIN_RESULT_GENERIC_ERROR = 5,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_INCORRECT_VERSION)
    DOTA_JOIN_RESULT_INCORRECT_VERSION = 6,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_IN_TEAM_PARTY)
    DOTA_JOIN_RESULT_IN_TEAM_PARTY = 7,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_NO_LOBBY_FOUND)
    DOTA_JOIN_RESULT_NO_LOBBY_FOUND = 8,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_LOBBY_FULL)
    DOTA_JOIN_RESULT_LOBBY_FULL = 9,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION)
    DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION = 10,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_TIMEOUT)
    DOTA_JOIN_RESULT_TIMEOUT = 11,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN)
    DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN = 12,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_BUSY)
    DOTA_JOIN_RESULT_BUSY = 13,
    // @@protoc_insertion_point(enum_value:DOTAJoinLobbyResult.DOTA_JOIN_RESULT_NO_PLAYTIME)
    DOTA_JOIN_RESULT_NO_PLAYTIME = 14,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTAJoinLobbyResult {
    const NAME: &'static str = "DOTAJoinLobbyResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAJoinLobbyResult> {
        match value {
            0 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            1 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ALREADY_IN_GAME),
            2 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INVALID_LOBBY),
            3 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_PASSWORD),
            4 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ACCESS_DENIED),
            5 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_GENERIC_ERROR),
            6 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_VERSION),
            7 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_IN_TEAM_PARTY),
            8 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_LOBBY_FOUND),
            9 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_LOBBY_FULL),
            10 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION),
            11 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_TIMEOUT),
            12 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN),
            13 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_BUSY),
            14 => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_PLAYTIME),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAJoinLobbyResult> {
        match str {
            "DOTA_JOIN_RESULT_SUCCESS" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            "DOTA_JOIN_RESULT_ALREADY_IN_GAME" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ALREADY_IN_GAME),
            "DOTA_JOIN_RESULT_INVALID_LOBBY" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INVALID_LOBBY),
            "DOTA_JOIN_RESULT_INCORRECT_PASSWORD" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_PASSWORD),
            "DOTA_JOIN_RESULT_ACCESS_DENIED" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ACCESS_DENIED),
            "DOTA_JOIN_RESULT_GENERIC_ERROR" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_GENERIC_ERROR),
            "DOTA_JOIN_RESULT_INCORRECT_VERSION" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_VERSION),
            "DOTA_JOIN_RESULT_IN_TEAM_PARTY" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_IN_TEAM_PARTY),
            "DOTA_JOIN_RESULT_NO_LOBBY_FOUND" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_LOBBY_FOUND),
            "DOTA_JOIN_RESULT_LOBBY_FULL" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_LOBBY_FULL),
            "DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION),
            "DOTA_JOIN_RESULT_TIMEOUT" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_TIMEOUT),
            "DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN),
            "DOTA_JOIN_RESULT_BUSY" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_BUSY),
            "DOTA_JOIN_RESULT_NO_PLAYTIME" => ::std::option::Option::Some(DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_PLAYTIME),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAJoinLobbyResult] = &[
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ALREADY_IN_GAME,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INVALID_LOBBY,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_PASSWORD,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_ACCESS_DENIED,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_GENERIC_ERROR,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_INCORRECT_VERSION,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_IN_TEAM_PARTY,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_LOBBY_FOUND,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_LOBBY_FULL,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_TIMEOUT,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_BUSY,
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_NO_PLAYTIME,
    ];
}

impl ::std::default::Default for DOTAJoinLobbyResult {
    fn default() -> Self {
        DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTASelectionPriorityRules)
pub enum DOTASelectionPriorityRules {
    // @@protoc_insertion_point(enum_value:DOTASelectionPriorityRules.k_DOTASelectionPriorityRules_Manual)
    k_DOTASelectionPriorityRules_Manual = 0,
    // @@protoc_insertion_point(enum_value:DOTASelectionPriorityRules.k_DOTASelectionPriorityRules_Automatic)
    k_DOTASelectionPriorityRules_Automatic = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTASelectionPriorityRules {
    const NAME: &'static str = "DOTASelectionPriorityRules";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTASelectionPriorityRules> {
        match value {
            0 => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            1 => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Automatic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTASelectionPriorityRules> {
        match str {
            "k_DOTASelectionPriorityRules_Manual" => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            "k_DOTASelectionPriorityRules_Automatic" => ::std::option::Option::Some(DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Automatic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTASelectionPriorityRules] = &[
        DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual,
        DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Automatic,
    ];
}

impl ::std::default::Default for DOTASelectionPriorityRules {
    fn default() -> Self {
        DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTASelectionPriorityChoice)
pub enum DOTASelectionPriorityChoice {
    // @@protoc_insertion_point(enum_value:DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_Invalid)
    k_DOTASelectionPriorityChoice_Invalid = 0,
    // @@protoc_insertion_point(enum_value:DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_FirstPick)
    k_DOTASelectionPriorityChoice_FirstPick = 1,
    // @@protoc_insertion_point(enum_value:DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_SecondPick)
    k_DOTASelectionPriorityChoice_SecondPick = 2,
    // @@protoc_insertion_point(enum_value:DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_Radiant)
    k_DOTASelectionPriorityChoice_Radiant = 3,
    // @@protoc_insertion_point(enum_value:DOTASelectionPriorityChoice.k_DOTASelectionPriorityChoice_Dire)
    k_DOTASelectionPriorityChoice_Dire = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTASelectionPriorityChoice {
    const NAME: &'static str = "DOTASelectionPriorityChoice";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTASelectionPriorityChoice> {
        match value {
            0 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            1 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_FirstPick),
            2 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_SecondPick),
            3 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Radiant),
            4 => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Dire),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTASelectionPriorityChoice> {
        match str {
            "k_DOTASelectionPriorityChoice_Invalid" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            "k_DOTASelectionPriorityChoice_FirstPick" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_FirstPick),
            "k_DOTASelectionPriorityChoice_SecondPick" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_SecondPick),
            "k_DOTASelectionPriorityChoice_Radiant" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Radiant),
            "k_DOTASelectionPriorityChoice_Dire" => ::std::option::Option::Some(DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Dire),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTASelectionPriorityChoice] = &[
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_FirstPick,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_SecondPick,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Radiant,
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Dire,
    ];
}

impl ::std::default::Default for DOTASelectionPriorityChoice {
    fn default() -> Self {
        DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTAMatchVote)
pub enum DOTAMatchVote {
    // @@protoc_insertion_point(enum_value:DOTAMatchVote.DOTAMatchVote_INVALID)
    DOTAMatchVote_INVALID = 0,
    // @@protoc_insertion_point(enum_value:DOTAMatchVote.DOTAMatchVote_POSITIVE)
    DOTAMatchVote_POSITIVE = 1,
    // @@protoc_insertion_point(enum_value:DOTAMatchVote.DOTAMatchVote_NEGATIVE)
    DOTAMatchVote_NEGATIVE = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTAMatchVote {
    const NAME: &'static str = "DOTAMatchVote";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTAMatchVote> {
        match value {
            0 => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_INVALID),
            1 => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_POSITIVE),
            2 => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_NEGATIVE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTAMatchVote> {
        match str {
            "DOTAMatchVote_INVALID" => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_INVALID),
            "DOTAMatchVote_POSITIVE" => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_POSITIVE),
            "DOTAMatchVote_NEGATIVE" => ::std::option::Option::Some(DOTAMatchVote::DOTAMatchVote_NEGATIVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTAMatchVote] = &[
        DOTAMatchVote::DOTAMatchVote_INVALID,
        DOTAMatchVote::DOTAMatchVote_POSITIVE,
        DOTAMatchVote::DOTAMatchVote_NEGATIVE,
    ];
}

impl ::std::default::Default for DOTAMatchVote {
    fn default() -> Self {
        DOTAMatchVote::DOTAMatchVote_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTALobbyVisibility)
pub enum DOTALobbyVisibility {
    // @@protoc_insertion_point(enum_value:DOTALobbyVisibility.DOTALobbyVisibility_Public)
    DOTALobbyVisibility_Public = 0,
    // @@protoc_insertion_point(enum_value:DOTALobbyVisibility.DOTALobbyVisibility_Friends)
    DOTALobbyVisibility_Friends = 1,
    // @@protoc_insertion_point(enum_value:DOTALobbyVisibility.DOTALobbyVisibility_Unlisted)
    DOTALobbyVisibility_Unlisted = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTALobbyVisibility {
    const NAME: &'static str = "DOTALobbyVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTALobbyVisibility> {
        match value {
            0 => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Public),
            1 => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Friends),
            2 => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Unlisted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTALobbyVisibility> {
        match str {
            "DOTALobbyVisibility_Public" => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Public),
            "DOTALobbyVisibility_Friends" => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Friends),
            "DOTALobbyVisibility_Unlisted" => ::std::option::Option::Some(DOTALobbyVisibility::DOTALobbyVisibility_Unlisted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTALobbyVisibility] = &[
        DOTALobbyVisibility::DOTALobbyVisibility_Public,
        DOTALobbyVisibility::DOTALobbyVisibility_Friends,
        DOTALobbyVisibility::DOTALobbyVisibility_Unlisted,
    ];
}

impl ::std::default::Default for DOTALobbyVisibility {
    fn default() -> Self {
        DOTALobbyVisibility::DOTALobbyVisibility_Public
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDOTAPlayerMMRType)
pub enum EDOTAPlayerMMRType {
    // @@protoc_insertion_point(enum_value:EDOTAPlayerMMRType.k_EDOTAPlayerMMRType_Invalid)
    k_EDOTAPlayerMMRType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EDOTAPlayerMMRType.k_EDOTAPlayerMMRType_GeneralHidden)
    k_EDOTAPlayerMMRType_GeneralHidden = 1,
    // @@protoc_insertion_point(enum_value:EDOTAPlayerMMRType.k_EDOTAPlayerMMRType_GeneralCompetitive)
    k_EDOTAPlayerMMRType_GeneralCompetitive = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDOTAPlayerMMRType {
    const NAME: &'static str = "EDOTAPlayerMMRType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAPlayerMMRType> {
        match value {
            0 => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid),
            1 => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralHidden),
            3 => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralCompetitive),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAPlayerMMRType> {
        match str {
            "k_EDOTAPlayerMMRType_Invalid" => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid),
            "k_EDOTAPlayerMMRType_GeneralHidden" => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralHidden),
            "k_EDOTAPlayerMMRType_GeneralCompetitive" => ::std::option::Option::Some(EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralCompetitive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAPlayerMMRType] = &[
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid,
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralHidden,
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_GeneralCompetitive,
    ];
}

impl ::std::default::Default for EDOTAPlayerMMRType {
    fn default() -> Self {
        EDOTAPlayerMMRType::k_EDOTAPlayerMMRType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDOTAMMRBoostType)
pub enum EDOTAMMRBoostType {
    // @@protoc_insertion_point(enum_value:EDOTAMMRBoostType.k_EDOTAMMRBoostType_None)
    k_EDOTAMMRBoostType_None = 0,
    // @@protoc_insertion_point(enum_value:EDOTAMMRBoostType.k_EDOTAMMRBoostType_Leader)
    k_EDOTAMMRBoostType_Leader = 1,
    // @@protoc_insertion_point(enum_value:EDOTAMMRBoostType.k_EDOTAMMRBoostType_Follower)
    k_EDOTAMMRBoostType_Follower = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDOTAMMRBoostType {
    const NAME: &'static str = "EDOTAMMRBoostType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAMMRBoostType> {
        match value {
            0 => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
            1 => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Leader),
            2 => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Follower),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAMMRBoostType> {
        match str {
            "k_EDOTAMMRBoostType_None" => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
            "k_EDOTAMMRBoostType_Leader" => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Leader),
            "k_EDOTAMMRBoostType_Follower" => ::std::option::Option::Some(EDOTAMMRBoostType::k_EDOTAMMRBoostType_Follower),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAMMRBoostType] = &[
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_None,
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_Leader,
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_Follower,
    ];
}

impl ::std::default::Default for EDOTAMMRBoostType {
    fn default() -> Self {
        EDOTAMMRBoostType::k_EDOTAMMRBoostType_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MatchType)
pub enum MatchType {
    // @@protoc_insertion_point(enum_value:MatchType.MATCH_TYPE_CASUAL)
    MATCH_TYPE_CASUAL = 0,
    // @@protoc_insertion_point(enum_value:MatchType.MATCH_TYPE_COOP_BOTS)
    MATCH_TYPE_COOP_BOTS = 1,
    // @@protoc_insertion_point(enum_value:MatchType.MATCH_TYPE_COMPETITIVE)
    MATCH_TYPE_COMPETITIVE = 4,
    // @@protoc_insertion_point(enum_value:MatchType.MATCH_TYPE_WEEKEND_TOURNEY)
    MATCH_TYPE_WEEKEND_TOURNEY = 5,
    // @@protoc_insertion_point(enum_value:MatchType.MATCH_TYPE_EVENT)
    MATCH_TYPE_EVENT = 7,
    // @@protoc_insertion_point(enum_value:MatchType.MATCH_TYPE_COACHES_CHALLENGE)
    MATCH_TYPE_COACHES_CHALLENGE = 12,
    // @@protoc_insertion_point(enum_value:MatchType.MATCH_TYPE_NEW_PLAYER_POOL)
    MATCH_TYPE_NEW_PLAYER_POOL = 14,
}

impl ::steam_vent_proto_common::protobuf::Enum for MatchType {
    const NAME: &'static str = "MatchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchType> {
        match value {
            0 => ::std::option::Option::Some(MatchType::MATCH_TYPE_CASUAL),
            1 => ::std::option::Option::Some(MatchType::MATCH_TYPE_COOP_BOTS),
            4 => ::std::option::Option::Some(MatchType::MATCH_TYPE_COMPETITIVE),
            5 => ::std::option::Option::Some(MatchType::MATCH_TYPE_WEEKEND_TOURNEY),
            7 => ::std::option::Option::Some(MatchType::MATCH_TYPE_EVENT),
            12 => ::std::option::Option::Some(MatchType::MATCH_TYPE_COACHES_CHALLENGE),
            14 => ::std::option::Option::Some(MatchType::MATCH_TYPE_NEW_PLAYER_POOL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MatchType> {
        match str {
            "MATCH_TYPE_CASUAL" => ::std::option::Option::Some(MatchType::MATCH_TYPE_CASUAL),
            "MATCH_TYPE_COOP_BOTS" => ::std::option::Option::Some(MatchType::MATCH_TYPE_COOP_BOTS),
            "MATCH_TYPE_COMPETITIVE" => ::std::option::Option::Some(MatchType::MATCH_TYPE_COMPETITIVE),
            "MATCH_TYPE_WEEKEND_TOURNEY" => ::std::option::Option::Some(MatchType::MATCH_TYPE_WEEKEND_TOURNEY),
            "MATCH_TYPE_EVENT" => ::std::option::Option::Some(MatchType::MATCH_TYPE_EVENT),
            "MATCH_TYPE_COACHES_CHALLENGE" => ::std::option::Option::Some(MatchType::MATCH_TYPE_COACHES_CHALLENGE),
            "MATCH_TYPE_NEW_PLAYER_POOL" => ::std::option::Option::Some(MatchType::MATCH_TYPE_NEW_PLAYER_POOL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatchType] = &[
        MatchType::MATCH_TYPE_CASUAL,
        MatchType::MATCH_TYPE_COOP_BOTS,
        MatchType::MATCH_TYPE_COMPETITIVE,
        MatchType::MATCH_TYPE_WEEKEND_TOURNEY,
        MatchType::MATCH_TYPE_EVENT,
        MatchType::MATCH_TYPE_COACHES_CHALLENGE,
        MatchType::MATCH_TYPE_NEW_PLAYER_POOL,
    ];
}

impl ::std::default::Default for MatchType {
    fn default() -> Self {
        MatchType::MATCH_TYPE_CASUAL
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTABotDifficulty)
pub enum DOTABotDifficulty {
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_PASSIVE)
    BOT_DIFFICULTY_PASSIVE = 0,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_EASY)
    BOT_DIFFICULTY_EASY = 1,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_MEDIUM)
    BOT_DIFFICULTY_MEDIUM = 2,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_HARD)
    BOT_DIFFICULTY_HARD = 3,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_UNFAIR)
    BOT_DIFFICULTY_UNFAIR = 4,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_INVALID)
    BOT_DIFFICULTY_INVALID = 5,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_EXTRA1)
    BOT_DIFFICULTY_EXTRA1 = 6,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_EXTRA2)
    BOT_DIFFICULTY_EXTRA2 = 7,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_EXTRA3)
    BOT_DIFFICULTY_EXTRA3 = 8,
    // @@protoc_insertion_point(enum_value:DOTABotDifficulty.BOT_DIFFICULTY_NPX)
    BOT_DIFFICULTY_NPX = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTABotDifficulty {
    const NAME: &'static str = "DOTABotDifficulty";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTABotDifficulty> {
        match value {
            0 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            1 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EASY),
            2 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_MEDIUM),
            3 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_HARD),
            4 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_UNFAIR),
            5 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_INVALID),
            6 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA1),
            7 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA2),
            8 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA3),
            9 => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_NPX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTABotDifficulty> {
        match str {
            "BOT_DIFFICULTY_PASSIVE" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            "BOT_DIFFICULTY_EASY" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EASY),
            "BOT_DIFFICULTY_MEDIUM" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_MEDIUM),
            "BOT_DIFFICULTY_HARD" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_HARD),
            "BOT_DIFFICULTY_UNFAIR" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_UNFAIR),
            "BOT_DIFFICULTY_INVALID" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_INVALID),
            "BOT_DIFFICULTY_EXTRA1" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA1),
            "BOT_DIFFICULTY_EXTRA2" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA2),
            "BOT_DIFFICULTY_EXTRA3" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_EXTRA3),
            "BOT_DIFFICULTY_NPX" => ::std::option::Option::Some(DOTABotDifficulty::BOT_DIFFICULTY_NPX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTABotDifficulty] = &[
        DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        DOTABotDifficulty::BOT_DIFFICULTY_EASY,
        DOTABotDifficulty::BOT_DIFFICULTY_MEDIUM,
        DOTABotDifficulty::BOT_DIFFICULTY_HARD,
        DOTABotDifficulty::BOT_DIFFICULTY_UNFAIR,
        DOTABotDifficulty::BOT_DIFFICULTY_INVALID,
        DOTABotDifficulty::BOT_DIFFICULTY_EXTRA1,
        DOTABotDifficulty::BOT_DIFFICULTY_EXTRA2,
        DOTABotDifficulty::BOT_DIFFICULTY_EXTRA3,
        DOTABotDifficulty::BOT_DIFFICULTY_NPX,
    ];
}

impl ::std::default::Default for DOTABotDifficulty {
    fn default() -> Self {
        DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_BOT_MODE)
pub enum DOTA_BOT_MODE {
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_NONE)
    DOTA_BOT_MODE_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_LANING)
    DOTA_BOT_MODE_LANING = 1,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_ATTACK)
    DOTA_BOT_MODE_ATTACK = 2,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_ROAM)
    DOTA_BOT_MODE_ROAM = 3,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_RETREAT)
    DOTA_BOT_MODE_RETREAT = 4,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_SECRET_SHOP)
    DOTA_BOT_MODE_SECRET_SHOP = 5,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_SIDE_SHOP)
    DOTA_BOT_MODE_SIDE_SHOP = 6,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_RUNE)
    DOTA_BOT_MODE_RUNE = 7,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_PUSH_TOWER_TOP)
    DOTA_BOT_MODE_PUSH_TOWER_TOP = 8,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_PUSH_TOWER_MID)
    DOTA_BOT_MODE_PUSH_TOWER_MID = 9,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_PUSH_TOWER_BOT)
    DOTA_BOT_MODE_PUSH_TOWER_BOT = 10,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_TOWER_TOP)
    DOTA_BOT_MODE_DEFEND_TOWER_TOP = 11,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_TOWER_MID)
    DOTA_BOT_MODE_DEFEND_TOWER_MID = 12,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_TOWER_BOT)
    DOTA_BOT_MODE_DEFEND_TOWER_BOT = 13,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_ASSEMBLE)
    DOTA_BOT_MODE_ASSEMBLE = 14,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS)
    DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS = 15,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_TEAM_ROAM)
    DOTA_BOT_MODE_TEAM_ROAM = 16,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_FARM)
    DOTA_BOT_MODE_FARM = 17,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_DEFEND_ALLY)
    DOTA_BOT_MODE_DEFEND_ALLY = 18,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_EVASIVE_MANEUVERS)
    DOTA_BOT_MODE_EVASIVE_MANEUVERS = 19,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_ROSHAN)
    DOTA_BOT_MODE_ROSHAN = 20,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_ITEM)
    DOTA_BOT_MODE_ITEM = 21,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_WARD)
    DOTA_BOT_MODE_WARD = 22,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_COMPANION)
    DOTA_BOT_MODE_COMPANION = 23,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_TUTORIAL_BOSS)
    DOTA_BOT_MODE_TUTORIAL_BOSS = 24,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_MINION)
    DOTA_BOT_MODE_MINION = 25,
    // @@protoc_insertion_point(enum_value:DOTA_BOT_MODE.DOTA_BOT_MODE_OUTPOST)
    DOTA_BOT_MODE_OUTPOST = 26,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_BOT_MODE {
    const NAME: &'static str = "DOTA_BOT_MODE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_BOT_MODE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_NONE),
            1 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_LANING),
            2 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ATTACK),
            3 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROAM),
            4 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RETREAT),
            5 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SECRET_SHOP),
            6 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SIDE_SHOP),
            7 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RUNE),
            8 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_TOP),
            9 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_MID),
            10 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_BOT),
            11 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_TOP),
            12 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_MID),
            13 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_BOT),
            14 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE),
            15 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS),
            16 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TEAM_ROAM),
            17 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_FARM),
            18 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_ALLY),
            19 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_EVASIVE_MANEUVERS),
            20 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROSHAN),
            21 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ITEM),
            22 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_WARD),
            23 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_COMPANION),
            24 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TUTORIAL_BOSS),
            25 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_MINION),
            26 => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_OUTPOST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_BOT_MODE> {
        match str {
            "DOTA_BOT_MODE_NONE" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_NONE),
            "DOTA_BOT_MODE_LANING" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_LANING),
            "DOTA_BOT_MODE_ATTACK" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ATTACK),
            "DOTA_BOT_MODE_ROAM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROAM),
            "DOTA_BOT_MODE_RETREAT" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RETREAT),
            "DOTA_BOT_MODE_SECRET_SHOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SECRET_SHOP),
            "DOTA_BOT_MODE_SIDE_SHOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_SIDE_SHOP),
            "DOTA_BOT_MODE_RUNE" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_RUNE),
            "DOTA_BOT_MODE_PUSH_TOWER_TOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_TOP),
            "DOTA_BOT_MODE_PUSH_TOWER_MID" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_MID),
            "DOTA_BOT_MODE_PUSH_TOWER_BOT" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_BOT),
            "DOTA_BOT_MODE_DEFEND_TOWER_TOP" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_TOP),
            "DOTA_BOT_MODE_DEFEND_TOWER_MID" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_MID),
            "DOTA_BOT_MODE_DEFEND_TOWER_BOT" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_BOT),
            "DOTA_BOT_MODE_ASSEMBLE" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE),
            "DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS),
            "DOTA_BOT_MODE_TEAM_ROAM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TEAM_ROAM),
            "DOTA_BOT_MODE_FARM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_FARM),
            "DOTA_BOT_MODE_DEFEND_ALLY" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_ALLY),
            "DOTA_BOT_MODE_EVASIVE_MANEUVERS" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_EVASIVE_MANEUVERS),
            "DOTA_BOT_MODE_ROSHAN" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ROSHAN),
            "DOTA_BOT_MODE_ITEM" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_ITEM),
            "DOTA_BOT_MODE_WARD" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_WARD),
            "DOTA_BOT_MODE_COMPANION" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_COMPANION),
            "DOTA_BOT_MODE_TUTORIAL_BOSS" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_TUTORIAL_BOSS),
            "DOTA_BOT_MODE_MINION" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_MINION),
            "DOTA_BOT_MODE_OUTPOST" => ::std::option::Option::Some(DOTA_BOT_MODE::DOTA_BOT_MODE_OUTPOST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_BOT_MODE] = &[
        DOTA_BOT_MODE::DOTA_BOT_MODE_NONE,
        DOTA_BOT_MODE::DOTA_BOT_MODE_LANING,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ATTACK,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ROAM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_RETREAT,
        DOTA_BOT_MODE::DOTA_BOT_MODE_SECRET_SHOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_SIDE_SHOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_RUNE,
        DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_TOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_MID,
        DOTA_BOT_MODE::DOTA_BOT_MODE_PUSH_TOWER_BOT,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_TOP,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_MID,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_TOWER_BOT,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS,
        DOTA_BOT_MODE::DOTA_BOT_MODE_TEAM_ROAM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_FARM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_DEFEND_ALLY,
        DOTA_BOT_MODE::DOTA_BOT_MODE_EVASIVE_MANEUVERS,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ROSHAN,
        DOTA_BOT_MODE::DOTA_BOT_MODE_ITEM,
        DOTA_BOT_MODE::DOTA_BOT_MODE_WARD,
        DOTA_BOT_MODE::DOTA_BOT_MODE_COMPANION,
        DOTA_BOT_MODE::DOTA_BOT_MODE_TUTORIAL_BOSS,
        DOTA_BOT_MODE::DOTA_BOT_MODE_MINION,
        DOTA_BOT_MODE::DOTA_BOT_MODE_OUTPOST,
    ];
}

impl ::std::default::Default for DOTA_BOT_MODE {
    fn default() -> Self {
        DOTA_BOT_MODE::DOTA_BOT_MODE_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MatchLanguages)
pub enum MatchLanguages {
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_INVALID)
    MATCH_LANGUAGE_INVALID = 0,
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_ENGLISH)
    MATCH_LANGUAGE_ENGLISH = 1,
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_RUSSIAN)
    MATCH_LANGUAGE_RUSSIAN = 2,
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_CHINESE)
    MATCH_LANGUAGE_CHINESE = 3,
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_KOREAN)
    MATCH_LANGUAGE_KOREAN = 4,
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_SPANISH)
    MATCH_LANGUAGE_SPANISH = 5,
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_PORTUGUESE)
    MATCH_LANGUAGE_PORTUGUESE = 6,
    // @@protoc_insertion_point(enum_value:MatchLanguages.MATCH_LANGUAGE_ENGLISH2)
    MATCH_LANGUAGE_ENGLISH2 = 7,
}

impl ::steam_vent_proto_common::protobuf::Enum for MatchLanguages {
    const NAME: &'static str = "MatchLanguages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchLanguages> {
        match value {
            0 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_INVALID),
            1 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH),
            2 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_RUSSIAN),
            3 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_CHINESE),
            4 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_KOREAN),
            5 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_SPANISH),
            6 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_PORTUGUESE),
            7 => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MatchLanguages> {
        match str {
            "MATCH_LANGUAGE_INVALID" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_INVALID),
            "MATCH_LANGUAGE_ENGLISH" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH),
            "MATCH_LANGUAGE_RUSSIAN" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_RUSSIAN),
            "MATCH_LANGUAGE_CHINESE" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_CHINESE),
            "MATCH_LANGUAGE_KOREAN" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_KOREAN),
            "MATCH_LANGUAGE_SPANISH" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_SPANISH),
            "MATCH_LANGUAGE_PORTUGUESE" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_PORTUGUESE),
            "MATCH_LANGUAGE_ENGLISH2" => ::std::option::Option::Some(MatchLanguages::MATCH_LANGUAGE_ENGLISH2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MatchLanguages] = &[
        MatchLanguages::MATCH_LANGUAGE_INVALID,
        MatchLanguages::MATCH_LANGUAGE_ENGLISH,
        MatchLanguages::MATCH_LANGUAGE_RUSSIAN,
        MatchLanguages::MATCH_LANGUAGE_CHINESE,
        MatchLanguages::MATCH_LANGUAGE_KOREAN,
        MatchLanguages::MATCH_LANGUAGE_SPANISH,
        MatchLanguages::MATCH_LANGUAGE_PORTUGUESE,
        MatchLanguages::MATCH_LANGUAGE_ENGLISH2,
    ];
}

impl ::std::default::Default for MatchLanguages {
    fn default() -> Self {
        MatchLanguages::MATCH_LANGUAGE_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETourneyQueueDeadlineState)
pub enum ETourneyQueueDeadlineState {
    // @@protoc_insertion_point(enum_value:ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_Normal)
    k_ETourneyQueueDeadlineState_Normal = 0,
    // @@protoc_insertion_point(enum_value:ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_Missed)
    k_ETourneyQueueDeadlineState_Missed = 1,
    // @@protoc_insertion_point(enum_value:ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_ExpiredOK)
    k_ETourneyQueueDeadlineState_ExpiredOK = 2,
    // @@protoc_insertion_point(enum_value:ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_SeekingBye)
    k_ETourneyQueueDeadlineState_SeekingBye = 3,
    // @@protoc_insertion_point(enum_value:ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_EligibleForRefund)
    k_ETourneyQueueDeadlineState_EligibleForRefund = 4,
    // @@protoc_insertion_point(enum_value:ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_NA)
    k_ETourneyQueueDeadlineState_NA = -1,
    // @@protoc_insertion_point(enum_value:ETourneyQueueDeadlineState.k_ETourneyQueueDeadlineState_ExpiringSoon)
    k_ETourneyQueueDeadlineState_ExpiringSoon = 101,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETourneyQueueDeadlineState {
    const NAME: &'static str = "ETourneyQueueDeadlineState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETourneyQueueDeadlineState> {
        match value {
            0 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal),
            1 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Missed),
            2 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiredOK),
            3 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_SeekingBye),
            4 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_EligibleForRefund),
            -1 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_NA),
            101 => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiringSoon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETourneyQueueDeadlineState> {
        match str {
            "k_ETourneyQueueDeadlineState_Normal" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal),
            "k_ETourneyQueueDeadlineState_Missed" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Missed),
            "k_ETourneyQueueDeadlineState_ExpiredOK" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiredOK),
            "k_ETourneyQueueDeadlineState_SeekingBye" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_SeekingBye),
            "k_ETourneyQueueDeadlineState_EligibleForRefund" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_EligibleForRefund),
            "k_ETourneyQueueDeadlineState_NA" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_NA),
            "k_ETourneyQueueDeadlineState_ExpiringSoon" => ::std::option::Option::Some(ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiringSoon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETourneyQueueDeadlineState] = &[
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Missed,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiredOK,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_SeekingBye,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_EligibleForRefund,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_NA,
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_ExpiringSoon,
    ];
}

impl ::std::default::Default for ETourneyQueueDeadlineState {
    fn default() -> Self {
        ETourneyQueueDeadlineState::k_ETourneyQueueDeadlineState_Normal
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMatchOutcome)
pub enum EMatchOutcome {
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Unknown)
    k_EMatchOutcome_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_RadVictory)
    k_EMatchOutcome_RadVictory = 2,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_DireVictory)
    k_EMatchOutcome_DireVictory = 3,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NeutralVictory)
    k_EMatchOutcome_NeutralVictory = 4,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NoTeamWinner)
    k_EMatchOutcome_NoTeamWinner = 5,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom1Victory)
    k_EMatchOutcome_Custom1Victory = 6,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom2Victory)
    k_EMatchOutcome_Custom2Victory = 7,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom3Victory)
    k_EMatchOutcome_Custom3Victory = 8,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom4Victory)
    k_EMatchOutcome_Custom4Victory = 9,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom5Victory)
    k_EMatchOutcome_Custom5Victory = 10,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom6Victory)
    k_EMatchOutcome_Custom6Victory = 11,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom7Victory)
    k_EMatchOutcome_Custom7Victory = 12,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_Custom8Victory)
    k_EMatchOutcome_Custom8Victory = 13,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NotScored_PoorNetworkConditions)
    k_EMatchOutcome_NotScored_PoorNetworkConditions = 64,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NotScored_Leaver)
    k_EMatchOutcome_NotScored_Leaver = 65,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NotScored_ServerCrash)
    k_EMatchOutcome_NotScored_ServerCrash = 66,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NotScored_NeverStarted)
    k_EMatchOutcome_NotScored_NeverStarted = 67,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NotScored_Canceled)
    k_EMatchOutcome_NotScored_Canceled = 68,
    // @@protoc_insertion_point(enum_value:EMatchOutcome.k_EMatchOutcome_NotScored_Suspicious)
    k_EMatchOutcome_NotScored_Suspicious = 69,
}

impl ::steam_vent_proto_common::protobuf::Enum for EMatchOutcome {
    const NAME: &'static str = "EMatchOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMatchOutcome> {
        match value {
            0 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Unknown),
            2 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_RadVictory),
            3 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_DireVictory),
            4 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NeutralVictory),
            5 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NoTeamWinner),
            6 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom1Victory),
            7 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom2Victory),
            8 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom3Victory),
            9 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom4Victory),
            10 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom5Victory),
            11 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom6Victory),
            12 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom7Victory),
            13 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom8Victory),
            64 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_PoorNetworkConditions),
            65 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Leaver),
            66 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_ServerCrash),
            67 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_NeverStarted),
            68 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Canceled),
            69 => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Suspicious),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMatchOutcome> {
        match str {
            "k_EMatchOutcome_Unknown" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Unknown),
            "k_EMatchOutcome_RadVictory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_RadVictory),
            "k_EMatchOutcome_DireVictory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_DireVictory),
            "k_EMatchOutcome_NeutralVictory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NeutralVictory),
            "k_EMatchOutcome_NoTeamWinner" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NoTeamWinner),
            "k_EMatchOutcome_Custom1Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom1Victory),
            "k_EMatchOutcome_Custom2Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom2Victory),
            "k_EMatchOutcome_Custom3Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom3Victory),
            "k_EMatchOutcome_Custom4Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom4Victory),
            "k_EMatchOutcome_Custom5Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom5Victory),
            "k_EMatchOutcome_Custom6Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom6Victory),
            "k_EMatchOutcome_Custom7Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom7Victory),
            "k_EMatchOutcome_Custom8Victory" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_Custom8Victory),
            "k_EMatchOutcome_NotScored_PoorNetworkConditions" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_PoorNetworkConditions),
            "k_EMatchOutcome_NotScored_Leaver" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Leaver),
            "k_EMatchOutcome_NotScored_ServerCrash" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_ServerCrash),
            "k_EMatchOutcome_NotScored_NeverStarted" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_NeverStarted),
            "k_EMatchOutcome_NotScored_Canceled" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Canceled),
            "k_EMatchOutcome_NotScored_Suspicious" => ::std::option::Option::Some(EMatchOutcome::k_EMatchOutcome_NotScored_Suspicious),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMatchOutcome] = &[
        EMatchOutcome::k_EMatchOutcome_Unknown,
        EMatchOutcome::k_EMatchOutcome_RadVictory,
        EMatchOutcome::k_EMatchOutcome_DireVictory,
        EMatchOutcome::k_EMatchOutcome_NeutralVictory,
        EMatchOutcome::k_EMatchOutcome_NoTeamWinner,
        EMatchOutcome::k_EMatchOutcome_Custom1Victory,
        EMatchOutcome::k_EMatchOutcome_Custom2Victory,
        EMatchOutcome::k_EMatchOutcome_Custom3Victory,
        EMatchOutcome::k_EMatchOutcome_Custom4Victory,
        EMatchOutcome::k_EMatchOutcome_Custom5Victory,
        EMatchOutcome::k_EMatchOutcome_Custom6Victory,
        EMatchOutcome::k_EMatchOutcome_Custom7Victory,
        EMatchOutcome::k_EMatchOutcome_Custom8Victory,
        EMatchOutcome::k_EMatchOutcome_NotScored_PoorNetworkConditions,
        EMatchOutcome::k_EMatchOutcome_NotScored_Leaver,
        EMatchOutcome::k_EMatchOutcome_NotScored_ServerCrash,
        EMatchOutcome::k_EMatchOutcome_NotScored_NeverStarted,
        EMatchOutcome::k_EMatchOutcome_NotScored_Canceled,
        EMatchOutcome::k_EMatchOutcome_NotScored_Suspicious,
    ];
}

impl ::std::default::Default for EMatchOutcome {
    fn default() -> Self {
        EMatchOutcome::k_EMatchOutcome_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELaneType)
pub enum ELaneType {
    // @@protoc_insertion_point(enum_value:ELaneType.LANE_TYPE_UNKNOWN)
    LANE_TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:ELaneType.LANE_TYPE_SAFE)
    LANE_TYPE_SAFE = 1,
    // @@protoc_insertion_point(enum_value:ELaneType.LANE_TYPE_OFF)
    LANE_TYPE_OFF = 2,
    // @@protoc_insertion_point(enum_value:ELaneType.LANE_TYPE_MID)
    LANE_TYPE_MID = 3,
    // @@protoc_insertion_point(enum_value:ELaneType.LANE_TYPE_JUNGLE)
    LANE_TYPE_JUNGLE = 4,
    // @@protoc_insertion_point(enum_value:ELaneType.LANE_TYPE_ROAM)
    LANE_TYPE_ROAM = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELaneType {
    const NAME: &'static str = "ELaneType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELaneType> {
        match value {
            0 => ::std::option::Option::Some(ELaneType::LANE_TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(ELaneType::LANE_TYPE_SAFE),
            2 => ::std::option::Option::Some(ELaneType::LANE_TYPE_OFF),
            3 => ::std::option::Option::Some(ELaneType::LANE_TYPE_MID),
            4 => ::std::option::Option::Some(ELaneType::LANE_TYPE_JUNGLE),
            5 => ::std::option::Option::Some(ELaneType::LANE_TYPE_ROAM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELaneType> {
        match str {
            "LANE_TYPE_UNKNOWN" => ::std::option::Option::Some(ELaneType::LANE_TYPE_UNKNOWN),
            "LANE_TYPE_SAFE" => ::std::option::Option::Some(ELaneType::LANE_TYPE_SAFE),
            "LANE_TYPE_OFF" => ::std::option::Option::Some(ELaneType::LANE_TYPE_OFF),
            "LANE_TYPE_MID" => ::std::option::Option::Some(ELaneType::LANE_TYPE_MID),
            "LANE_TYPE_JUNGLE" => ::std::option::Option::Some(ELaneType::LANE_TYPE_JUNGLE),
            "LANE_TYPE_ROAM" => ::std::option::Option::Some(ELaneType::LANE_TYPE_ROAM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELaneType] = &[
        ELaneType::LANE_TYPE_UNKNOWN,
        ELaneType::LANE_TYPE_SAFE,
        ELaneType::LANE_TYPE_OFF,
        ELaneType::LANE_TYPE_MID,
        ELaneType::LANE_TYPE_JUNGLE,
        ELaneType::LANE_TYPE_ROAM,
    ];
}

impl ::std::default::Default for ELaneType {
    fn default() -> Self {
        ELaneType::LANE_TYPE_UNKNOWN
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBadgeType)
pub enum EBadgeType {
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_Invalid)
    k_EBadgeType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI7_Midweek)
    k_EBadgeType_TI7_Midweek = 1,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI7_Finals)
    k_EBadgeType_TI7_Finals = 2,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI7_AllEvent)
    k_EBadgeType_TI7_AllEvent = 3,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI8_Midweek)
    k_EBadgeType_TI8_Midweek = 4,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI8_Finals)
    k_EBadgeType_TI8_Finals = 5,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI8_AllEvent)
    k_EBadgeType_TI8_AllEvent = 6,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI10)
    k_EBadgeType_TI10 = 7,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI11_PlayoffsDay1)
    k_EBadgeType_TI11_PlayoffsDay1 = 8,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI11_PlayoffsDay2)
    k_EBadgeType_TI11_PlayoffsDay2 = 9,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI11_PlayoffsDay3)
    k_EBadgeType_TI11_PlayoffsDay3 = 10,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI11_PlayoffsDay4)
    k_EBadgeType_TI11_PlayoffsDay4 = 11,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI11_FinalsWeekend)
    k_EBadgeType_TI11_FinalsWeekend = 12,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI12_PlayoffsDay1)
    k_EBadgeType_TI12_PlayoffsDay1 = 13,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI12_PlayoffsDay2)
    k_EBadgeType_TI12_PlayoffsDay2 = 14,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI12_PlayoffsDay3)
    k_EBadgeType_TI12_PlayoffsDay3 = 15,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI12_FinalsWeekend)
    k_EBadgeType_TI12_FinalsWeekend = 16,
    // @@protoc_insertion_point(enum_value:EBadgeType.k_EBadgeType_TI12_Special)
    k_EBadgeType_TI12_Special = 17,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBadgeType {
    const NAME: &'static str = "EBadgeType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBadgeType> {
        match value {
            0 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_Invalid),
            1 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Midweek),
            2 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Finals),
            3 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_AllEvent),
            4 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Midweek),
            5 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Finals),
            6 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_AllEvent),
            7 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI10),
            8 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay1),
            9 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay2),
            10 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay3),
            11 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay4),
            12 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_FinalsWeekend),
            13 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_PlayoffsDay1),
            14 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_PlayoffsDay2),
            15 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_PlayoffsDay3),
            16 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_FinalsWeekend),
            17 => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_Special),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBadgeType> {
        match str {
            "k_EBadgeType_Invalid" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_Invalid),
            "k_EBadgeType_TI7_Midweek" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Midweek),
            "k_EBadgeType_TI7_Finals" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_Finals),
            "k_EBadgeType_TI7_AllEvent" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI7_AllEvent),
            "k_EBadgeType_TI8_Midweek" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Midweek),
            "k_EBadgeType_TI8_Finals" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_Finals),
            "k_EBadgeType_TI8_AllEvent" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI8_AllEvent),
            "k_EBadgeType_TI10" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI10),
            "k_EBadgeType_TI11_PlayoffsDay1" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay1),
            "k_EBadgeType_TI11_PlayoffsDay2" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay2),
            "k_EBadgeType_TI11_PlayoffsDay3" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay3),
            "k_EBadgeType_TI11_PlayoffsDay4" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_PlayoffsDay4),
            "k_EBadgeType_TI11_FinalsWeekend" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI11_FinalsWeekend),
            "k_EBadgeType_TI12_PlayoffsDay1" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_PlayoffsDay1),
            "k_EBadgeType_TI12_PlayoffsDay2" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_PlayoffsDay2),
            "k_EBadgeType_TI12_PlayoffsDay3" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_PlayoffsDay3),
            "k_EBadgeType_TI12_FinalsWeekend" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_FinalsWeekend),
            "k_EBadgeType_TI12_Special" => ::std::option::Option::Some(EBadgeType::k_EBadgeType_TI12_Special),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBadgeType] = &[
        EBadgeType::k_EBadgeType_Invalid,
        EBadgeType::k_EBadgeType_TI7_Midweek,
        EBadgeType::k_EBadgeType_TI7_Finals,
        EBadgeType::k_EBadgeType_TI7_AllEvent,
        EBadgeType::k_EBadgeType_TI8_Midweek,
        EBadgeType::k_EBadgeType_TI8_Finals,
        EBadgeType::k_EBadgeType_TI8_AllEvent,
        EBadgeType::k_EBadgeType_TI10,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay1,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay2,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay3,
        EBadgeType::k_EBadgeType_TI11_PlayoffsDay4,
        EBadgeType::k_EBadgeType_TI11_FinalsWeekend,
        EBadgeType::k_EBadgeType_TI12_PlayoffsDay1,
        EBadgeType::k_EBadgeType_TI12_PlayoffsDay2,
        EBadgeType::k_EBadgeType_TI12_PlayoffsDay3,
        EBadgeType::k_EBadgeType_TI12_FinalsWeekend,
        EBadgeType::k_EBadgeType_TI12_Special,
    ];
}

impl ::std::default::Default for EBadgeType {
    fn default() -> Self {
        EBadgeType::k_EBadgeType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueStatus)
pub enum ELeagueStatus {
    // @@protoc_insertion_point(enum_value:ELeagueStatus.LEAGUE_STATUS_UNSET)
    LEAGUE_STATUS_UNSET = 0,
    // @@protoc_insertion_point(enum_value:ELeagueStatus.LEAGUE_STATUS_UNSUBMITTED)
    LEAGUE_STATUS_UNSUBMITTED = 1,
    // @@protoc_insertion_point(enum_value:ELeagueStatus.LEAGUE_STATUS_SUBMITTED)
    LEAGUE_STATUS_SUBMITTED = 2,
    // @@protoc_insertion_point(enum_value:ELeagueStatus.LEAGUE_STATUS_ACCEPTED)
    LEAGUE_STATUS_ACCEPTED = 3,
    // @@protoc_insertion_point(enum_value:ELeagueStatus.LEAGUE_STATUS_REJECTED)
    LEAGUE_STATUS_REJECTED = 4,
    // @@protoc_insertion_point(enum_value:ELeagueStatus.LEAGUE_STATUS_CONCLUDED)
    LEAGUE_STATUS_CONCLUDED = 5,
    // @@protoc_insertion_point(enum_value:ELeagueStatus.LEAGUE_STATUS_DELETED)
    LEAGUE_STATUS_DELETED = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueStatus {
    const NAME: &'static str = "ELeagueStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueStatus> {
        match value {
            0 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSET),
            1 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSUBMITTED),
            2 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_SUBMITTED),
            3 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_ACCEPTED),
            4 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_REJECTED),
            5 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_CONCLUDED),
            6 => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_DELETED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueStatus> {
        match str {
            "LEAGUE_STATUS_UNSET" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSET),
            "LEAGUE_STATUS_UNSUBMITTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_UNSUBMITTED),
            "LEAGUE_STATUS_SUBMITTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_SUBMITTED),
            "LEAGUE_STATUS_ACCEPTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_ACCEPTED),
            "LEAGUE_STATUS_REJECTED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_REJECTED),
            "LEAGUE_STATUS_CONCLUDED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_CONCLUDED),
            "LEAGUE_STATUS_DELETED" => ::std::option::Option::Some(ELeagueStatus::LEAGUE_STATUS_DELETED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueStatus] = &[
        ELeagueStatus::LEAGUE_STATUS_UNSET,
        ELeagueStatus::LEAGUE_STATUS_UNSUBMITTED,
        ELeagueStatus::LEAGUE_STATUS_SUBMITTED,
        ELeagueStatus::LEAGUE_STATUS_ACCEPTED,
        ELeagueStatus::LEAGUE_STATUS_REJECTED,
        ELeagueStatus::LEAGUE_STATUS_CONCLUDED,
        ELeagueStatus::LEAGUE_STATUS_DELETED,
    ];
}

impl ::std::default::Default for ELeagueStatus {
    fn default() -> Self {
        ELeagueStatus::LEAGUE_STATUS_UNSET
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueRegion)
pub enum ELeagueRegion {
    // @@protoc_insertion_point(enum_value:ELeagueRegion.LEAGUE_REGION_UNSET)
    LEAGUE_REGION_UNSET = 0,
    // @@protoc_insertion_point(enum_value:ELeagueRegion.LEAGUE_REGION_NA)
    LEAGUE_REGION_NA = 1,
    // @@protoc_insertion_point(enum_value:ELeagueRegion.LEAGUE_REGION_SA)
    LEAGUE_REGION_SA = 2,
    // @@protoc_insertion_point(enum_value:ELeagueRegion.LEAGUE_REGION_WEU)
    LEAGUE_REGION_WEU = 3,
    // @@protoc_insertion_point(enum_value:ELeagueRegion.LEAGUE_REGION_EEU)
    LEAGUE_REGION_EEU = 4,
    // @@protoc_insertion_point(enum_value:ELeagueRegion.LEAGUE_REGION_CHINA)
    LEAGUE_REGION_CHINA = 5,
    // @@protoc_insertion_point(enum_value:ELeagueRegion.LEAGUE_REGION_SEA)
    LEAGUE_REGION_SEA = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueRegion {
    const NAME: &'static str = "ELeagueRegion";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueRegion> {
        match value {
            0 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_UNSET),
            1 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_NA),
            2 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SA),
            3 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_WEU),
            4 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_EEU),
            5 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_CHINA),
            6 => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SEA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueRegion> {
        match str {
            "LEAGUE_REGION_UNSET" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_UNSET),
            "LEAGUE_REGION_NA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_NA),
            "LEAGUE_REGION_SA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SA),
            "LEAGUE_REGION_WEU" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_WEU),
            "LEAGUE_REGION_EEU" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_EEU),
            "LEAGUE_REGION_CHINA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_CHINA),
            "LEAGUE_REGION_SEA" => ::std::option::Option::Some(ELeagueRegion::LEAGUE_REGION_SEA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueRegion] = &[
        ELeagueRegion::LEAGUE_REGION_UNSET,
        ELeagueRegion::LEAGUE_REGION_NA,
        ELeagueRegion::LEAGUE_REGION_SA,
        ELeagueRegion::LEAGUE_REGION_WEU,
        ELeagueRegion::LEAGUE_REGION_EEU,
        ELeagueRegion::LEAGUE_REGION_CHINA,
        ELeagueRegion::LEAGUE_REGION_SEA,
    ];
}

impl ::std::default::Default for ELeagueRegion {
    fn default() -> Self {
        ELeagueRegion::LEAGUE_REGION_UNSET
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueTier)
pub enum ELeagueTier {
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_UNSET)
    LEAGUE_TIER_UNSET = 0,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_AMATEUR)
    LEAGUE_TIER_AMATEUR = 1,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_PROFESSIONAL)
    LEAGUE_TIER_PROFESSIONAL = 2,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_MINOR)
    LEAGUE_TIER_MINOR = 3,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_MAJOR)
    LEAGUE_TIER_MAJOR = 4,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_INTERNATIONAL)
    LEAGUE_TIER_INTERNATIONAL = 5,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_DPC_QUALIFIER)
    LEAGUE_TIER_DPC_QUALIFIER = 6,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_DPC_LEAGUE_QUALIFIER)
    LEAGUE_TIER_DPC_LEAGUE_QUALIFIER = 7,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_DPC_LEAGUE)
    LEAGUE_TIER_DPC_LEAGUE = 8,
    // @@protoc_insertion_point(enum_value:ELeagueTier.LEAGUE_TIER_DPC_LEAGUE_FINALS)
    LEAGUE_TIER_DPC_LEAGUE_FINALS = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueTier {
    const NAME: &'static str = "ELeagueTier";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueTier> {
        match value {
            0 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_UNSET),
            1 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_AMATEUR),
            2 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_PROFESSIONAL),
            3 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MINOR),
            4 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MAJOR),
            5 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_INTERNATIONAL),
            6 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_QUALIFIER),
            7 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_QUALIFIER),
            8 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE),
            9 => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_FINALS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueTier> {
        match str {
            "LEAGUE_TIER_UNSET" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_UNSET),
            "LEAGUE_TIER_AMATEUR" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_AMATEUR),
            "LEAGUE_TIER_PROFESSIONAL" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_PROFESSIONAL),
            "LEAGUE_TIER_MINOR" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MINOR),
            "LEAGUE_TIER_MAJOR" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_MAJOR),
            "LEAGUE_TIER_INTERNATIONAL" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_INTERNATIONAL),
            "LEAGUE_TIER_DPC_QUALIFIER" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_QUALIFIER),
            "LEAGUE_TIER_DPC_LEAGUE_QUALIFIER" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_QUALIFIER),
            "LEAGUE_TIER_DPC_LEAGUE" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE),
            "LEAGUE_TIER_DPC_LEAGUE_FINALS" => ::std::option::Option::Some(ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_FINALS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueTier] = &[
        ELeagueTier::LEAGUE_TIER_UNSET,
        ELeagueTier::LEAGUE_TIER_AMATEUR,
        ELeagueTier::LEAGUE_TIER_PROFESSIONAL,
        ELeagueTier::LEAGUE_TIER_MINOR,
        ELeagueTier::LEAGUE_TIER_MAJOR,
        ELeagueTier::LEAGUE_TIER_INTERNATIONAL,
        ELeagueTier::LEAGUE_TIER_DPC_QUALIFIER,
        ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_QUALIFIER,
        ELeagueTier::LEAGUE_TIER_DPC_LEAGUE,
        ELeagueTier::LEAGUE_TIER_DPC_LEAGUE_FINALS,
    ];
}

impl ::std::default::Default for ELeagueTier {
    fn default() -> Self {
        ELeagueTier::LEAGUE_TIER_UNSET
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueTierCategory)
pub enum ELeagueTierCategory {
    // @@protoc_insertion_point(enum_value:ELeagueTierCategory.LEAGUE_TIER_CATEGORY_AMATEUR)
    LEAGUE_TIER_CATEGORY_AMATEUR = 1,
    // @@protoc_insertion_point(enum_value:ELeagueTierCategory.LEAGUE_TIER_CATEGORY_PROFESSIONAL)
    LEAGUE_TIER_CATEGORY_PROFESSIONAL = 2,
    // @@protoc_insertion_point(enum_value:ELeagueTierCategory.LEAGUE_TIER_CATEGORY_DPC)
    LEAGUE_TIER_CATEGORY_DPC = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueTierCategory {
    const NAME: &'static str = "ELeagueTierCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueTierCategory> {
        match value {
            1 => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR),
            2 => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_PROFESSIONAL),
            3 => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_DPC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueTierCategory> {
        match str {
            "LEAGUE_TIER_CATEGORY_AMATEUR" => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR),
            "LEAGUE_TIER_CATEGORY_PROFESSIONAL" => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_PROFESSIONAL),
            "LEAGUE_TIER_CATEGORY_DPC" => ::std::option::Option::Some(ELeagueTierCategory::LEAGUE_TIER_CATEGORY_DPC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueTierCategory] = &[
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR,
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_PROFESSIONAL,
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_DPC,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ELeagueTierCategory {
    fn default() -> Self {
        ELeagueTierCategory::LEAGUE_TIER_CATEGORY_AMATEUR
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueDivision)
pub enum ELeagueDivision {
    // @@protoc_insertion_point(enum_value:ELeagueDivision.LEAGUE_DIVISION_UNSET)
    LEAGUE_DIVISION_UNSET = 0,
    // @@protoc_insertion_point(enum_value:ELeagueDivision.LEAGUE_DIVISION_I)
    LEAGUE_DIVISION_I = 1,
    // @@protoc_insertion_point(enum_value:ELeagueDivision.LEAGUE_DIVISION_II)
    LEAGUE_DIVISION_II = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueDivision {
    const NAME: &'static str = "ELeagueDivision";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueDivision> {
        match value {
            0 => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_UNSET),
            1 => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_I),
            2 => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_II),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueDivision> {
        match str {
            "LEAGUE_DIVISION_UNSET" => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_UNSET),
            "LEAGUE_DIVISION_I" => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_I),
            "LEAGUE_DIVISION_II" => ::std::option::Option::Some(ELeagueDivision::LEAGUE_DIVISION_II),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueDivision] = &[
        ELeagueDivision::LEAGUE_DIVISION_UNSET,
        ELeagueDivision::LEAGUE_DIVISION_I,
        ELeagueDivision::LEAGUE_DIVISION_II,
    ];
}

impl ::std::default::Default for ELeagueDivision {
    fn default() -> Self {
        ELeagueDivision::LEAGUE_DIVISION_UNSET
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueBroadcastProvider)
pub enum ELeagueBroadcastProvider {
    // @@protoc_insertion_point(enum_value:ELeagueBroadcastProvider.LEAGUE_BROADCAST_UNKNOWN)
    LEAGUE_BROADCAST_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:ELeagueBroadcastProvider.LEAGUE_BROADCAST_STEAM)
    LEAGUE_BROADCAST_STEAM = 1,
    // @@protoc_insertion_point(enum_value:ELeagueBroadcastProvider.LEAGUE_BROADCAST_TWITCH)
    LEAGUE_BROADCAST_TWITCH = 2,
    // @@protoc_insertion_point(enum_value:ELeagueBroadcastProvider.LEAGUE_BROADCAST_YOUTUBE)
    LEAGUE_BROADCAST_YOUTUBE = 3,
    // @@protoc_insertion_point(enum_value:ELeagueBroadcastProvider.LEAGUE_BROADCAST_OTHER)
    LEAGUE_BROADCAST_OTHER = 100,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueBroadcastProvider {
    const NAME: &'static str = "ELeagueBroadcastProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueBroadcastProvider> {
        match value {
            0 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN),
            1 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_STEAM),
            2 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_TWITCH),
            3 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_YOUTUBE),
            100 => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueBroadcastProvider> {
        match str {
            "LEAGUE_BROADCAST_UNKNOWN" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN),
            "LEAGUE_BROADCAST_STEAM" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_STEAM),
            "LEAGUE_BROADCAST_TWITCH" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_TWITCH),
            "LEAGUE_BROADCAST_YOUTUBE" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_YOUTUBE),
            "LEAGUE_BROADCAST_OTHER" => ::std::option::Option::Some(ELeagueBroadcastProvider::LEAGUE_BROADCAST_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueBroadcastProvider] = &[
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_STEAM,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_TWITCH,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_YOUTUBE,
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_OTHER,
    ];
}

impl ::std::default::Default for ELeagueBroadcastProvider {
    fn default() -> Self {
        ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeaguePhase)
pub enum ELeaguePhase {
    // @@protoc_insertion_point(enum_value:ELeaguePhase.LEAGUE_PHASE_UNSET)
    LEAGUE_PHASE_UNSET = 0,
    // @@protoc_insertion_point(enum_value:ELeaguePhase.LEAGUE_PHASE_REGIONAL_QUALIFIER)
    LEAGUE_PHASE_REGIONAL_QUALIFIER = 1,
    // @@protoc_insertion_point(enum_value:ELeaguePhase.LEAGUE_PHASE_GROUP_STAGE)
    LEAGUE_PHASE_GROUP_STAGE = 2,
    // @@protoc_insertion_point(enum_value:ELeaguePhase.LEAGUE_PHASE_MAIN_EVENT)
    LEAGUE_PHASE_MAIN_EVENT = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeaguePhase {
    const NAME: &'static str = "ELeaguePhase";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeaguePhase> {
        match value {
            0 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_UNSET),
            1 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_REGIONAL_QUALIFIER),
            2 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_GROUP_STAGE),
            3 => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_MAIN_EVENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeaguePhase> {
        match str {
            "LEAGUE_PHASE_UNSET" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_UNSET),
            "LEAGUE_PHASE_REGIONAL_QUALIFIER" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_REGIONAL_QUALIFIER),
            "LEAGUE_PHASE_GROUP_STAGE" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_GROUP_STAGE),
            "LEAGUE_PHASE_MAIN_EVENT" => ::std::option::Option::Some(ELeaguePhase::LEAGUE_PHASE_MAIN_EVENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeaguePhase] = &[
        ELeaguePhase::LEAGUE_PHASE_UNSET,
        ELeaguePhase::LEAGUE_PHASE_REGIONAL_QUALIFIER,
        ELeaguePhase::LEAGUE_PHASE_GROUP_STAGE,
        ELeaguePhase::LEAGUE_PHASE_MAIN_EVENT,
    ];
}

impl ::std::default::Default for ELeaguePhase {
    fn default() -> Self {
        ELeaguePhase::LEAGUE_PHASE_UNSET
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueAuditAction)
pub enum ELeagueAuditAction {
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_INVALID)
    LEAGUE_AUDIT_ACTION_INVALID = 0,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_CREATE)
    LEAGUE_AUDIT_ACTION_LEAGUE_CREATE = 1,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_EDIT)
    LEAGUE_AUDIT_ACTION_LEAGUE_EDIT = 2,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_DELETE)
    LEAGUE_AUDIT_ACTION_LEAGUE_DELETE = 3,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD = 4,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE = 5,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE = 6,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD)
    LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD = 7,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE)
    LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE = 8,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED)
    LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED = 9,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED)
    LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED = 10,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED)
    LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED = 11,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL)
    LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL = 12,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM = 13,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM)
    LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM = 14,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START)
    LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START = 15,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END)
    LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END = 16,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM)
    LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM = 17,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM)
    LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM = 18,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED)
    LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED = 19,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT)
    LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT = 20,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP)
    LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP = 21,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE)
    LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE = 100,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY)
    LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY = 101,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM)
    LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM = 102,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM)
    LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM = 103,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING = 104,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT)
    LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT = 105,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE)
    LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE = 106,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED)
    LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED = 107,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING = 108,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING = 109,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_CREATE)
    LEAGUE_AUDIT_ACTION_NODE_CREATE = 200,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_DESTROY)
    LEAGUE_AUDIT_ACTION_NODE_DESTROY = 201,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE)
    LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE = 202,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_TEAM)
    LEAGUE_AUDIT_ACTION_NODE_SET_TEAM = 203,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID)
    LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID = 204,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING)
    LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING = 205,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_SET_TIME)
    LEAGUE_AUDIT_ACTION_NODE_SET_TIME = 206,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED)
    LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED = 207,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_COMPLETED)
    LEAGUE_AUDIT_ACTION_NODE_COMPLETED = 208,
    // @@protoc_insertion_point(enum_value:ELeagueAuditAction.LEAGUE_AUDIT_ACTION_NODE_EDIT)
    LEAGUE_AUDIT_ACTION_NODE_EDIT = 209,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueAuditAction {
    const NAME: &'static str = "ELeagueAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueAuditAction> {
        match value {
            0 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID),
            1 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_CREATE),
            2 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_EDIT),
            3 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_DELETE),
            4 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD),
            5 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE),
            6 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE),
            7 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD),
            8 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE),
            9 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED),
            10 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED),
            11 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED),
            12 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL),
            13 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM),
            14 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM),
            15 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START),
            16 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END),
            17 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM),
            18 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM),
            19 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED),
            20 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT),
            21 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP),
            100 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE),
            101 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY),
            102 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM),
            103 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM),
            104 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING),
            105 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT),
            106 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE),
            107 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED),
            108 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING),
            109 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING),
            200 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_CREATE),
            201 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_DESTROY),
            202 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE),
            203 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TEAM),
            204 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID),
            205 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING),
            206 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TIME),
            207 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED),
            208 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_COMPLETED),
            209 => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_EDIT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueAuditAction> {
        match str {
            "LEAGUE_AUDIT_ACTION_INVALID" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID),
            "LEAGUE_AUDIT_ACTION_LEAGUE_CREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_CREATE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_EDIT),
            "LEAGUE_AUDIT_ACTION_LEAGUE_DELETE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_DELETE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE),
            "LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START),
            "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END),
            "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED),
            "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT),
            "LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODE_CREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_CREATE),
            "LEAGUE_AUDIT_ACTION_NODE_DESTROY" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_DESTROY),
            "LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE),
            "LEAGUE_AUDIT_ACTION_NODE_SET_TEAM" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TEAM),
            "LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID),
            "LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING),
            "LEAGUE_AUDIT_ACTION_NODE_SET_TIME" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TIME),
            "LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED),
            "LEAGUE_AUDIT_ACTION_NODE_COMPLETED" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_COMPLETED),
            "LEAGUE_AUDIT_ACTION_NODE_EDIT" => ::std::option::Option::Some(ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_EDIT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueAuditAction] = &[
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_CREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_EDIT,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_DELETE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_CREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_DESTROY,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TEAM,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_SET_TIME,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_COMPLETED,
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_NODE_EDIT,
    ];
}

impl ::std::default::Default for ELeagueAuditAction {
    fn default() -> Self {
        ELeagueAuditAction::LEAGUE_AUDIT_ACTION_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_COMBATLOG_TYPES)
pub enum DOTA_COMBATLOG_TYPES {
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_INVALID)
    DOTA_COMBATLOG_INVALID = -1,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_DAMAGE)
    DOTA_COMBATLOG_DAMAGE = 0,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_HEAL)
    DOTA_COMBATLOG_HEAL = 1,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MODIFIER_ADD)
    DOTA_COMBATLOG_MODIFIER_ADD = 2,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MODIFIER_REMOVE)
    DOTA_COMBATLOG_MODIFIER_REMOVE = 3,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_DEATH)
    DOTA_COMBATLOG_DEATH = 4,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ABILITY)
    DOTA_COMBATLOG_ABILITY = 5,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ITEM)
    DOTA_COMBATLOG_ITEM = 6,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_LOCATION)
    DOTA_COMBATLOG_LOCATION = 7,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_GOLD)
    DOTA_COMBATLOG_GOLD = 8,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_GAME_STATE)
    DOTA_COMBATLOG_GAME_STATE = 9,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_XP)
    DOTA_COMBATLOG_XP = 10,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PURCHASE)
    DOTA_COMBATLOG_PURCHASE = 11,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_BUYBACK)
    DOTA_COMBATLOG_BUYBACK = 12,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ABILITY_TRIGGER)
    DOTA_COMBATLOG_ABILITY_TRIGGER = 13,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PLAYERSTATS)
    DOTA_COMBATLOG_PLAYERSTATS = 14,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MULTIKILL)
    DOTA_COMBATLOG_MULTIKILL = 15,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_KILLSTREAK)
    DOTA_COMBATLOG_KILLSTREAK = 16,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_TEAM_BUILDING_KILL)
    DOTA_COMBATLOG_TEAM_BUILDING_KILL = 17,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_FIRST_BLOOD)
    DOTA_COMBATLOG_FIRST_BLOOD = 18,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MODIFIER_STACK_EVENT)
    DOTA_COMBATLOG_MODIFIER_STACK_EVENT = 19,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_NEUTRAL_CAMP_STACK)
    DOTA_COMBATLOG_NEUTRAL_CAMP_STACK = 20,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PICKUP_RUNE)
    DOTA_COMBATLOG_PICKUP_RUNE = 21,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_REVEALED_INVISIBLE)
    DOTA_COMBATLOG_REVEALED_INVISIBLE = 22,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_HERO_SAVED)
    DOTA_COMBATLOG_HERO_SAVED = 23,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MANA_RESTORED)
    DOTA_COMBATLOG_MANA_RESTORED = 24,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_HERO_LEVELUP)
    DOTA_COMBATLOG_HERO_LEVELUP = 25,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_BOTTLE_HEAL_ALLY)
    DOTA_COMBATLOG_BOTTLE_HEAL_ALLY = 26,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ENDGAME_STATS)
    DOTA_COMBATLOG_ENDGAME_STATS = 27,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_INTERRUPT_CHANNEL)
    DOTA_COMBATLOG_INTERRUPT_CHANNEL = 28,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ALLIED_GOLD)
    DOTA_COMBATLOG_ALLIED_GOLD = 29,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_AEGIS_TAKEN)
    DOTA_COMBATLOG_AEGIS_TAKEN = 30,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_MANA_DAMAGE)
    DOTA_COMBATLOG_MANA_DAMAGE = 31,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED)
    DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED = 32,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_UNIT_SUMMONED)
    DOTA_COMBATLOG_UNIT_SUMMONED = 33,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_ATTACK_EVADE)
    DOTA_COMBATLOG_ATTACK_EVADE = 34,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_TREE_CUT)
    DOTA_COMBATLOG_TREE_CUT = 35,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_SUCCESSFUL_SCAN)
    DOTA_COMBATLOG_SUCCESSFUL_SCAN = 36,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_END_KILLSTREAK)
    DOTA_COMBATLOG_END_KILLSTREAK = 37,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_BLOODSTONE_CHARGE)
    DOTA_COMBATLOG_BLOODSTONE_CHARGE = 38,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_CRITICAL_DAMAGE)
    DOTA_COMBATLOG_CRITICAL_DAMAGE = 39,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_SPELL_ABSORB)
    DOTA_COMBATLOG_SPELL_ABSORB = 40,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_UNIT_TELEPORTED)
    DOTA_COMBATLOG_UNIT_TELEPORTED = 41,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_KILL_EATER_EVENT)
    DOTA_COMBATLOG_KILL_EATER_EVENT = 42,
    // @@protoc_insertion_point(enum_value:DOTA_COMBATLOG_TYPES.DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED)
    DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED = 43,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_COMBATLOG_TYPES {
    const NAME: &'static str = "DOTA_COMBATLOG_TYPES";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_COMBATLOG_TYPES> {
        match value {
            -1 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID),
            0 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE),
            1 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL),
            2 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD),
            3 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE),
            4 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH),
            5 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY),
            6 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM),
            7 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION),
            8 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD),
            9 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE),
            10 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP),
            11 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE),
            12 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK),
            13 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER),
            14 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS),
            15 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL),
            16 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK),
            17 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL),
            18 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD),
            19 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_STACK_EVENT),
            20 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK),
            21 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE),
            22 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE),
            23 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED),
            24 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED),
            25 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP),
            26 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY),
            27 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS),
            28 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL),
            29 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD),
            30 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN),
            31 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE),
            32 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED),
            33 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED),
            34 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE),
            35 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT),
            36 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN),
            37 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK),
            38 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE),
            39 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE),
            40 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB),
            41 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_TELEPORTED),
            42 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILL_EATER_EVENT),
            43 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_COMBATLOG_TYPES> {
        match str {
            "DOTA_COMBATLOG_INVALID" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID),
            "DOTA_COMBATLOG_DAMAGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE),
            "DOTA_COMBATLOG_HEAL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL),
            "DOTA_COMBATLOG_MODIFIER_ADD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD),
            "DOTA_COMBATLOG_MODIFIER_REMOVE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE),
            "DOTA_COMBATLOG_DEATH" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH),
            "DOTA_COMBATLOG_ABILITY" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY),
            "DOTA_COMBATLOG_ITEM" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM),
            "DOTA_COMBATLOG_LOCATION" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION),
            "DOTA_COMBATLOG_GOLD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD),
            "DOTA_COMBATLOG_GAME_STATE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE),
            "DOTA_COMBATLOG_XP" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP),
            "DOTA_COMBATLOG_PURCHASE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE),
            "DOTA_COMBATLOG_BUYBACK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK),
            "DOTA_COMBATLOG_ABILITY_TRIGGER" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER),
            "DOTA_COMBATLOG_PLAYERSTATS" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS),
            "DOTA_COMBATLOG_MULTIKILL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL),
            "DOTA_COMBATLOG_KILLSTREAK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK),
            "DOTA_COMBATLOG_TEAM_BUILDING_KILL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL),
            "DOTA_COMBATLOG_FIRST_BLOOD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD),
            "DOTA_COMBATLOG_MODIFIER_STACK_EVENT" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_STACK_EVENT),
            "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK),
            "DOTA_COMBATLOG_PICKUP_RUNE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE),
            "DOTA_COMBATLOG_REVEALED_INVISIBLE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE),
            "DOTA_COMBATLOG_HERO_SAVED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED),
            "DOTA_COMBATLOG_MANA_RESTORED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED),
            "DOTA_COMBATLOG_HERO_LEVELUP" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP),
            "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY),
            "DOTA_COMBATLOG_ENDGAME_STATS" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS),
            "DOTA_COMBATLOG_INTERRUPT_CHANNEL" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL),
            "DOTA_COMBATLOG_ALLIED_GOLD" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD),
            "DOTA_COMBATLOG_AEGIS_TAKEN" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN),
            "DOTA_COMBATLOG_MANA_DAMAGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE),
            "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED),
            "DOTA_COMBATLOG_UNIT_SUMMONED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED),
            "DOTA_COMBATLOG_ATTACK_EVADE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE),
            "DOTA_COMBATLOG_TREE_CUT" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT),
            "DOTA_COMBATLOG_SUCCESSFUL_SCAN" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN),
            "DOTA_COMBATLOG_END_KILLSTREAK" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK),
            "DOTA_COMBATLOG_BLOODSTONE_CHARGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE),
            "DOTA_COMBATLOG_CRITICAL_DAMAGE" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE),
            "DOTA_COMBATLOG_SPELL_ABSORB" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB),
            "DOTA_COMBATLOG_UNIT_TELEPORTED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_TELEPORTED),
            "DOTA_COMBATLOG_KILL_EATER_EVENT" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILL_EATER_EVENT),
            "DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED" => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_COMBATLOG_TYPES] = &[
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_STACK_EVENT,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_TELEPORTED,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILL_EATER_EVENT,
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_COMBATLOG_TYPES {
    fn default() -> Self {
        DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDPCFavoriteType)
pub enum EDPCFavoriteType {
    // @@protoc_insertion_point(enum_value:EDPCFavoriteType.FAVORITE_TYPE_ALL)
    FAVORITE_TYPE_ALL = 0,
    // @@protoc_insertion_point(enum_value:EDPCFavoriteType.FAVORITE_TYPE_PLAYER)
    FAVORITE_TYPE_PLAYER = 1,
    // @@protoc_insertion_point(enum_value:EDPCFavoriteType.FAVORITE_TYPE_TEAM)
    FAVORITE_TYPE_TEAM = 2,
    // @@protoc_insertion_point(enum_value:EDPCFavoriteType.FAVORITE_TYPE_LEAGUE)
    FAVORITE_TYPE_LEAGUE = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDPCFavoriteType {
    const NAME: &'static str = "EDPCFavoriteType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDPCFavoriteType> {
        match value {
            0 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_ALL),
            1 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_PLAYER),
            2 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_TEAM),
            3 => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_LEAGUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDPCFavoriteType> {
        match str {
            "FAVORITE_TYPE_ALL" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_ALL),
            "FAVORITE_TYPE_PLAYER" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_PLAYER),
            "FAVORITE_TYPE_TEAM" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_TEAM),
            "FAVORITE_TYPE_LEAGUE" => ::std::option::Option::Some(EDPCFavoriteType::FAVORITE_TYPE_LEAGUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDPCFavoriteType] = &[
        EDPCFavoriteType::FAVORITE_TYPE_ALL,
        EDPCFavoriteType::FAVORITE_TYPE_PLAYER,
        EDPCFavoriteType::FAVORITE_TYPE_TEAM,
        EDPCFavoriteType::FAVORITE_TYPE_LEAGUE,
    ];
}

impl ::std::default::Default for EDPCFavoriteType {
    fn default() -> Self {
        EDPCFavoriteType::FAVORITE_TYPE_ALL
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDPCPushNotification)
pub enum EDPCPushNotification {
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_MATCH_STARTING)
    DPC_PUSH_NOTIFICATION_MATCH_STARTING = 1,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM)
    DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM = 10,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM)
    DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM = 11,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH)
    DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH = 12,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH)
    DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH = 13,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_LEAGUE_RESULT)
    DPC_PUSH_NOTIFICATION_LEAGUE_RESULT = 20,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE)
    DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE = 30,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_PREDICTION_RESULT)
    DPC_PUSH_NOTIFICATION_PREDICTION_RESULT = 31,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED)
    DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED = 40,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY)
    DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY = 41,
    // @@protoc_insertion_point(enum_value:EDPCPushNotification.DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS)
    DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS = 42,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDPCPushNotification {
    const NAME: &'static str = "EDPCPushNotification";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDPCPushNotification> {
        match value {
            1 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING),
            10 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM),
            11 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM),
            12 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH),
            13 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH),
            20 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_LEAGUE_RESULT),
            30 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE),
            31 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_RESULT),
            40 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED),
            41 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY),
            42 => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDPCPushNotification> {
        match str {
            "DPC_PUSH_NOTIFICATION_MATCH_STARTING" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING),
            "DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM),
            "DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM),
            "DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH),
            "DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH),
            "DPC_PUSH_NOTIFICATION_LEAGUE_RESULT" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_LEAGUE_RESULT),
            "DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE),
            "DPC_PUSH_NOTIFICATION_PREDICTION_RESULT" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_RESULT),
            "DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED),
            "DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY),
            "DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS" => ::std::option::Option::Some(EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDPCPushNotification] = &[
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_LEAGUE_RESULT,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_PREDICTION_RESULT,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY,
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDPCPushNotification {
    fn default() -> Self {
        EDPCPushNotification::DPC_PUSH_NOTIFICATION_MATCH_STARTING
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EEventActionScoreMode)
pub enum EEventActionScoreMode {
    // @@protoc_insertion_point(enum_value:EEventActionScoreMode.k_eEventActionScoreMode_Add)
    k_eEventActionScoreMode_Add = 0,
    // @@protoc_insertion_point(enum_value:EEventActionScoreMode.k_eEventActionScoreMode_Min)
    k_eEventActionScoreMode_Min = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EEventActionScoreMode {
    const NAME: &'static str = "EEventActionScoreMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EEventActionScoreMode> {
        match value {
            0 => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Add),
            1 => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Min),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EEventActionScoreMode> {
        match str {
            "k_eEventActionScoreMode_Add" => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Add),
            "k_eEventActionScoreMode_Min" => ::std::option::Option::Some(EEventActionScoreMode::k_eEventActionScoreMode_Min),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EEventActionScoreMode] = &[
        EEventActionScoreMode::k_eEventActionScoreMode_Add,
        EEventActionScoreMode::k_eEventActionScoreMode_Min,
    ];
}

impl ::std::default::Default for EEventActionScoreMode {
    fn default() -> Self {
        EEventActionScoreMode::k_eEventActionScoreMode_Add
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPlayerChallengeHistoryType)
pub enum EPlayerChallengeHistoryType {
    // @@protoc_insertion_point(enum_value:EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_Invalid)
    k_EPlayerChallengeHistoryType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_KillEater)
    k_EPlayerChallengeHistoryType_KillEater = 1,
    // @@protoc_insertion_point(enum_value:EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_DotaPlusRelic)
    k_EPlayerChallengeHistoryType_DotaPlusRelic = 2,
    // @@protoc_insertion_point(enum_value:EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge)
    k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge = 3,
    // @@protoc_insertion_point(enum_value:EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_InGameEventChallenge)
    k_EPlayerChallengeHistoryType_InGameEventChallenge = 4,
    // @@protoc_insertion_point(enum_value:EPlayerChallengeHistoryType.k_EPlayerChallengeHistoryType_GuildContract)
    k_EPlayerChallengeHistoryType_GuildContract = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPlayerChallengeHistoryType {
    const NAME: &'static str = "EPlayerChallengeHistoryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlayerChallengeHistoryType> {
        match value {
            0 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid),
            1 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_KillEater),
            2 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusRelic),
            3 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge),
            4 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_InGameEventChallenge),
            5 => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_GuildContract),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPlayerChallengeHistoryType> {
        match str {
            "k_EPlayerChallengeHistoryType_Invalid" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid),
            "k_EPlayerChallengeHistoryType_KillEater" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_KillEater),
            "k_EPlayerChallengeHistoryType_DotaPlusRelic" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusRelic),
            "k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge),
            "k_EPlayerChallengeHistoryType_InGameEventChallenge" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_InGameEventChallenge),
            "k_EPlayerChallengeHistoryType_GuildContract" => ::std::option::Option::Some(EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_GuildContract),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPlayerChallengeHistoryType] = &[
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_KillEater,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusRelic,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_InGameEventChallenge,
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_GuildContract,
    ];
}

impl ::std::default::Default for EPlayerChallengeHistoryType {
    fn default() -> Self {
        EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOverwatchReportReason)
pub enum EOverwatchReportReason {
    // @@protoc_insertion_point(enum_value:EOverwatchReportReason.k_EOverwatchReportReason_Unknown)
    k_EOverwatchReportReason_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EOverwatchReportReason.k_EOverwatchReportReason_Cheating)
    k_EOverwatchReportReason_Cheating = 1,
    // @@protoc_insertion_point(enum_value:EOverwatchReportReason.k_EOverwatchReportReason_Feeding)
    k_EOverwatchReportReason_Feeding = 2,
    // @@protoc_insertion_point(enum_value:EOverwatchReportReason.k_EOverwatchReportReason_Griefing)
    k_EOverwatchReportReason_Griefing = 3,
    // @@protoc_insertion_point(enum_value:EOverwatchReportReason.k_EOverwatchReportReason_Suspicious)
    k_EOverwatchReportReason_Suspicious = 4,
    // @@protoc_insertion_point(enum_value:EOverwatchReportReason.k_EOverwatchReportReason_AbilityAbuse)
    k_EOverwatchReportReason_AbilityAbuse = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EOverwatchReportReason {
    const NAME: &'static str = "EOverwatchReportReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverwatchReportReason> {
        match value {
            0 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Unknown),
            1 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Cheating),
            2 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Feeding),
            3 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Griefing),
            4 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Suspicious),
            5 => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_AbilityAbuse),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverwatchReportReason> {
        match str {
            "k_EOverwatchReportReason_Unknown" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Unknown),
            "k_EOverwatchReportReason_Cheating" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Cheating),
            "k_EOverwatchReportReason_Feeding" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Feeding),
            "k_EOverwatchReportReason_Griefing" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Griefing),
            "k_EOverwatchReportReason_Suspicious" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_Suspicious),
            "k_EOverwatchReportReason_AbilityAbuse" => ::std::option::Option::Some(EOverwatchReportReason::k_EOverwatchReportReason_AbilityAbuse),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverwatchReportReason] = &[
        EOverwatchReportReason::k_EOverwatchReportReason_Unknown,
        EOverwatchReportReason::k_EOverwatchReportReason_Cheating,
        EOverwatchReportReason::k_EOverwatchReportReason_Feeding,
        EOverwatchReportReason::k_EOverwatchReportReason_Griefing,
        EOverwatchReportReason::k_EOverwatchReportReason_Suspicious,
        EOverwatchReportReason::k_EOverwatchReportReason_AbilityAbuse,
    ];
}

impl ::std::default::Default for EOverwatchReportReason {
    fn default() -> Self {
        EOverwatchReportReason::k_EOverwatchReportReason_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECandyShopUpgrade)
pub enum ECandyShopUpgrade {
    // @@protoc_insertion_point(enum_value:ECandyShopUpgrade.k_ECandyShopUpgradeInvalid)
    k_ECandyShopUpgradeInvalid = -1,
    // @@protoc_insertion_point(enum_value:ECandyShopUpgrade.k_ECandyShopUpgrade_InventorySize)
    k_ECandyShopUpgrade_InventorySize = 0,
    // @@protoc_insertion_point(enum_value:ECandyShopUpgrade.k_ECandyShopUpgrade_RewardShelf)
    k_ECandyShopUpgrade_RewardShelf = 1,
    // @@protoc_insertion_point(enum_value:ECandyShopUpgrade.k_ECandyShopUpgrade_ExtraExchangeRecipe)
    k_ECandyShopUpgrade_ExtraExchangeRecipe = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECandyShopUpgrade {
    const NAME: &'static str = "ECandyShopUpgrade";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECandyShopUpgrade> {
        match value {
            -1 => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgradeInvalid),
            0 => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgrade_InventorySize),
            1 => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgrade_RewardShelf),
            2 => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgrade_ExtraExchangeRecipe),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECandyShopUpgrade> {
        match str {
            "k_ECandyShopUpgradeInvalid" => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgradeInvalid),
            "k_ECandyShopUpgrade_InventorySize" => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgrade_InventorySize),
            "k_ECandyShopUpgrade_RewardShelf" => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgrade_RewardShelf),
            "k_ECandyShopUpgrade_ExtraExchangeRecipe" => ::std::option::Option::Some(ECandyShopUpgrade::k_ECandyShopUpgrade_ExtraExchangeRecipe),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECandyShopUpgrade] = &[
        ECandyShopUpgrade::k_ECandyShopUpgradeInvalid,
        ECandyShopUpgrade::k_ECandyShopUpgrade_InventorySize,
        ECandyShopUpgrade::k_ECandyShopUpgrade_RewardShelf,
        ECandyShopUpgrade::k_ECandyShopUpgrade_ExtraExchangeRecipe,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECandyShopUpgrade {
    fn default() -> Self {
        ECandyShopUpgrade::k_ECandyShopUpgradeInvalid
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

impl ::steam_vent_proto_common::RpcMessage for CDOTAClientHardwareSpecs {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTASaveGame {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACombatLogEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPendingEventAward {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
