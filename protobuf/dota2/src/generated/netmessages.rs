// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `netmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CCLCMsg_ClientInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.send_table_crc)
    pub send_table_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.server_count)
    pub server_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_id)
    pub friends_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_name)
    pub friends_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ClientInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ClientInfo {
    fn default() -> &'a CCLCMsg_ClientInfo {
        <CCLCMsg_ClientInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ClientInfo {
    pub fn new() -> CCLCMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 send_table_crc = 1;

    pub fn send_table_crc(&self) -> u32 {
        self.send_table_crc.unwrap_or(0)
    }

    pub fn clear_send_table_crc(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
    }

    pub fn has_send_table_crc(&self) -> bool {
        self.send_table_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_table_crc(&mut self, v: u32) {
        self.send_table_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 server_count = 2;

    pub fn server_count(&self) -> u32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: u32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 3;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional uint32 friends_id = 5;

    pub fn friends_id(&self) -> u32 {
        self.friends_id.unwrap_or(0)
    }

    pub fn clear_friends_id(&mut self) {
        self.friends_id = ::std::option::Option::None;
    }

    pub fn has_friends_id(&self) -> bool {
        self.friends_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_id(&mut self, v: u32) {
        self.friends_id = ::std::option::Option::Some(v);
    }

    // optional string friends_name = 6;

    pub fn friends_name(&self) -> &str {
        match self.friends_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_friends_name(&mut self) {
        self.friends_name = ::std::option::Option::None;
    }

    pub fn has_friends_name(&self) -> bool {
        self.friends_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_name(&mut self, v: ::std::string::String) {
        self.friends_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friends_name(&mut self) -> &mut ::std::string::String {
        if self.friends_name.is_none() {
            self.friends_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.friends_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friends_name(&mut self) -> ::std::string::String {
        self.friends_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_ClientInfo {
    const NAME: &'static str = "CCLCMsg_ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.send_table_crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.friends_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.friends_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.send_table_crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.friends_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.friends_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.send_table_crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.friends_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.friends_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ClientInfo {
        CCLCMsg_ClientInfo::new()
    }

    fn clear(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.friends_id = ::std::option::Option::None;
        self.friends_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ClientInfo {
        static instance: CCLCMsg_ClientInfo = CCLCMsg_ClientInfo {
            send_table_crc: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            friends_id: ::std::option::Option::None,
            friends_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_Move)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_Move {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_Move.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CCLCMsg_Move.last_command_number)
    pub last_command_number: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_Move.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_Move {
    fn default() -> &'a CCLCMsg_Move {
        <CCLCMsg_Move as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_Move {
    pub fn new() -> CCLCMsg_Move {
        ::std::default::Default::default()
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 last_command_number = 4;

    pub fn last_command_number(&self) -> u32 {
        self.last_command_number.unwrap_or(0)
    }

    pub fn clear_last_command_number(&mut self) {
        self.last_command_number = ::std::option::Option::None;
    }

    pub fn has_last_command_number(&self) -> bool {
        self.last_command_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_command_number(&mut self, v: u32) {
        self.last_command_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_Move {
    const NAME: &'static str = "CCLCMsg_Move";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.last_command_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.last_command_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.last_command_number {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_Move {
        CCLCMsg_Move::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.last_command_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_Move {
        static instance: CCLCMsg_Move = CCLCMsg_Move {
            data: ::std::option::Option::None,
            last_command_number: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgVoiceAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVoiceAudio {
    // message fields
    // @@protoc_insertion_point(field:CMsgVoiceAudio.format)
    pub format: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<VoiceDataFormat_t>>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.voice_data)
    pub voice_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.sequence_bytes)
    pub sequence_bytes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.section_number)
    pub section_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.sample_rate)
    pub sample_rate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.uncompressed_sample_offset)
    pub uncompressed_sample_offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.num_packets)
    pub num_packets: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.packet_offsets)
    pub packet_offsets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.voice_level)
    pub voice_level: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVoiceAudio.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVoiceAudio {
    fn default() -> &'a CMsgVoiceAudio {
        <CMsgVoiceAudio as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgVoiceAudio {
    pub fn new() -> CMsgVoiceAudio {
        ::std::default::Default::default()
    }

    // optional .VoiceDataFormat_t format = 1;

    pub fn format(&self) -> VoiceDataFormat_t {
        match self.format {
            Some(e) => e.enum_value_or(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            None => VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: VoiceDataFormat_t) {
        self.format = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes voice_data = 2;

    pub fn voice_data(&self) -> &[u8] {
        match self.voice_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_voice_data(&mut self) {
        self.voice_data = ::std::option::Option::None;
    }

    pub fn has_voice_data(&self) -> bool {
        self.voice_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.voice_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.voice_data.is_none() {
            self.voice_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.voice_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_data(&mut self) -> ::std::vec::Vec<u8> {
        self.voice_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 sequence_bytes = 3;

    pub fn sequence_bytes(&self) -> i32 {
        self.sequence_bytes.unwrap_or(0)
    }

    pub fn clear_sequence_bytes(&mut self) {
        self.sequence_bytes = ::std::option::Option::None;
    }

    pub fn has_sequence_bytes(&self) -> bool {
        self.sequence_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_bytes(&mut self, v: i32) {
        self.sequence_bytes = ::std::option::Option::Some(v);
    }

    // optional uint32 section_number = 4;

    pub fn section_number(&self) -> u32 {
        self.section_number.unwrap_or(0)
    }

    pub fn clear_section_number(&mut self) {
        self.section_number = ::std::option::Option::None;
    }

    pub fn has_section_number(&self) -> bool {
        self.section_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_number(&mut self, v: u32) {
        self.section_number = ::std::option::Option::Some(v);
    }

    // optional uint32 sample_rate = 5;

    pub fn sample_rate(&self) -> u32 {
        self.sample_rate.unwrap_or(0)
    }

    pub fn clear_sample_rate(&mut self) {
        self.sample_rate = ::std::option::Option::None;
    }

    pub fn has_sample_rate(&self) -> bool {
        self.sample_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sample_rate(&mut self, v: u32) {
        self.sample_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 uncompressed_sample_offset = 6;

    pub fn uncompressed_sample_offset(&self) -> u32 {
        self.uncompressed_sample_offset.unwrap_or(0)
    }

    pub fn clear_uncompressed_sample_offset(&mut self) {
        self.uncompressed_sample_offset = ::std::option::Option::None;
    }

    pub fn has_uncompressed_sample_offset(&self) -> bool {
        self.uncompressed_sample_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_sample_offset(&mut self, v: u32) {
        self.uncompressed_sample_offset = ::std::option::Option::Some(v);
    }

    // optional uint32 num_packets = 7;

    pub fn num_packets(&self) -> u32 {
        self.num_packets.unwrap_or(0)
    }

    pub fn clear_num_packets(&mut self) {
        self.num_packets = ::std::option::Option::None;
    }

    pub fn has_num_packets(&self) -> bool {
        self.num_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_packets(&mut self, v: u32) {
        self.num_packets = ::std::option::Option::Some(v);
    }

    // optional float voice_level = 9;

    pub fn voice_level(&self) -> f32 {
        self.voice_level.unwrap_or(0.)
    }

    pub fn clear_voice_level(&mut self) {
        self.voice_level = ::std::option::Option::None;
    }

    pub fn has_voice_level(&self) -> bool {
        self.voice_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_level(&mut self, v: f32) {
        self.voice_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgVoiceAudio {
    const NAME: &'static str = "CMsgVoiceAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.voice_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.sequence_bytes = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.section_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.sample_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.uncompressed_sample_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.num_packets = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.packet_offsets)?;
                },
                64 => {
                    self.packet_offsets.push(is.read_uint32()?);
                },
                77 => {
                    self.voice_level = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.voice_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.sequence_bytes {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.section_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sample_rate {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.uncompressed_sample_offset {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.num_packets {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(8, &self.packet_offsets);
        if let Some(v) = self.voice_level {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voice_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.sequence_bytes {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.section_number {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sample_rate {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.uncompressed_sample_offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.num_packets {
            os.write_uint32(7, v)?;
        }
        os.write_repeated_packed_uint32(8, &self.packet_offsets)?;
        if let Some(v) = self.voice_level {
            os.write_float(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVoiceAudio {
        CMsgVoiceAudio::new()
    }

    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.voice_data = ::std::option::Option::None;
        self.sequence_bytes = ::std::option::Option::None;
        self.section_number = ::std::option::Option::None;
        self.sample_rate = ::std::option::Option::None;
        self.uncompressed_sample_offset = ::std::option::Option::None;
        self.num_packets = ::std::option::Option::None;
        self.packet_offsets.clear();
        self.voice_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVoiceAudio {
        static instance: CMsgVoiceAudio = CMsgVoiceAudio {
            format: ::std::option::Option::None,
            voice_data: ::std::option::Option::None,
            sequence_bytes: ::std::option::Option::None,
            section_number: ::std::option::Option::None,
            sample_rate: ::std::option::Option::None,
            uncompressed_sample_offset: ::std::option::Option::None,
            num_packets: ::std::option::Option::None,
            packet_offsets: ::std::vec::Vec::new(),
            voice_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_VoiceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.audio)
    pub audio: ::steam_vent_proto_common::protobuf::MessageField<CMsgVoiceAudio>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.tick)
    pub tick: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_VoiceData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_VoiceData {
    fn default() -> &'a CCLCMsg_VoiceData {
        <CCLCMsg_VoiceData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_VoiceData {
    pub fn new() -> CCLCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional fixed64 xuid = 2;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional uint32 tick = 3;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_VoiceData {
    const NAME: &'static str = "CCLCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.audio)?;
                },
                17 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.audio.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.tick {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_VoiceData {
        CCLCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.audio.clear();
        self.xuid = ::std::option::Option::None;
        self.tick = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_VoiceData {
        static instance: CCLCMsg_VoiceData = CCLCMsg_VoiceData {
            audio: ::steam_vent_proto_common::protobuf::MessageField::none(),
            xuid: ::std::option::Option::None,
            tick: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_BaselineAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_BaselineAck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_tick)
    pub baseline_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_nr)
    pub baseline_nr: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_BaselineAck.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_BaselineAck {
    fn default() -> &'a CCLCMsg_BaselineAck {
        <CCLCMsg_BaselineAck as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_BaselineAck {
    pub fn new() -> CCLCMsg_BaselineAck {
        ::std::default::Default::default()
    }

    // optional int32 baseline_tick = 1;

    pub fn baseline_tick(&self) -> i32 {
        self.baseline_tick.unwrap_or(0)
    }

    pub fn clear_baseline_tick(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
    }

    pub fn has_baseline_tick(&self) -> bool {
        self.baseline_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_tick(&mut self, v: i32) {
        self.baseline_tick = ::std::option::Option::Some(v);
    }

    // optional int32 baseline_nr = 2;

    pub fn baseline_nr(&self) -> i32 {
        self.baseline_nr.unwrap_or(0)
    }

    pub fn clear_baseline_nr(&mut self) {
        self.baseline_nr = ::std::option::Option::None;
    }

    pub fn has_baseline_nr(&self) -> bool {
        self.baseline_nr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_nr(&mut self, v: i32) {
        self.baseline_nr = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_BaselineAck {
    const NAME: &'static str = "CCLCMsg_BaselineAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.baseline_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.baseline_nr = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.baseline_tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.baseline_nr {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.baseline_tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.baseline_nr {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_BaselineAck {
        CCLCMsg_BaselineAck::new()
    }

    fn clear(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
        self.baseline_nr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_BaselineAck {
        static instance: CCLCMsg_BaselineAck = CCLCMsg_BaselineAck {
            baseline_tick: ::std::option::Option::None,
            baseline_nr: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_ListenEvents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ListenEvents {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ListenEvents.event_mask)
    pub event_mask: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ListenEvents.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ListenEvents {
    fn default() -> &'a CCLCMsg_ListenEvents {
        <CCLCMsg_ListenEvents as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ListenEvents {
    pub fn new() -> CCLCMsg_ListenEvents {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_ListenEvents {
    const NAME: &'static str = "CCLCMsg_ListenEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.event_mask)?;
                },
                13 => {
                    self.event_mask.push(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.event_mask.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.event_mask {
            os.write_fixed32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ListenEvents {
        CCLCMsg_ListenEvents::new()
    }

    fn clear(&mut self) {
        self.event_mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ListenEvents {
        static instance: CCLCMsg_ListenEvents = CCLCMsg_ListenEvents {
            event_mask: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_RespondCvarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RespondCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.status_code)
    pub status_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RespondCvarValue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RespondCvarValue {
    fn default() -> &'a CCLCMsg_RespondCvarValue {
        <CCLCMsg_RespondCvarValue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RespondCvarValue {
    pub fn new() -> CCLCMsg_RespondCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional int32 status_code = 2;

    pub fn status_code(&self) -> i32 {
        self.status_code.unwrap_or(0)
    }

    pub fn clear_status_code(&mut self) {
        self.status_code = ::std::option::Option::None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 4;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_RespondCvarValue {
    const NAME: &'static str = "CCLCMsg_RespondCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.status_code = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.status_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.status_code {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RespondCvarValue {
        CCLCMsg_RespondCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.status_code = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RespondCvarValue {
        static instance: CCLCMsg_RespondCvarValue = CCLCMsg_RespondCvarValue {
            cookie: ::std::option::Option::None,
            status_code: ::std::option::Option::None,
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_FileCRCCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_FileCRCCheck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_path)
    pub code_path: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_filename)
    pub code_filename: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.crc)
    pub crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_FileCRCCheck.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_FileCRCCheck {
    fn default() -> &'a CCLCMsg_FileCRCCheck {
        <CCLCMsg_FileCRCCheck as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_FileCRCCheck {
    pub fn new() -> CCLCMsg_FileCRCCheck {
        ::std::default::Default::default()
    }

    // optional int32 code_path = 1;

    pub fn code_path(&self) -> i32 {
        self.code_path.unwrap_or(0)
    }

    pub fn clear_code_path(&mut self) {
        self.code_path = ::std::option::Option::None;
    }

    pub fn has_code_path(&self) -> bool {
        self.code_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_path(&mut self, v: i32) {
        self.code_path = ::std::option::Option::Some(v);
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 code_filename = 3;

    pub fn code_filename(&self) -> i32 {
        self.code_filename.unwrap_or(0)
    }

    pub fn clear_code_filename(&mut self) {
        self.code_filename = ::std::option::Option::None;
    }

    pub fn has_code_filename(&self) -> bool {
        self.code_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_filename(&mut self, v: i32) {
        self.code_filename = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 crc = 5;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_FileCRCCheck {
    const NAME: &'static str = "CCLCMsg_FileCRCCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code_path = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.code_filename = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                45 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code_path {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.code_filename {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.code_path {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.code_filename {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.crc {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_FileCRCCheck {
        CCLCMsg_FileCRCCheck::new()
    }

    fn clear(&mut self) {
        self.code_path = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.code_filename = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_FileCRCCheck {
        static instance: CCLCMsg_FileCRCCheck = CCLCMsg_FileCRCCheck {
            code_path: ::std::option::Option::None,
            path: ::std::option::Option::None,
            code_filename: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_LoadingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_LoadingProgress {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_LoadingProgress.progress)
    pub progress: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_LoadingProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_LoadingProgress {
    fn default() -> &'a CCLCMsg_LoadingProgress {
        <CCLCMsg_LoadingProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_LoadingProgress {
    pub fn new() -> CCLCMsg_LoadingProgress {
        ::std::default::Default::default()
    }

    // optional int32 progress = 1;

    pub fn progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_LoadingProgress {
    const NAME: &'static str = "CCLCMsg_LoadingProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.progress = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.progress {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.progress {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_LoadingProgress {
        CCLCMsg_LoadingProgress::new()
    }

    fn clear(&mut self) {
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_LoadingProgress {
        static instance: CCLCMsg_LoadingProgress = CCLCMsg_LoadingProgress {
            progress: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_SplitPlayerConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_SplitPlayerConnect {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_SplitPlayerConnect.playername)
    pub playername: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_SplitPlayerConnect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_SplitPlayerConnect {
    fn default() -> &'a CCLCMsg_SplitPlayerConnect {
        <CCLCMsg_SplitPlayerConnect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_SplitPlayerConnect {
    pub fn new() -> CCLCMsg_SplitPlayerConnect {
        ::std::default::Default::default()
    }

    // optional string playername = 1;

    pub fn playername(&self) -> &str {
        match self.playername.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_playername(&mut self) {
        self.playername = ::std::option::Option::None;
    }

    pub fn has_playername(&self) -> bool {
        self.playername.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playername(&mut self, v: ::std::string::String) {
        self.playername = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playername(&mut self) -> &mut ::std::string::String {
        if self.playername.is_none() {
            self.playername = ::std::option::Option::Some(::std::string::String::new());
        }
        self.playername.as_mut().unwrap()
    }

    // Take field
    pub fn take_playername(&mut self) -> ::std::string::String {
        self.playername.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_SplitPlayerConnect {
    const NAME: &'static str = "CCLCMsg_SplitPlayerConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.playername = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playername.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.playername.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_SplitPlayerConnect {
        CCLCMsg_SplitPlayerConnect::new()
    }

    fn clear(&mut self) {
        self.playername = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_SplitPlayerConnect {
        static instance: CCLCMsg_SplitPlayerConnect = CCLCMsg_SplitPlayerConnect {
            playername: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_SplitPlayerDisconnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_SplitPlayerDisconnect {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_SplitPlayerDisconnect.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_SplitPlayerDisconnect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_SplitPlayerDisconnect {
    fn default() -> &'a CCLCMsg_SplitPlayerDisconnect {
        <CCLCMsg_SplitPlayerDisconnect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_SplitPlayerDisconnect {
    pub fn new() -> CCLCMsg_SplitPlayerDisconnect {
        ::std::default::Default::default()
    }

    // optional int32 slot = 1;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_SplitPlayerDisconnect {
    const NAME: &'static str = "CCLCMsg_SplitPlayerDisconnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.slot {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_SplitPlayerDisconnect {
        CCLCMsg_SplitPlayerDisconnect::new()
    }

    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_SplitPlayerDisconnect {
        static instance: CCLCMsg_SplitPlayerDisconnect = CCLCMsg_SplitPlayerDisconnect {
            slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_ServerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ServerStatus {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ServerStatus.simplified)
    pub simplified: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ServerStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ServerStatus {
    fn default() -> &'a CCLCMsg_ServerStatus {
        <CCLCMsg_ServerStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ServerStatus {
    pub fn new() -> CCLCMsg_ServerStatus {
        ::std::default::Default::default()
    }

    // optional bool simplified = 1;

    pub fn simplified(&self) -> bool {
        self.simplified.unwrap_or(false)
    }

    pub fn clear_simplified(&mut self) {
        self.simplified = ::std::option::Option::None;
    }

    pub fn has_simplified(&self) -> bool {
        self.simplified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_simplified(&mut self, v: bool) {
        self.simplified = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_ServerStatus {
    const NAME: &'static str = "CCLCMsg_ServerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.simplified = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.simplified {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.simplified {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ServerStatus {
        CCLCMsg_ServerStatus::new()
    }

    fn clear(&mut self) {
        self.simplified = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ServerStatus {
        static instance: CCLCMsg_ServerStatus = CCLCMsg_ServerStatus {
            simplified: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_RequestPause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RequestPause {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RequestPause.pause_type)
    pub pause_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<RequestPause_t>>,
    // @@protoc_insertion_point(field:CCLCMsg_RequestPause.pause_group)
    pub pause_group: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RequestPause.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RequestPause {
    fn default() -> &'a CCLCMsg_RequestPause {
        <CCLCMsg_RequestPause as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RequestPause {
    pub fn new() -> CCLCMsg_RequestPause {
        ::std::default::Default::default()
    }

    // optional .RequestPause_t pause_type = 1;

    pub fn pause_type(&self) -> RequestPause_t {
        match self.pause_type {
            Some(e) => e.enum_value_or(RequestPause_t::RP_PAUSE),
            None => RequestPause_t::RP_PAUSE,
        }
    }

    pub fn clear_pause_type(&mut self) {
        self.pause_type = ::std::option::Option::None;
    }

    pub fn has_pause_type(&self) -> bool {
        self.pause_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_type(&mut self, v: RequestPause_t) {
        self.pause_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 pause_group = 2;

    pub fn pause_group(&self) -> i32 {
        self.pause_group.unwrap_or(0)
    }

    pub fn clear_pause_group(&mut self) {
        self.pause_group = ::std::option::Option::None;
    }

    pub fn has_pause_group(&self) -> bool {
        self.pause_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_group(&mut self, v: i32) {
        self.pause_group = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_RequestPause {
    const NAME: &'static str = "CCLCMsg_RequestPause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pause_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.pause_group = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pause_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.pause_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pause_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.pause_group {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RequestPause {
        CCLCMsg_RequestPause::new()
    }

    fn clear(&mut self) {
        self.pause_type = ::std::option::Option::None;
        self.pause_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RequestPause {
        static instance: CCLCMsg_RequestPause = CCLCMsg_RequestPause {
            pause_type: ::std::option::Option::None,
            pause_group: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_CmdKeyValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_CmdKeyValues.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_CmdKeyValues {
    fn default() -> &'a CCLCMsg_CmdKeyValues {
        <CCLCMsg_CmdKeyValues as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_CmdKeyValues {
    pub fn new() -> CCLCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_CmdKeyValues {
    const NAME: &'static str = "CCLCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_CmdKeyValues {
        CCLCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_CmdKeyValues {
        static instance: CCLCMsg_CmdKeyValues = CCLCMsg_CmdKeyValues {
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_RconServerDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RconServerDetails {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RconServerDetails.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RconServerDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RconServerDetails {
    fn default() -> &'a CCLCMsg_RconServerDetails {
        <CCLCMsg_RconServerDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RconServerDetails {
    pub fn new() -> CCLCMsg_RconServerDetails {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_RconServerDetails {
    const NAME: &'static str = "CCLCMsg_RconServerDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RconServerDetails {
        CCLCMsg_RconServerDetails::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RconServerDetails {
        static instance: CCLCMsg_RconServerDetails = CCLCMsg_RconServerDetails {
            token: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSource2SystemSpecs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource2SystemSpecs {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_id)
    pub cpu_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_brand)
    pub cpu_brand: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_model)
    pub cpu_model: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_num_physical)
    pub cpu_num_physical: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.ram_physical_total_mb)
    pub ram_physical_total_mb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_rendersystem_dll_name)
    pub gpu_rendersystem_dll_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_vendor_id)
    pub gpu_vendor_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_driver_name)
    pub gpu_driver_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_driver_version_high)
    pub gpu_driver_version_high: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_driver_version_low)
    pub gpu_driver_version_low: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_dx_support_level)
    pub gpu_dx_support_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_texture_memory_size_mb)
    pub gpu_texture_memory_size_mb: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource2SystemSpecs.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource2SystemSpecs {
    fn default() -> &'a CMsgSource2SystemSpecs {
        <CMsgSource2SystemSpecs as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSource2SystemSpecs {
    pub fn new() -> CMsgSource2SystemSpecs {
        ::std::default::Default::default()
    }

    // optional string cpu_id = 1;

    pub fn cpu_id(&self) -> &str {
        match self.cpu_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cpu_id(&mut self) {
        self.cpu_id = ::std::option::Option::None;
    }

    pub fn has_cpu_id(&self) -> bool {
        self.cpu_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_id(&mut self, v: ::std::string::String) {
        self.cpu_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_id(&mut self) -> &mut ::std::string::String {
        if self.cpu_id.is_none() {
            self.cpu_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cpu_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_id(&mut self) -> ::std::string::String {
        self.cpu_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cpu_brand = 2;

    pub fn cpu_brand(&self) -> &str {
        match self.cpu_brand.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cpu_brand(&mut self) {
        self.cpu_brand = ::std::option::Option::None;
    }

    pub fn has_cpu_brand(&self) -> bool {
        self.cpu_brand.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_brand(&mut self, v: ::std::string::String) {
        self.cpu_brand = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_brand(&mut self) -> &mut ::std::string::String {
        if self.cpu_brand.is_none() {
            self.cpu_brand = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cpu_brand.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_brand(&mut self) -> ::std::string::String {
        self.cpu_brand.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 cpu_model = 3;

    pub fn cpu_model(&self) -> u32 {
        self.cpu_model.unwrap_or(0)
    }

    pub fn clear_cpu_model(&mut self) {
        self.cpu_model = ::std::option::Option::None;
    }

    pub fn has_cpu_model(&self) -> bool {
        self.cpu_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_model(&mut self, v: u32) {
        self.cpu_model = ::std::option::Option::Some(v);
    }

    // optional uint32 cpu_num_physical = 4;

    pub fn cpu_num_physical(&self) -> u32 {
        self.cpu_num_physical.unwrap_or(0)
    }

    pub fn clear_cpu_num_physical(&mut self) {
        self.cpu_num_physical = ::std::option::Option::None;
    }

    pub fn has_cpu_num_physical(&self) -> bool {
        self.cpu_num_physical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_num_physical(&mut self, v: u32) {
        self.cpu_num_physical = ::std::option::Option::Some(v);
    }

    // optional uint32 ram_physical_total_mb = 21;

    pub fn ram_physical_total_mb(&self) -> u32 {
        self.ram_physical_total_mb.unwrap_or(0)
    }

    pub fn clear_ram_physical_total_mb(&mut self) {
        self.ram_physical_total_mb = ::std::option::Option::None;
    }

    pub fn has_ram_physical_total_mb(&self) -> bool {
        self.ram_physical_total_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ram_physical_total_mb(&mut self, v: u32) {
        self.ram_physical_total_mb = ::std::option::Option::Some(v);
    }

    // optional string gpu_rendersystem_dll_name = 41;

    pub fn gpu_rendersystem_dll_name(&self) -> &str {
        match self.gpu_rendersystem_dll_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gpu_rendersystem_dll_name(&mut self) {
        self.gpu_rendersystem_dll_name = ::std::option::Option::None;
    }

    pub fn has_gpu_rendersystem_dll_name(&self) -> bool {
        self.gpu_rendersystem_dll_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_rendersystem_dll_name(&mut self, v: ::std::string::String) {
        self.gpu_rendersystem_dll_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gpu_rendersystem_dll_name(&mut self) -> &mut ::std::string::String {
        if self.gpu_rendersystem_dll_name.is_none() {
            self.gpu_rendersystem_dll_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gpu_rendersystem_dll_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_gpu_rendersystem_dll_name(&mut self) -> ::std::string::String {
        self.gpu_rendersystem_dll_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gpu_vendor_id = 42;

    pub fn gpu_vendor_id(&self) -> u32 {
        self.gpu_vendor_id.unwrap_or(0)
    }

    pub fn clear_gpu_vendor_id(&mut self) {
        self.gpu_vendor_id = ::std::option::Option::None;
    }

    pub fn has_gpu_vendor_id(&self) -> bool {
        self.gpu_vendor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_vendor_id(&mut self, v: u32) {
        self.gpu_vendor_id = ::std::option::Option::Some(v);
    }

    // optional string gpu_driver_name = 43;

    pub fn gpu_driver_name(&self) -> &str {
        match self.gpu_driver_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gpu_driver_name(&mut self) {
        self.gpu_driver_name = ::std::option::Option::None;
    }

    pub fn has_gpu_driver_name(&self) -> bool {
        self.gpu_driver_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_driver_name(&mut self, v: ::std::string::String) {
        self.gpu_driver_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gpu_driver_name(&mut self) -> &mut ::std::string::String {
        if self.gpu_driver_name.is_none() {
            self.gpu_driver_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gpu_driver_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_gpu_driver_name(&mut self) -> ::std::string::String {
        self.gpu_driver_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gpu_driver_version_high = 44;

    pub fn gpu_driver_version_high(&self) -> u32 {
        self.gpu_driver_version_high.unwrap_or(0)
    }

    pub fn clear_gpu_driver_version_high(&mut self) {
        self.gpu_driver_version_high = ::std::option::Option::None;
    }

    pub fn has_gpu_driver_version_high(&self) -> bool {
        self.gpu_driver_version_high.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_driver_version_high(&mut self, v: u32) {
        self.gpu_driver_version_high = ::std::option::Option::Some(v);
    }

    // optional uint32 gpu_driver_version_low = 45;

    pub fn gpu_driver_version_low(&self) -> u32 {
        self.gpu_driver_version_low.unwrap_or(0)
    }

    pub fn clear_gpu_driver_version_low(&mut self) {
        self.gpu_driver_version_low = ::std::option::Option::None;
    }

    pub fn has_gpu_driver_version_low(&self) -> bool {
        self.gpu_driver_version_low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_driver_version_low(&mut self, v: u32) {
        self.gpu_driver_version_low = ::std::option::Option::Some(v);
    }

    // optional uint32 gpu_dx_support_level = 46;

    pub fn gpu_dx_support_level(&self) -> u32 {
        self.gpu_dx_support_level.unwrap_or(0)
    }

    pub fn clear_gpu_dx_support_level(&mut self) {
        self.gpu_dx_support_level = ::std::option::Option::None;
    }

    pub fn has_gpu_dx_support_level(&self) -> bool {
        self.gpu_dx_support_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_dx_support_level(&mut self, v: u32) {
        self.gpu_dx_support_level = ::std::option::Option::Some(v);
    }

    // optional uint32 gpu_texture_memory_size_mb = 47;

    pub fn gpu_texture_memory_size_mb(&self) -> u32 {
        self.gpu_texture_memory_size_mb.unwrap_or(0)
    }

    pub fn clear_gpu_texture_memory_size_mb(&mut self) {
        self.gpu_texture_memory_size_mb = ::std::option::Option::None;
    }

    pub fn has_gpu_texture_memory_size_mb(&self) -> bool {
        self.gpu_texture_memory_size_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_texture_memory_size_mb(&mut self, v: u32) {
        self.gpu_texture_memory_size_mb = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSource2SystemSpecs {
    const NAME: &'static str = "CMsgSource2SystemSpecs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cpu_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.cpu_brand = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.cpu_model = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.cpu_num_physical = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.ram_physical_total_mb = ::std::option::Option::Some(is.read_uint32()?);
                },
                330 => {
                    self.gpu_rendersystem_dll_name = ::std::option::Option::Some(is.read_string()?);
                },
                336 => {
                    self.gpu_vendor_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                346 => {
                    self.gpu_driver_name = ::std::option::Option::Some(is.read_string()?);
                },
                352 => {
                    self.gpu_driver_version_high = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.gpu_driver_version_low = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.gpu_dx_support_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.gpu_texture_memory_size_mb = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cpu_brand.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cpu_model {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.cpu_num_physical {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ram_physical_total_mb {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.gpu_rendersystem_dll_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(41, &v);
        }
        if let Some(v) = self.gpu_vendor_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.gpu_driver_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(43, &v);
        }
        if let Some(v) = self.gpu_driver_version_high {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.gpu_driver_version_low {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.gpu_dx_support_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.gpu_texture_memory_size_mb {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(47, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cpu_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.cpu_brand.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cpu_model {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.cpu_num_physical {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ram_physical_total_mb {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.gpu_rendersystem_dll_name.as_ref() {
            os.write_string(41, v)?;
        }
        if let Some(v) = self.gpu_vendor_id {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.gpu_driver_name.as_ref() {
            os.write_string(43, v)?;
        }
        if let Some(v) = self.gpu_driver_version_high {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.gpu_driver_version_low {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.gpu_dx_support_level {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.gpu_texture_memory_size_mb {
            os.write_uint32(47, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource2SystemSpecs {
        CMsgSource2SystemSpecs::new()
    }

    fn clear(&mut self) {
        self.cpu_id = ::std::option::Option::None;
        self.cpu_brand = ::std::option::Option::None;
        self.cpu_model = ::std::option::Option::None;
        self.cpu_num_physical = ::std::option::Option::None;
        self.ram_physical_total_mb = ::std::option::Option::None;
        self.gpu_rendersystem_dll_name = ::std::option::Option::None;
        self.gpu_vendor_id = ::std::option::Option::None;
        self.gpu_driver_name = ::std::option::Option::None;
        self.gpu_driver_version_high = ::std::option::Option::None;
        self.gpu_driver_version_low = ::std::option::Option::None;
        self.gpu_dx_support_level = ::std::option::Option::None;
        self.gpu_texture_memory_size_mb = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource2SystemSpecs {
        static instance: CMsgSource2SystemSpecs = CMsgSource2SystemSpecs {
            cpu_id: ::std::option::Option::None,
            cpu_brand: ::std::option::Option::None,
            cpu_model: ::std::option::Option::None,
            cpu_num_physical: ::std::option::Option::None,
            ram_physical_total_mb: ::std::option::Option::None,
            gpu_rendersystem_dll_name: ::std::option::Option::None,
            gpu_vendor_id: ::std::option::Option::None,
            gpu_driver_name: ::std::option::Option::None,
            gpu_driver_version_high: ::std::option::Option::None,
            gpu_driver_version_low: ::std::option::Option::None,
            gpu_dx_support_level: ::std::option::Option::None,
            gpu_texture_memory_size_mb: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSource2VProfLiteReportItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource2VProfLiteReportItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.active_samples)
    pub active_samples: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_max)
    pub usec_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_avg_active)
    pub usec_avg_active: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p50_active)
    pub usec_p50_active: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p99_active)
    pub usec_p99_active: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_avg_all)
    pub usec_avg_all: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p50_all)
    pub usec_p50_all: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p99_all)
    pub usec_p99_all: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource2VProfLiteReportItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource2VProfLiteReportItem {
    fn default() -> &'a CMsgSource2VProfLiteReportItem {
        <CMsgSource2VProfLiteReportItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSource2VProfLiteReportItem {
    pub fn new() -> CMsgSource2VProfLiteReportItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_samples = 2;

    pub fn active_samples(&self) -> u32 {
        self.active_samples.unwrap_or(0)
    }

    pub fn clear_active_samples(&mut self) {
        self.active_samples = ::std::option::Option::None;
    }

    pub fn has_active_samples(&self) -> bool {
        self.active_samples.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_samples(&mut self, v: u32) {
        self.active_samples = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_max = 3;

    pub fn usec_max(&self) -> u32 {
        self.usec_max.unwrap_or(0)
    }

    pub fn clear_usec_max(&mut self) {
        self.usec_max = ::std::option::Option::None;
    }

    pub fn has_usec_max(&self) -> bool {
        self.usec_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_max(&mut self, v: u32) {
        self.usec_max = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_avg_active = 11;

    pub fn usec_avg_active(&self) -> u32 {
        self.usec_avg_active.unwrap_or(0)
    }

    pub fn clear_usec_avg_active(&mut self) {
        self.usec_avg_active = ::std::option::Option::None;
    }

    pub fn has_usec_avg_active(&self) -> bool {
        self.usec_avg_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_avg_active(&mut self, v: u32) {
        self.usec_avg_active = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p50_active = 12;

    pub fn usec_p50_active(&self) -> u32 {
        self.usec_p50_active.unwrap_or(0)
    }

    pub fn clear_usec_p50_active(&mut self) {
        self.usec_p50_active = ::std::option::Option::None;
    }

    pub fn has_usec_p50_active(&self) -> bool {
        self.usec_p50_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p50_active(&mut self, v: u32) {
        self.usec_p50_active = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p99_active = 13;

    pub fn usec_p99_active(&self) -> u32 {
        self.usec_p99_active.unwrap_or(0)
    }

    pub fn clear_usec_p99_active(&mut self) {
        self.usec_p99_active = ::std::option::Option::None;
    }

    pub fn has_usec_p99_active(&self) -> bool {
        self.usec_p99_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p99_active(&mut self, v: u32) {
        self.usec_p99_active = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_avg_all = 21;

    pub fn usec_avg_all(&self) -> u32 {
        self.usec_avg_all.unwrap_or(0)
    }

    pub fn clear_usec_avg_all(&mut self) {
        self.usec_avg_all = ::std::option::Option::None;
    }

    pub fn has_usec_avg_all(&self) -> bool {
        self.usec_avg_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_avg_all(&mut self, v: u32) {
        self.usec_avg_all = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p50_all = 22;

    pub fn usec_p50_all(&self) -> u32 {
        self.usec_p50_all.unwrap_or(0)
    }

    pub fn clear_usec_p50_all(&mut self) {
        self.usec_p50_all = ::std::option::Option::None;
    }

    pub fn has_usec_p50_all(&self) -> bool {
        self.usec_p50_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p50_all(&mut self, v: u32) {
        self.usec_p50_all = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p99_all = 23;

    pub fn usec_p99_all(&self) -> u32 {
        self.usec_p99_all.unwrap_or(0)
    }

    pub fn clear_usec_p99_all(&mut self) {
        self.usec_p99_all = ::std::option::Option::None;
    }

    pub fn has_usec_p99_all(&self) -> bool {
        self.usec_p99_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p99_all(&mut self, v: u32) {
        self.usec_p99_all = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSource2VProfLiteReportItem {
    const NAME: &'static str = "CMsgSource2VProfLiteReportItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.active_samples = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.usec_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.usec_avg_active = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.usec_p50_active = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.usec_p99_active = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.usec_avg_all = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.usec_p50_all = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.usec_p99_all = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.active_samples {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.usec_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.usec_avg_active {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.usec_p50_active {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.usec_p99_active {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.usec_avg_all {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.usec_p50_all {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.usec_p99_all {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.active_samples {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.usec_max {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.usec_avg_active {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.usec_p50_active {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.usec_p99_active {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.usec_avg_all {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.usec_p50_all {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.usec_p99_all {
            os.write_uint32(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource2VProfLiteReportItem {
        CMsgSource2VProfLiteReportItem::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.active_samples = ::std::option::Option::None;
        self.usec_max = ::std::option::Option::None;
        self.usec_avg_active = ::std::option::Option::None;
        self.usec_p50_active = ::std::option::Option::None;
        self.usec_p99_active = ::std::option::Option::None;
        self.usec_avg_all = ::std::option::Option::None;
        self.usec_p50_all = ::std::option::Option::None;
        self.usec_p99_all = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource2VProfLiteReportItem {
        static instance: CMsgSource2VProfLiteReportItem = CMsgSource2VProfLiteReportItem {
            name: ::std::option::Option::None,
            active_samples: ::std::option::Option::None,
            usec_max: ::std::option::Option::None,
            usec_avg_active: ::std::option::Option::None,
            usec_p50_active: ::std::option::Option::None,
            usec_p99_active: ::std::option::Option::None,
            usec_avg_all: ::std::option::Option::None,
            usec_p50_all: ::std::option::Option::None,
            usec_p99_all: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSource2VProfLiteReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource2VProfLiteReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReport.total)
    pub total: ::steam_vent_proto_common::protobuf::MessageField<CMsgSource2VProfLiteReportItem>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReport.items)
    pub items: ::std::vec::Vec<CMsgSource2VProfLiteReportItem>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReport.discarded_frames)
    pub discarded_frames: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource2VProfLiteReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource2VProfLiteReport {
    fn default() -> &'a CMsgSource2VProfLiteReport {
        <CMsgSource2VProfLiteReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSource2VProfLiteReport {
    pub fn new() -> CMsgSource2VProfLiteReport {
        ::std::default::Default::default()
    }

    // optional uint32 discarded_frames = 3;

    pub fn discarded_frames(&self) -> u32 {
        self.discarded_frames.unwrap_or(0)
    }

    pub fn clear_discarded_frames(&mut self) {
        self.discarded_frames = ::std::option::Option::None;
    }

    pub fn has_discarded_frames(&self) -> bool {
        self.discarded_frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discarded_frames(&mut self, v: u32) {
        self.discarded_frames = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSource2VProfLiteReport {
    const NAME: &'static str = "CMsgSource2VProfLiteReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.total)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                24 => {
                    self.discarded_frames = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.total.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.discarded_frames {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.total.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.discarded_frames {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource2VProfLiteReport {
        CMsgSource2VProfLiteReport::new()
    }

    fn clear(&mut self) {
        self.total.clear();
        self.items.clear();
        self.discarded_frames = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource2VProfLiteReport {
        static instance: CMsgSource2VProfLiteReport = CMsgSource2VProfLiteReport {
            total: ::steam_vent_proto_common::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            discarded_frames: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_Diagnostic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_Diagnostic {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_Diagnostic.system_specs)
    pub system_specs: ::steam_vent_proto_common::protobuf::MessageField<CMsgSource2SystemSpecs>,
    // @@protoc_insertion_point(field:CCLCMsg_Diagnostic.vprof_report)
    pub vprof_report: ::steam_vent_proto_common::protobuf::MessageField<CMsgSource2VProfLiteReport>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_Diagnostic.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_Diagnostic {
    fn default() -> &'a CCLCMsg_Diagnostic {
        <CCLCMsg_Diagnostic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_Diagnostic {
    pub fn new() -> CCLCMsg_Diagnostic {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_Diagnostic {
    const NAME: &'static str = "CCLCMsg_Diagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.system_specs)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.vprof_report)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.system_specs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vprof_report.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.system_specs.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vprof_report.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_Diagnostic {
        CCLCMsg_Diagnostic::new()
    }

    fn clear(&mut self) {
        self.system_specs.clear();
        self.vprof_report.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_Diagnostic {
        static instance: CCLCMsg_Diagnostic = CCLCMsg_Diagnostic {
            system_specs: ::steam_vent_proto_common::protobuf::MessageField::none(),
            vprof_report: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSource2Metrics_MatchPerfSummary_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSource2Metrics_MatchPerfSummary_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.game_mode)
    pub game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.server_build_id)
    pub server_build_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.server_profile)
    pub server_profile: ::steam_vent_proto_common::protobuf::MessageField<CMsgSource2VProfLiteReport>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.clients)
    pub clients: ::std::vec::Vec<csource2metrics_match_perf_summary_notification::Client>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.map)
    pub map: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSource2Metrics_MatchPerfSummary_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSource2Metrics_MatchPerfSummary_Notification {
    fn default() -> &'a CSource2Metrics_MatchPerfSummary_Notification {
        <CSource2Metrics_MatchPerfSummary_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSource2Metrics_MatchPerfSummary_Notification {
    pub fn new() -> CSource2Metrics_MatchPerfSummary_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string game_mode = 2;

    pub fn game_mode(&self) -> &str {
        match self.game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: ::std::string::String) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mode(&mut self) -> &mut ::std::string::String {
        if self.game_mode.is_none() {
            self.game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mode(&mut self) -> ::std::string::String {
        self.game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_build_id = 3;

    pub fn server_build_id(&self) -> u32 {
        self.server_build_id.unwrap_or(0)
    }

    pub fn clear_server_build_id(&mut self) {
        self.server_build_id = ::std::option::Option::None;
    }

    pub fn has_server_build_id(&self) -> bool {
        self.server_build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_build_id(&mut self, v: u32) {
        self.server_build_id = ::std::option::Option::Some(v);
    }

    // optional string map = 20;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSource2Metrics_MatchPerfSummary_Notification {
    const NAME: &'static str = "CSource2Metrics_MatchPerfSummary_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.server_build_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.server_profile)?;
                },
                90 => {
                    self.clients.push(is.read_message()?);
                },
                162 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_mode.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.server_build_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_profile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.clients {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.map.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(20, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_mode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.server_build_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_profile.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.clients {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.map.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSource2Metrics_MatchPerfSummary_Notification {
        CSource2Metrics_MatchPerfSummary_Notification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.server_build_id = ::std::option::Option::None;
        self.server_profile.clear();
        self.clients.clear();
        self.map = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSource2Metrics_MatchPerfSummary_Notification {
        static instance: CSource2Metrics_MatchPerfSummary_Notification = CSource2Metrics_MatchPerfSummary_Notification {
            appid: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            server_build_id: ::std::option::Option::None,
            server_profile: ::steam_vent_proto_common::protobuf::MessageField::none(),
            clients: ::std::vec::Vec::new(),
            map: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSource2Metrics_MatchPerfSummary_Notification`
pub mod csource2metrics_match_perf_summary_notification {
    // @@protoc_insertion_point(message:CSource2Metrics_MatchPerfSummary_Notification.Client)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Client {
        // message fields
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.system_specs)
        pub system_specs: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgSource2SystemSpecs>,
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.profile)
        pub profile: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgSource2VProfLiteReport>,
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.build_id)
        pub build_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.steamid)
        pub steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSource2Metrics_MatchPerfSummary_Notification.Client.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Client {
        fn default() -> &'a Client {
            <Client as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Client {
        pub fn new() -> Client {
            ::std::default::Default::default()
        }

        // optional uint32 build_id = 3;

        pub fn build_id(&self) -> u32 {
            self.build_id.unwrap_or(0)
        }

        pub fn clear_build_id(&mut self) {
            self.build_id = ::std::option::Option::None;
        }

        pub fn has_build_id(&self) -> bool {
            self.build_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_build_id(&mut self, v: u32) {
            self.build_id = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid = 10;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Client {
        const NAME: &'static str = "Client";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.system_specs)?;
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.profile)?;
                    },
                    24 => {
                        self.build_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    81 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.system_specs.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.profile.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.build_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.system_specs.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.profile.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.build_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.steamid {
                os.write_fixed64(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Client {
            Client::new()
        }

        fn clear(&mut self) {
            self.system_specs.clear();
            self.profile.clear();
            self.build_id = ::std::option::Option::None;
            self.steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Client {
            static instance: Client = Client {
                system_specs: ::steam_vent_proto_common::protobuf::MessageField::none(),
                profile: ::steam_vent_proto_common::protobuf::MessageField::none(),
                build_id: ::std::option::Option::None,
                steamid: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsg_ServerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ServerInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.protocol)
    pub protocol: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.server_count)
    pub server_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_dedicated)
    pub is_dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.c_os)
    pub c_os: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_clients)
    pub max_clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_classes)
    pub max_classes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.tick_interval)
    pub tick_interval: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_dir)
    pub game_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.sky_name)
    pub sky_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.host_name)
    pub host_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.addon_name)
    pub addon_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_session_config)
    pub game_session_config: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CSVCMsg_GameSessionConfiguration>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_session_manifest)
    pub game_session_manifest: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ServerInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ServerInfo {
    fn default() -> &'a CSVCMsg_ServerInfo {
        <CSVCMsg_ServerInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ServerInfo {
    pub fn new() -> CSVCMsg_ServerInfo {
        ::std::default::Default::default()
    }

    // optional int32 protocol = 1;

    pub fn protocol(&self) -> i32 {
        self.protocol.unwrap_or(0)
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: i32) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // optional int32 server_count = 2;

    pub fn server_count(&self) -> i32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: i32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_dedicated = 3;

    pub fn is_dedicated(&self) -> bool {
        self.is_dedicated.unwrap_or(false)
    }

    pub fn clear_is_dedicated(&mut self) {
        self.is_dedicated = ::std::option::Option::None;
    }

    pub fn has_is_dedicated(&self) -> bool {
        self.is_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dedicated(&mut self, v: bool) {
        self.is_dedicated = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 4;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional int32 c_os = 6;

    pub fn c_os(&self) -> i32 {
        self.c_os.unwrap_or(0)
    }

    pub fn clear_c_os(&mut self) {
        self.c_os = ::std::option::Option::None;
    }

    pub fn has_c_os(&self) -> bool {
        self.c_os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c_os(&mut self, v: i32) {
        self.c_os = ::std::option::Option::Some(v);
    }

    // optional int32 max_clients = 10;

    pub fn max_clients(&self) -> i32 {
        self.max_clients.unwrap_or(0)
    }

    pub fn clear_max_clients(&mut self) {
        self.max_clients = ::std::option::Option::None;
    }

    pub fn has_max_clients(&self) -> bool {
        self.max_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_clients(&mut self, v: i32) {
        self.max_clients = ::std::option::Option::Some(v);
    }

    // optional int32 max_classes = 11;

    pub fn max_classes(&self) -> i32 {
        self.max_classes.unwrap_or(0)
    }

    pub fn clear_max_classes(&mut self) {
        self.max_classes = ::std::option::Option::None;
    }

    pub fn has_max_classes(&self) -> bool {
        self.max_classes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_classes(&mut self, v: i32) {
        self.max_classes = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 12;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional float tick_interval = 13;

    pub fn tick_interval(&self) -> f32 {
        self.tick_interval.unwrap_or(0.)
    }

    pub fn clear_tick_interval(&mut self) {
        self.tick_interval = ::std::option::Option::None;
    }

    pub fn has_tick_interval(&self) -> bool {
        self.tick_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_interval(&mut self, v: f32) {
        self.tick_interval = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 14;

    pub fn game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir = ::std::option::Option::None;
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 15;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sky_name = 16;

    pub fn sky_name(&self) -> &str {
        match self.sky_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sky_name(&mut self) {
        self.sky_name = ::std::option::Option::None;
    }

    pub fn has_sky_name(&self) -> bool {
        self.sky_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sky_name(&mut self, v: ::std::string::String) {
        self.sky_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sky_name(&mut self) -> &mut ::std::string::String {
        if self.sky_name.is_none() {
            self.sky_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sky_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sky_name(&mut self) -> ::std::string::String {
        self.sky_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host_name = 17;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string addon_name = 18;

    pub fn addon_name(&self) -> &str {
        match self.addon_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_addon_name(&mut self) {
        self.addon_name = ::std::option::Option::None;
    }

    pub fn has_addon_name(&self) -> bool {
        self.addon_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addon_name(&mut self, v: ::std::string::String) {
        self.addon_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addon_name(&mut self) -> &mut ::std::string::String {
        if self.addon_name.is_none() {
            self.addon_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.addon_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_addon_name(&mut self) -> ::std::string::String {
        self.addon_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes game_session_manifest = 20;

    pub fn game_session_manifest(&self) -> &[u8] {
        match self.game_session_manifest.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_session_manifest(&mut self) {
        self.game_session_manifest = ::std::option::Option::None;
    }

    pub fn has_game_session_manifest(&self) -> bool {
        self.game_session_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_session_manifest(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_session_manifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_session_manifest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_session_manifest.is_none() {
            self.game_session_manifest = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_session_manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_session_manifest(&mut self) -> ::std::vec::Vec<u8> {
        self.game_session_manifest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_ServerInfo {
    const NAME: &'static str = "CSVCMsg_ServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.c_os = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.max_clients = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.max_classes = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                109 => {
                    self.tick_interval = ::std::option::Option::Some(is.read_float()?);
                },
                114 => {
                    self.game_dir = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.sky_name = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.host_name = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.addon_name = ::std::option::Option::Some(is.read_string()?);
                },
                154 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.game_session_config)?;
                },
                162 => {
                    self.game_session_manifest = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.server_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.c_os {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.max_clients {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.max_classes {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.tick_interval {
            my_size += 1 + 4;
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.sky_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.addon_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_session_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_session_manifest.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.protocol {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_dedicated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.c_os {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.max_clients {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.max_classes {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.tick_interval {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.sky_name.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.addon_name.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.game_session_config.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.game_session_manifest.as_ref() {
            os.write_bytes(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ServerInfo {
        CSVCMsg_ServerInfo::new()
    }

    fn clear(&mut self) {
        self.protocol = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_dedicated = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.c_os = ::std::option::Option::None;
        self.max_clients = ::std::option::Option::None;
        self.max_classes = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.tick_interval = ::std::option::Option::None;
        self.game_dir = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.sky_name = ::std::option::Option::None;
        self.host_name = ::std::option::Option::None;
        self.addon_name = ::std::option::Option::None;
        self.game_session_config.clear();
        self.game_session_manifest = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ServerInfo {
        static instance: CSVCMsg_ServerInfo = CSVCMsg_ServerInfo {
            protocol: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_dedicated: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            c_os: ::std::option::Option::None,
            max_clients: ::std::option::Option::None,
            max_classes: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            tick_interval: ::std::option::Option::None,
            game_dir: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            sky_name: ::std::option::Option::None,
            host_name: ::std::option::Option::None,
            addon_name: ::std::option::Option::None,
            game_session_config: ::steam_vent_proto_common::protobuf::MessageField::none(),
            game_session_manifest: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_ClassInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ClassInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.create_on_client)
    pub create_on_client: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.classes)
    pub classes: ::std::vec::Vec<csvcmsg_class_info::Class_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ClassInfo {
    fn default() -> &'a CSVCMsg_ClassInfo {
        <CSVCMsg_ClassInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ClassInfo {
    pub fn new() -> CSVCMsg_ClassInfo {
        ::std::default::Default::default()
    }

    // optional bool create_on_client = 1;

    pub fn create_on_client(&self) -> bool {
        self.create_on_client.unwrap_or(false)
    }

    pub fn clear_create_on_client(&mut self) {
        self.create_on_client = ::std::option::Option::None;
    }

    pub fn has_create_on_client(&self) -> bool {
        self.create_on_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_on_client(&mut self, v: bool) {
        self.create_on_client = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_ClassInfo {
    const NAME: &'static str = "CSVCMsg_ClassInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.create_on_client = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.classes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.create_on_client {
            my_size += 1 + 1;
        }
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.create_on_client {
            os.write_bool(1, v)?;
        }
        for v in &self.classes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ClassInfo {
        CSVCMsg_ClassInfo::new()
    }

    fn clear(&mut self) {
        self.create_on_client = ::std::option::Option::None;
        self.classes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ClassInfo {
        static instance: CSVCMsg_ClassInfo = CSVCMsg_ClassInfo {
            create_on_client: ::std::option::Option::None,
            classes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSVCMsg_ClassInfo`
pub mod csvcmsg_class_info {
    // @@protoc_insertion_point(message:CSVCMsg_ClassInfo.class_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Class_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_name)
        pub class_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.class_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Class_t {
        fn default() -> &'a Class_t {
            <Class_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Class_t {
        pub fn new() -> Class_t {
            ::std::default::Default::default()
        }

        // optional int32 class_id = 1;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional string class_name = 3;

        pub fn class_name(&self) -> &str {
            match self.class_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_class_name(&mut self) {
            self.class_name = ::std::option::Option::None;
        }

        pub fn has_class_name(&self) -> bool {
            self.class_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_name(&mut self, v: ::std::string::String) {
            self.class_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
            if self.class_name.is_none() {
                self.class_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.class_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_class_name(&mut self) -> ::std::string::String {
            self.class_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Class_t {
        const NAME: &'static str = "class_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.class_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.class_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.class_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.class_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.class_name.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Class_t {
            Class_t::new()
        }

        fn clear(&mut self) {
            self.class_id = ::std::option::Option::None;
            self.class_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Class_t {
            static instance: Class_t = Class_t {
                class_id: ::std::option::Option::None,
                class_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsg_SetPause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SetPause {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetPause.paused)
    pub paused: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetPause.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetPause {
    fn default() -> &'a CSVCMsg_SetPause {
        <CSVCMsg_SetPause as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetPause {
    pub fn new() -> CSVCMsg_SetPause {
        ::std::default::Default::default()
    }

    // optional bool paused = 1;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_SetPause {
    const NAME: &'static str = "CSVCMsg_SetPause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.paused {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetPause {
        CSVCMsg_SetPause::new()
    }

    fn clear(&mut self) {
        self.paused = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetPause {
        static instance: CSVCMsg_SetPause = CSVCMsg_SetPause {
            paused: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_VoiceInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_VoiceInit {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.quality)
    pub quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.codec)
    pub codec: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceInit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceInit {
    fn default() -> &'a CSVCMsg_VoiceInit {
        <CSVCMsg_VoiceInit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceInit {
    pub fn new() -> CSVCMsg_VoiceInit {
        ::std::default::Default::default()
    }

    // optional int32 quality = 1;

    pub fn quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional string codec = 2;

    pub fn codec(&self) -> &str {
        match self.codec.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: ::std::string::String) {
        self.codec = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&mut self) -> &mut ::std::string::String {
        if self.codec.is_none() {
            self.codec = ::std::option::Option::Some(::std::string::String::new());
        }
        self.codec.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec(&mut self) -> ::std::string::String {
        self.codec.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 version = 3;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0i32)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_VoiceInit {
    const NAME: &'static str = "CSVCMsg_VoiceInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quality = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.codec = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.codec.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quality {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.codec.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceInit {
        CSVCMsg_VoiceInit::new()
    }

    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceInit {
        static instance: CSVCMsg_VoiceInit = CSVCMsg_VoiceInit {
            quality: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_Print)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Print {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Print.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Print.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Print {
    fn default() -> &'a CSVCMsg_Print {
        <CSVCMsg_Print as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Print {
    pub fn new() -> CSVCMsg_Print {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_Print {
    const NAME: &'static str = "CSVCMsg_Print";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Print {
        CSVCMsg_Print::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Print {
        static instance: CSVCMsg_Print = CSVCMsg_Print {
            text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_Sounds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Sounds {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.reliable_sound)
    pub reliable_sound: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounds)
    pub sounds: ::std::vec::Vec<csvcmsg_sounds::Sounddata_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Sounds {
    fn default() -> &'a CSVCMsg_Sounds {
        <CSVCMsg_Sounds as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Sounds {
    pub fn new() -> CSVCMsg_Sounds {
        ::std::default::Default::default()
    }

    // optional bool reliable_sound = 1;

    pub fn reliable_sound(&self) -> bool {
        self.reliable_sound.unwrap_or(false)
    }

    pub fn clear_reliable_sound(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
    }

    pub fn has_reliable_sound(&self) -> bool {
        self.reliable_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_sound(&mut self, v: bool) {
        self.reliable_sound = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_Sounds {
    const NAME: &'static str = "CSVCMsg_Sounds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_sound = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.sounds.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_sound {
            my_size += 1 + 1;
        }
        for value in &self.sounds {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reliable_sound {
            os.write_bool(1, v)?;
        }
        for v in &self.sounds {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Sounds {
        CSVCMsg_Sounds::new()
    }

    fn clear(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
        self.sounds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Sounds {
        static instance: CSVCMsg_Sounds = CSVCMsg_Sounds {
            reliable_sound: ::std::option::Option::None,
            sounds: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSVCMsg_Sounds`
pub mod csvcmsg_sounds {
    // @@protoc_insertion_point(message:CSVCMsg_Sounds.sounddata_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sounddata_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_x)
        pub origin_x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_y)
        pub origin_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_z)
        pub origin_z: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.volume)
        pub volume: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.delay_value)
        pub delay_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sequence_number)
        pub sequence_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.entity_index)
        pub entity_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.channel)
        pub channel: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.pitch)
        pub pitch: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num)
        pub sound_num: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num_handle)
        pub sound_num_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.speaker_entity)
        pub speaker_entity: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.random_seed)
        pub random_seed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_level)
        pub sound_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_sentence)
        pub is_sentence: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_ambient)
        pub is_ambient: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.guid)
        pub guid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_resource_id)
        pub sound_resource_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.sounddata_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sounddata_t {
        fn default() -> &'a Sounddata_t {
            <Sounddata_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Sounddata_t {
        pub fn new() -> Sounddata_t {
            ::std::default::Default::default()
        }

        // optional sint32 origin_x = 1;

        pub fn origin_x(&self) -> i32 {
            self.origin_x.unwrap_or(0)
        }

        pub fn clear_origin_x(&mut self) {
            self.origin_x = ::std::option::Option::None;
        }

        pub fn has_origin_x(&self) -> bool {
            self.origin_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_x(&mut self, v: i32) {
            self.origin_x = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_y = 2;

        pub fn origin_y(&self) -> i32 {
            self.origin_y.unwrap_or(0)
        }

        pub fn clear_origin_y(&mut self) {
            self.origin_y = ::std::option::Option::None;
        }

        pub fn has_origin_y(&self) -> bool {
            self.origin_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_y(&mut self, v: i32) {
            self.origin_y = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_z = 3;

        pub fn origin_z(&self) -> i32 {
            self.origin_z.unwrap_or(0)
        }

        pub fn clear_origin_z(&mut self) {
            self.origin_z = ::std::option::Option::None;
        }

        pub fn has_origin_z(&self) -> bool {
            self.origin_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_z(&mut self, v: i32) {
            self.origin_z = ::std::option::Option::Some(v);
        }

        // optional uint32 volume = 4;

        pub fn volume(&self) -> u32 {
            self.volume.unwrap_or(0)
        }

        pub fn clear_volume(&mut self) {
            self.volume = ::std::option::Option::None;
        }

        pub fn has_volume(&self) -> bool {
            self.volume.is_some()
        }

        // Param is passed by value, moved
        pub fn set_volume(&mut self, v: u32) {
            self.volume = ::std::option::Option::Some(v);
        }

        // optional float delay_value = 5;

        pub fn delay_value(&self) -> f32 {
            self.delay_value.unwrap_or(0.)
        }

        pub fn clear_delay_value(&mut self) {
            self.delay_value = ::std::option::Option::None;
        }

        pub fn has_delay_value(&self) -> bool {
            self.delay_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay_value(&mut self, v: f32) {
            self.delay_value = ::std::option::Option::Some(v);
        }

        // optional int32 sequence_number = 6;

        pub fn sequence_number(&self) -> i32 {
            self.sequence_number.unwrap_or(0)
        }

        pub fn clear_sequence_number(&mut self) {
            self.sequence_number = ::std::option::Option::None;
        }

        pub fn has_sequence_number(&self) -> bool {
            self.sequence_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_number(&mut self, v: i32) {
            self.sequence_number = ::std::option::Option::Some(v);
        }

        // optional int32 entity_index = 7;

        pub fn entity_index(&self) -> i32 {
            self.entity_index.unwrap_or(-1i32)
        }

        pub fn clear_entity_index(&mut self) {
            self.entity_index = ::std::option::Option::None;
        }

        pub fn has_entity_index(&self) -> bool {
            self.entity_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_index(&mut self, v: i32) {
            self.entity_index = ::std::option::Option::Some(v);
        }

        // optional int32 channel = 8;

        pub fn channel(&self) -> i32 {
            self.channel.unwrap_or(0)
        }

        pub fn clear_channel(&mut self) {
            self.channel = ::std::option::Option::None;
        }

        pub fn has_channel(&self) -> bool {
            self.channel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_channel(&mut self, v: i32) {
            self.channel = ::std::option::Option::Some(v);
        }

        // optional int32 pitch = 9;

        pub fn pitch(&self) -> i32 {
            self.pitch.unwrap_or(0)
        }

        pub fn clear_pitch(&mut self) {
            self.pitch = ::std::option::Option::None;
        }

        pub fn has_pitch(&self) -> bool {
            self.pitch.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pitch(&mut self, v: i32) {
            self.pitch = ::std::option::Option::Some(v);
        }

        // optional int32 flags = 10;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 sound_num = 11;

        pub fn sound_num(&self) -> u32 {
            self.sound_num.unwrap_or(0)
        }

        pub fn clear_sound_num(&mut self) {
            self.sound_num = ::std::option::Option::None;
        }

        pub fn has_sound_num(&self) -> bool {
            self.sound_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num(&mut self, v: u32) {
            self.sound_num = ::std::option::Option::Some(v);
        }

        // optional fixed32 sound_num_handle = 12;

        pub fn sound_num_handle(&self) -> u32 {
            self.sound_num_handle.unwrap_or(0)
        }

        pub fn clear_sound_num_handle(&mut self) {
            self.sound_num_handle = ::std::option::Option::None;
        }

        pub fn has_sound_num_handle(&self) -> bool {
            self.sound_num_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num_handle(&mut self, v: u32) {
            self.sound_num_handle = ::std::option::Option::Some(v);
        }

        // optional int32 speaker_entity = 13;

        pub fn speaker_entity(&self) -> i32 {
            self.speaker_entity.unwrap_or(0)
        }

        pub fn clear_speaker_entity(&mut self) {
            self.speaker_entity = ::std::option::Option::None;
        }

        pub fn has_speaker_entity(&self) -> bool {
            self.speaker_entity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_speaker_entity(&mut self, v: i32) {
            self.speaker_entity = ::std::option::Option::Some(v);
        }

        // optional int32 random_seed = 14;

        pub fn random_seed(&self) -> i32 {
            self.random_seed.unwrap_or(0)
        }

        pub fn clear_random_seed(&mut self) {
            self.random_seed = ::std::option::Option::None;
        }

        pub fn has_random_seed(&self) -> bool {
            self.random_seed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_random_seed(&mut self, v: i32) {
            self.random_seed = ::std::option::Option::Some(v);
        }

        // optional int32 sound_level = 15;

        pub fn sound_level(&self) -> i32 {
            self.sound_level.unwrap_or(0)
        }

        pub fn clear_sound_level(&mut self) {
            self.sound_level = ::std::option::Option::None;
        }

        pub fn has_sound_level(&self) -> bool {
            self.sound_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_level(&mut self, v: i32) {
            self.sound_level = ::std::option::Option::Some(v);
        }

        // optional bool is_sentence = 16;

        pub fn is_sentence(&self) -> bool {
            self.is_sentence.unwrap_or(false)
        }

        pub fn clear_is_sentence(&mut self) {
            self.is_sentence = ::std::option::Option::None;
        }

        pub fn has_is_sentence(&self) -> bool {
            self.is_sentence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_sentence(&mut self, v: bool) {
            self.is_sentence = ::std::option::Option::Some(v);
        }

        // optional bool is_ambient = 17;

        pub fn is_ambient(&self) -> bool {
            self.is_ambient.unwrap_or(false)
        }

        pub fn clear_is_ambient(&mut self) {
            self.is_ambient = ::std::option::Option::None;
        }

        pub fn has_is_ambient(&self) -> bool {
            self.is_ambient.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_ambient(&mut self, v: bool) {
            self.is_ambient = ::std::option::Option::Some(v);
        }

        // optional uint32 guid = 18;

        pub fn guid(&self) -> u32 {
            self.guid.unwrap_or(0)
        }

        pub fn clear_guid(&mut self) {
            self.guid = ::std::option::Option::None;
        }

        pub fn has_guid(&self) -> bool {
            self.guid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guid(&mut self, v: u32) {
            self.guid = ::std::option::Option::Some(v);
        }

        // optional fixed64 sound_resource_id = 19;

        pub fn sound_resource_id(&self) -> u64 {
            self.sound_resource_id.unwrap_or(0)
        }

        pub fn clear_sound_resource_id(&mut self) {
            self.sound_resource_id = ::std::option::Option::None;
        }

        pub fn has_sound_resource_id(&self) -> bool {
            self.sound_resource_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_resource_id(&mut self, v: u64) {
            self.sound_resource_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Sounddata_t {
        const NAME: &'static str = "sounddata_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.origin_x = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    16 => {
                        self.origin_y = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    24 => {
                        self.origin_z = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    32 => {
                        self.volume = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    45 => {
                        self.delay_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.channel = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.pitch = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.sound_num = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    101 => {
                        self.sound_num_handle = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    104 => {
                        self.speaker_entity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.random_seed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.sound_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.is_sentence = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.is_ambient = ::std::option::Option::Some(is.read_bool()?);
                    },
                    144 => {
                        self.guid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    153 => {
                        self.sound_resource_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.origin_x {
                my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(1, v);
            }
            if let Some(v) = self.origin_y {
                my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(2, v);
            }
            if let Some(v) = self.origin_z {
                my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(3, v);
            }
            if let Some(v) = self.volume {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.delay_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sequence_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.entity_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.channel {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.pitch {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.flags {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.sound_num {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.sound_num_handle {
                my_size += 1 + 4;
            }
            if let Some(v) = self.speaker_entity {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.random_seed {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.sound_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.is_sentence {
                my_size += 2 + 1;
            }
            if let Some(v) = self.is_ambient {
                my_size += 2 + 1;
            }
            if let Some(v) = self.guid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.sound_resource_id {
                my_size += 2 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.origin_x {
                os.write_sint32(1, v)?;
            }
            if let Some(v) = self.origin_y {
                os.write_sint32(2, v)?;
            }
            if let Some(v) = self.origin_z {
                os.write_sint32(3, v)?;
            }
            if let Some(v) = self.volume {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.delay_value {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.sequence_number {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.entity_index {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.channel {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.pitch {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.sound_num {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.sound_num_handle {
                os.write_fixed32(12, v)?;
            }
            if let Some(v) = self.speaker_entity {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.random_seed {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.sound_level {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.is_sentence {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.is_ambient {
                os.write_bool(17, v)?;
            }
            if let Some(v) = self.guid {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.sound_resource_id {
                os.write_fixed64(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sounddata_t {
            Sounddata_t::new()
        }

        fn clear(&mut self) {
            self.origin_x = ::std::option::Option::None;
            self.origin_y = ::std::option::Option::None;
            self.origin_z = ::std::option::Option::None;
            self.volume = ::std::option::Option::None;
            self.delay_value = ::std::option::Option::None;
            self.sequence_number = ::std::option::Option::None;
            self.entity_index = ::std::option::Option::None;
            self.channel = ::std::option::Option::None;
            self.pitch = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.sound_num = ::std::option::Option::None;
            self.sound_num_handle = ::std::option::Option::None;
            self.speaker_entity = ::std::option::Option::None;
            self.random_seed = ::std::option::Option::None;
            self.sound_level = ::std::option::Option::None;
            self.is_sentence = ::std::option::Option::None;
            self.is_ambient = ::std::option::Option::None;
            self.guid = ::std::option::Option::None;
            self.sound_resource_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sounddata_t {
            static instance: Sounddata_t = Sounddata_t {
                origin_x: ::std::option::Option::None,
                origin_y: ::std::option::Option::None,
                origin_z: ::std::option::Option::None,
                volume: ::std::option::Option::None,
                delay_value: ::std::option::Option::None,
                sequence_number: ::std::option::Option::None,
                entity_index: ::std::option::Option::None,
                channel: ::std::option::Option::None,
                pitch: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                sound_num: ::std::option::Option::None,
                sound_num_handle: ::std::option::Option::None,
                speaker_entity: ::std::option::Option::None,
                random_seed: ::std::option::Option::None,
                sound_level: ::std::option::Option::None,
                is_sentence: ::std::option::Option::None,
                is_ambient: ::std::option::Option::None,
                guid: ::std::option::Option::None,
                sound_resource_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsg_Prefetch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Prefetch {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Prefetch.sound_index)
    pub sound_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_Prefetch.resource_type)
    pub resource_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<PrefetchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Prefetch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Prefetch {
    fn default() -> &'a CSVCMsg_Prefetch {
        <CSVCMsg_Prefetch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Prefetch {
    pub fn new() -> CSVCMsg_Prefetch {
        ::std::default::Default::default()
    }

    // optional int32 sound_index = 1;

    pub fn sound_index(&self) -> i32 {
        self.sound_index.unwrap_or(0)
    }

    pub fn clear_sound_index(&mut self) {
        self.sound_index = ::std::option::Option::None;
    }

    pub fn has_sound_index(&self) -> bool {
        self.sound_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_index(&mut self, v: i32) {
        self.sound_index = ::std::option::Option::Some(v);
    }

    // optional .PrefetchType resource_type = 2;

    pub fn resource_type(&self) -> PrefetchType {
        match self.resource_type {
            Some(e) => e.enum_value_or(PrefetchType::PFT_SOUND),
            None => PrefetchType::PFT_SOUND,
        }
    }

    pub fn clear_resource_type(&mut self) {
        self.resource_type = ::std::option::Option::None;
    }

    pub fn has_resource_type(&self) -> bool {
        self.resource_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource_type(&mut self, v: PrefetchType) {
        self.resource_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_Prefetch {
    const NAME: &'static str = "CSVCMsg_Prefetch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sound_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.resource_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sound_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.resource_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.sound_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.resource_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Prefetch {
        CSVCMsg_Prefetch::new()
    }

    fn clear(&mut self) {
        self.sound_index = ::std::option::Option::None;
        self.resource_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Prefetch {
        static instance: CSVCMsg_Prefetch = CSVCMsg_Prefetch {
            sound_index: ::std::option::Option::None,
            resource_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_SetView)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SetView {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetView.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_SetView.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetView.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetView {
    fn default() -> &'a CSVCMsg_SetView {
        <CSVCMsg_SetView as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetView {
    pub fn new() -> CSVCMsg_SetView {
        ::std::default::Default::default()
    }

    // optional int32 entity_index = 1;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(-1i32)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 slot = 2;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(-1i32)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_SetView {
    const NAME: &'static str = "CSVCMsg_SetView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetView {
        CSVCMsg_SetView::new()
    }

    fn clear(&mut self) {
        self.entity_index = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetView {
        static instance: CSVCMsg_SetView = CSVCMsg_SetView {
            entity_index: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_FixAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FixAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.relative)
    pub relative: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.angle)
    pub angle: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FixAngle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FixAngle {
    fn default() -> &'a CSVCMsg_FixAngle {
        <CSVCMsg_FixAngle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FixAngle {
    pub fn new() -> CSVCMsg_FixAngle {
        ::std::default::Default::default()
    }

    // optional bool relative = 1;

    pub fn relative(&self) -> bool {
        self.relative.unwrap_or(false)
    }

    pub fn clear_relative(&mut self) {
        self.relative = ::std::option::Option::None;
    }

    pub fn has_relative(&self) -> bool {
        self.relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative(&mut self, v: bool) {
        self.relative = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_FixAngle {
    const NAME: &'static str = "CSVCMsg_FixAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.relative = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relative {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.relative {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FixAngle {
        CSVCMsg_FixAngle::new()
    }

    fn clear(&mut self) {
        self.relative = ::std::option::Option::None;
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FixAngle {
        static instance: CSVCMsg_FixAngle = CSVCMsg_FixAngle {
            relative: ::std::option::Option::None,
            angle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_CrosshairAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CrosshairAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CrosshairAngle.angle)
    pub angle: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CrosshairAngle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CrosshairAngle {
    fn default() -> &'a CSVCMsg_CrosshairAngle {
        <CSVCMsg_CrosshairAngle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CrosshairAngle {
    pub fn new() -> CSVCMsg_CrosshairAngle {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_CrosshairAngle {
    const NAME: &'static str = "CSVCMsg_CrosshairAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.angle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CrosshairAngle {
        CSVCMsg_CrosshairAngle::new()
    }

    fn clear(&mut self) {
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CrosshairAngle {
        static instance: CSVCMsg_CrosshairAngle = CSVCMsg_CrosshairAngle {
            angle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_BSPDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_BSPDecal {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.pos)
    pub pos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.decal_texture_index)
    pub decal_texture_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.model_index)
    pub model_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_BSPDecal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_BSPDecal {
    fn default() -> &'a CSVCMsg_BSPDecal {
        <CSVCMsg_BSPDecal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_BSPDecal {
    pub fn new() -> CSVCMsg_BSPDecal {
        ::std::default::Default::default()
    }

    // optional int32 decal_texture_index = 2;

    pub fn decal_texture_index(&self) -> i32 {
        self.decal_texture_index.unwrap_or(0)
    }

    pub fn clear_decal_texture_index(&mut self) {
        self.decal_texture_index = ::std::option::Option::None;
    }

    pub fn has_decal_texture_index(&self) -> bool {
        self.decal_texture_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decal_texture_index(&mut self, v: i32) {
        self.decal_texture_index = ::std::option::Option::Some(v);
    }

    // optional int32 entity_index = 3;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(-1i32)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 model_index = 4;

    pub fn model_index(&self) -> i32 {
        self.model_index.unwrap_or(0)
    }

    pub fn clear_model_index(&mut self) {
        self.model_index = ::std::option::Option::None;
    }

    pub fn has_model_index(&self) -> bool {
        self.model_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_index(&mut self, v: i32) {
        self.model_index = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 5;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_BSPDecal {
    const NAME: &'static str = "CSVCMsg_BSPDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                16 => {
                    self.decal_texture_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.model_index = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.decal_texture_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.model_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.decal_texture_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.model_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_BSPDecal {
        CSVCMsg_BSPDecal::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.decal_texture_index = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.model_index = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_BSPDecal {
        static instance: CSVCMsg_BSPDecal = CSVCMsg_BSPDecal {
            pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            decal_texture_index: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            model_index: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_SplitScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SplitScreen {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ESplitScreenMessageType>>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.player_index)
    pub player_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SplitScreen.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SplitScreen {
    fn default() -> &'a CSVCMsg_SplitScreen {
        <CSVCMsg_SplitScreen as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SplitScreen {
    pub fn new() -> CSVCMsg_SplitScreen {
        ::std::default::Default::default()
    }

    // optional .ESplitScreenMessageType type = 1;

    pub fn type_(&self) -> ESplitScreenMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            None => ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESplitScreenMessageType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 slot = 2;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional int32 player_index = 3;

    pub fn player_index(&self) -> i32 {
        self.player_index.unwrap_or(-1i32)
    }

    pub fn clear_player_index(&mut self) {
        self.player_index = ::std::option::Option::None;
    }

    pub fn has_player_index(&self) -> bool {
        self.player_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_index(&mut self, v: i32) {
        self.player_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_SplitScreen {
    const NAME: &'static str = "CSVCMsg_SplitScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SplitScreen {
        CSVCMsg_SplitScreen::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.player_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SplitScreen {
        static instance: CSVCMsg_SplitScreen = CSVCMsg_SplitScreen {
            type_: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            player_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_GetCvarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GetCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cvar_name)
    pub cvar_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GetCvarValue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GetCvarValue {
    fn default() -> &'a CSVCMsg_GetCvarValue {
        <CSVCMsg_GetCvarValue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GetCvarValue {
    pub fn new() -> CSVCMsg_GetCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional string cvar_name = 2;

    pub fn cvar_name(&self) -> &str {
        match self.cvar_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cvar_name(&mut self) {
        self.cvar_name = ::std::option::Option::None;
    }

    pub fn has_cvar_name(&self) -> bool {
        self.cvar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cvar_name(&mut self, v: ::std::string::String) {
        self.cvar_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cvar_name(&mut self) -> &mut ::std::string::String {
        if self.cvar_name.is_none() {
            self.cvar_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cvar_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_cvar_name(&mut self) -> ::std::string::String {
        self.cvar_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_GetCvarValue {
    const NAME: &'static str = "CSVCMsg_GetCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.cvar_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cvar_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cvar_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GetCvarValue {
        CSVCMsg_GetCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.cvar_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GetCvarValue {
        static instance: CSVCMsg_GetCvarValue = CSVCMsg_GetCvarValue {
            cookie: ::std::option::Option::None,
            cvar_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_Menu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Menu {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Menu.dialog_type)
    pub dialog_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_Menu.menu_key_values)
    pub menu_key_values: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Menu.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Menu {
    fn default() -> &'a CSVCMsg_Menu {
        <CSVCMsg_Menu as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Menu {
    pub fn new() -> CSVCMsg_Menu {
        ::std::default::Default::default()
    }

    // optional int32 dialog_type = 1;

    pub fn dialog_type(&self) -> i32 {
        self.dialog_type.unwrap_or(0)
    }

    pub fn clear_dialog_type(&mut self) {
        self.dialog_type = ::std::option::Option::None;
    }

    pub fn has_dialog_type(&self) -> bool {
        self.dialog_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_type(&mut self, v: i32) {
        self.dialog_type = ::std::option::Option::Some(v);
    }

    // optional bytes menu_key_values = 2;

    pub fn menu_key_values(&self) -> &[u8] {
        match self.menu_key_values.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_menu_key_values(&mut self) {
        self.menu_key_values = ::std::option::Option::None;
    }

    pub fn has_menu_key_values(&self) -> bool {
        self.menu_key_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_key_values(&mut self, v: ::std::vec::Vec<u8>) {
        self.menu_key_values = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_key_values(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.menu_key_values.is_none() {
            self.menu_key_values = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.menu_key_values.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_key_values(&mut self) -> ::std::vec::Vec<u8> {
        self.menu_key_values.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_Menu {
    const NAME: &'static str = "CSVCMsg_Menu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dialog_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.menu_key_values = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dialog_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dialog_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Menu {
        CSVCMsg_Menu::new()
    }

    fn clear(&mut self) {
        self.dialog_type = ::std::option::Option::None;
        self.menu_key_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Menu {
        static instance: CSVCMsg_Menu = CSVCMsg_Menu {
            dialog_type: ::std::option::Option::None,
            menu_key_values: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_UserMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UserMessage {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_type)
    pub msg_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_data)
    pub msg_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UserMessage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UserMessage {
    fn default() -> &'a CSVCMsg_UserMessage {
        <CSVCMsg_UserMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UserMessage {
    pub fn new() -> CSVCMsg_UserMessage {
        ::std::default::Default::default()
    }

    // optional int32 msg_type = 1;

    pub fn msg_type(&self) -> i32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes msg_data = 2;

    pub fn msg_data(&self) -> &[u8] {
        match self.msg_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_msg_data(&mut self) {
        self.msg_data = ::std::option::Option::None;
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.msg_data.is_none() {
            self.msg_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_data(&mut self) -> ::std::vec::Vec<u8> {
        self.msg_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 passthrough = 3;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_UserMessage {
    const NAME: &'static str = "CSVCMsg_UserMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.msg_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.msg_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.msg_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UserMessage {
        CSVCMsg_UserMessage::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.msg_data = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UserMessage {
        static instance: CSVCMsg_UserMessage = CSVCMsg_UserMessage {
            msg_type: ::std::option::Option::None,
            msg_data: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_SendTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SendTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.is_end)
    pub is_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.net_table_name)
    pub net_table_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.needs_decoder)
    pub needs_decoder: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.props)
    pub props: ::std::vec::Vec<csvcmsg_send_table::Sendprop_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SendTable {
    fn default() -> &'a CSVCMsg_SendTable {
        <CSVCMsg_SendTable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SendTable {
    pub fn new() -> CSVCMsg_SendTable {
        ::std::default::Default::default()
    }

    // optional bool is_end = 1;

    pub fn is_end(&self) -> bool {
        self.is_end.unwrap_or(false)
    }

    pub fn clear_is_end(&mut self) {
        self.is_end = ::std::option::Option::None;
    }

    pub fn has_is_end(&self) -> bool {
        self.is_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_end(&mut self, v: bool) {
        self.is_end = ::std::option::Option::Some(v);
    }

    // optional string net_table_name = 2;

    pub fn net_table_name(&self) -> &str {
        match self.net_table_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_net_table_name(&mut self) {
        self.net_table_name = ::std::option::Option::None;
    }

    pub fn has_net_table_name(&self) -> bool {
        self.net_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_table_name(&mut self, v: ::std::string::String) {
        self.net_table_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_table_name(&mut self) -> &mut ::std::string::String {
        if self.net_table_name.is_none() {
            self.net_table_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.net_table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_table_name(&mut self) -> ::std::string::String {
        self.net_table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool needs_decoder = 3;

    pub fn needs_decoder(&self) -> bool {
        self.needs_decoder.unwrap_or(false)
    }

    pub fn clear_needs_decoder(&mut self) {
        self.needs_decoder = ::std::option::Option::None;
    }

    pub fn has_needs_decoder(&self) -> bool {
        self.needs_decoder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_decoder(&mut self, v: bool) {
        self.needs_decoder = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_SendTable {
    const NAME: &'static str = "CSVCMsg_SendTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_end = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.net_table_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.needs_decoder = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.props.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.needs_decoder {
            my_size += 1 + 1;
        }
        for value in &self.props {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.is_end {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.needs_decoder {
            os.write_bool(3, v)?;
        }
        for v in &self.props {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SendTable {
        CSVCMsg_SendTable::new()
    }

    fn clear(&mut self) {
        self.is_end = ::std::option::Option::None;
        self.net_table_name = ::std::option::Option::None;
        self.needs_decoder = ::std::option::Option::None;
        self.props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SendTable {
        static instance: CSVCMsg_SendTable = CSVCMsg_SendTable {
            is_end: ::std::option::Option::None,
            net_table_name: ::std::option::Option::None,
            needs_decoder: ::std::option::Option::None,
            props: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSVCMsg_SendTable`
pub mod csvcmsg_send_table {
    // @@protoc_insertion_point(message:CSVCMsg_SendTable.sendprop_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sendprop_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.var_name)
        pub var_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.priority)
        pub priority: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.dt_name)
        pub dt_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_elements)
        pub num_elements: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.low_value)
        pub low_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.high_value)
        pub high_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_bits)
        pub num_bits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.sendprop_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sendprop_t {
        fn default() -> &'a Sendprop_t {
            <Sendprop_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Sendprop_t {
        pub fn new() -> Sendprop_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string var_name = 2;

        pub fn var_name(&self) -> &str {
            match self.var_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_var_name(&mut self) {
            self.var_name = ::std::option::Option::None;
        }

        pub fn has_var_name(&self) -> bool {
            self.var_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_var_name(&mut self, v: ::std::string::String) {
            self.var_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_var_name(&mut self) -> &mut ::std::string::String {
            if self.var_name.is_none() {
                self.var_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.var_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_var_name(&mut self) -> ::std::string::String {
            self.var_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 flags = 3;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional int32 priority = 4;

        pub fn priority(&self) -> i32 {
            self.priority.unwrap_or(0)
        }

        pub fn clear_priority(&mut self) {
            self.priority = ::std::option::Option::None;
        }

        pub fn has_priority(&self) -> bool {
            self.priority.is_some()
        }

        // Param is passed by value, moved
        pub fn set_priority(&mut self, v: i32) {
            self.priority = ::std::option::Option::Some(v);
        }

        // optional string dt_name = 5;

        pub fn dt_name(&self) -> &str {
            match self.dt_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dt_name(&mut self) {
            self.dt_name = ::std::option::Option::None;
        }

        pub fn has_dt_name(&self) -> bool {
            self.dt_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dt_name(&mut self, v: ::std::string::String) {
            self.dt_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dt_name(&mut self) -> &mut ::std::string::String {
            if self.dt_name.is_none() {
                self.dt_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dt_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dt_name(&mut self) -> ::std::string::String {
            self.dt_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 num_elements = 6;

        pub fn num_elements(&self) -> i32 {
            self.num_elements.unwrap_or(0)
        }

        pub fn clear_num_elements(&mut self) {
            self.num_elements = ::std::option::Option::None;
        }

        pub fn has_num_elements(&self) -> bool {
            self.num_elements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_elements(&mut self, v: i32) {
            self.num_elements = ::std::option::Option::Some(v);
        }

        // optional float low_value = 7;

        pub fn low_value(&self) -> f32 {
            self.low_value.unwrap_or(0.)
        }

        pub fn clear_low_value(&mut self) {
            self.low_value = ::std::option::Option::None;
        }

        pub fn has_low_value(&self) -> bool {
            self.low_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_low_value(&mut self, v: f32) {
            self.low_value = ::std::option::Option::Some(v);
        }

        // optional float high_value = 8;

        pub fn high_value(&self) -> f32 {
            self.high_value.unwrap_or(0.)
        }

        pub fn clear_high_value(&mut self) {
            self.high_value = ::std::option::Option::None;
        }

        pub fn has_high_value(&self) -> bool {
            self.high_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_high_value(&mut self, v: f32) {
            self.high_value = ::std::option::Option::Some(v);
        }

        // optional int32 num_bits = 9;

        pub fn num_bits(&self) -> i32 {
            self.num_bits.unwrap_or(0)
        }

        pub fn clear_num_bits(&mut self) {
            self.num_bits = ::std::option::Option::None;
        }

        pub fn has_num_bits(&self) -> bool {
            self.num_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_bits(&mut self, v: i32) {
            self.num_bits = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Sendprop_t {
        const NAME: &'static str = "sendprop_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.var_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.priority = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.dt_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.num_elements = ::std::option::Option::Some(is.read_int32()?);
                    },
                    61 => {
                        self.low_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.high_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.num_bits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.var_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.flags {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.priority {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.dt_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.num_elements {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.low_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.high_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.num_bits {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.var_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.priority {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.dt_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.num_elements {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.low_value {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.high_value {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.num_bits {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sendprop_t {
            Sendprop_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.var_name = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.priority = ::std::option::Option::None;
            self.dt_name = ::std::option::Option::None;
            self.num_elements = ::std::option::Option::None;
            self.low_value = ::std::option::Option::None;
            self.high_value = ::std::option::Option::None;
            self.num_bits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sendprop_t {
            static instance: Sendprop_t = Sendprop_t {
                type_: ::std::option::Option::None,
                var_name: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                priority: ::std::option::Option::None,
                dt_name: ::std::option::Option::None,
                num_elements: ::std::option::Option::None,
                low_value: ::std::option::Option::None,
                high_value: ::std::option::Option::None,
                num_bits: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsg_GameEventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GameEventList {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptors)
    pub descriptors: ::std::vec::Vec<csvcmsg_game_event_list::Descriptor_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameEventList {
    fn default() -> &'a CSVCMsg_GameEventList {
        <CSVCMsg_GameEventList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameEventList {
    pub fn new() -> CSVCMsg_GameEventList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_GameEventList {
    const NAME: &'static str = "CSVCMsg_GameEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.descriptors {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameEventList {
        CSVCMsg_GameEventList::new()
    }

    fn clear(&mut self) {
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameEventList {
        static instance: CSVCMsg_GameEventList = CSVCMsg_GameEventList {
            descriptors: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSVCMsg_GameEventList`
pub mod csvcmsg_game_event_list {
    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.key_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.descriptor_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Descriptor_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.eventid)
        pub eventid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.keys)
        pub keys: ::std::vec::Vec<Key_t>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.descriptor_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Descriptor_t {
        fn default() -> &'a Descriptor_t {
            <Descriptor_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Descriptor_t {
        pub fn new() -> Descriptor_t {
            ::std::default::Default::default()
        }

        // optional int32 eventid = 1;

        pub fn eventid(&self) -> i32 {
            self.eventid.unwrap_or(0)
        }

        pub fn clear_eventid(&mut self) {
            self.eventid = ::std::option::Option::None;
        }

        pub fn has_eventid(&self) -> bool {
            self.eventid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eventid(&mut self, v: i32) {
            self.eventid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Descriptor_t {
        const NAME: &'static str = "descriptor_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eventid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.keys.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eventid {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            for value in &self.keys {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.eventid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.keys {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Descriptor_t {
            Descriptor_t::new()
        }

        fn clear(&mut self) {
            self.eventid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.keys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Descriptor_t {
            static instance: Descriptor_t = Descriptor_t {
                eventid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                keys: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsg_PacketEntities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PacketEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.max_entries)
    pub max_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.updated_entries)
    pub updated_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.legacy_is_delta)
    pub legacy_is_delta: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.update_baseline)
    pub update_baseline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.baseline)
    pub baseline: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.delta_from)
    pub delta_from: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.entity_data)
    pub entity_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.pending_full_frame)
    pub pending_full_frame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.active_spawngroup_handle)
    pub active_spawngroup_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.max_spawngroup_creationsequence)
    pub max_spawngroup_creationsequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.last_cmd_number_executed)
    pub last_cmd_number_executed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.last_cmd_number_recv_delta)
    pub last_cmd_number_recv_delta: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.server_tick)
    pub server_tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.serialized_entities)
    pub serialized_entities: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baselines)
    pub alternate_baselines: ::std::vec::Vec<csvcmsg_packet_entities::Alternate_baseline_t>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.has_pvs_vis_bits)
    pub has_pvs_vis_bits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.cmd_recv_status)
    pub cmd_recv_status: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.non_transmitted_entities)
    pub non_transmitted_entities: ::steam_vent_proto_common::protobuf::MessageField<csvcmsg_packet_entities::Non_transmitted_entities_t>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.cq_starved_command_ticks)
    pub cq_starved_command_ticks: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.cq_discarded_command_ticks)
    pub cq_discarded_command_ticks: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.dev_padding)
    pub dev_padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PacketEntities {
    fn default() -> &'a CSVCMsg_PacketEntities {
        <CSVCMsg_PacketEntities as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PacketEntities {
    pub fn new() -> CSVCMsg_PacketEntities {
        ::std::default::Default::default()
    }

    // optional int32 max_entries = 1;

    pub fn max_entries(&self) -> i32 {
        self.max_entries.unwrap_or(0)
    }

    pub fn clear_max_entries(&mut self) {
        self.max_entries = ::std::option::Option::None;
    }

    pub fn has_max_entries(&self) -> bool {
        self.max_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: i32) {
        self.max_entries = ::std::option::Option::Some(v);
    }

    // optional int32 updated_entries = 2;

    pub fn updated_entries(&self) -> i32 {
        self.updated_entries.unwrap_or(0)
    }

    pub fn clear_updated_entries(&mut self) {
        self.updated_entries = ::std::option::Option::None;
    }

    pub fn has_updated_entries(&self) -> bool {
        self.updated_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_entries(&mut self, v: i32) {
        self.updated_entries = ::std::option::Option::Some(v);
    }

    // optional bool legacy_is_delta = 3;

    pub fn legacy_is_delta(&self) -> bool {
        self.legacy_is_delta.unwrap_or(false)
    }

    pub fn clear_legacy_is_delta(&mut self) {
        self.legacy_is_delta = ::std::option::Option::None;
    }

    pub fn has_legacy_is_delta(&self) -> bool {
        self.legacy_is_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_is_delta(&mut self, v: bool) {
        self.legacy_is_delta = ::std::option::Option::Some(v);
    }

    // optional bool update_baseline = 4;

    pub fn update_baseline(&self) -> bool {
        self.update_baseline.unwrap_or(false)
    }

    pub fn clear_update_baseline(&mut self) {
        self.update_baseline = ::std::option::Option::None;
    }

    pub fn has_update_baseline(&self) -> bool {
        self.update_baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_baseline(&mut self, v: bool) {
        self.update_baseline = ::std::option::Option::Some(v);
    }

    // optional int32 baseline = 5;

    pub fn baseline(&self) -> i32 {
        self.baseline.unwrap_or(0)
    }

    pub fn clear_baseline(&mut self) {
        self.baseline = ::std::option::Option::None;
    }

    pub fn has_baseline(&self) -> bool {
        self.baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline(&mut self, v: i32) {
        self.baseline = ::std::option::Option::Some(v);
    }

    // optional int32 delta_from = 6;

    pub fn delta_from(&self) -> i32 {
        self.delta_from.unwrap_or(0)
    }

    pub fn clear_delta_from(&mut self) {
        self.delta_from = ::std::option::Option::None;
    }

    pub fn has_delta_from(&self) -> bool {
        self.delta_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_from(&mut self, v: i32) {
        self.delta_from = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 7;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::std::vec::Vec<u8> {
        self.entity_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool pending_full_frame = 8;

    pub fn pending_full_frame(&self) -> bool {
        self.pending_full_frame.unwrap_or(false)
    }

    pub fn clear_pending_full_frame(&mut self) {
        self.pending_full_frame = ::std::option::Option::None;
    }

    pub fn has_pending_full_frame(&self) -> bool {
        self.pending_full_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_full_frame(&mut self, v: bool) {
        self.pending_full_frame = ::std::option::Option::Some(v);
    }

    // optional uint32 active_spawngroup_handle = 9;

    pub fn active_spawngroup_handle(&self) -> u32 {
        self.active_spawngroup_handle.unwrap_or(0)
    }

    pub fn clear_active_spawngroup_handle(&mut self) {
        self.active_spawngroup_handle = ::std::option::Option::None;
    }

    pub fn has_active_spawngroup_handle(&self) -> bool {
        self.active_spawngroup_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_spawngroup_handle(&mut self, v: u32) {
        self.active_spawngroup_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spawngroup_creationsequence = 10;

    pub fn max_spawngroup_creationsequence(&self) -> u32 {
        self.max_spawngroup_creationsequence.unwrap_or(0)
    }

    pub fn clear_max_spawngroup_creationsequence(&mut self) {
        self.max_spawngroup_creationsequence = ::std::option::Option::None;
    }

    pub fn has_max_spawngroup_creationsequence(&self) -> bool {
        self.max_spawngroup_creationsequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spawngroup_creationsequence(&mut self, v: u32) {
        self.max_spawngroup_creationsequence = ::std::option::Option::Some(v);
    }

    // optional uint32 last_cmd_number_executed = 11;

    pub fn last_cmd_number_executed(&self) -> u32 {
        self.last_cmd_number_executed.unwrap_or(0)
    }

    pub fn clear_last_cmd_number_executed(&mut self) {
        self.last_cmd_number_executed = ::std::option::Option::None;
    }

    pub fn has_last_cmd_number_executed(&self) -> bool {
        self.last_cmd_number_executed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_cmd_number_executed(&mut self, v: u32) {
        self.last_cmd_number_executed = ::std::option::Option::Some(v);
    }

    // optional sint32 last_cmd_number_recv_delta = 17;

    pub fn last_cmd_number_recv_delta(&self) -> i32 {
        self.last_cmd_number_recv_delta.unwrap_or(0)
    }

    pub fn clear_last_cmd_number_recv_delta(&mut self) {
        self.last_cmd_number_recv_delta = ::std::option::Option::None;
    }

    pub fn has_last_cmd_number_recv_delta(&self) -> bool {
        self.last_cmd_number_recv_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_cmd_number_recv_delta(&mut self, v: i32) {
        self.last_cmd_number_recv_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 server_tick = 12;

    pub fn server_tick(&self) -> u32 {
        self.server_tick.unwrap_or(0)
    }

    pub fn clear_server_tick(&mut self) {
        self.server_tick = ::std::option::Option::None;
    }

    pub fn has_server_tick(&self) -> bool {
        self.server_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tick(&mut self, v: u32) {
        self.server_tick = ::std::option::Option::Some(v);
    }

    // optional bytes serialized_entities = 13;

    pub fn serialized_entities(&self) -> &[u8] {
        match self.serialized_entities.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_entities(&mut self) {
        self.serialized_entities = ::std::option::Option::None;
    }

    pub fn has_serialized_entities(&self) -> bool {
        self.serialized_entities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_entities(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_entities = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_entities(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_entities.is_none() {
            self.serialized_entities = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_entities.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_entities(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_entities.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 has_pvs_vis_bits = 16;

    pub fn has_pvs_vis_bits(&self) -> u32 {
        self.has_pvs_vis_bits.unwrap_or(0)
    }

    pub fn clear_has_pvs_vis_bits(&mut self) {
        self.has_pvs_vis_bits = ::std::option::Option::None;
    }

    pub fn has_has_pvs_vis_bits(&self) -> bool {
        self.has_pvs_vis_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_pvs_vis_bits(&mut self, v: u32) {
        self.has_pvs_vis_bits = ::std::option::Option::Some(v);
    }

    // optional uint32 cq_starved_command_ticks = 20;

    pub fn cq_starved_command_ticks(&self) -> u32 {
        self.cq_starved_command_ticks.unwrap_or(0)
    }

    pub fn clear_cq_starved_command_ticks(&mut self) {
        self.cq_starved_command_ticks = ::std::option::Option::None;
    }

    pub fn has_cq_starved_command_ticks(&self) -> bool {
        self.cq_starved_command_ticks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cq_starved_command_ticks(&mut self, v: u32) {
        self.cq_starved_command_ticks = ::std::option::Option::Some(v);
    }

    // optional uint32 cq_discarded_command_ticks = 21;

    pub fn cq_discarded_command_ticks(&self) -> u32 {
        self.cq_discarded_command_ticks.unwrap_or(0)
    }

    pub fn clear_cq_discarded_command_ticks(&mut self) {
        self.cq_discarded_command_ticks = ::std::option::Option::None;
    }

    pub fn has_cq_discarded_command_ticks(&self) -> bool {
        self.cq_discarded_command_ticks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cq_discarded_command_ticks(&mut self, v: u32) {
        self.cq_discarded_command_ticks = ::std::option::Option::Some(v);
    }

    // optional bytes dev_padding = 999;

    pub fn dev_padding(&self) -> &[u8] {
        match self.dev_padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dev_padding(&mut self) {
        self.dev_padding = ::std::option::Option::None;
    }

    pub fn has_dev_padding(&self) -> bool {
        self.dev_padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dev_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dev_padding.is_none() {
            self.dev_padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.dev_padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_dev_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.dev_padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_PacketEntities {
    const NAME: &'static str = "CSVCMsg_PacketEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.updated_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.legacy_is_delta = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.update_baseline = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.baseline = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.delta_from = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.entity_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.pending_full_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.active_spawngroup_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.max_spawngroup_creationsequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.last_cmd_number_executed = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.last_cmd_number_recv_delta = ::std::option::Option::Some(is.read_sint32()?);
                },
                96 => {
                    self.server_tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.serialized_entities = ::std::option::Option::Some(is.read_bytes()?);
                },
                122 => {
                    self.alternate_baselines.push(is.read_message()?);
                },
                128 => {
                    self.has_pvs_vis_bits = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    is.read_repeated_packed_sint32_into(&mut self.cmd_recv_status)?;
                },
                176 => {
                    self.cmd_recv_status.push(is.read_sint32()?);
                },
                154 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.non_transmitted_entities)?;
                },
                160 => {
                    self.cq_starved_command_ticks = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.cq_discarded_command_ticks = ::std::option::Option::Some(is.read_uint32()?);
                },
                7994 => {
                    self.dev_padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_entries {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.updated_entries {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.legacy_is_delta {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_baseline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.baseline {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.delta_from {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.pending_full_frame {
            my_size += 1 + 1;
        }
        if let Some(v) = self.active_spawngroup_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.max_spawngroup_creationsequence {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.last_cmd_number_executed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.last_cmd_number_recv_delta {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(17, v);
        }
        if let Some(v) = self.server_tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.serialized_entities.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(13, &v);
        }
        for value in &self.alternate_baselines {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.has_pvs_vis_bits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_sint32_size(22, &self.cmd_recv_status);
        if let Some(v) = self.non_transmitted_entities.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cq_starved_command_ticks {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.cq_discarded_command_ticks {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.dev_padding.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(999, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.max_entries {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.updated_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.legacy_is_delta {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.update_baseline {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.baseline {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delta_from {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.pending_full_frame {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.active_spawngroup_handle {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.max_spawngroup_creationsequence {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.last_cmd_number_executed {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.last_cmd_number_recv_delta {
            os.write_sint32(17, v)?;
        }
        if let Some(v) = self.server_tick {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.serialized_entities.as_ref() {
            os.write_bytes(13, v)?;
        }
        for v in &self.alternate_baselines {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.has_pvs_vis_bits {
            os.write_uint32(16, v)?;
        }
        os.write_repeated_packed_sint32(22, &self.cmd_recv_status)?;
        if let Some(v) = self.non_transmitted_entities.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.cq_starved_command_ticks {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.cq_discarded_command_ticks {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.dev_padding.as_ref() {
            os.write_bytes(999, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PacketEntities {
        CSVCMsg_PacketEntities::new()
    }

    fn clear(&mut self) {
        self.max_entries = ::std::option::Option::None;
        self.updated_entries = ::std::option::Option::None;
        self.legacy_is_delta = ::std::option::Option::None;
        self.update_baseline = ::std::option::Option::None;
        self.baseline = ::std::option::Option::None;
        self.delta_from = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.pending_full_frame = ::std::option::Option::None;
        self.active_spawngroup_handle = ::std::option::Option::None;
        self.max_spawngroup_creationsequence = ::std::option::Option::None;
        self.last_cmd_number_executed = ::std::option::Option::None;
        self.last_cmd_number_recv_delta = ::std::option::Option::None;
        self.server_tick = ::std::option::Option::None;
        self.serialized_entities = ::std::option::Option::None;
        self.alternate_baselines.clear();
        self.has_pvs_vis_bits = ::std::option::Option::None;
        self.cmd_recv_status.clear();
        self.non_transmitted_entities.clear();
        self.cq_starved_command_ticks = ::std::option::Option::None;
        self.cq_discarded_command_ticks = ::std::option::Option::None;
        self.dev_padding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PacketEntities {
        static instance: CSVCMsg_PacketEntities = CSVCMsg_PacketEntities {
            max_entries: ::std::option::Option::None,
            updated_entries: ::std::option::Option::None,
            legacy_is_delta: ::std::option::Option::None,
            update_baseline: ::std::option::Option::None,
            baseline: ::std::option::Option::None,
            delta_from: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            pending_full_frame: ::std::option::Option::None,
            active_spawngroup_handle: ::std::option::Option::None,
            max_spawngroup_creationsequence: ::std::option::Option::None,
            last_cmd_number_executed: ::std::option::Option::None,
            last_cmd_number_recv_delta: ::std::option::Option::None,
            server_tick: ::std::option::Option::None,
            serialized_entities: ::std::option::Option::None,
            alternate_baselines: ::std::vec::Vec::new(),
            has_pvs_vis_bits: ::std::option::Option::None,
            cmd_recv_status: ::std::vec::Vec::new(),
            non_transmitted_entities: ::steam_vent_proto_common::protobuf::MessageField::none(),
            cq_starved_command_ticks: ::std::option::Option::None,
            cq_discarded_command_ticks: ::std::option::Option::None,
            dev_padding: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSVCMsg_PacketEntities`
pub mod csvcmsg_packet_entities {
    // @@protoc_insertion_point(message:CSVCMsg_PacketEntities.alternate_baseline_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Alternate_baseline_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baseline_t.entity_index)
        pub entity_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baseline_t.baseline_index)
        pub baseline_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.alternate_baseline_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Alternate_baseline_t {
        fn default() -> &'a Alternate_baseline_t {
            <Alternate_baseline_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Alternate_baseline_t {
        pub fn new() -> Alternate_baseline_t {
            ::std::default::Default::default()
        }

        // optional int32 entity_index = 1;

        pub fn entity_index(&self) -> i32 {
            self.entity_index.unwrap_or(0)
        }

        pub fn clear_entity_index(&mut self) {
            self.entity_index = ::std::option::Option::None;
        }

        pub fn has_entity_index(&self) -> bool {
            self.entity_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_index(&mut self, v: i32) {
            self.entity_index = ::std::option::Option::Some(v);
        }

        // optional int32 baseline_index = 2;

        pub fn baseline_index(&self) -> i32 {
            self.baseline_index.unwrap_or(0)
        }

        pub fn clear_baseline_index(&mut self) {
            self.baseline_index = ::std::option::Option::None;
        }

        pub fn has_baseline_index(&self) -> bool {
            self.baseline_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_baseline_index(&mut self, v: i32) {
            self.baseline_index = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Alternate_baseline_t {
        const NAME: &'static str = "alternate_baseline_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.baseline_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.baseline_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.entity_index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.baseline_index {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Alternate_baseline_t {
            Alternate_baseline_t::new()
        }

        fn clear(&mut self) {
            self.entity_index = ::std::option::Option::None;
            self.baseline_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Alternate_baseline_t {
            static instance: Alternate_baseline_t = Alternate_baseline_t {
                entity_index: ::std::option::Option::None,
                baseline_index: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CSVCMsg_PacketEntities.non_transmitted_entities_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Non_transmitted_entities_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.non_transmitted_entities_t.header_count)
        pub header_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.non_transmitted_entities_t.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.non_transmitted_entities_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Non_transmitted_entities_t {
        fn default() -> &'a Non_transmitted_entities_t {
            <Non_transmitted_entities_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Non_transmitted_entities_t {
        pub fn new() -> Non_transmitted_entities_t {
            ::std::default::Default::default()
        }

        // optional int32 header_count = 1;

        pub fn header_count(&self) -> i32 {
            self.header_count.unwrap_or(0)
        }

        pub fn clear_header_count(&mut self) {
            self.header_count = ::std::option::Option::None;
        }

        pub fn has_header_count(&self) -> bool {
            self.header_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_header_count(&mut self, v: i32) {
            self.header_count = ::std::option::Option::Some(v);
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Non_transmitted_entities_t {
        const NAME: &'static str = "non_transmitted_entities_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.header_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.header_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.header_count {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Non_transmitted_entities_t {
            Non_transmitted_entities_t::new()
        }

        fn clear(&mut self) {
            self.header_count = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Non_transmitted_entities_t {
            static instance: Non_transmitted_entities_t = Non_transmitted_entities_t {
                header_count: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsg_TempEntities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_TempEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.reliable)
    pub reliable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.entity_data)
    pub entity_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_TempEntities.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_TempEntities {
    fn default() -> &'a CSVCMsg_TempEntities {
        <CSVCMsg_TempEntities as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_TempEntities {
    pub fn new() -> CSVCMsg_TempEntities {
        ::std::default::Default::default()
    }

    // optional bool reliable = 1;

    pub fn reliable(&self) -> bool {
        self.reliable.unwrap_or(false)
    }

    pub fn clear_reliable(&mut self) {
        self.reliable = ::std::option::Option::None;
    }

    pub fn has_reliable(&self) -> bool {
        self.reliable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable(&mut self, v: bool) {
        self.reliable = ::std::option::Option::Some(v);
    }

    // optional int32 num_entries = 2;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 3;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::std::vec::Vec<u8> {
        self.entity_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_TempEntities {
    const NAME: &'static str = "CSVCMsg_TempEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.entity_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_entries {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reliable {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_TempEntities {
        CSVCMsg_TempEntities::new()
    }

    fn clear(&mut self) {
        self.reliable = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_TempEntities {
        static instance: CSVCMsg_TempEntities = CSVCMsg_TempEntities {
            reliable: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_CreateStringTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CreateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_fixed_size)
    pub user_data_fixed_size: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size)
    pub user_data_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size_bits)
    pub user_data_size_bits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.flags)
    pub flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.string_data)
    pub string_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.uncompressed_size)
    pub uncompressed_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.data_compressed)
    pub data_compressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.using_varint_bitcounts)
    pub using_varint_bitcounts: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CreateStringTable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CreateStringTable {
    fn default() -> &'a CSVCMsg_CreateStringTable {
        <CSVCMsg_CreateStringTable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CreateStringTable {
    pub fn new() -> CSVCMsg_CreateStringTable {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 num_entries = 2;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bool user_data_fixed_size = 3;

    pub fn user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.unwrap_or(false)
    }

    pub fn clear_user_data_fixed_size(&mut self) {
        self.user_data_fixed_size = ::std::option::Option::None;
    }

    pub fn has_user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_fixed_size(&mut self, v: bool) {
        self.user_data_fixed_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size = 4;

    pub fn user_data_size(&self) -> i32 {
        self.user_data_size.unwrap_or(0)
    }

    pub fn clear_user_data_size(&mut self) {
        self.user_data_size = ::std::option::Option::None;
    }

    pub fn has_user_data_size(&self) -> bool {
        self.user_data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size(&mut self, v: i32) {
        self.user_data_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size_bits = 5;

    pub fn user_data_size_bits(&self) -> i32 {
        self.user_data_size_bits.unwrap_or(0)
    }

    pub fn clear_user_data_size_bits(&mut self) {
        self.user_data_size_bits = ::std::option::Option::None;
    }

    pub fn has_user_data_size_bits(&self) -> bool {
        self.user_data_size_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size_bits(&mut self, v: i32) {
        self.user_data_size_bits = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 6;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 7;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::std::vec::Vec<u8> {
        self.string_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 uncompressed_size = 8;

    pub fn uncompressed_size(&self) -> i32 {
        self.uncompressed_size.unwrap_or(0)
    }

    pub fn clear_uncompressed_size(&mut self) {
        self.uncompressed_size = ::std::option::Option::None;
    }

    pub fn has_uncompressed_size(&self) -> bool {
        self.uncompressed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_size(&mut self, v: i32) {
        self.uncompressed_size = ::std::option::Option::Some(v);
    }

    // optional bool data_compressed = 9;

    pub fn data_compressed(&self) -> bool {
        self.data_compressed.unwrap_or(false)
    }

    pub fn clear_data_compressed(&mut self) {
        self.data_compressed = ::std::option::Option::None;
    }

    pub fn has_data_compressed(&self) -> bool {
        self.data_compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_compressed(&mut self, v: bool) {
        self.data_compressed = ::std::option::Option::Some(v);
    }

    // optional bool using_varint_bitcounts = 10;

    pub fn using_varint_bitcounts(&self) -> bool {
        self.using_varint_bitcounts.unwrap_or(false)
    }

    pub fn clear_using_varint_bitcounts(&mut self) {
        self.using_varint_bitcounts = ::std::option::Option::None;
    }

    pub fn has_using_varint_bitcounts(&self) -> bool {
        self.using_varint_bitcounts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_using_varint_bitcounts(&mut self, v: bool) {
        self.using_varint_bitcounts = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_CreateStringTable {
    const NAME: &'static str = "CSVCMsg_CreateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.user_data_fixed_size = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.user_data_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.user_data_size_bits = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.string_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.uncompressed_size = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.data_compressed = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.using_varint_bitcounts = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.num_entries {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.user_data_fixed_size {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_data_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.user_data_size_bits {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.uncompressed_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.data_compressed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.using_varint_bitcounts {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.user_data_fixed_size {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.user_data_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.user_data_size_bits {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.uncompressed_size {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.data_compressed {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.using_varint_bitcounts {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CreateStringTable {
        CSVCMsg_CreateStringTable::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.user_data_fixed_size = ::std::option::Option::None;
        self.user_data_size = ::std::option::Option::None;
        self.user_data_size_bits = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.uncompressed_size = ::std::option::Option::None;
        self.data_compressed = ::std::option::Option::None;
        self.using_varint_bitcounts = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CreateStringTable {
        static instance: CSVCMsg_CreateStringTable = CSVCMsg_CreateStringTable {
            name: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            user_data_fixed_size: ::std::option::Option::None,
            user_data_size: ::std::option::Option::None,
            user_data_size_bits: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            uncompressed_size: ::std::option::Option::None,
            data_compressed: ::std::option::Option::None,
            using_varint_bitcounts: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_UpdateStringTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UpdateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.table_id)
    pub table_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.num_changed_entries)
    pub num_changed_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.string_data)
    pub string_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UpdateStringTable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UpdateStringTable {
    fn default() -> &'a CSVCMsg_UpdateStringTable {
        <CSVCMsg_UpdateStringTable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UpdateStringTable {
    pub fn new() -> CSVCMsg_UpdateStringTable {
        ::std::default::Default::default()
    }

    // optional int32 table_id = 1;

    pub fn table_id(&self) -> i32 {
        self.table_id.unwrap_or(0)
    }

    pub fn clear_table_id(&mut self) {
        self.table_id = ::std::option::Option::None;
    }

    pub fn has_table_id(&self) -> bool {
        self.table_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: i32) {
        self.table_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_changed_entries = 2;

    pub fn num_changed_entries(&self) -> i32 {
        self.num_changed_entries.unwrap_or(0)
    }

    pub fn clear_num_changed_entries(&mut self) {
        self.num_changed_entries = ::std::option::Option::None;
    }

    pub fn has_num_changed_entries(&self) -> bool {
        self.num_changed_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_changed_entries(&mut self, v: i32) {
        self.num_changed_entries = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 3;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::std::vec::Vec<u8> {
        self.string_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_UpdateStringTable {
    const NAME: &'static str = "CSVCMsg_UpdateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.table_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.num_changed_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.string_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.table_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.num_changed_entries {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.table_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.num_changed_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UpdateStringTable {
        CSVCMsg_UpdateStringTable::new()
    }

    fn clear(&mut self) {
        self.table_id = ::std::option::Option::None;
        self.num_changed_entries = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UpdateStringTable {
        static instance: CSVCMsg_UpdateStringTable = CSVCMsg_UpdateStringTable {
            table_id: ::std::option::Option::None,
            num_changed_entries: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_VoiceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.audio)
    pub audio: ::steam_vent_proto_common::protobuf::MessageField<CMsgVoiceAudio>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.client)
    pub client: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.proximity)
    pub proximity: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.audible_mask)
    pub audible_mask: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.tick)
    pub tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceData {
    fn default() -> &'a CSVCMsg_VoiceData {
        <CSVCMsg_VoiceData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceData {
    pub fn new() -> CSVCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional int32 client = 2;

    pub fn client(&self) -> i32 {
        self.client.unwrap_or(-1i32)
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional bool proximity = 3;

    pub fn proximity(&self) -> bool {
        self.proximity.unwrap_or(false)
    }

    pub fn clear_proximity(&mut self) {
        self.proximity = ::std::option::Option::None;
    }

    pub fn has_proximity(&self) -> bool {
        self.proximity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proximity(&mut self, v: bool) {
        self.proximity = ::std::option::Option::Some(v);
    }

    // optional fixed64 xuid = 4;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 audible_mask = 5;

    pub fn audible_mask(&self) -> i32 {
        self.audible_mask.unwrap_or(0)
    }

    pub fn clear_audible_mask(&mut self) {
        self.audible_mask = ::std::option::Option::None;
    }

    pub fn has_audible_mask(&self) -> bool {
        self.audible_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audible_mask(&mut self, v: i32) {
        self.audible_mask = ::std::option::Option::Some(v);
    }

    // optional uint32 tick = 6;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 passthrough = 7;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_VoiceData {
    const NAME: &'static str = "CSVCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.audio)?;
                },
                16 => {
                    self.client = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.proximity = ::std::option::Option::Some(is.read_bool()?);
                },
                33 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.audible_mask = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.proximity {
            my_size += 1 + 1;
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.audible_mask {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.audio.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.proximity {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.audible_mask {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.tick {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceData {
        CSVCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.audio.clear();
        self.client = ::std::option::Option::None;
        self.proximity = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.audible_mask = ::std::option::Option::None;
        self.tick = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceData {
        static instance: CSVCMsg_VoiceData = CSVCMsg_VoiceData {
            audio: ::steam_vent_proto_common::protobuf::MessageField::none(),
            client: ::std::option::Option::None,
            proximity: ::std::option::Option::None,
            xuid: ::std::option::Option::None,
            audible_mask: ::std::option::Option::None,
            tick: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_PacketReliable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PacketReliable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.messagessize)
    pub messagessize: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.state)
    pub state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PacketReliable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PacketReliable {
    fn default() -> &'a CSVCMsg_PacketReliable {
        <CSVCMsg_PacketReliable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PacketReliable {
    pub fn new() -> CSVCMsg_PacketReliable {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 messagessize = 2;

    pub fn messagessize(&self) -> i32 {
        self.messagessize.unwrap_or(0)
    }

    pub fn clear_messagessize(&mut self) {
        self.messagessize = ::std::option::Option::None;
    }

    pub fn has_messagessize(&self) -> bool {
        self.messagessize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagessize(&mut self, v: i32) {
        self.messagessize = ::std::option::Option::Some(v);
    }

    // optional bool state = 3;

    pub fn state(&self) -> bool {
        self.state.unwrap_or(false)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_PacketReliable {
    const NAME: &'static str = "CSVCMsg_PacketReliable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.messagessize = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.messagessize {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.messagessize {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PacketReliable {
        CSVCMsg_PacketReliable::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.messagessize = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PacketReliable {
        static instance: CSVCMsg_PacketReliable = CSVCMsg_PacketReliable {
            tick: ::std::option::Option::None,
            messagessize: ::std::option::Option::None,
            state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_FullFrameSplit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FullFrameSplit {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.section)
    pub section: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.total)
    pub total: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FullFrameSplit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FullFrameSplit {
    fn default() -> &'a CSVCMsg_FullFrameSplit {
        <CSVCMsg_FullFrameSplit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FullFrameSplit {
    pub fn new() -> CSVCMsg_FullFrameSplit {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 section = 2;

    pub fn section(&self) -> i32 {
        self.section.unwrap_or(0)
    }

    pub fn clear_section(&mut self) {
        self.section = ::std::option::Option::None;
    }

    pub fn has_section(&self) -> bool {
        self.section.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section(&mut self, v: i32) {
        self.section = ::std::option::Option::Some(v);
    }

    // optional int32 total = 3;

    pub fn total(&self) -> i32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional bytes data = 4;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_FullFrameSplit {
    const NAME: &'static str = "CSVCMsg_FullFrameSplit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.section = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.total = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.section {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.total {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.section {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.total {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FullFrameSplit {
        CSVCMsg_FullFrameSplit::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.section = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FullFrameSplit {
        static instance: CSVCMsg_FullFrameSplit = CSVCMsg_FullFrameSplit {
            tick: ::std::option::Option::None,
            section: ::std::option::Option::None,
            total: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_HLTVStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HLTVStatus {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.master)
    pub master: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.clients)
    pub clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.slots)
    pub slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.proxies)
    pub proxies: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HLTVStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HLTVStatus {
    fn default() -> &'a CSVCMsg_HLTVStatus {
        <CSVCMsg_HLTVStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HLTVStatus {
    pub fn new() -> CSVCMsg_HLTVStatus {
        ::std::default::Default::default()
    }

    // optional string master = 1;

    pub fn master(&self) -> &str {
        match self.master.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_master(&mut self) {
        self.master = ::std::option::Option::None;
    }

    pub fn has_master(&self) -> bool {
        self.master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_master(&mut self, v: ::std::string::String) {
        self.master = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master(&mut self) -> &mut ::std::string::String {
        if self.master.is_none() {
            self.master = ::std::option::Option::Some(::std::string::String::new());
        }
        self.master.as_mut().unwrap()
    }

    // Take field
    pub fn take_master(&mut self) -> ::std::string::String {
        self.master.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 clients = 2;

    pub fn clients(&self) -> i32 {
        self.clients.unwrap_or(0)
    }

    pub fn clear_clients(&mut self) {
        self.clients = ::std::option::Option::None;
    }

    pub fn has_clients(&self) -> bool {
        self.clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clients(&mut self, v: i32) {
        self.clients = ::std::option::Option::Some(v);
    }

    // optional int32 slots = 3;

    pub fn slots(&self) -> i32 {
        self.slots.unwrap_or(0)
    }

    pub fn clear_slots(&mut self) {
        self.slots = ::std::option::Option::None;
    }

    pub fn has_slots(&self) -> bool {
        self.slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: i32) {
        self.slots = ::std::option::Option::Some(v);
    }

    // optional int32 proxies = 4;

    pub fn proxies(&self) -> i32 {
        self.proxies.unwrap_or(0)
    }

    pub fn clear_proxies(&mut self) {
        self.proxies = ::std::option::Option::None;
    }

    pub fn has_proxies(&self) -> bool {
        self.proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxies(&mut self, v: i32) {
        self.proxies = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_HLTVStatus {
    const NAME: &'static str = "CSVCMsg_HLTVStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.master = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.clients = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slots = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.proxies = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.master.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clients {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.proxies {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.master.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clients {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slots {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.proxies {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HLTVStatus {
        CSVCMsg_HLTVStatus::new()
    }

    fn clear(&mut self) {
        self.master = ::std::option::Option::None;
        self.clients = ::std::option::Option::None;
        self.slots = ::std::option::Option::None;
        self.proxies = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HLTVStatus {
        static instance: CSVCMsg_HLTVStatus = CSVCMsg_HLTVStatus {
            master: ::std::option::Option::None,
            clients: ::std::option::Option::None,
            slots: ::std::option::Option::None,
            proxies: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_ServerSteamID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ServerSteamID {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ServerSteamID.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ServerSteamID.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ServerSteamID {
    fn default() -> &'a CSVCMsg_ServerSteamID {
        <CSVCMsg_ServerSteamID as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ServerSteamID {
    pub fn new() -> CSVCMsg_ServerSteamID {
        ::std::default::Default::default()
    }

    // optional uint64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_ServerSteamID {
    const NAME: &'static str = "CSVCMsg_ServerSteamID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ServerSteamID {
        CSVCMsg_ServerSteamID::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ServerSteamID {
        static instance: CSVCMsg_ServerSteamID = CSVCMsg_ServerSteamID {
            steam_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_CmdKeyValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CmdKeyValues.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CmdKeyValues {
    fn default() -> &'a CSVCMsg_CmdKeyValues {
        <CSVCMsg_CmdKeyValues as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CmdKeyValues {
    pub fn new() -> CSVCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_CmdKeyValues {
    const NAME: &'static str = "CSVCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CmdKeyValues {
        CSVCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CmdKeyValues {
        static instance: CSVCMsg_CmdKeyValues = CSVCMsg_CmdKeyValues {
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_RconServerDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_RconServerDetails {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_RconServerDetails.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_RconServerDetails.details)
    pub details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_RconServerDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_RconServerDetails {
    fn default() -> &'a CSVCMsg_RconServerDetails {
        <CSVCMsg_RconServerDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_RconServerDetails {
    pub fn new() -> CSVCMsg_RconServerDetails {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string details = 2;

    pub fn details(&self) -> &str {
        match self.details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        self.details.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_RconServerDetails {
    const NAME: &'static str = "CSVCMsg_RconServerDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.details.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_RconServerDetails {
        CSVCMsg_RconServerDetails::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_RconServerDetails {
        static instance: CSVCMsg_RconServerDetails = CSVCMsg_RconServerDetails {
            token: ::std::option::Option::None,
            details: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgIPCAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIPCAddress {
    // message fields
    // @@protoc_insertion_point(field:CMsgIPCAddress.computer_guid)
    pub computer_guid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIPCAddress.process_id)
    pub process_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPCAddress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPCAddress {
    fn default() -> &'a CMsgIPCAddress {
        <CMsgIPCAddress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgIPCAddress {
    pub fn new() -> CMsgIPCAddress {
        ::std::default::Default::default()
    }

    // optional fixed64 computer_guid = 1;

    pub fn computer_guid(&self) -> u64 {
        self.computer_guid.unwrap_or(0)
    }

    pub fn clear_computer_guid(&mut self) {
        self.computer_guid = ::std::option::Option::None;
    }

    pub fn has_computer_guid(&self) -> bool {
        self.computer_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_computer_guid(&mut self, v: u64) {
        self.computer_guid = ::std::option::Option::Some(v);
    }

    // optional uint32 process_id = 2;

    pub fn process_id(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }

    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgIPCAddress {
    const NAME: &'static str = "CMsgIPCAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.computer_guid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.computer_guid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.process_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.computer_guid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.process_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPCAddress {
        CMsgIPCAddress::new()
    }

    fn clear(&mut self) {
        self.computer_guid = ::std::option::Option::None;
        self.process_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPCAddress {
        static instance: CMsgIPCAddress = CMsgIPCAddress {
            computer_guid: ::std::option::Option::None,
            process_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerPeer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerPeer {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerPeer.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerPeer.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerPeer.ipc)
    pub ipc: ::steam_vent_proto_common::protobuf::MessageField<CMsgIPCAddress>,
    // @@protoc_insertion_point(field:CMsgServerPeer.they_hear_you)
    pub they_hear_you: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerPeer.you_hear_them)
    pub you_hear_them: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerPeer.is_listenserver_host)
    pub is_listenserver_host: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerPeer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerPeer {
    fn default() -> &'a CMsgServerPeer {
        <CMsgServerPeer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerPeer {
    pub fn new() -> CMsgServerPeer {
        ::std::default::Default::default()
    }

    // optional int32 player_slot = 1;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool they_hear_you = 4;

    pub fn they_hear_you(&self) -> bool {
        self.they_hear_you.unwrap_or(false)
    }

    pub fn clear_they_hear_you(&mut self) {
        self.they_hear_you = ::std::option::Option::None;
    }

    pub fn has_they_hear_you(&self) -> bool {
        self.they_hear_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_they_hear_you(&mut self, v: bool) {
        self.they_hear_you = ::std::option::Option::Some(v);
    }

    // optional bool you_hear_them = 5;

    pub fn you_hear_them(&self) -> bool {
        self.you_hear_them.unwrap_or(false)
    }

    pub fn clear_you_hear_them(&mut self) {
        self.you_hear_them = ::std::option::Option::None;
    }

    pub fn has_you_hear_them(&self) -> bool {
        self.you_hear_them.is_some()
    }

    // Param is passed by value, moved
    pub fn set_you_hear_them(&mut self, v: bool) {
        self.you_hear_them = ::std::option::Option::Some(v);
    }

    // optional bool is_listenserver_host = 6;

    pub fn is_listenserver_host(&self) -> bool {
        self.is_listenserver_host.unwrap_or(false)
    }

    pub fn clear_is_listenserver_host(&mut self) {
        self.is_listenserver_host = ::std::option::Option::None;
    }

    pub fn has_is_listenserver_host(&self) -> bool {
        self.is_listenserver_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_listenserver_host(&mut self, v: bool) {
        self.is_listenserver_host = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerPeer {
    const NAME: &'static str = "CMsgServerPeer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ipc)?;
                },
                32 => {
                    self.they_hear_you = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.you_hear_them = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_listenserver_host = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ipc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.they_hear_you {
            my_size += 1 + 1;
        }
        if let Some(v) = self.you_hear_them {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_listenserver_host {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_slot {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ipc.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.they_hear_you {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.you_hear_them {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_listenserver_host {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerPeer {
        CMsgServerPeer::new()
    }

    fn clear(&mut self) {
        self.player_slot = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ipc.clear();
        self.they_hear_you = ::std::option::Option::None;
        self.you_hear_them = ::std::option::Option::None;
        self.is_listenserver_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerPeer {
        static instance: CMsgServerPeer = CMsgServerPeer {
            player_slot: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            ipc: ::steam_vent_proto_common::protobuf::MessageField::none(),
            they_hear_you: ::std::option::Option::None,
            you_hear_them: ::std::option::Option::None,
            is_listenserver_host: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_PeerList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PeerList {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PeerList.peer)
    pub peer: ::std::vec::Vec<CMsgServerPeer>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PeerList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PeerList {
    fn default() -> &'a CSVCMsg_PeerList {
        <CSVCMsg_PeerList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PeerList {
    pub fn new() -> CSVCMsg_PeerList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_PeerList {
    const NAME: &'static str = "CSVCMsg_PeerList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.peer.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.peer {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.peer {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PeerList {
        CSVCMsg_PeerList::new()
    }

    fn clear(&mut self) {
        self.peer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PeerList {
        static instance: CSVCMsg_PeerList = CSVCMsg_PeerList {
            peer: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_ClearAllStringTables)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ClearAllStringTables {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ClearAllStringTables.mapname)
    pub mapname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ClearAllStringTables.create_tables_skipped)
    pub create_tables_skipped: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ClearAllStringTables.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ClearAllStringTables {
    fn default() -> &'a CSVCMsg_ClearAllStringTables {
        <CSVCMsg_ClearAllStringTables as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ClearAllStringTables {
    pub fn new() -> CSVCMsg_ClearAllStringTables {
        ::std::default::Default::default()
    }

    // optional string mapname = 1;

    pub fn mapname(&self) -> &str {
        match self.mapname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mapname(&mut self) {
        self.mapname = ::std::option::Option::None;
    }

    pub fn has_mapname(&self) -> bool {
        self.mapname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapname(&mut self, v: ::std::string::String) {
        self.mapname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mapname(&mut self) -> &mut ::std::string::String {
        if self.mapname.is_none() {
            self.mapname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mapname.as_mut().unwrap()
    }

    // Take field
    pub fn take_mapname(&mut self) -> ::std::string::String {
        self.mapname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool create_tables_skipped = 3;

    pub fn create_tables_skipped(&self) -> bool {
        self.create_tables_skipped.unwrap_or(false)
    }

    pub fn clear_create_tables_skipped(&mut self) {
        self.create_tables_skipped = ::std::option::Option::None;
    }

    pub fn has_create_tables_skipped(&self) -> bool {
        self.create_tables_skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_tables_skipped(&mut self, v: bool) {
        self.create_tables_skipped = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_ClearAllStringTables {
    const NAME: &'static str = "CSVCMsg_ClearAllStringTables";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mapname = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.create_tables_skipped = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mapname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.create_tables_skipped {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mapname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.create_tables_skipped {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ClearAllStringTables {
        CSVCMsg_ClearAllStringTables::new()
    }

    fn clear(&mut self) {
        self.mapname = ::std::option::Option::None;
        self.create_tables_skipped = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ClearAllStringTables {
        static instance: CSVCMsg_ClearAllStringTables = CSVCMsg_ClearAllStringTables {
            mapname: ::std::option::Option::None,
            create_tables_skipped: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:ProtoFlattenedSerializerField_t)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoFlattenedSerializerField_t {
    // message fields
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_type_sym)
    pub var_type_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_name_sym)
    pub var_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.bit_count)
    pub bit_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.low_value)
    pub low_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.high_value)
    pub high_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.encode_flags)
    pub encode_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.field_serializer_name_sym)
    pub field_serializer_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.field_serializer_version)
    pub field_serializer_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.send_node_sym)
    pub send_node_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_encoder_sym)
    pub var_encoder_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_types)
    pub polymorphic_types: ::std::vec::Vec<proto_flattened_serializer_field_t::Polymorphic_field_t>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_serializer_sym)
    pub var_serializer_sym: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoFlattenedSerializerField_t.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoFlattenedSerializerField_t {
    fn default() -> &'a ProtoFlattenedSerializerField_t {
        <ProtoFlattenedSerializerField_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl ProtoFlattenedSerializerField_t {
    pub fn new() -> ProtoFlattenedSerializerField_t {
        ::std::default::Default::default()
    }

    // optional int32 var_type_sym = 1;

    pub fn var_type_sym(&self) -> i32 {
        self.var_type_sym.unwrap_or(0)
    }

    pub fn clear_var_type_sym(&mut self) {
        self.var_type_sym = ::std::option::Option::None;
    }

    pub fn has_var_type_sym(&self) -> bool {
        self.var_type_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_type_sym(&mut self, v: i32) {
        self.var_type_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_name_sym = 2;

    pub fn var_name_sym(&self) -> i32 {
        self.var_name_sym.unwrap_or(0)
    }

    pub fn clear_var_name_sym(&mut self) {
        self.var_name_sym = ::std::option::Option::None;
    }

    pub fn has_var_name_sym(&self) -> bool {
        self.var_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_name_sym(&mut self, v: i32) {
        self.var_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 bit_count = 3;

    pub fn bit_count(&self) -> i32 {
        self.bit_count.unwrap_or(0)
    }

    pub fn clear_bit_count(&mut self) {
        self.bit_count = ::std::option::Option::None;
    }

    pub fn has_bit_count(&self) -> bool {
        self.bit_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bit_count(&mut self, v: i32) {
        self.bit_count = ::std::option::Option::Some(v);
    }

    // optional float low_value = 4;

    pub fn low_value(&self) -> f32 {
        self.low_value.unwrap_or(0.)
    }

    pub fn clear_low_value(&mut self) {
        self.low_value = ::std::option::Option::None;
    }

    pub fn has_low_value(&self) -> bool {
        self.low_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_value(&mut self, v: f32) {
        self.low_value = ::std::option::Option::Some(v);
    }

    // optional float high_value = 5;

    pub fn high_value(&self) -> f32 {
        self.high_value.unwrap_or(0.)
    }

    pub fn clear_high_value(&mut self) {
        self.high_value = ::std::option::Option::None;
    }

    pub fn has_high_value(&self) -> bool {
        self.high_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_value(&mut self, v: f32) {
        self.high_value = ::std::option::Option::Some(v);
    }

    // optional int32 encode_flags = 6;

    pub fn encode_flags(&self) -> i32 {
        self.encode_flags.unwrap_or(0)
    }

    pub fn clear_encode_flags(&mut self) {
        self.encode_flags = ::std::option::Option::None;
    }

    pub fn has_encode_flags(&self) -> bool {
        self.encode_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encode_flags(&mut self, v: i32) {
        self.encode_flags = ::std::option::Option::Some(v);
    }

    // optional int32 field_serializer_name_sym = 7;

    pub fn field_serializer_name_sym(&self) -> i32 {
        self.field_serializer_name_sym.unwrap_or(0)
    }

    pub fn clear_field_serializer_name_sym(&mut self) {
        self.field_serializer_name_sym = ::std::option::Option::None;
    }

    pub fn has_field_serializer_name_sym(&self) -> bool {
        self.field_serializer_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_serializer_name_sym(&mut self, v: i32) {
        self.field_serializer_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 field_serializer_version = 8;

    pub fn field_serializer_version(&self) -> i32 {
        self.field_serializer_version.unwrap_or(0)
    }

    pub fn clear_field_serializer_version(&mut self) {
        self.field_serializer_version = ::std::option::Option::None;
    }

    pub fn has_field_serializer_version(&self) -> bool {
        self.field_serializer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_serializer_version(&mut self, v: i32) {
        self.field_serializer_version = ::std::option::Option::Some(v);
    }

    // optional int32 send_node_sym = 9;

    pub fn send_node_sym(&self) -> i32 {
        self.send_node_sym.unwrap_or(0)
    }

    pub fn clear_send_node_sym(&mut self) {
        self.send_node_sym = ::std::option::Option::None;
    }

    pub fn has_send_node_sym(&self) -> bool {
        self.send_node_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_node_sym(&mut self, v: i32) {
        self.send_node_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_encoder_sym = 10;

    pub fn var_encoder_sym(&self) -> i32 {
        self.var_encoder_sym.unwrap_or(0)
    }

    pub fn clear_var_encoder_sym(&mut self) {
        self.var_encoder_sym = ::std::option::Option::None;
    }

    pub fn has_var_encoder_sym(&self) -> bool {
        self.var_encoder_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_encoder_sym(&mut self, v: i32) {
        self.var_encoder_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_serializer_sym = 12;

    pub fn var_serializer_sym(&self) -> i32 {
        self.var_serializer_sym.unwrap_or(0)
    }

    pub fn clear_var_serializer_sym(&mut self) {
        self.var_serializer_sym = ::std::option::Option::None;
    }

    pub fn has_var_serializer_sym(&self) -> bool {
        self.var_serializer_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_serializer_sym(&mut self, v: i32) {
        self.var_serializer_sym = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for ProtoFlattenedSerializerField_t {
    const NAME: &'static str = "ProtoFlattenedSerializerField_t";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.var_type_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.var_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.bit_count = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.low_value = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.high_value = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.encode_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.field_serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.field_serializer_version = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.send_node_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.var_encoder_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                90 => {
                    self.polymorphic_types.push(is.read_message()?);
                },
                96 => {
                    self.var_serializer_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.var_type_sym {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.var_name_sym {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.bit_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.low_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.high_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.encode_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.field_serializer_name_sym {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.field_serializer_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.send_node_sym {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.var_encoder_sym {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        for value in &self.polymorphic_types {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.var_serializer_sym {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.var_type_sym {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.var_name_sym {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.bit_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.low_value {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.high_value {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.encode_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.field_serializer_name_sym {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.field_serializer_version {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.send_node_sym {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.var_encoder_sym {
            os.write_int32(10, v)?;
        }
        for v in &self.polymorphic_types {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.var_serializer_sym {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoFlattenedSerializerField_t {
        ProtoFlattenedSerializerField_t::new()
    }

    fn clear(&mut self) {
        self.var_type_sym = ::std::option::Option::None;
        self.var_name_sym = ::std::option::Option::None;
        self.bit_count = ::std::option::Option::None;
        self.low_value = ::std::option::Option::None;
        self.high_value = ::std::option::Option::None;
        self.encode_flags = ::std::option::Option::None;
        self.field_serializer_name_sym = ::std::option::Option::None;
        self.field_serializer_version = ::std::option::Option::None;
        self.send_node_sym = ::std::option::Option::None;
        self.var_encoder_sym = ::std::option::Option::None;
        self.polymorphic_types.clear();
        self.var_serializer_sym = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoFlattenedSerializerField_t {
        static instance: ProtoFlattenedSerializerField_t = ProtoFlattenedSerializerField_t {
            var_type_sym: ::std::option::Option::None,
            var_name_sym: ::std::option::Option::None,
            bit_count: ::std::option::Option::None,
            low_value: ::std::option::Option::None,
            high_value: ::std::option::Option::None,
            encode_flags: ::std::option::Option::None,
            field_serializer_name_sym: ::std::option::Option::None,
            field_serializer_version: ::std::option::Option::None,
            send_node_sym: ::std::option::Option::None,
            var_encoder_sym: ::std::option::Option::None,
            polymorphic_types: ::std::vec::Vec::new(),
            var_serializer_sym: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ProtoFlattenedSerializerField_t`
pub mod proto_flattened_serializer_field_t {
    // @@protoc_insertion_point(message:ProtoFlattenedSerializerField_t.polymorphic_field_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Polymorphic_field_t {
        // message fields
        // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_field_t.polymorphic_field_serializer_name_sym)
        pub polymorphic_field_serializer_name_sym: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_field_t.polymorphic_field_serializer_version)
        pub polymorphic_field_serializer_version: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:ProtoFlattenedSerializerField_t.polymorphic_field_t.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Polymorphic_field_t {
        fn default() -> &'a Polymorphic_field_t {
            <Polymorphic_field_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Polymorphic_field_t {
        pub fn new() -> Polymorphic_field_t {
            ::std::default::Default::default()
        }

        // optional int32 polymorphic_field_serializer_name_sym = 1;

        pub fn polymorphic_field_serializer_name_sym(&self) -> i32 {
            self.polymorphic_field_serializer_name_sym.unwrap_or(0)
        }

        pub fn clear_polymorphic_field_serializer_name_sym(&mut self) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::None;
        }

        pub fn has_polymorphic_field_serializer_name_sym(&self) -> bool {
            self.polymorphic_field_serializer_name_sym.is_some()
        }

        // Param is passed by value, moved
        pub fn set_polymorphic_field_serializer_name_sym(&mut self, v: i32) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::Some(v);
        }

        // optional int32 polymorphic_field_serializer_version = 2;

        pub fn polymorphic_field_serializer_version(&self) -> i32 {
            self.polymorphic_field_serializer_version.unwrap_or(0)
        }

        pub fn clear_polymorphic_field_serializer_version(&mut self) {
            self.polymorphic_field_serializer_version = ::std::option::Option::None;
        }

        pub fn has_polymorphic_field_serializer_version(&self) -> bool {
            self.polymorphic_field_serializer_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_polymorphic_field_serializer_version(&mut self, v: i32) {
            self.polymorphic_field_serializer_version = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Polymorphic_field_t {
        const NAME: &'static str = "polymorphic_field_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.polymorphic_field_serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.polymorphic_field_serializer_version = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.polymorphic_field_serializer_name_sym {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.polymorphic_field_serializer_version {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.polymorphic_field_serializer_name_sym {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.polymorphic_field_serializer_version {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Polymorphic_field_t {
            Polymorphic_field_t::new()
        }

        fn clear(&mut self) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::None;
            self.polymorphic_field_serializer_version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Polymorphic_field_t {
            static instance: Polymorphic_field_t = Polymorphic_field_t {
                polymorphic_field_serializer_name_sym: ::std::option::Option::None,
                polymorphic_field_serializer_version: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:ProtoFlattenedSerializer_t)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoFlattenedSerializer_t {
    // message fields
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.serializer_name_sym)
    pub serializer_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.serializer_version)
    pub serializer_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.fields_index)
    pub fields_index: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoFlattenedSerializer_t.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoFlattenedSerializer_t {
    fn default() -> &'a ProtoFlattenedSerializer_t {
        <ProtoFlattenedSerializer_t as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl ProtoFlattenedSerializer_t {
    pub fn new() -> ProtoFlattenedSerializer_t {
        ::std::default::Default::default()
    }

    // optional int32 serializer_name_sym = 1;

    pub fn serializer_name_sym(&self) -> i32 {
        self.serializer_name_sym.unwrap_or(0)
    }

    pub fn clear_serializer_name_sym(&mut self) {
        self.serializer_name_sym = ::std::option::Option::None;
    }

    pub fn has_serializer_name_sym(&self) -> bool {
        self.serializer_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serializer_name_sym(&mut self, v: i32) {
        self.serializer_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 serializer_version = 2;

    pub fn serializer_version(&self) -> i32 {
        self.serializer_version.unwrap_or(0)
    }

    pub fn clear_serializer_version(&mut self) {
        self.serializer_version = ::std::option::Option::None;
    }

    pub fn has_serializer_version(&self) -> bool {
        self.serializer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serializer_version(&mut self, v: i32) {
        self.serializer_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for ProtoFlattenedSerializer_t {
    const NAME: &'static str = "ProtoFlattenedSerializer_t";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.serializer_version = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.fields_index)?;
                },
                24 => {
                    self.fields_index.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serializer_name_sym {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.serializer_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.fields_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.serializer_name_sym {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.serializer_version {
            os.write_int32(2, v)?;
        }
        for v in &self.fields_index {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoFlattenedSerializer_t {
        ProtoFlattenedSerializer_t::new()
    }

    fn clear(&mut self) {
        self.serializer_name_sym = ::std::option::Option::None;
        self.serializer_version = ::std::option::Option::None;
        self.fields_index.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoFlattenedSerializer_t {
        static instance: ProtoFlattenedSerializer_t = ProtoFlattenedSerializer_t {
            serializer_name_sym: ::std::option::Option::None,
            serializer_version: ::std::option::Option::None,
            fields_index: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_FlattenedSerializer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FlattenedSerializer {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.serializers)
    pub serializers: ::std::vec::Vec<ProtoFlattenedSerializer_t>,
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.symbols)
    pub symbols: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.fields)
    pub fields: ::std::vec::Vec<ProtoFlattenedSerializerField_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FlattenedSerializer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FlattenedSerializer {
    fn default() -> &'a CSVCMsg_FlattenedSerializer {
        <CSVCMsg_FlattenedSerializer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FlattenedSerializer {
    pub fn new() -> CSVCMsg_FlattenedSerializer {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_FlattenedSerializer {
    const NAME: &'static str = "CSVCMsg_FlattenedSerializer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serializers.push(is.read_message()?);
                },
                18 => {
                    self.symbols.push(is.read_string()?);
                },
                26 => {
                    self.fields.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.serializers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.symbols {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &value);
        };
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.serializers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.symbols {
            os.write_string(2, &v)?;
        };
        for v in &self.fields {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FlattenedSerializer {
        CSVCMsg_FlattenedSerializer::new()
    }

    fn clear(&mut self) {
        self.serializers.clear();
        self.symbols.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FlattenedSerializer {
        static instance: CSVCMsg_FlattenedSerializer = CSVCMsg_FlattenedSerializer {
            serializers: ::std::vec::Vec::new(),
            symbols: ::std::vec::Vec::new(),
            fields: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_StopSound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_StopSound {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_StopSound.guid)
    pub guid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_StopSound.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_StopSound {
    fn default() -> &'a CSVCMsg_StopSound {
        <CSVCMsg_StopSound as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_StopSound {
    pub fn new() -> CSVCMsg_StopSound {
        ::std::default::Default::default()
    }

    // optional fixed32 guid = 1;

    pub fn guid(&self) -> u32 {
        self.guid.unwrap_or(0)
    }

    pub fn clear_guid(&mut self) {
        self.guid = ::std::option::Option::None;
    }

    pub fn has_guid(&self) -> bool {
        self.guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid(&mut self, v: u32) {
        self.guid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_StopSound {
    const NAME: &'static str = "CSVCMsg_StopSound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.guid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guid {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guid {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_StopSound {
        CSVCMsg_StopSound::new()
    }

    fn clear(&mut self) {
        self.guid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_StopSound {
        static instance: CSVCMsg_StopSound = CSVCMsg_StopSound {
            guid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBidirMsg_RebroadcastGameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBidirMsg_RebroadcastGameEvent {
    // message fields
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.posttoserver)
    pub posttoserver: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.buftype)
    pub buftype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.clientbitcount)
    pub clientbitcount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.receivingclients)
    pub receivingclients: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBidirMsg_RebroadcastGameEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBidirMsg_RebroadcastGameEvent {
    fn default() -> &'a CBidirMsg_RebroadcastGameEvent {
        <CBidirMsg_RebroadcastGameEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CBidirMsg_RebroadcastGameEvent {
    pub fn new() -> CBidirMsg_RebroadcastGameEvent {
        ::std::default::Default::default()
    }

    // optional bool posttoserver = 1;

    pub fn posttoserver(&self) -> bool {
        self.posttoserver.unwrap_or(false)
    }

    pub fn clear_posttoserver(&mut self) {
        self.posttoserver = ::std::option::Option::None;
    }

    pub fn has_posttoserver(&self) -> bool {
        self.posttoserver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttoserver(&mut self, v: bool) {
        self.posttoserver = ::std::option::Option::Some(v);
    }

    // optional int32 buftype = 2;

    pub fn buftype(&self) -> i32 {
        self.buftype.unwrap_or(0)
    }

    pub fn clear_buftype(&mut self) {
        self.buftype = ::std::option::Option::None;
    }

    pub fn has_buftype(&self) -> bool {
        self.buftype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buftype(&mut self, v: i32) {
        self.buftype = ::std::option::Option::Some(v);
    }

    // optional uint32 clientbitcount = 3;

    pub fn clientbitcount(&self) -> u32 {
        self.clientbitcount.unwrap_or(0)
    }

    pub fn clear_clientbitcount(&mut self) {
        self.clientbitcount = ::std::option::Option::None;
    }

    pub fn has_clientbitcount(&self) -> bool {
        self.clientbitcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientbitcount(&mut self, v: u32) {
        self.clientbitcount = ::std::option::Option::Some(v);
    }

    // optional uint64 receivingclients = 4;

    pub fn receivingclients(&self) -> u64 {
        self.receivingclients.unwrap_or(0)
    }

    pub fn clear_receivingclients(&mut self) {
        self.receivingclients = ::std::option::Option::None;
    }

    pub fn has_receivingclients(&self) -> bool {
        self.receivingclients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receivingclients(&mut self, v: u64) {
        self.receivingclients = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CBidirMsg_RebroadcastGameEvent {
    const NAME: &'static str = "CBidirMsg_RebroadcastGameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.posttoserver = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.buftype = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.clientbitcount = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.receivingclients = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.posttoserver {
            my_size += 1 + 1;
        }
        if let Some(v) = self.buftype {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.clientbitcount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.receivingclients {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.posttoserver {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.buftype {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.clientbitcount {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.receivingclients {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBidirMsg_RebroadcastGameEvent {
        CBidirMsg_RebroadcastGameEvent::new()
    }

    fn clear(&mut self) {
        self.posttoserver = ::std::option::Option::None;
        self.buftype = ::std::option::Option::None;
        self.clientbitcount = ::std::option::Option::None;
        self.receivingclients = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBidirMsg_RebroadcastGameEvent {
        static instance: CBidirMsg_RebroadcastGameEvent = CBidirMsg_RebroadcastGameEvent {
            posttoserver: ::std::option::Option::None,
            buftype: ::std::option::Option::None,
            clientbitcount: ::std::option::Option::None,
            receivingclients: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CBidirMsg_RebroadcastSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBidirMsg_RebroadcastSource {
    // message fields
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastSource.eventsource)
    pub eventsource: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBidirMsg_RebroadcastSource.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBidirMsg_RebroadcastSource {
    fn default() -> &'a CBidirMsg_RebroadcastSource {
        <CBidirMsg_RebroadcastSource as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CBidirMsg_RebroadcastSource {
    pub fn new() -> CBidirMsg_RebroadcastSource {
        ::std::default::Default::default()
    }

    // optional int32 eventsource = 1;

    pub fn eventsource(&self) -> i32 {
        self.eventsource.unwrap_or(0)
    }

    pub fn clear_eventsource(&mut self) {
        self.eventsource = ::std::option::Option::None;
    }

    pub fn has_eventsource(&self) -> bool {
        self.eventsource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsource(&mut self, v: i32) {
        self.eventsource = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CBidirMsg_RebroadcastSource {
    const NAME: &'static str = "CBidirMsg_RebroadcastSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventsource = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventsource {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eventsource {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBidirMsg_RebroadcastSource {
        CBidirMsg_RebroadcastSource::new()
    }

    fn clear(&mut self) {
        self.eventsource = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBidirMsg_RebroadcastSource {
        static instance: CBidirMsg_RebroadcastSource = CBidirMsg_RebroadcastSource {
            eventsource: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerNetworkStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerNetworkStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.dedicated)
    pub dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.cpu_usage)
    pub cpu_usage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.memory_used_mb)
    pub memory_used_mb: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.memory_free_mb)
    pub memory_free_mb: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.uptime)
    pub uptime: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.spawn_count)
    pub spawn_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_clients)
    pub num_clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_bots)
    pub num_bots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_spectators)
    pub num_spectators: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_tv_relays)
    pub num_tv_relays: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.fps)
    pub fps: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.ports)
    pub ports: ::std::vec::Vec<cmsg_server_network_stats::Port>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_ping_ms)
    pub avg_ping_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_engine_latency_out)
    pub avg_engine_latency_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_packets_out)
    pub avg_packets_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_packets_in)
    pub avg_packets_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_loss_out)
    pub avg_loss_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_loss_in)
    pub avg_loss_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_data_out)
    pub avg_data_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_data_in)
    pub avg_data_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_data_in)
    pub total_data_in: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_packets_in)
    pub total_packets_in: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_data_out)
    pub total_data_out: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_packets_out)
    pub total_packets_out: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.players)
    pub players: ::std::vec::Vec<cmsg_server_network_stats::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerNetworkStats {
    fn default() -> &'a CMsgServerNetworkStats {
        <CMsgServerNetworkStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerNetworkStats {
    pub fn new() -> CMsgServerNetworkStats {
        ::std::default::Default::default()
    }

    // optional bool dedicated = 1;

    pub fn dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }

    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional int32 cpu_usage = 2;

    pub fn cpu_usage(&self) -> i32 {
        self.cpu_usage.unwrap_or(0)
    }

    pub fn clear_cpu_usage(&mut self) {
        self.cpu_usage = ::std::option::Option::None;
    }

    pub fn has_cpu_usage(&self) -> bool {
        self.cpu_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_usage(&mut self, v: i32) {
        self.cpu_usage = ::std::option::Option::Some(v);
    }

    // optional int32 memory_used_mb = 3;

    pub fn memory_used_mb(&self) -> i32 {
        self.memory_used_mb.unwrap_or(0)
    }

    pub fn clear_memory_used_mb(&mut self) {
        self.memory_used_mb = ::std::option::Option::None;
    }

    pub fn has_memory_used_mb(&self) -> bool {
        self.memory_used_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_used_mb(&mut self, v: i32) {
        self.memory_used_mb = ::std::option::Option::Some(v);
    }

    // optional int32 memory_free_mb = 4;

    pub fn memory_free_mb(&self) -> i32 {
        self.memory_free_mb.unwrap_or(0)
    }

    pub fn clear_memory_free_mb(&mut self) {
        self.memory_free_mb = ::std::option::Option::None;
    }

    pub fn has_memory_free_mb(&self) -> bool {
        self.memory_free_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_free_mb(&mut self, v: i32) {
        self.memory_free_mb = ::std::option::Option::Some(v);
    }

    // optional int32 uptime = 5;

    pub fn uptime(&self) -> i32 {
        self.uptime.unwrap_or(0)
    }

    pub fn clear_uptime(&mut self) {
        self.uptime = ::std::option::Option::None;
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: i32) {
        self.uptime = ::std::option::Option::Some(v);
    }

    // optional int32 spawn_count = 6;

    pub fn spawn_count(&self) -> i32 {
        self.spawn_count.unwrap_or(0)
    }

    pub fn clear_spawn_count(&mut self) {
        self.spawn_count = ::std::option::Option::None;
    }

    pub fn has_spawn_count(&self) -> bool {
        self.spawn_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_count(&mut self, v: i32) {
        self.spawn_count = ::std::option::Option::Some(v);
    }

    // optional int32 num_clients = 8;

    pub fn num_clients(&self) -> i32 {
        self.num_clients.unwrap_or(0)
    }

    pub fn clear_num_clients(&mut self) {
        self.num_clients = ::std::option::Option::None;
    }

    pub fn has_num_clients(&self) -> bool {
        self.num_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_clients(&mut self, v: i32) {
        self.num_clients = ::std::option::Option::Some(v);
    }

    // optional int32 num_bots = 9;

    pub fn num_bots(&self) -> i32 {
        self.num_bots.unwrap_or(0)
    }

    pub fn clear_num_bots(&mut self) {
        self.num_bots = ::std::option::Option::None;
    }

    pub fn has_num_bots(&self) -> bool {
        self.num_bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bots(&mut self, v: i32) {
        self.num_bots = ::std::option::Option::Some(v);
    }

    // optional int32 num_spectators = 10;

    pub fn num_spectators(&self) -> i32 {
        self.num_spectators.unwrap_or(0)
    }

    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: i32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional int32 num_tv_relays = 11;

    pub fn num_tv_relays(&self) -> i32 {
        self.num_tv_relays.unwrap_or(0)
    }

    pub fn clear_num_tv_relays(&mut self) {
        self.num_tv_relays = ::std::option::Option::None;
    }

    pub fn has_num_tv_relays(&self) -> bool {
        self.num_tv_relays.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_tv_relays(&mut self, v: i32) {
        self.num_tv_relays = ::std::option::Option::Some(v);
    }

    // optional float fps = 12;

    pub fn fps(&self) -> f32 {
        self.fps.unwrap_or(0.)
    }

    pub fn clear_fps(&mut self) {
        self.fps = ::std::option::Option::None;
    }

    pub fn has_fps(&self) -> bool {
        self.fps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: f32) {
        self.fps = ::std::option::Option::Some(v);
    }

    // optional float avg_ping_ms = 18;

    pub fn avg_ping_ms(&self) -> f32 {
        self.avg_ping_ms.unwrap_or(0.)
    }

    pub fn clear_avg_ping_ms(&mut self) {
        self.avg_ping_ms = ::std::option::Option::None;
    }

    pub fn has_avg_ping_ms(&self) -> bool {
        self.avg_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_ping_ms(&mut self, v: f32) {
        self.avg_ping_ms = ::std::option::Option::Some(v);
    }

    // optional float avg_engine_latency_out = 19;

    pub fn avg_engine_latency_out(&self) -> f32 {
        self.avg_engine_latency_out.unwrap_or(0.)
    }

    pub fn clear_avg_engine_latency_out(&mut self) {
        self.avg_engine_latency_out = ::std::option::Option::None;
    }

    pub fn has_avg_engine_latency_out(&self) -> bool {
        self.avg_engine_latency_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_engine_latency_out(&mut self, v: f32) {
        self.avg_engine_latency_out = ::std::option::Option::Some(v);
    }

    // optional float avg_packets_out = 20;

    pub fn avg_packets_out(&self) -> f32 {
        self.avg_packets_out.unwrap_or(0.)
    }

    pub fn clear_avg_packets_out(&mut self) {
        self.avg_packets_out = ::std::option::Option::None;
    }

    pub fn has_avg_packets_out(&self) -> bool {
        self.avg_packets_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_packets_out(&mut self, v: f32) {
        self.avg_packets_out = ::std::option::Option::Some(v);
    }

    // optional float avg_packets_in = 21;

    pub fn avg_packets_in(&self) -> f32 {
        self.avg_packets_in.unwrap_or(0.)
    }

    pub fn clear_avg_packets_in(&mut self) {
        self.avg_packets_in = ::std::option::Option::None;
    }

    pub fn has_avg_packets_in(&self) -> bool {
        self.avg_packets_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_packets_in(&mut self, v: f32) {
        self.avg_packets_in = ::std::option::Option::Some(v);
    }

    // optional float avg_loss_out = 22;

    pub fn avg_loss_out(&self) -> f32 {
        self.avg_loss_out.unwrap_or(0.)
    }

    pub fn clear_avg_loss_out(&mut self) {
        self.avg_loss_out = ::std::option::Option::None;
    }

    pub fn has_avg_loss_out(&self) -> bool {
        self.avg_loss_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_loss_out(&mut self, v: f32) {
        self.avg_loss_out = ::std::option::Option::Some(v);
    }

    // optional float avg_loss_in = 23;

    pub fn avg_loss_in(&self) -> f32 {
        self.avg_loss_in.unwrap_or(0.)
    }

    pub fn clear_avg_loss_in(&mut self) {
        self.avg_loss_in = ::std::option::Option::None;
    }

    pub fn has_avg_loss_in(&self) -> bool {
        self.avg_loss_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_loss_in(&mut self, v: f32) {
        self.avg_loss_in = ::std::option::Option::Some(v);
    }

    // optional float avg_data_out = 24;

    pub fn avg_data_out(&self) -> f32 {
        self.avg_data_out.unwrap_or(0.)
    }

    pub fn clear_avg_data_out(&mut self) {
        self.avg_data_out = ::std::option::Option::None;
    }

    pub fn has_avg_data_out(&self) -> bool {
        self.avg_data_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_data_out(&mut self, v: f32) {
        self.avg_data_out = ::std::option::Option::Some(v);
    }

    // optional float avg_data_in = 25;

    pub fn avg_data_in(&self) -> f32 {
        self.avg_data_in.unwrap_or(0.)
    }

    pub fn clear_avg_data_in(&mut self) {
        self.avg_data_in = ::std::option::Option::None;
    }

    pub fn has_avg_data_in(&self) -> bool {
        self.avg_data_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_data_in(&mut self, v: f32) {
        self.avg_data_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_data_in = 26;

    pub fn total_data_in(&self) -> u64 {
        self.total_data_in.unwrap_or(0)
    }

    pub fn clear_total_data_in(&mut self) {
        self.total_data_in = ::std::option::Option::None;
    }

    pub fn has_total_data_in(&self) -> bool {
        self.total_data_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_data_in(&mut self, v: u64) {
        self.total_data_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_packets_in = 27;

    pub fn total_packets_in(&self) -> u64 {
        self.total_packets_in.unwrap_or(0)
    }

    pub fn clear_total_packets_in(&mut self) {
        self.total_packets_in = ::std::option::Option::None;
    }

    pub fn has_total_packets_in(&self) -> bool {
        self.total_packets_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_packets_in(&mut self, v: u64) {
        self.total_packets_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_data_out = 28;

    pub fn total_data_out(&self) -> u64 {
        self.total_data_out.unwrap_or(0)
    }

    pub fn clear_total_data_out(&mut self) {
        self.total_data_out = ::std::option::Option::None;
    }

    pub fn has_total_data_out(&self) -> bool {
        self.total_data_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_data_out(&mut self, v: u64) {
        self.total_data_out = ::std::option::Option::Some(v);
    }

    // optional uint64 total_packets_out = 29;

    pub fn total_packets_out(&self) -> u64 {
        self.total_packets_out.unwrap_or(0)
    }

    pub fn clear_total_packets_out(&mut self) {
        self.total_packets_out = ::std::option::Option::None;
    }

    pub fn has_total_packets_out(&self) -> bool {
        self.total_packets_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_packets_out(&mut self, v: u64) {
        self.total_packets_out = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerNetworkStats {
    const NAME: &'static str = "CMsgServerNetworkStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.cpu_usage = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.memory_used_mb = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.memory_free_mb = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.uptime = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.spawn_count = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.num_clients = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.num_bots = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.num_spectators = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.num_tv_relays = ::std::option::Option::Some(is.read_int32()?);
                },
                101 => {
                    self.fps = ::std::option::Option::Some(is.read_float()?);
                },
                138 => {
                    self.ports.push(is.read_message()?);
                },
                149 => {
                    self.avg_ping_ms = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.avg_engine_latency_out = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.avg_packets_out = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.avg_packets_in = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.avg_loss_out = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.avg_loss_in = ::std::option::Option::Some(is.read_float()?);
                },
                197 => {
                    self.avg_data_out = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.avg_data_in = ::std::option::Option::Some(is.read_float()?);
                },
                208 => {
                    self.total_data_in = ::std::option::Option::Some(is.read_uint64()?);
                },
                216 => {
                    self.total_packets_in = ::std::option::Option::Some(is.read_uint64()?);
                },
                224 => {
                    self.total_data_out = ::std::option::Option::Some(is.read_uint64()?);
                },
                232 => {
                    self.total_packets_out = ::std::option::Option::Some(is.read_uint64()?);
                },
                242 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cpu_usage {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.memory_used_mb {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.memory_free_mb {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.uptime {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.spawn_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.num_clients {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.num_bots {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.num_spectators {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.num_tv_relays {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.fps {
            my_size += 1 + 4;
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.avg_ping_ms {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_engine_latency_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_packets_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_packets_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_loss_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_loss_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_data_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_data_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.total_data_in {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(26, v);
        }
        if let Some(v) = self.total_packets_in {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(27, v);
        }
        if let Some(v) = self.total_data_out {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(28, v);
        }
        if let Some(v) = self.total_packets_out {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(29, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dedicated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.cpu_usage {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.memory_used_mb {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.memory_free_mb {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.uptime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.spawn_count {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.num_clients {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.num_bots {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.num_spectators {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.num_tv_relays {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.fps {
            os.write_float(12, v)?;
        }
        for v in &self.ports {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.avg_ping_ms {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.avg_engine_latency_out {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.avg_packets_out {
            os.write_float(20, v)?;
        }
        if let Some(v) = self.avg_packets_in {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.avg_loss_out {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.avg_loss_in {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.avg_data_out {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.avg_data_in {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.total_data_in {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.total_packets_in {
            os.write_uint64(27, v)?;
        }
        if let Some(v) = self.total_data_out {
            os.write_uint64(28, v)?;
        }
        if let Some(v) = self.total_packets_out {
            os.write_uint64(29, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerNetworkStats {
        CMsgServerNetworkStats::new()
    }

    fn clear(&mut self) {
        self.dedicated = ::std::option::Option::None;
        self.cpu_usage = ::std::option::Option::None;
        self.memory_used_mb = ::std::option::Option::None;
        self.memory_free_mb = ::std::option::Option::None;
        self.uptime = ::std::option::Option::None;
        self.spawn_count = ::std::option::Option::None;
        self.num_clients = ::std::option::Option::None;
        self.num_bots = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.num_tv_relays = ::std::option::Option::None;
        self.fps = ::std::option::Option::None;
        self.ports.clear();
        self.avg_ping_ms = ::std::option::Option::None;
        self.avg_engine_latency_out = ::std::option::Option::None;
        self.avg_packets_out = ::std::option::Option::None;
        self.avg_packets_in = ::std::option::Option::None;
        self.avg_loss_out = ::std::option::Option::None;
        self.avg_loss_in = ::std::option::Option::None;
        self.avg_data_out = ::std::option::Option::None;
        self.avg_data_in = ::std::option::Option::None;
        self.total_data_in = ::std::option::Option::None;
        self.total_packets_in = ::std::option::Option::None;
        self.total_data_out = ::std::option::Option::None;
        self.total_packets_out = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerNetworkStats {
        static instance: CMsgServerNetworkStats = CMsgServerNetworkStats {
            dedicated: ::std::option::Option::None,
            cpu_usage: ::std::option::Option::None,
            memory_used_mb: ::std::option::Option::None,
            memory_free_mb: ::std::option::Option::None,
            uptime: ::std::option::Option::None,
            spawn_count: ::std::option::Option::None,
            num_clients: ::std::option::Option::None,
            num_bots: ::std::option::Option::None,
            num_spectators: ::std::option::Option::None,
            num_tv_relays: ::std::option::Option::None,
            fps: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            avg_ping_ms: ::std::option::Option::None,
            avg_engine_latency_out: ::std::option::Option::None,
            avg_packets_out: ::std::option::Option::None,
            avg_packets_in: ::std::option::Option::None,
            avg_loss_out: ::std::option::Option::None,
            avg_loss_in: ::std::option::Option::None,
            avg_data_out: ::std::option::Option::None,
            avg_data_in: ::std::option::Option::None,
            total_data_in: ::std::option::Option::None,
            total_packets_in: ::std::option::Option::None,
            total_data_out: ::std::option::Option::None,
            total_packets_out: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerNetworkStats`
pub mod cmsg_server_network_stats {
    // @@protoc_insertion_point(message:CMsgServerNetworkStats.Port)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Port {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Port.port)
        pub port: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Port.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.Port.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Port {
        fn default() -> &'a Port {
            <Port as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Port {
        pub fn new() -> Port {
            ::std::default::Default::default()
        }

        // optional int32 port = 1;

        pub fn port(&self) -> i32 {
            self.port.unwrap_or(0)
        }

        pub fn clear_port(&mut self) {
            self.port = ::std::option::Option::None;
        }

        pub fn has_port(&self) -> bool {
            self.port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_port(&mut self, v: i32) {
            self.port = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Port {
        const NAME: &'static str = "Port";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.port = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.port {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.port {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Port {
            Port::new()
        }

        fn clear(&mut self) {
            self.port = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Port {
            static instance: Port = Port {
                port: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgServerNetworkStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.remote_addr)
        pub remote_addr: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.ping_avg_ms)
        pub ping_avg_ms: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.packet_loss_pct)
        pub packet_loss_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.is_bot)
        pub is_bot: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.loss_in)
        pub loss_in: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.loss_out)
        pub loss_out: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.engine_latency_ms)
        pub engine_latency_ms: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string remote_addr = 2;

        pub fn remote_addr(&self) -> &str {
            match self.remote_addr.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_remote_addr(&mut self) {
            self.remote_addr = ::std::option::Option::None;
        }

        pub fn has_remote_addr(&self) -> bool {
            self.remote_addr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remote_addr(&mut self, v: ::std::string::String) {
            self.remote_addr = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_remote_addr(&mut self) -> &mut ::std::string::String {
            if self.remote_addr.is_none() {
                self.remote_addr = ::std::option::Option::Some(::std::string::String::new());
            }
            self.remote_addr.as_mut().unwrap()
        }

        // Take field
        pub fn take_remote_addr(&mut self) -> ::std::string::String {
            self.remote_addr.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 ping_avg_ms = 4;

        pub fn ping_avg_ms(&self) -> i32 {
            self.ping_avg_ms.unwrap_or(0)
        }

        pub fn clear_ping_avg_ms(&mut self) {
            self.ping_avg_ms = ::std::option::Option::None;
        }

        pub fn has_ping_avg_ms(&self) -> bool {
            self.ping_avg_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_avg_ms(&mut self, v: i32) {
            self.ping_avg_ms = ::std::option::Option::Some(v);
        }

        // optional float packet_loss_pct = 5;

        pub fn packet_loss_pct(&self) -> f32 {
            self.packet_loss_pct.unwrap_or(0.)
        }

        pub fn clear_packet_loss_pct(&mut self) {
            self.packet_loss_pct = ::std::option::Option::None;
        }

        pub fn has_packet_loss_pct(&self) -> bool {
            self.packet_loss_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packet_loss_pct(&mut self, v: f32) {
            self.packet_loss_pct = ::std::option::Option::Some(v);
        }

        // optional bool is_bot = 6;

        pub fn is_bot(&self) -> bool {
            self.is_bot.unwrap_or(false)
        }

        pub fn clear_is_bot(&mut self) {
            self.is_bot = ::std::option::Option::None;
        }

        pub fn has_is_bot(&self) -> bool {
            self.is_bot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_bot(&mut self, v: bool) {
            self.is_bot = ::std::option::Option::Some(v);
        }

        // optional float loss_in = 7;

        pub fn loss_in(&self) -> f32 {
            self.loss_in.unwrap_or(0.)
        }

        pub fn clear_loss_in(&mut self) {
            self.loss_in = ::std::option::Option::None;
        }

        pub fn has_loss_in(&self) -> bool {
            self.loss_in.is_some()
        }

        // Param is passed by value, moved
        pub fn set_loss_in(&mut self, v: f32) {
            self.loss_in = ::std::option::Option::Some(v);
        }

        // optional float loss_out = 8;

        pub fn loss_out(&self) -> f32 {
            self.loss_out.unwrap_or(0.)
        }

        pub fn clear_loss_out(&mut self) {
            self.loss_out = ::std::option::Option::None;
        }

        pub fn has_loss_out(&self) -> bool {
            self.loss_out.is_some()
        }

        // Param is passed by value, moved
        pub fn set_loss_out(&mut self, v: f32) {
            self.loss_out = ::std::option::Option::Some(v);
        }

        // optional int32 engine_latency_ms = 9;

        pub fn engine_latency_ms(&self) -> i32 {
            self.engine_latency_ms.unwrap_or(0)
        }

        pub fn clear_engine_latency_ms(&mut self) {
            self.engine_latency_ms = ::std::option::Option::None;
        }

        pub fn has_engine_latency_ms(&self) -> bool {
            self.engine_latency_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_engine_latency_ms(&mut self, v: i32) {
            self.engine_latency_ms = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.remote_addr = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.ping_avg_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.packet_loss_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.is_bot = ::std::option::Option::Some(is.read_bool()?);
                    },
                    61 => {
                        self.loss_in = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.loss_out = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.engine_latency_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.remote_addr.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.ping_avg_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.packet_loss_pct {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_bot {
                my_size += 1 + 1;
            }
            if let Some(v) = self.loss_in {
                my_size += 1 + 4;
            }
            if let Some(v) = self.loss_out {
                my_size += 1 + 4;
            }
            if let Some(v) = self.engine_latency_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.remote_addr.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.ping_avg_ms {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.packet_loss_pct {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.is_bot {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.loss_in {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.loss_out {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.engine_latency_ms {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.remote_addr = ::std::option::Option::None;
            self.ping_avg_ms = ::std::option::Option::None;
            self.packet_loss_pct = ::std::option::Option::None;
            self.is_bot = ::std::option::Option::None;
            self.loss_in = ::std::option::Option::None;
            self.loss_out = ::std::option::Option::None;
            self.engine_latency_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steamid: ::std::option::Option::None,
                remote_addr: ::std::option::Option::None,
                ping_avg_ms: ::std::option::Option::None,
                packet_loss_pct: ::std::option::Option::None,
                is_bot: ::std::option::Option::None,
                loss_in: ::std::option::Option::None,
                loss_out: ::std::option::Option::None,
                engine_latency_ms: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSVCMsg_HltvReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.delay)
    pub delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.primary_target)
    pub primary_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_stop_at)
    pub replay_stop_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_start_at)
    pub replay_start_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_begin)
    pub replay_slowdown_begin: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_end)
    pub replay_slowdown_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_rate)
    pub replay_slowdown_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HltvReplay.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HltvReplay {
    fn default() -> &'a CSVCMsg_HltvReplay {
        <CSVCMsg_HltvReplay as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HltvReplay {
    pub fn new() -> CSVCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 delay = 1;

    pub fn delay(&self) -> i32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: i32) {
        self.delay = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target = 2;

    pub fn primary_target(&self) -> i32 {
        self.primary_target.unwrap_or(-1i32)
    }

    pub fn clear_primary_target(&mut self) {
        self.primary_target = ::std::option::Option::None;
    }

    pub fn has_primary_target(&self) -> bool {
        self.primary_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target(&mut self, v: i32) {
        self.primary_target = ::std::option::Option::Some(v);
    }

    // optional int32 replay_stop_at = 3;

    pub fn replay_stop_at(&self) -> i32 {
        self.replay_stop_at.unwrap_or(0)
    }

    pub fn clear_replay_stop_at(&mut self) {
        self.replay_stop_at = ::std::option::Option::None;
    }

    pub fn has_replay_stop_at(&self) -> bool {
        self.replay_stop_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_stop_at(&mut self, v: i32) {
        self.replay_stop_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_start_at = 4;

    pub fn replay_start_at(&self) -> i32 {
        self.replay_start_at.unwrap_or(0)
    }

    pub fn clear_replay_start_at(&mut self) {
        self.replay_start_at = ::std::option::Option::None;
    }

    pub fn has_replay_start_at(&self) -> bool {
        self.replay_start_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_start_at(&mut self, v: i32) {
        self.replay_start_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_begin = 5;

    pub fn replay_slowdown_begin(&self) -> i32 {
        self.replay_slowdown_begin.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_begin(&mut self) {
        self.replay_slowdown_begin = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_begin(&self) -> bool {
        self.replay_slowdown_begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_begin(&mut self, v: i32) {
        self.replay_slowdown_begin = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_end = 6;

    pub fn replay_slowdown_end(&self) -> i32 {
        self.replay_slowdown_end.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_end(&mut self) {
        self.replay_slowdown_end = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_end(&self) -> bool {
        self.replay_slowdown_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_end(&mut self, v: i32) {
        self.replay_slowdown_end = ::std::option::Option::Some(v);
    }

    // optional float replay_slowdown_rate = 7;

    pub fn replay_slowdown_rate(&self) -> f32 {
        self.replay_slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_replay_slowdown_rate(&mut self) {
        self.replay_slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_rate(&self) -> bool {
        self.replay_slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_rate(&mut self, v: f32) {
        self.replay_slowdown_rate = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 8;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_HltvReplay {
    const NAME: &'static str = "CSVCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.delay = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.primary_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.replay_stop_at = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.replay_start_at = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.replay_slowdown_begin = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.replay_slowdown_end = ::std::option::Option::Some(is.read_int32()?);
                },
                61 => {
                    self.replay_slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delay {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.primary_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.replay_stop_at {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.replay_start_at {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.replay_slowdown_begin {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.replay_slowdown_end {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.replay_slowdown_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.delay {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.primary_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.replay_stop_at {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.replay_start_at {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.replay_slowdown_begin {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.replay_slowdown_end {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.replay_slowdown_rate {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HltvReplay {
        CSVCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.delay = ::std::option::Option::None;
        self.primary_target = ::std::option::Option::None;
        self.replay_stop_at = ::std::option::Option::None;
        self.replay_start_at = ::std::option::Option::None;
        self.replay_slowdown_begin = ::std::option::Option::None;
        self.replay_slowdown_end = ::std::option::Option::None;
        self.replay_slowdown_rate = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HltvReplay {
        static instance: CSVCMsg_HltvReplay = CSVCMsg_HltvReplay {
            delay: ::std::option::Option::None,
            primary_target: ::std::option::Option::None,
            replay_stop_at: ::std::option::Option::None,
            replay_start_at: ::std::option::Option::None,
            replay_slowdown_begin: ::std::option::Option::None,
            replay_slowdown_end: ::std::option::Option::None,
            replay_slowdown_rate: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_HltvReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.request)
    pub request: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_length)
    pub slowdown_length: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_rate)
    pub slowdown_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.primary_target)
    pub primary_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.event_time)
    pub event_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_HltvReplay.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_HltvReplay {
    fn default() -> &'a CCLCMsg_HltvReplay {
        <CCLCMsg_HltvReplay as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_HltvReplay {
    pub fn new() -> CCLCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 request = 1;

    pub fn request(&self) -> i32 {
        self.request.unwrap_or(0)
    }

    pub fn clear_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: i32) {
        self.request = ::std::option::Option::Some(v);
    }

    // optional float slowdown_length = 2;

    pub fn slowdown_length(&self) -> f32 {
        self.slowdown_length.unwrap_or(0.)
    }

    pub fn clear_slowdown_length(&mut self) {
        self.slowdown_length = ::std::option::Option::None;
    }

    pub fn has_slowdown_length(&self) -> bool {
        self.slowdown_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_length(&mut self, v: f32) {
        self.slowdown_length = ::std::option::Option::Some(v);
    }

    // optional float slowdown_rate = 3;

    pub fn slowdown_rate(&self) -> f32 {
        self.slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_slowdown_rate(&mut self) {
        self.slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_slowdown_rate(&self) -> bool {
        self.slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_rate(&mut self, v: f32) {
        self.slowdown_rate = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target = 4;

    pub fn primary_target(&self) -> i32 {
        self.primary_target.unwrap_or(-1i32)
    }

    pub fn clear_primary_target(&mut self) {
        self.primary_target = ::std::option::Option::None;
    }

    pub fn has_primary_target(&self) -> bool {
        self.primary_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target(&mut self, v: i32) {
        self.primary_target = ::std::option::Option::Some(v);
    }

    // optional float event_time = 5;

    pub fn event_time(&self) -> f32 {
        self.event_time.unwrap_or(0.)
    }

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: f32) {
        self.event_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_HltvReplay {
    const NAME: &'static str = "CCLCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.slowdown_length = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.primary_target = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.event_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slowdown_length {
            my_size += 1 + 4;
        }
        if let Some(v) = self.slowdown_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.primary_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.event_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.request {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slowdown_length {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.slowdown_rate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.primary_target {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_HltvReplay {
        CCLCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.slowdown_length = ::std::option::Option::None;
        self.slowdown_rate = ::std::option::Option::None;
        self.primary_target = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_HltvReplay {
        static instance: CCLCMsg_HltvReplay = CCLCMsg_HltvReplay {
            request: ::std::option::Option::None,
            slowdown_length: ::std::option::Option::None,
            slowdown_rate: ::std::option::Option::None,
            primary_target: ::std::option::Option::None,
            event_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_Broadcast_Command)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Broadcast_Command {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Broadcast_Command.cmd)
    pub cmd: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Broadcast_Command.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Broadcast_Command {
    fn default() -> &'a CSVCMsg_Broadcast_Command {
        <CSVCMsg_Broadcast_Command as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Broadcast_Command {
    pub fn new() -> CSVCMsg_Broadcast_Command {
        ::std::default::Default::default()
    }

    // optional string cmd = 1;

    pub fn cmd(&self) -> &str {
        match self.cmd.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::std::string::String) {
        self.cmd = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut ::std::string::String {
        if self.cmd.is_none() {
            self.cmd = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::std::string::String {
        self.cmd.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_Broadcast_Command {
    const NAME: &'static str = "CSVCMsg_Broadcast_Command";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cmd = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmd.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cmd.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Broadcast_Command {
        CSVCMsg_Broadcast_Command::new()
    }

    fn clear(&mut self) {
        self.cmd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Broadcast_Command {
        static instance: CSVCMsg_Broadcast_Command = CSVCMsg_Broadcast_Command {
            cmd: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCLCMsg_HltvFixupOperatorTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_HltvFixupOperatorTick {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.props_data)
    pub props_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.eye_angles)
    pub eye_angles: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.observer_mode)
    pub observer_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.cameraman_scoreboard)
    pub cameraman_scoreboard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.observer_target)
    pub observer_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.view_offset)
    pub view_offset: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_HltvFixupOperatorTick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_HltvFixupOperatorTick {
    fn default() -> &'a CCLCMsg_HltvFixupOperatorTick {
        <CCLCMsg_HltvFixupOperatorTick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_HltvFixupOperatorTick {
    pub fn new() -> CCLCMsg_HltvFixupOperatorTick {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional bytes props_data = 2;

    pub fn props_data(&self) -> &[u8] {
        match self.props_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_props_data(&mut self) {
        self.props_data = ::std::option::Option::None;
    }

    pub fn has_props_data(&self) -> bool {
        self.props_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_props_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.props_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_props_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.props_data.is_none() {
            self.props_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.props_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_props_data(&mut self) -> ::std::vec::Vec<u8> {
        self.props_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 observer_mode = 5;

    pub fn observer_mode(&self) -> i32 {
        self.observer_mode.unwrap_or(0)
    }

    pub fn clear_observer_mode(&mut self) {
        self.observer_mode = ::std::option::Option::None;
    }

    pub fn has_observer_mode(&self) -> bool {
        self.observer_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_mode(&mut self, v: i32) {
        self.observer_mode = ::std::option::Option::Some(v);
    }

    // optional bool cameraman_scoreboard = 6;

    pub fn cameraman_scoreboard(&self) -> bool {
        self.cameraman_scoreboard.unwrap_or(false)
    }

    pub fn clear_cameraman_scoreboard(&mut self) {
        self.cameraman_scoreboard = ::std::option::Option::None;
    }

    pub fn has_cameraman_scoreboard(&self) -> bool {
        self.cameraman_scoreboard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cameraman_scoreboard(&mut self, v: bool) {
        self.cameraman_scoreboard = ::std::option::Option::Some(v);
    }

    // optional int32 observer_target = 7;

    pub fn observer_target(&self) -> i32 {
        self.observer_target.unwrap_or(0)
    }

    pub fn clear_observer_target(&mut self) {
        self.observer_target = ::std::option::Option::None;
    }

    pub fn has_observer_target(&self) -> bool {
        self.observer_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_target(&mut self, v: i32) {
        self.observer_target = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCLCMsg_HltvFixupOperatorTick {
    const NAME: &'static str = "CCLCMsg_HltvFixupOperatorTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.props_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.eye_angles)?;
                },
                40 => {
                    self.observer_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.cameraman_scoreboard = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.observer_target = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.view_offset)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.props_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eye_angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.observer_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.cameraman_scoreboard {
            my_size += 1 + 1;
        }
        if let Some(v) = self.observer_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.view_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.props_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.eye_angles.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.observer_mode {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cameraman_scoreboard {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.observer_target {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.view_offset.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_HltvFixupOperatorTick {
        CCLCMsg_HltvFixupOperatorTick::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.props_data = ::std::option::Option::None;
        self.origin.clear();
        self.eye_angles.clear();
        self.observer_mode = ::std::option::Option::None;
        self.cameraman_scoreboard = ::std::option::Option::None;
        self.observer_target = ::std::option::Option::None;
        self.view_offset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_HltvFixupOperatorTick {
        static instance: CCLCMsg_HltvFixupOperatorTick = CCLCMsg_HltvFixupOperatorTick {
            tick: ::std::option::Option::None,
            props_data: ::std::option::Option::None,
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            eye_angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
            observer_mode: ::std::option::Option::None,
            cameraman_scoreboard: ::std::option::Option::None,
            observer_target: ::std::option::Option::None,
            view_offset: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_HltvFixupOperatorStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HltvFixupOperatorStatus {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HltvFixupOperatorStatus.mode)
    pub mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvFixupOperatorStatus.override_operator_name)
    pub override_operator_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HltvFixupOperatorStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HltvFixupOperatorStatus {
    fn default() -> &'a CSVCMsg_HltvFixupOperatorStatus {
        <CSVCMsg_HltvFixupOperatorStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HltvFixupOperatorStatus {
    pub fn new() -> CSVCMsg_HltvFixupOperatorStatus {
        ::std::default::Default::default()
    }

    // optional uint32 mode = 1;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional string override_operator_name = 2;

    pub fn override_operator_name(&self) -> &str {
        match self.override_operator_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_override_operator_name(&mut self) {
        self.override_operator_name = ::std::option::Option::None;
    }

    pub fn has_override_operator_name(&self) -> bool {
        self.override_operator_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_operator_name(&mut self, v: ::std::string::String) {
        self.override_operator_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_override_operator_name(&mut self) -> &mut ::std::string::String {
        if self.override_operator_name.is_none() {
            self.override_operator_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.override_operator_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_override_operator_name(&mut self) -> ::std::string::String {
        self.override_operator_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_HltvFixupOperatorStatus {
    const NAME: &'static str = "CSVCMsg_HltvFixupOperatorStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.override_operator_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.override_operator_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.override_operator_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HltvFixupOperatorStatus {
        CSVCMsg_HltvFixupOperatorStatus::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.override_operator_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HltvFixupOperatorStatus {
        static instance: CSVCMsg_HltvFixupOperatorStatus = CSVCMsg_HltvFixupOperatorStatus {
            mode: ::std::option::Option::None,
            override_operator_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerUserCmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerUserCmd {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerUserCmd.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgServerUserCmd.cmd_number)
    pub cmd_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerUserCmd.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerUserCmd.server_tick_executed)
    pub server_tick_executed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerUserCmd.client_tick)
    pub client_tick: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerUserCmd.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerUserCmd {
    fn default() -> &'a CMsgServerUserCmd {
        <CMsgServerUserCmd as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerUserCmd {
    pub fn new() -> CMsgServerUserCmd {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 cmd_number = 2;

    pub fn cmd_number(&self) -> i32 {
        self.cmd_number.unwrap_or(0)
    }

    pub fn clear_cmd_number(&mut self) {
        self.cmd_number = ::std::option::Option::None;
    }

    pub fn has_cmd_number(&self) -> bool {
        self.cmd_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_number(&mut self, v: i32) {
        self.cmd_number = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 3;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 server_tick_executed = 4;

    pub fn server_tick_executed(&self) -> i32 {
        self.server_tick_executed.unwrap_or(0)
    }

    pub fn clear_server_tick_executed(&mut self) {
        self.server_tick_executed = ::std::option::Option::None;
    }

    pub fn has_server_tick_executed(&self) -> bool {
        self.server_tick_executed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tick_executed(&mut self, v: i32) {
        self.server_tick_executed = ::std::option::Option::Some(v);
    }

    // optional int32 client_tick = 5;

    pub fn client_tick(&self) -> i32 {
        self.client_tick.unwrap_or(0)
    }

    pub fn clear_client_tick(&mut self) {
        self.client_tick = ::std::option::Option::None;
    }

    pub fn has_client_tick(&self) -> bool {
        self.client_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_tick(&mut self, v: i32) {
        self.client_tick = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerUserCmd {
    const NAME: &'static str = "CMsgServerUserCmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.cmd_number = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.server_tick_executed = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.cmd_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.server_tick_executed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.cmd_number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.server_tick_executed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_tick {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerUserCmd {
        CMsgServerUserCmd::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.cmd_number = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.server_tick_executed = ::std::option::Option::None;
        self.client_tick = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerUserCmd {
        static instance: CMsgServerUserCmd = CMsgServerUserCmd {
            data: ::std::option::Option::None,
            cmd_number: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            server_tick_executed: ::std::option::Option::None,
            client_tick: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSVCMsg_UserCommands)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UserCommands {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UserCommands.commands)
    pub commands: ::std::vec::Vec<CMsgServerUserCmd>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UserCommands.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UserCommands {
    fn default() -> &'a CSVCMsg_UserCommands {
        <CSVCMsg_UserCommands as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UserCommands {
    pub fn new() -> CSVCMsg_UserCommands {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSVCMsg_UserCommands {
    const NAME: &'static str = "CSVCMsg_UserCommands";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commands.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.commands {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.commands {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UserCommands {
        CSVCMsg_UserCommands::new()
    }

    fn clear(&mut self) {
        self.commands.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UserCommands {
        static instance: CSVCMsg_UserCommands = CSVCMsg_UserCommands {
            commands: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CLC_Messages)
pub enum CLC_Messages {
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ClientInfo)
    clc_ClientInfo = 20,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_Move)
    clc_Move = 21,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_VoiceData)
    clc_VoiceData = 22,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_BaselineAck)
    clc_BaselineAck = 23,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RespondCvarValue)
    clc_RespondCvarValue = 25,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_FileCRCCheck)
    clc_FileCRCCheck = 26,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_LoadingProgress)
    clc_LoadingProgress = 27,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_SplitPlayerConnect)
    clc_SplitPlayerConnect = 28,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_SplitPlayerDisconnect)
    clc_SplitPlayerDisconnect = 30,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ServerStatus)
    clc_ServerStatus = 31,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RequestPause)
    clc_RequestPause = 33,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_CmdKeyValues)
    clc_CmdKeyValues = 34,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RconServerDetails)
    clc_RconServerDetails = 35,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_HltvReplay)
    clc_HltvReplay = 36,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_Diagnostic)
    clc_Diagnostic = 37,
}

impl ::steam_vent_proto_common::protobuf::Enum for CLC_Messages {
    const NAME: &'static str = "CLC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CLC_Messages> {
        match value {
            20 => ::std::option::Option::Some(CLC_Messages::clc_ClientInfo),
            21 => ::std::option::Option::Some(CLC_Messages::clc_Move),
            22 => ::std::option::Option::Some(CLC_Messages::clc_VoiceData),
            23 => ::std::option::Option::Some(CLC_Messages::clc_BaselineAck),
            25 => ::std::option::Option::Some(CLC_Messages::clc_RespondCvarValue),
            26 => ::std::option::Option::Some(CLC_Messages::clc_FileCRCCheck),
            27 => ::std::option::Option::Some(CLC_Messages::clc_LoadingProgress),
            28 => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerConnect),
            30 => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerDisconnect),
            31 => ::std::option::Option::Some(CLC_Messages::clc_ServerStatus),
            33 => ::std::option::Option::Some(CLC_Messages::clc_RequestPause),
            34 => ::std::option::Option::Some(CLC_Messages::clc_CmdKeyValues),
            35 => ::std::option::Option::Some(CLC_Messages::clc_RconServerDetails),
            36 => ::std::option::Option::Some(CLC_Messages::clc_HltvReplay),
            37 => ::std::option::Option::Some(CLC_Messages::clc_Diagnostic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CLC_Messages> {
        match str {
            "clc_ClientInfo" => ::std::option::Option::Some(CLC_Messages::clc_ClientInfo),
            "clc_Move" => ::std::option::Option::Some(CLC_Messages::clc_Move),
            "clc_VoiceData" => ::std::option::Option::Some(CLC_Messages::clc_VoiceData),
            "clc_BaselineAck" => ::std::option::Option::Some(CLC_Messages::clc_BaselineAck),
            "clc_RespondCvarValue" => ::std::option::Option::Some(CLC_Messages::clc_RespondCvarValue),
            "clc_FileCRCCheck" => ::std::option::Option::Some(CLC_Messages::clc_FileCRCCheck),
            "clc_LoadingProgress" => ::std::option::Option::Some(CLC_Messages::clc_LoadingProgress),
            "clc_SplitPlayerConnect" => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerConnect),
            "clc_SplitPlayerDisconnect" => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerDisconnect),
            "clc_ServerStatus" => ::std::option::Option::Some(CLC_Messages::clc_ServerStatus),
            "clc_RequestPause" => ::std::option::Option::Some(CLC_Messages::clc_RequestPause),
            "clc_CmdKeyValues" => ::std::option::Option::Some(CLC_Messages::clc_CmdKeyValues),
            "clc_RconServerDetails" => ::std::option::Option::Some(CLC_Messages::clc_RconServerDetails),
            "clc_HltvReplay" => ::std::option::Option::Some(CLC_Messages::clc_HltvReplay),
            "clc_Diagnostic" => ::std::option::Option::Some(CLC_Messages::clc_Diagnostic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CLC_Messages] = &[
        CLC_Messages::clc_ClientInfo,
        CLC_Messages::clc_Move,
        CLC_Messages::clc_VoiceData,
        CLC_Messages::clc_BaselineAck,
        CLC_Messages::clc_RespondCvarValue,
        CLC_Messages::clc_FileCRCCheck,
        CLC_Messages::clc_LoadingProgress,
        CLC_Messages::clc_SplitPlayerConnect,
        CLC_Messages::clc_SplitPlayerDisconnect,
        CLC_Messages::clc_ServerStatus,
        CLC_Messages::clc_RequestPause,
        CLC_Messages::clc_CmdKeyValues,
        CLC_Messages::clc_RconServerDetails,
        CLC_Messages::clc_HltvReplay,
        CLC_Messages::clc_Diagnostic,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CLC_Messages {
    fn default() -> Self {
        CLC_Messages::clc_ClientInfo
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SVC_Messages)
pub enum SVC_Messages {
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ServerInfo)
    svc_ServerInfo = 40,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_FlattenedSerializer)
    svc_FlattenedSerializer = 41,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ClassInfo)
    svc_ClassInfo = 42,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetPause)
    svc_SetPause = 43,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CreateStringTable)
    svc_CreateStringTable = 44,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UpdateStringTable)
    svc_UpdateStringTable = 45,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceInit)
    svc_VoiceInit = 46,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceData)
    svc_VoiceData = 47,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Print)
    svc_Print = 48,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Sounds)
    svc_Sounds = 49,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetView)
    svc_SetView = 50,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ClearAllStringTables)
    svc_ClearAllStringTables = 51,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CmdKeyValues)
    svc_CmdKeyValues = 52,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_BSPDecal)
    svc_BSPDecal = 53,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SplitScreen)
    svc_SplitScreen = 54,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PacketEntities)
    svc_PacketEntities = 55,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Prefetch)
    svc_Prefetch = 56,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Menu)
    svc_Menu = 57,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_GetCvarValue)
    svc_GetCvarValue = 58,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_StopSound)
    svc_StopSound = 59,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PeerList)
    svc_PeerList = 60,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PacketReliable)
    svc_PacketReliable = 61,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HLTVStatus)
    svc_HLTVStatus = 62,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ServerSteamID)
    svc_ServerSteamID = 63,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_FullFrameSplit)
    svc_FullFrameSplit = 70,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_RconServerDetails)
    svc_RconServerDetails = 71,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UserMessage)
    svc_UserMessage = 72,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Broadcast_Command)
    svc_Broadcast_Command = 74,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HltvFixupOperatorStatus)
    svc_HltvFixupOperatorStatus = 75,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UserCmds)
    svc_UserCmds = 76,
}

impl ::steam_vent_proto_common::protobuf::Enum for SVC_Messages {
    const NAME: &'static str = "SVC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SVC_Messages> {
        match value {
            40 => ::std::option::Option::Some(SVC_Messages::svc_ServerInfo),
            41 => ::std::option::Option::Some(SVC_Messages::svc_FlattenedSerializer),
            42 => ::std::option::Option::Some(SVC_Messages::svc_ClassInfo),
            43 => ::std::option::Option::Some(SVC_Messages::svc_SetPause),
            44 => ::std::option::Option::Some(SVC_Messages::svc_CreateStringTable),
            45 => ::std::option::Option::Some(SVC_Messages::svc_UpdateStringTable),
            46 => ::std::option::Option::Some(SVC_Messages::svc_VoiceInit),
            47 => ::std::option::Option::Some(SVC_Messages::svc_VoiceData),
            48 => ::std::option::Option::Some(SVC_Messages::svc_Print),
            49 => ::std::option::Option::Some(SVC_Messages::svc_Sounds),
            50 => ::std::option::Option::Some(SVC_Messages::svc_SetView),
            51 => ::std::option::Option::Some(SVC_Messages::svc_ClearAllStringTables),
            52 => ::std::option::Option::Some(SVC_Messages::svc_CmdKeyValues),
            53 => ::std::option::Option::Some(SVC_Messages::svc_BSPDecal),
            54 => ::std::option::Option::Some(SVC_Messages::svc_SplitScreen),
            55 => ::std::option::Option::Some(SVC_Messages::svc_PacketEntities),
            56 => ::std::option::Option::Some(SVC_Messages::svc_Prefetch),
            57 => ::std::option::Option::Some(SVC_Messages::svc_Menu),
            58 => ::std::option::Option::Some(SVC_Messages::svc_GetCvarValue),
            59 => ::std::option::Option::Some(SVC_Messages::svc_StopSound),
            60 => ::std::option::Option::Some(SVC_Messages::svc_PeerList),
            61 => ::std::option::Option::Some(SVC_Messages::svc_PacketReliable),
            62 => ::std::option::Option::Some(SVC_Messages::svc_HLTVStatus),
            63 => ::std::option::Option::Some(SVC_Messages::svc_ServerSteamID),
            70 => ::std::option::Option::Some(SVC_Messages::svc_FullFrameSplit),
            71 => ::std::option::Option::Some(SVC_Messages::svc_RconServerDetails),
            72 => ::std::option::Option::Some(SVC_Messages::svc_UserMessage),
            74 => ::std::option::Option::Some(SVC_Messages::svc_Broadcast_Command),
            75 => ::std::option::Option::Some(SVC_Messages::svc_HltvFixupOperatorStatus),
            76 => ::std::option::Option::Some(SVC_Messages::svc_UserCmds),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SVC_Messages> {
        match str {
            "svc_ServerInfo" => ::std::option::Option::Some(SVC_Messages::svc_ServerInfo),
            "svc_FlattenedSerializer" => ::std::option::Option::Some(SVC_Messages::svc_FlattenedSerializer),
            "svc_ClassInfo" => ::std::option::Option::Some(SVC_Messages::svc_ClassInfo),
            "svc_SetPause" => ::std::option::Option::Some(SVC_Messages::svc_SetPause),
            "svc_CreateStringTable" => ::std::option::Option::Some(SVC_Messages::svc_CreateStringTable),
            "svc_UpdateStringTable" => ::std::option::Option::Some(SVC_Messages::svc_UpdateStringTable),
            "svc_VoiceInit" => ::std::option::Option::Some(SVC_Messages::svc_VoiceInit),
            "svc_VoiceData" => ::std::option::Option::Some(SVC_Messages::svc_VoiceData),
            "svc_Print" => ::std::option::Option::Some(SVC_Messages::svc_Print),
            "svc_Sounds" => ::std::option::Option::Some(SVC_Messages::svc_Sounds),
            "svc_SetView" => ::std::option::Option::Some(SVC_Messages::svc_SetView),
            "svc_ClearAllStringTables" => ::std::option::Option::Some(SVC_Messages::svc_ClearAllStringTables),
            "svc_CmdKeyValues" => ::std::option::Option::Some(SVC_Messages::svc_CmdKeyValues),
            "svc_BSPDecal" => ::std::option::Option::Some(SVC_Messages::svc_BSPDecal),
            "svc_SplitScreen" => ::std::option::Option::Some(SVC_Messages::svc_SplitScreen),
            "svc_PacketEntities" => ::std::option::Option::Some(SVC_Messages::svc_PacketEntities),
            "svc_Prefetch" => ::std::option::Option::Some(SVC_Messages::svc_Prefetch),
            "svc_Menu" => ::std::option::Option::Some(SVC_Messages::svc_Menu),
            "svc_GetCvarValue" => ::std::option::Option::Some(SVC_Messages::svc_GetCvarValue),
            "svc_StopSound" => ::std::option::Option::Some(SVC_Messages::svc_StopSound),
            "svc_PeerList" => ::std::option::Option::Some(SVC_Messages::svc_PeerList),
            "svc_PacketReliable" => ::std::option::Option::Some(SVC_Messages::svc_PacketReliable),
            "svc_HLTVStatus" => ::std::option::Option::Some(SVC_Messages::svc_HLTVStatus),
            "svc_ServerSteamID" => ::std::option::Option::Some(SVC_Messages::svc_ServerSteamID),
            "svc_FullFrameSplit" => ::std::option::Option::Some(SVC_Messages::svc_FullFrameSplit),
            "svc_RconServerDetails" => ::std::option::Option::Some(SVC_Messages::svc_RconServerDetails),
            "svc_UserMessage" => ::std::option::Option::Some(SVC_Messages::svc_UserMessage),
            "svc_Broadcast_Command" => ::std::option::Option::Some(SVC_Messages::svc_Broadcast_Command),
            "svc_HltvFixupOperatorStatus" => ::std::option::Option::Some(SVC_Messages::svc_HltvFixupOperatorStatus),
            "svc_UserCmds" => ::std::option::Option::Some(SVC_Messages::svc_UserCmds),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SVC_Messages] = &[
        SVC_Messages::svc_ServerInfo,
        SVC_Messages::svc_FlattenedSerializer,
        SVC_Messages::svc_ClassInfo,
        SVC_Messages::svc_SetPause,
        SVC_Messages::svc_CreateStringTable,
        SVC_Messages::svc_UpdateStringTable,
        SVC_Messages::svc_VoiceInit,
        SVC_Messages::svc_VoiceData,
        SVC_Messages::svc_Print,
        SVC_Messages::svc_Sounds,
        SVC_Messages::svc_SetView,
        SVC_Messages::svc_ClearAllStringTables,
        SVC_Messages::svc_CmdKeyValues,
        SVC_Messages::svc_BSPDecal,
        SVC_Messages::svc_SplitScreen,
        SVC_Messages::svc_PacketEntities,
        SVC_Messages::svc_Prefetch,
        SVC_Messages::svc_Menu,
        SVC_Messages::svc_GetCvarValue,
        SVC_Messages::svc_StopSound,
        SVC_Messages::svc_PeerList,
        SVC_Messages::svc_PacketReliable,
        SVC_Messages::svc_HLTVStatus,
        SVC_Messages::svc_ServerSteamID,
        SVC_Messages::svc_FullFrameSplit,
        SVC_Messages::svc_RconServerDetails,
        SVC_Messages::svc_UserMessage,
        SVC_Messages::svc_Broadcast_Command,
        SVC_Messages::svc_HltvFixupOperatorStatus,
        SVC_Messages::svc_UserCmds,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SVC_Messages {
    fn default() -> Self {
        SVC_Messages::svc_ServerInfo
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceDataFormat_t)
pub enum VoiceDataFormat_t {
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_STEAM)
    VOICEDATA_FORMAT_STEAM = 0,
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_ENGINE)
    VOICEDATA_FORMAT_ENGINE = 1,
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_OPUS)
    VOICEDATA_FORMAT_OPUS = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for VoiceDataFormat_t {
    const NAME: &'static str = "VoiceDataFormat_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceDataFormat_t> {
        match value {
            0 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            1 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            2 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_OPUS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceDataFormat_t> {
        match str {
            "VOICEDATA_FORMAT_STEAM" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            "VOICEDATA_FORMAT_ENGINE" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            "VOICEDATA_FORMAT_OPUS" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_OPUS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceDataFormat_t] = &[
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM,
        VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE,
        VoiceDataFormat_t::VOICEDATA_FORMAT_OPUS,
    ];
}

impl ::std::default::Default for VoiceDataFormat_t {
    fn default() -> Self {
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RequestPause_t)
pub enum RequestPause_t {
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_PAUSE)
    RP_PAUSE = 0,
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_UNPAUSE)
    RP_UNPAUSE = 1,
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_TOGGLEPAUSE)
    RP_TOGGLEPAUSE = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for RequestPause_t {
    const NAME: &'static str = "RequestPause_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestPause_t> {
        match value {
            0 => ::std::option::Option::Some(RequestPause_t::RP_PAUSE),
            1 => ::std::option::Option::Some(RequestPause_t::RP_UNPAUSE),
            2 => ::std::option::Option::Some(RequestPause_t::RP_TOGGLEPAUSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RequestPause_t> {
        match str {
            "RP_PAUSE" => ::std::option::Option::Some(RequestPause_t::RP_PAUSE),
            "RP_UNPAUSE" => ::std::option::Option::Some(RequestPause_t::RP_UNPAUSE),
            "RP_TOGGLEPAUSE" => ::std::option::Option::Some(RequestPause_t::RP_TOGGLEPAUSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RequestPause_t] = &[
        RequestPause_t::RP_PAUSE,
        RequestPause_t::RP_UNPAUSE,
        RequestPause_t::RP_TOGGLEPAUSE,
    ];
}

impl ::std::default::Default for RequestPause_t {
    fn default() -> Self {
        RequestPause_t::RP_PAUSE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PrefetchType)
pub enum PrefetchType {
    // @@protoc_insertion_point(enum_value:PrefetchType.PFT_SOUND)
    PFT_SOUND = 0,
}

impl ::steam_vent_proto_common::protobuf::Enum for PrefetchType {
    const NAME: &'static str = "PrefetchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrefetchType> {
        match value {
            0 => ::std::option::Option::Some(PrefetchType::PFT_SOUND),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PrefetchType> {
        match str {
            "PFT_SOUND" => ::std::option::Option::Some(PrefetchType::PFT_SOUND),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PrefetchType] = &[
        PrefetchType::PFT_SOUND,
    ];
}

impl ::std::default::Default for PrefetchType {
    fn default() -> Self {
        PrefetchType::PFT_SOUND
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESplitScreenMessageType)
pub enum ESplitScreenMessageType {
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER)
    MSG_SPLITSCREEN_ADDUSER = 0,
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_REMOVEUSER)
    MSG_SPLITSCREEN_REMOVEUSER = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESplitScreenMessageType {
    const NAME: &'static str = "ESplitScreenMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScreenMessageType> {
        match value {
            0 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            1 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESplitScreenMessageType> {
        match str {
            "MSG_SPLITSCREEN_ADDUSER" => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            "MSG_SPLITSCREEN_REMOVEUSER" => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScreenMessageType] = &[
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER,
    ];
}

impl ::std::default::Default for ESplitScreenMessageType {
    fn default() -> Self {
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EQueryCvarValueStatus)
pub enum EQueryCvarValueStatus {
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_ValueIntact)
    eQueryCvarValueStatus_ValueIntact = 0,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_CvarNotFound)
    eQueryCvarValueStatus_CvarNotFound = 1,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_NotACvar)
    eQueryCvarValueStatus_NotACvar = 2,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_CvarProtected)
    eQueryCvarValueStatus_CvarProtected = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EQueryCvarValueStatus {
    const NAME: &'static str = "EQueryCvarValueStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EQueryCvarValueStatus> {
        match value {
            0 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact),
            1 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound),
            2 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar),
            3 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EQueryCvarValueStatus> {
        match str {
            "eQueryCvarValueStatus_ValueIntact" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact),
            "eQueryCvarValueStatus_CvarNotFound" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound),
            "eQueryCvarValueStatus_NotACvar" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar),
            "eQueryCvarValueStatus_CvarProtected" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EQueryCvarValueStatus] = &[
        EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact,
        EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound,
        EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar,
        EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected,
    ];
}

impl ::std::default::Default for EQueryCvarValueStatus {
    fn default() -> Self {
        EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DIALOG_TYPE)
pub enum DIALOG_TYPE {
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_MSG)
    DIALOG_MSG = 0,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_MENU)
    DIALOG_MENU = 1,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_TEXT)
    DIALOG_TEXT = 2,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_ENTRY)
    DIALOG_ENTRY = 3,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_ASKCONNECT)
    DIALOG_ASKCONNECT = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for DIALOG_TYPE {
    const NAME: &'static str = "DIALOG_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DIALOG_TYPE> {
        match value {
            0 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MSG),
            1 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MENU),
            2 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_TEXT),
            3 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ENTRY),
            4 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ASKCONNECT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DIALOG_TYPE> {
        match str {
            "DIALOG_MSG" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MSG),
            "DIALOG_MENU" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MENU),
            "DIALOG_TEXT" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_TEXT),
            "DIALOG_ENTRY" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ENTRY),
            "DIALOG_ASKCONNECT" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ASKCONNECT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DIALOG_TYPE] = &[
        DIALOG_TYPE::DIALOG_MSG,
        DIALOG_TYPE::DIALOG_MENU,
        DIALOG_TYPE::DIALOG_TEXT,
        DIALOG_TYPE::DIALOG_ENTRY,
        DIALOG_TYPE::DIALOG_ASKCONNECT,
    ];
}

impl ::std::default::Default for DIALOG_TYPE {
    fn default() -> Self {
        DIALOG_TYPE::DIALOG_MSG
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SVC_Messages_LowFrequency)
pub enum SVC_Messages_LowFrequency {
    // @@protoc_insertion_point(enum_value:SVC_Messages_LowFrequency.svc_dummy)
    svc_dummy = 600,
}

impl ::steam_vent_proto_common::protobuf::Enum for SVC_Messages_LowFrequency {
    const NAME: &'static str = "SVC_Messages_LowFrequency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SVC_Messages_LowFrequency> {
        match value {
            600 => ::std::option::Option::Some(SVC_Messages_LowFrequency::svc_dummy),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SVC_Messages_LowFrequency> {
        match str {
            "svc_dummy" => ::std::option::Option::Some(SVC_Messages_LowFrequency::svc_dummy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SVC_Messages_LowFrequency] = &[
        SVC_Messages_LowFrequency::svc_dummy,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SVC_Messages_LowFrequency {
    fn default() -> Self {
        SVC_Messages_LowFrequency::svc_dummy
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Bidirectional_Messages)
pub enum Bidirectional_Messages {
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_RebroadcastGameEvent)
    bi_RebroadcastGameEvent = 16,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_RebroadcastSource)
    bi_RebroadcastSource = 17,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_GameEvent)
    bi_GameEvent = 18,
}

impl ::steam_vent_proto_common::protobuf::Enum for Bidirectional_Messages {
    const NAME: &'static str = "Bidirectional_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Bidirectional_Messages> {
        match value {
            16 => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastGameEvent),
            17 => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastSource),
            18 => ::std::option::Option::Some(Bidirectional_Messages::bi_GameEvent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Bidirectional_Messages> {
        match str {
            "bi_RebroadcastGameEvent" => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastGameEvent),
            "bi_RebroadcastSource" => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastSource),
            "bi_GameEvent" => ::std::option::Option::Some(Bidirectional_Messages::bi_GameEvent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Bidirectional_Messages] = &[
        Bidirectional_Messages::bi_RebroadcastGameEvent,
        Bidirectional_Messages::bi_RebroadcastSource,
        Bidirectional_Messages::bi_GameEvent,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Bidirectional_Messages {
    fn default() -> Self {
        Bidirectional_Messages::bi_RebroadcastGameEvent
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Bidirectional_Messages_LowFrequency)
pub enum Bidirectional_Messages_LowFrequency {
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages_LowFrequency.bi_RelayInfo)
    bi_RelayInfo = 700,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages_LowFrequency.bi_RelayPacket)
    bi_RelayPacket = 701,
}

impl ::steam_vent_proto_common::protobuf::Enum for Bidirectional_Messages_LowFrequency {
    const NAME: &'static str = "Bidirectional_Messages_LowFrequency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Bidirectional_Messages_LowFrequency> {
        match value {
            700 => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayInfo),
            701 => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayPacket),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Bidirectional_Messages_LowFrequency> {
        match str {
            "bi_RelayInfo" => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayInfo),
            "bi_RelayPacket" => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayPacket),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Bidirectional_Messages_LowFrequency] = &[
        Bidirectional_Messages_LowFrequency::bi_RelayInfo,
        Bidirectional_Messages_LowFrequency::bi_RelayPacket,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Bidirectional_Messages_LowFrequency {
    fn default() -> Self {
        Bidirectional_Messages_LowFrequency::bi_RelayInfo
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ReplayEventType_t)
pub enum ReplayEventType_t {
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_CANCEL)
    REPLAY_EVENT_CANCEL = 0,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_DEATH)
    REPLAY_EVENT_DEATH = 1,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_GENERIC)
    REPLAY_EVENT_GENERIC = 2,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_STUCK_NEED_FULL_UPDATE)
    REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_VICTORY)
    REPLAY_EVENT_VICTORY = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ReplayEventType_t {
    const NAME: &'static str = "ReplayEventType_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReplayEventType_t> {
        match value {
            0 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_CANCEL),
            1 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_DEATH),
            2 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_GENERIC),
            3 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE),
            4 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_VICTORY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ReplayEventType_t> {
        match str {
            "REPLAY_EVENT_CANCEL" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_CANCEL),
            "REPLAY_EVENT_DEATH" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_DEATH),
            "REPLAY_EVENT_GENERIC" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_GENERIC),
            "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE),
            "REPLAY_EVENT_VICTORY" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_VICTORY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReplayEventType_t] = &[
        ReplayEventType_t::REPLAY_EVENT_CANCEL,
        ReplayEventType_t::REPLAY_EVENT_DEATH,
        ReplayEventType_t::REPLAY_EVENT_GENERIC,
        ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE,
        ReplayEventType_t::REPLAY_EVENT_VICTORY,
    ];
}

impl ::std::default::Default for ReplayEventType_t {
    fn default() -> Self {
        ReplayEventType_t::REPLAY_EVENT_CANCEL
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::networkbasetypes::*;
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_ClientInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_Move {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgVoiceAudio {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_VoiceData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_BaselineAck {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_ListenEvents {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_RespondCvarValue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_FileCRCCheck {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_LoadingProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_SplitPlayerConnect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_SplitPlayerDisconnect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_ServerStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_RequestPause {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_CmdKeyValues {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_RconServerDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSource2SystemSpecs {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSource2VProfLiteReportItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSource2VProfLiteReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_Diagnostic {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSource2Metrics_MatchPerfSummary_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_ServerInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_ClassInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_SetPause {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_VoiceInit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_Print {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_Sounds {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_Prefetch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_SetView {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_FixAngle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_CrosshairAngle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_BSPDecal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_SplitScreen {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_GetCvarValue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_Menu {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_UserMessage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_SendTable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_GameEventList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_PacketEntities {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_TempEntities {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_CreateStringTable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_UpdateStringTable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_VoiceData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_PacketReliable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_FullFrameSplit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_HLTVStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_ServerSteamID {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_CmdKeyValues {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_RconServerDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgIPCAddress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerPeer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_PeerList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_ClearAllStringTables {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for ProtoFlattenedSerializerField_t {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for ProtoFlattenedSerializer_t {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_FlattenedSerializer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_StopSound {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CBidirMsg_RebroadcastGameEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CBidirMsg_RebroadcastSource {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerNetworkStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_HltvReplay {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_HltvReplay {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_Broadcast_Command {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCLCMsg_HltvFixupOperatorTick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_HltvFixupOperatorStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerUserCmd {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSVCMsg_UserCommands {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
