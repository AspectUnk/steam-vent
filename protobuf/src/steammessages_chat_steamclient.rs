// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_chat.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct CChat_RequestFriendPersonaStates_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Request {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Request {
        <CChat_RequestFriendPersonaStates_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Request {
    pub fn new() -> CChat_RequestFriendPersonaStates_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChat_RequestFriendPersonaStates_Request {
        CChat_RequestFriendPersonaStates_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChat_RequestFriendPersonaStates_Request>(
                "CChat_RequestFriendPersonaStates_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Request {
        static instance: ::protobuf::rt::LazyV2<CChat_RequestFriendPersonaStates_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChat_RequestFriendPersonaStates_Request::new)
    }
}

impl ::protobuf::Clear for CChat_RequestFriendPersonaStates_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChat_RequestFriendPersonaStates_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChat_RequestFriendPersonaStates_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Response {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Response {
        <CChat_RequestFriendPersonaStates_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Response {
    pub fn new() -> CChat_RequestFriendPersonaStates_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChat_RequestFriendPersonaStates_Response {
        CChat_RequestFriendPersonaStates_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChat_RequestFriendPersonaStates_Response>(
                "CChat_RequestFriendPersonaStates_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Response {
        static instance: ::protobuf::rt::LazyV2<CChat_RequestFriendPersonaStates_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChat_RequestFriendPersonaStates_Response::new)
    }
}

impl ::protobuf::Clear for CChat_RequestFriendPersonaStates_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChat_RequestFriendPersonaStates_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateChatRoomGroup_Request {
    // message fields
    steamid_partner: ::std::option::Option<u64>,
    steamid_invited: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub steamid_invitees: ::std::vec::Vec<u64>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Request {
        <CChatRoom_CreateChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Request {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_partner = 1;


    pub fn get_steamid_partner(&self) -> u64 {
        self.steamid_partner.unwrap_or(0)
    }
    pub fn clear_steamid_partner(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
    }

    pub fn has_steamid_partner(&self) -> bool {
        self.steamid_partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_partner(&mut self, v: u64) {
        self.steamid_partner = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_invited = 2;


    pub fn get_steamid_invited(&self) -> u64 {
        self.steamid_invited.unwrap_or(0)
    }
    pub fn clear_steamid_invited(&mut self) {
        self.steamid_invited = ::std::option::Option::None;
    }

    pub fn has_steamid_invited(&self) -> bool {
        self.steamid_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invited(&mut self, v: u64) {
        self.steamid_invited = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed64 steamid_invitees = 4;


    pub fn get_steamid_invitees(&self) -> &[u64] {
        &self.steamid_invitees
    }
    pub fn clear_steamid_invitees(&mut self) {
        self.steamid_invitees.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitees(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_invitees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_invitees(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_invitees
    }

    // Take field
    pub fn take_steamid_invitees(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_invitees, ::std::vec::Vec::new())
    }

    // optional uint32 watching_broadcast_accountid = 6;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 7;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_partner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_invited = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_invitees)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_partner {
            my_size += 9;
        }
        if let Some(v) = self.steamid_invited {
            my_size += 9;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += 9 * self.steamid_invitees.len() as u32;
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_partner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steamid_invited {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.steamid_invitees {
            os.write_fixed64(4, *v)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        CChatRoom_CreateChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_partner",
                |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_partner },
                |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_partner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_invited",
                |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invited },
                |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invited },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.name },
                |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_invitees",
                |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invitees },
                |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invitees },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "watching_broadcast_accountid",
                |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_accountid },
                |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "watching_broadcast_channel_id",
                |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_channel_id },
                |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_channel_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateChatRoomGroup_Request>(
                "CChatRoom_CreateChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoomGroup_Request {
    fn clear(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
        self.steamid_invited = ::std::option::Option::None;
        self.name.clear();
        self.steamid_invitees.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRole {
    // message fields
    role_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRole {
    fn default() -> &'a CChatRole {
        <CChatRole as ::protobuf::Message>::default_instance()
    }
}

impl CChatRole {
    pub fn new() -> CChatRole {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 3;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRole {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRole {
        CChatRole::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRole| { &m.role_id },
                |m: &mut CChatRole| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRole| { &m.name },
                |m: &mut CChatRole| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRole| { &m.ordinal },
                |m: &mut CChatRole| { &mut m.ordinal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRole>(
                "CChatRole",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRole {
        static instance: ::protobuf::rt::LazyV2<CChatRole> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRole::new)
    }
}

impl ::protobuf::Clear for CChatRole {
    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.name.clear();
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRole {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoleActions {
    // message fields
    role_id: ::std::option::Option<u64>,
    can_create_rename_delete_channel: ::std::option::Option<bool>,
    can_kick: ::std::option::Option<bool>,
    can_ban: ::std::option::Option<bool>,
    can_invite: ::std::option::Option<bool>,
    can_change_tagline_avatar_name: ::std::option::Option<bool>,
    can_chat: ::std::option::Option<bool>,
    can_view_history: ::std::option::Option<bool>,
    can_change_group_roles: ::std::option::Option<bool>,
    can_change_user_roles: ::std::option::Option<bool>,
    can_mention_all: ::std::option::Option<bool>,
    can_set_watching_broadcast: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoleActions {
    fn default() -> &'a CChatRoleActions {
        <CChatRoleActions as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoleActions {
    pub fn new() -> CChatRoleActions {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional bool can_create_rename_delete_channel = 2;


    pub fn get_can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.unwrap_or(false)
    }
    pub fn clear_can_create_rename_delete_channel(&mut self) {
        self.can_create_rename_delete_channel = ::std::option::Option::None;
    }

    pub fn has_can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_create_rename_delete_channel(&mut self, v: bool) {
        self.can_create_rename_delete_channel = ::std::option::Option::Some(v);
    }

    // optional bool can_kick = 3;


    pub fn get_can_kick(&self) -> bool {
        self.can_kick.unwrap_or(false)
    }
    pub fn clear_can_kick(&mut self) {
        self.can_kick = ::std::option::Option::None;
    }

    pub fn has_can_kick(&self) -> bool {
        self.can_kick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_kick(&mut self, v: bool) {
        self.can_kick = ::std::option::Option::Some(v);
    }

    // optional bool can_ban = 4;


    pub fn get_can_ban(&self) -> bool {
        self.can_ban.unwrap_or(false)
    }
    pub fn clear_can_ban(&mut self) {
        self.can_ban = ::std::option::Option::None;
    }

    pub fn has_can_ban(&self) -> bool {
        self.can_ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_ban(&mut self, v: bool) {
        self.can_ban = ::std::option::Option::Some(v);
    }

    // optional bool can_invite = 5;


    pub fn get_can_invite(&self) -> bool {
        self.can_invite.unwrap_or(false)
    }
    pub fn clear_can_invite(&mut self) {
        self.can_invite = ::std::option::Option::None;
    }

    pub fn has_can_invite(&self) -> bool {
        self.can_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_invite(&mut self, v: bool) {
        self.can_invite = ::std::option::Option::Some(v);
    }

    // optional bool can_change_tagline_avatar_name = 6;


    pub fn get_can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.unwrap_or(false)
    }
    pub fn clear_can_change_tagline_avatar_name(&mut self) {
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
    }

    pub fn has_can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_tagline_avatar_name(&mut self, v: bool) {
        self.can_change_tagline_avatar_name = ::std::option::Option::Some(v);
    }

    // optional bool can_chat = 7;


    pub fn get_can_chat(&self) -> bool {
        self.can_chat.unwrap_or(false)
    }
    pub fn clear_can_chat(&mut self) {
        self.can_chat = ::std::option::Option::None;
    }

    pub fn has_can_chat(&self) -> bool {
        self.can_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_chat(&mut self, v: bool) {
        self.can_chat = ::std::option::Option::Some(v);
    }

    // optional bool can_view_history = 8;


    pub fn get_can_view_history(&self) -> bool {
        self.can_view_history.unwrap_or(false)
    }
    pub fn clear_can_view_history(&mut self) {
        self.can_view_history = ::std::option::Option::None;
    }

    pub fn has_can_view_history(&self) -> bool {
        self.can_view_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_view_history(&mut self, v: bool) {
        self.can_view_history = ::std::option::Option::Some(v);
    }

    // optional bool can_change_group_roles = 9;


    pub fn get_can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.unwrap_or(false)
    }
    pub fn clear_can_change_group_roles(&mut self) {
        self.can_change_group_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_group_roles(&mut self, v: bool) {
        self.can_change_group_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_change_user_roles = 10;


    pub fn get_can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.unwrap_or(false)
    }
    pub fn clear_can_change_user_roles(&mut self) {
        self.can_change_user_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_user_roles(&mut self, v: bool) {
        self.can_change_user_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_mention_all = 11;


    pub fn get_can_mention_all(&self) -> bool {
        self.can_mention_all.unwrap_or(false)
    }
    pub fn clear_can_mention_all(&mut self) {
        self.can_mention_all = ::std::option::Option::None;
    }

    pub fn has_can_mention_all(&self) -> bool {
        self.can_mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_mention_all(&mut self, v: bool) {
        self.can_mention_all = ::std::option::Option::Some(v);
    }

    // optional bool can_set_watching_broadcast = 12;


    pub fn get_can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.unwrap_or(false)
    }
    pub fn clear_can_set_watching_broadcast(&mut self) {
        self.can_set_watching_broadcast = ::std::option::Option::None;
    }

    pub fn has_can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_set_watching_broadcast(&mut self, v: bool) {
        self.can_set_watching_broadcast = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoleActions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_create_rename_delete_channel = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_kick = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_ban = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_invite = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_change_tagline_avatar_name = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_chat = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_view_history = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_change_group_roles = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_change_user_roles = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_mention_all = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_set_watching_broadcast = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            my_size += 2;
        }
        if let Some(v) = self.can_kick {
            my_size += 2;
        }
        if let Some(v) = self.can_ban {
            my_size += 2;
        }
        if let Some(v) = self.can_invite {
            my_size += 2;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            my_size += 2;
        }
        if let Some(v) = self.can_chat {
            my_size += 2;
        }
        if let Some(v) = self.can_view_history {
            my_size += 2;
        }
        if let Some(v) = self.can_change_group_roles {
            my_size += 2;
        }
        if let Some(v) = self.can_change_user_roles {
            my_size += 2;
        }
        if let Some(v) = self.can_mention_all {
            my_size += 2;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.can_kick {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.can_ban {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_invite {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.can_chat {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.can_view_history {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.can_change_group_roles {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.can_change_user_roles {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.can_mention_all {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoleActions {
        CChatRoleActions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoleActions| { &m.role_id },
                |m: &mut CChatRoleActions| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_create_rename_delete_channel",
                |m: &CChatRoleActions| { &m.can_create_rename_delete_channel },
                |m: &mut CChatRoleActions| { &mut m.can_create_rename_delete_channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_kick",
                |m: &CChatRoleActions| { &m.can_kick },
                |m: &mut CChatRoleActions| { &mut m.can_kick },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_ban",
                |m: &CChatRoleActions| { &m.can_ban },
                |m: &mut CChatRoleActions| { &mut m.can_ban },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_invite",
                |m: &CChatRoleActions| { &m.can_invite },
                |m: &mut CChatRoleActions| { &mut m.can_invite },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_change_tagline_avatar_name",
                |m: &CChatRoleActions| { &m.can_change_tagline_avatar_name },
                |m: &mut CChatRoleActions| { &mut m.can_change_tagline_avatar_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_chat",
                |m: &CChatRoleActions| { &m.can_chat },
                |m: &mut CChatRoleActions| { &mut m.can_chat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_view_history",
                |m: &CChatRoleActions| { &m.can_view_history },
                |m: &mut CChatRoleActions| { &mut m.can_view_history },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_change_group_roles",
                |m: &CChatRoleActions| { &m.can_change_group_roles },
                |m: &mut CChatRoleActions| { &mut m.can_change_group_roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_change_user_roles",
                |m: &CChatRoleActions| { &m.can_change_user_roles },
                |m: &mut CChatRoleActions| { &mut m.can_change_user_roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_mention_all",
                |m: &CChatRoleActions| { &m.can_mention_all },
                |m: &mut CChatRoleActions| { &mut m.can_mention_all },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_set_watching_broadcast",
                |m: &CChatRoleActions| { &m.can_set_watching_broadcast },
                |m: &mut CChatRoleActions| { &mut m.can_set_watching_broadcast },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoleActions>(
                "CChatRoleActions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoleActions {
        static instance: ::protobuf::rt::LazyV2<CChatRoleActions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoleActions::new)
    }
}

impl ::protobuf::Clear for CChatRoleActions {
    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.can_create_rename_delete_channel = ::std::option::Option::None;
        self.can_kick = ::std::option::Option::None;
        self.can_ban = ::std::option::Option::None;
        self.can_invite = ::std::option::Option::None;
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
        self.can_chat = ::std::option::Option::None;
        self.can_view_history = ::std::option::Option::None;
        self.can_change_group_roles = ::std::option::Option::None;
        self.can_change_user_roles = ::std::option::Option::None;
        self.can_mention_all = ::std::option::Option::None;
        self.can_set_watching_broadcast = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoleActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoleActions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatPartyBeacon {
    // message fields
    app_id: ::std::option::Option<u32>,
    steamid_owner: ::std::option::Option<u64>,
    beacon_id: ::std::option::Option<u64>,
    game_metadata: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatPartyBeacon {
    fn default() -> &'a CChatPartyBeacon {
        <CChatPartyBeacon as ::protobuf::Message>::default_instance()
    }
}

impl CChatPartyBeacon {
    pub fn new() -> CChatPartyBeacon {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_owner = 2;


    pub fn get_steamid_owner(&self) -> u64 {
        self.steamid_owner.unwrap_or(0)
    }
    pub fn clear_steamid_owner(&mut self) {
        self.steamid_owner = ::std::option::Option::None;
    }

    pub fn has_steamid_owner(&self) -> bool {
        self.steamid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_owner(&mut self, v: u64) {
        self.steamid_owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 beacon_id = 3;


    pub fn get_beacon_id(&self) -> u64 {
        self.beacon_id.unwrap_or(0)
    }
    pub fn clear_beacon_id(&mut self) {
        self.beacon_id = ::std::option::Option::None;
    }

    pub fn has_beacon_id(&self) -> bool {
        self.beacon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_id(&mut self, v: u64) {
        self.beacon_id = ::std::option::Option::Some(v);
    }

    // optional string game_metadata = 4;


    pub fn get_game_metadata(&self) -> &str {
        match self.game_metadata.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_metadata(&mut self) {
        self.game_metadata.clear();
    }

    pub fn has_game_metadata(&self) -> bool {
        self.game_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_metadata(&mut self, v: ::std::string::String) {
        self.game_metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_metadata(&mut self) -> &mut ::std::string::String {
        if self.game_metadata.is_none() {
            self.game_metadata.set_default();
        }
        self.game_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_metadata(&mut self) -> ::std::string::String {
        self.game_metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatPartyBeacon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_owner = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.beacon_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_owner {
            my_size += 9;
        }
        if let Some(v) = self.beacon_id {
            my_size += 9;
        }
        if let Some(ref v) = self.game_metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid_owner {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.beacon_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.game_metadata.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatPartyBeacon {
        CChatPartyBeacon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CChatPartyBeacon| { &m.app_id },
                |m: &mut CChatPartyBeacon| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_owner",
                |m: &CChatPartyBeacon| { &m.steamid_owner },
                |m: &mut CChatPartyBeacon| { &mut m.steamid_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "beacon_id",
                |m: &CChatPartyBeacon| { &m.beacon_id },
                |m: &mut CChatPartyBeacon| { &mut m.beacon_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_metadata",
                |m: &CChatPartyBeacon| { &m.game_metadata },
                |m: &mut CChatPartyBeacon| { &mut m.game_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatPartyBeacon>(
                "CChatPartyBeacon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatPartyBeacon {
        static instance: ::protobuf::rt::LazyV2<CChatPartyBeacon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatPartyBeacon::new)
    }
}

impl ::protobuf::Clear for CChatPartyBeacon {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steamid_owner = ::std::option::Option::None;
        self.beacon_id = ::std::option::Option::None;
        self.game_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatPartyBeacon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatPartyBeacon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomGroupHeaderState {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    clanid: ::std::option::Option<u32>,
    accountid_owner: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    tagline: ::protobuf::SingularField<::std::string::String>,
    avatar_sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    default_role_id: ::std::option::Option<u64>,
    pub roles: ::protobuf::RepeatedField<CChatRole>,
    pub role_actions: ::protobuf::RepeatedField<CChatRoleActions>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    pub party_beacons: ::protobuf::RepeatedField<CChatPartyBeacon>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    active_minigame_id: ::std::option::Option<u64>,
    avatar_ugc_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupHeaderState {
    fn default() -> &'a CChatRoomGroupHeaderState {
        <CChatRoomGroupHeaderState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupHeaderState {
    pub fn new() -> CChatRoomGroupHeaderState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;


    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 clanid = 13;


    pub fn get_clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }
    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_owner = 14;


    pub fn get_accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }
    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 21;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string tagline = 15;


    pub fn get_tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagline(&mut self) {
        self.tagline.clear();
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline.set_default();
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes avatar_sha = 16;


    pub fn get_avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha.clear();
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha.set_default();
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 default_role_id = 17;


    pub fn get_default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }
    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRole roles = 18;


    pub fn get_roles(&self) -> &[CChatRole] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<CChatRole>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<CChatRole> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<CChatRole> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }

    // repeated .CChatRoleActions role_actions = 19;


    pub fn get_role_actions(&self) -> &[CChatRoleActions] {
        &self.role_actions
    }
    pub fn clear_role_actions(&mut self) {
        self.role_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_actions(&mut self, v: ::protobuf::RepeatedField<CChatRoleActions>) {
        self.role_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_actions(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoleActions> {
        &mut self.role_actions
    }

    // Take field
    pub fn take_role_actions(&mut self) -> ::protobuf::RepeatedField<CChatRoleActions> {
        ::std::mem::replace(&mut self.role_actions, ::protobuf::RepeatedField::new())
    }

    // optional uint32 watching_broadcast_accountid = 20;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // repeated .CChatPartyBeacon party_beacons = 22;


    pub fn get_party_beacons(&self) -> &[CChatPartyBeacon] {
        &self.party_beacons
    }
    pub fn clear_party_beacons(&mut self) {
        self.party_beacons.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_beacons(&mut self, v: ::protobuf::RepeatedField<CChatPartyBeacon>) {
        self.party_beacons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_beacons(&mut self) -> &mut ::protobuf::RepeatedField<CChatPartyBeacon> {
        &mut self.party_beacons
    }

    // Take field
    pub fn take_party_beacons(&mut self) -> ::protobuf::RepeatedField<CChatPartyBeacon> {
        ::std::mem::replace(&mut self.party_beacons, ::protobuf::RepeatedField::new())
    }

    // optional uint64 watching_broadcast_channel_id = 23;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 24;


    pub fn get_active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }
    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 25;


    pub fn get_avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url.clear();
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url.set_default();
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoomGroupHeaderState {
    fn is_initialized(&self) -> bool {
        for v in &self.roles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.role_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.party_beacons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clanid = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_owner = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagline)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.avatar_sha)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_role_id = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roles)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_actions)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.party_beacons)?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.active_minigame_id = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.avatar_ugc_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.avatar_ugc_url.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(21, v)?;
        }
        if let Some(ref v) = self.tagline.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            os.write_bytes(16, &v)?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(17, v)?;
        }
        for v in &self.roles {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.role_actions {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(20, v)?;
        }
        for v in &self.party_beacons {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(23, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(24, v)?;
        }
        if let Some(ref v) = self.avatar_ugc_url.as_ref() {
            os.write_string(25, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomGroupHeaderState {
        CChatRoomGroupHeaderState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoomGroupHeaderState| { &m.chat_group_id },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chat_name",
                |m: &CChatRoomGroupHeaderState| { &m.chat_name },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "clanid",
                |m: &CChatRoomGroupHeaderState| { &m.clanid },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.clanid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_owner",
                |m: &CChatRoomGroupHeaderState| { &m.accountid_owner },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.accountid_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CChatRoomGroupHeaderState| { &m.appid },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tagline",
                |m: &CChatRoomGroupHeaderState| { &m.tagline },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.tagline },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "avatar_sha",
                |m: &CChatRoomGroupHeaderState| { &m.avatar_sha },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.avatar_sha },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "default_role_id",
                |m: &CChatRoomGroupHeaderState| { &m.default_role_id },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.default_role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRole>>(
                "roles",
                |m: &CChatRoomGroupHeaderState| { &m.roles },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                "role_actions",
                |m: &CChatRoomGroupHeaderState| { &m.role_actions },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.role_actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "watching_broadcast_accountid",
                |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_accountid },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatPartyBeacon>>(
                "party_beacons",
                |m: &CChatRoomGroupHeaderState| { &m.party_beacons },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.party_beacons },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "watching_broadcast_channel_id",
                |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_channel_id },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "active_minigame_id",
                |m: &CChatRoomGroupHeaderState| { &m.active_minigame_id },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.active_minigame_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "avatar_ugc_url",
                |m: &CChatRoomGroupHeaderState| { &m.avatar_ugc_url },
                |m: &mut CChatRoomGroupHeaderState| { &mut m.avatar_ugc_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomGroupHeaderState>(
                "CChatRoomGroupHeaderState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomGroupHeaderState {
        static instance: ::protobuf::rt::LazyV2<CChatRoomGroupHeaderState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomGroupHeaderState::new)
    }
}

impl ::protobuf::Clear for CChatRoomGroupHeaderState {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_name.clear();
        self.clanid = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.tagline.clear();
        self.avatar_sha.clear();
        self.default_role_id = ::std::option::Option::None;
        self.roles.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomGroupHeaderState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupHeaderState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomMember {
    // message fields
    accountid: ::std::option::Option<u32>,
    state: ::std::option::Option<EChatRoomJoinState>,
    rank: ::std::option::Option<EChatRoomGroupRank>,
    time_kick_expire: ::std::option::Option<u32>,
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomMember {
    fn default() -> &'a CChatRoomMember {
        <CChatRoomMember as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMember {
    pub fn new() -> CChatRoomMember {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomJoinState state = 3;


    pub fn get_state(&self) -> EChatRoomJoinState {
        self.state.unwrap_or(EChatRoomJoinState::k_EChatRoomJoinState_Default)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EChatRoomJoinState) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomGroupRank rank = 4;


    pub fn get_rank(&self) -> EChatRoomGroupRank {
        self.rank.unwrap_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 time_kick_expire = 6;


    pub fn get_time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }
    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // repeated uint64 role_ids = 7;


    pub fn get_role_ids(&self) -> &[u64] {
        &self.role_ids
    }
    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoomMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.rank, 4, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_kick_expire = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.role_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.rank {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(6, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomMember {
        CChatRoomMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CChatRoomMember| { &m.accountid },
                |m: &mut CChatRoomMember| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomJoinState>>(
                "state",
                |m: &CChatRoomMember| { &m.state },
                |m: &mut CChatRoomMember| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomGroupRank>>(
                "rank",
                |m: &CChatRoomMember| { &m.rank },
                |m: &mut CChatRoomMember| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_kick_expire",
                |m: &CChatRoomMember| { &m.time_kick_expire },
                |m: &mut CChatRoomMember| { &mut m.time_kick_expire },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_ids",
                |m: &CChatRoomMember| { &m.role_ids },
                |m: &mut CChatRoomMember| { &mut m.role_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomMember>(
                "CChatRoomMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomMember {
        static instance: ::protobuf::rt::LazyV2<CChatRoomMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomMember::new)
    }
}

impl ::protobuf::Clear for CChatRoomMember {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.time_kick_expire = ::std::option::Option::None;
        self.role_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomState {
    // message fields
    chat_id: ::std::option::Option<u64>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    voice_allowed: ::std::option::Option<bool>,
    pub members_in_voice: ::std::vec::Vec<u32>,
    time_last_message: ::std::option::Option<u32>,
    sort_order: ::std::option::Option<u32>,
    last_message: ::protobuf::SingularField<::std::string::String>,
    accountid_last_message: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomState {
    fn default() -> &'a CChatRoomState {
        <CChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomState {
    pub fn new() -> CChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;


    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool voice_allowed = 3;


    pub fn get_voice_allowed(&self) -> bool {
        self.voice_allowed.unwrap_or(false)
    }
    pub fn clear_voice_allowed(&mut self) {
        self.voice_allowed = ::std::option::Option::None;
    }

    pub fn has_voice_allowed(&self) -> bool {
        self.voice_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_allowed(&mut self, v: bool) {
        self.voice_allowed = ::std::option::Option::Some(v);
    }

    // repeated uint32 members_in_voice = 4;


    pub fn get_members_in_voice(&self) -> &[u32] {
        &self.members_in_voice
    }
    pub fn clear_members_in_voice(&mut self) {
        self.members_in_voice.clear();
    }

    // Param is passed by value, moved
    pub fn set_members_in_voice(&mut self, v: ::std::vec::Vec<u32>) {
        self.members_in_voice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members_in_voice(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.members_in_voice
    }

    // Take field
    pub fn take_members_in_voice(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.members_in_voice, ::std::vec::Vec::new())
    }

    // optional uint32 time_last_message = 5;


    pub fn get_time_last_message(&self) -> u32 {
        self.time_last_message.unwrap_or(0)
    }
    pub fn clear_time_last_message(&mut self) {
        self.time_last_message = ::std::option::Option::None;
    }

    pub fn has_time_last_message(&self) -> bool {
        self.time_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_message(&mut self, v: u32) {
        self.time_last_message = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 6;


    pub fn get_sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }
    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }

    // optional string last_message = 7;


    pub fn get_last_message(&self) -> &str {
        match self.last_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_last_message(&mut self) {
        self.last_message.clear();
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: ::std::string::String) {
        self.last_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message(&mut self) -> &mut ::std::string::String {
        if self.last_message.is_none() {
            self.last_message.set_default();
        }
        self.last_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message(&mut self) -> ::std::string::String {
        self.last_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_last_message = 8;


    pub fn get_accountid_last_message(&self) -> u32 {
        self.accountid_last_message.unwrap_or(0)
    }
    pub fn clear_accountid_last_message(&mut self) {
        self.accountid_last_message = ::std::option::Option::None;
    }

    pub fn has_accountid_last_message(&self) -> bool {
        self.accountid_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_last_message(&mut self, v: u32) {
        self.accountid_last_message = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_allowed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.members_in_voice)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_message = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sort_order = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.last_message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_last_message = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.voice_allowed {
            my_size += 2;
        }
        for value in &self.members_in_voice {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.time_last_message {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sort_order {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.last_message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.accountid_last_message {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.voice_allowed {
            os.write_bool(3, v)?;
        }
        for v in &self.members_in_voice {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.time_last_message {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.last_message.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.accountid_last_message {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomState {
        CChatRoomState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoomState| { &m.chat_id },
                |m: &mut CChatRoomState| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chat_name",
                |m: &CChatRoomState| { &m.chat_name },
                |m: &mut CChatRoomState| { &mut m.chat_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "voice_allowed",
                |m: &CChatRoomState| { &m.voice_allowed },
                |m: &mut CChatRoomState| { &mut m.voice_allowed },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "members_in_voice",
                |m: &CChatRoomState| { &m.members_in_voice },
                |m: &mut CChatRoomState| { &mut m.members_in_voice },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last_message",
                |m: &CChatRoomState| { &m.time_last_message },
                |m: &mut CChatRoomState| { &mut m.time_last_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sort_order",
                |m: &CChatRoomState| { &m.sort_order },
                |m: &mut CChatRoomState| { &mut m.sort_order },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_message",
                |m: &CChatRoomState| { &m.last_message },
                |m: &mut CChatRoomState| { &mut m.last_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_last_message",
                |m: &CChatRoomState| { &m.accountid_last_message },
                |m: &mut CChatRoomState| { &mut m.accountid_last_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomState>(
                "CChatRoomState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomState {
        static instance: ::protobuf::rt::LazyV2<CChatRoomState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomState::new)
    }
}

impl ::protobuf::Clear for CChatRoomState {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_name.clear();
        self.voice_allowed = ::std::option::Option::None;
        self.members_in_voice.clear();
        self.time_last_message = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.last_message.clear();
        self.accountid_last_message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomGroupState {
    // message fields
    pub header_state: ::protobuf::SingularPtrField<CChatRoomGroupHeaderState>,
    pub members: ::protobuf::RepeatedField<CChatRoomMember>,
    default_chat_id: ::std::option::Option<u64>,
    pub chat_rooms: ::protobuf::RepeatedField<CChatRoomState>,
    pub kicked: ::protobuf::RepeatedField<CChatRoomMember>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupState {
    fn default() -> &'a CChatRoomGroupState {
        <CChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupState {
    pub fn new() -> CChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupHeaderState header_state = 1;


    pub fn get_header_state(&self) -> &CChatRoomGroupHeaderState {
        self.header_state.as_ref().unwrap_or_else(|| <CChatRoomGroupHeaderState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header_state(&mut self) {
        self.header_state.clear();
    }

    pub fn has_header_state(&self) -> bool {
        self.header_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_state(&mut self, v: CChatRoomGroupHeaderState) {
        self.header_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_state(&mut self) -> &mut CChatRoomGroupHeaderState {
        if self.header_state.is_none() {
            self.header_state.set_default();
        }
        self.header_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_state(&mut self) -> CChatRoomGroupHeaderState {
        self.header_state.take().unwrap_or_else(|| CChatRoomGroupHeaderState::new())
    }

    // repeated .CChatRoomMember members = 2;


    pub fn get_members(&self) -> &[CChatRoomMember] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CChatRoomMember>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomMember> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CChatRoomMember> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional uint64 default_chat_id = 4;


    pub fn get_default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }
    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 5;


    pub fn get_chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }
    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::protobuf::RepeatedField<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::protobuf::RepeatedField<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::protobuf::RepeatedField::new())
    }

    // repeated .CChatRoomMember kicked = 7;


    pub fn get_kicked(&self) -> &[CChatRoomMember] {
        &self.kicked
    }
    pub fn clear_kicked(&mut self) {
        self.kicked.clear();
    }

    // Param is passed by value, moved
    pub fn set_kicked(&mut self, v: ::protobuf::RepeatedField<CChatRoomMember>) {
        self.kicked = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kicked(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomMember> {
        &mut self.kicked
    }

    // Take field
    pub fn take_kicked(&mut self) -> ::protobuf::RepeatedField<CChatRoomMember> {
        ::std::mem::replace(&mut self.kicked, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoomGroupState {
    fn is_initialized(&self) -> bool {
        for v in &self.header_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chat_rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kicked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header_state)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_chat_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_rooms)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kicked)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.kicked {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.default_chat_id {
            os.write_uint64(4, v)?;
        }
        for v in &self.chat_rooms {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.kicked {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomGroupState {
        CChatRoomGroupState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupHeaderState>>(
                "header_state",
                |m: &CChatRoomGroupState| { &m.header_state },
                |m: &mut CChatRoomGroupState| { &mut m.header_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMember>>(
                "members",
                |m: &CChatRoomGroupState| { &m.members },
                |m: &mut CChatRoomGroupState| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "default_chat_id",
                |m: &CChatRoomGroupState| { &m.default_chat_id },
                |m: &mut CChatRoomGroupState| { &mut m.default_chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                "chat_rooms",
                |m: &CChatRoomGroupState| { &m.chat_rooms },
                |m: &mut CChatRoomGroupState| { &mut m.chat_rooms },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMember>>(
                "kicked",
                |m: &CChatRoomGroupState| { &m.kicked },
                |m: &mut CChatRoomGroupState| { &mut m.kicked },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomGroupState>(
                "CChatRoomGroupState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomGroupState {
        static instance: ::protobuf::rt::LazyV2<CChatRoomGroupState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomGroupState::new)
    }
}

impl ::protobuf::Clear for CChatRoomGroupState {
    fn clear(&mut self) {
        self.header_state.clear();
        self.members.clear();
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.kicked.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CUserChatRoomState {
    // message fields
    chat_id: ::std::option::Option<u64>,
    time_joined: ::std::option::Option<u32>,
    time_last_ack: ::std::option::Option<u32>,
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    time_last_mention: ::std::option::Option<u32>,
    unread_indicator_muted: ::std::option::Option<bool>,
    time_first_unread: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomState {
    fn default() -> &'a CUserChatRoomState {
        <CUserChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomState {
    pub fn new() -> CUserChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;


    pub fn get_time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }
    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_ack = 3;


    pub fn get_time_last_ack(&self) -> u32 {
        self.time_last_ack.unwrap_or(0)
    }
    pub fn clear_time_last_ack(&mut self) {
        self.time_last_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_ack(&self) -> bool {
        self.time_last_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_ack(&mut self, v: u32) {
        self.time_last_ack = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_mention = 6;


    pub fn get_time_last_mention(&self) -> u32 {
        self.time_last_mention.unwrap_or(0)
    }
    pub fn clear_time_last_mention(&mut self) {
        self.time_last_mention = ::std::option::Option::None;
    }

    pub fn has_time_last_mention(&self) -> bool {
        self.time_last_mention.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_mention(&mut self, v: u32) {
        self.time_last_mention = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_unread = 8;


    pub fn get_time_first_unread(&self) -> u32 {
        self.time_first_unread.unwrap_or(0)
    }
    pub fn clear_time_first_unread(&mut self) {
        self.time_first_unread = ::std::option::Option::None;
    }

    pub fn has_time_first_unread(&self) -> bool {
        self.time_first_unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_unread(&mut self, v: u32) {
        self.time_first_unread = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CUserChatRoomState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_joined = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_ack = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_mention = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_first_unread = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_ack {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.time_last_mention {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        if let Some(v) = self.time_first_unread {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_ack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.time_last_mention {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.time_first_unread {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CUserChatRoomState {
        CUserChatRoomState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CUserChatRoomState| { &m.chat_id },
                |m: &mut CUserChatRoomState| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_joined",
                |m: &CUserChatRoomState| { &m.time_joined },
                |m: &mut CUserChatRoomState| { &mut m.time_joined },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last_ack",
                |m: &CUserChatRoomState| { &m.time_last_ack },
                |m: &mut CUserChatRoomState| { &mut m.time_last_ack },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "desktop_notification_level",
                |m: &CUserChatRoomState| { &m.desktop_notification_level },
                |m: &mut CUserChatRoomState| { &mut m.desktop_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "mobile_notification_level",
                |m: &CUserChatRoomState| { &m.mobile_notification_level },
                |m: &mut CUserChatRoomState| { &mut m.mobile_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last_mention",
                |m: &CUserChatRoomState| { &m.time_last_mention },
                |m: &mut CUserChatRoomState| { &mut m.time_last_mention },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unread_indicator_muted",
                |m: &CUserChatRoomState| { &m.unread_indicator_muted },
                |m: &mut CUserChatRoomState| { &mut m.unread_indicator_muted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_first_unread",
                |m: &CUserChatRoomState| { &m.time_first_unread },
                |m: &mut CUserChatRoomState| { &mut m.time_first_unread },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CUserChatRoomState>(
                "CUserChatRoomState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CUserChatRoomState {
        static instance: ::protobuf::rt::LazyV2<CUserChatRoomState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CUserChatRoomState::new)
    }
}

impl ::protobuf::Clear for CUserChatRoomState {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.time_last_ack = ::std::option::Option::None;
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_mention = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.time_first_unread = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CUserChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserChatRoomState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CUserChatRoomGroupState {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    time_joined: ::std::option::Option<u32>,
    pub user_chat_room_state: ::protobuf::RepeatedField<CUserChatRoomState>,
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    time_last_group_ack: ::std::option::Option<u32>,
    unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomGroupState {
    fn default() -> &'a CUserChatRoomGroupState {
        <CUserChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomGroupState {
    pub fn new() -> CUserChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;


    pub fn get_time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }
    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // repeated .CUserChatRoomState user_chat_room_state = 3;


    pub fn get_user_chat_room_state(&self) -> &[CUserChatRoomState] {
        &self.user_chat_room_state
    }
    pub fn clear_user_chat_room_state(&mut self) {
        self.user_chat_room_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_chat_room_state(&mut self, v: ::protobuf::RepeatedField<CUserChatRoomState>) {
        self.user_chat_room_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_chat_room_state(&mut self) -> &mut ::protobuf::RepeatedField<CUserChatRoomState> {
        &mut self.user_chat_room_state
    }

    // Take field
    pub fn take_user_chat_room_state(&mut self) -> ::protobuf::RepeatedField<CUserChatRoomState> {
        ::std::mem::replace(&mut self.user_chat_room_state, ::protobuf::RepeatedField::new())
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_group_ack = 6;


    pub fn get_time_last_group_ack(&self) -> u32 {
        self.time_last_group_ack.unwrap_or(0)
    }
    pub fn clear_time_last_group_ack(&mut self) {
        self.time_last_group_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_group_ack(&self) -> bool {
        self.time_last_group_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_group_ack(&mut self, v: u32) {
        self.time_last_group_ack = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CUserChatRoomGroupState {
    fn is_initialized(&self) -> bool {
        for v in &self.user_chat_room_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_joined = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_chat_room_state)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_group_ack = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_chat_room_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.time_last_group_ack {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        for v in &self.user_chat_room_state {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.time_last_group_ack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CUserChatRoomGroupState {
        CUserChatRoomGroupState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CUserChatRoomGroupState| { &m.chat_group_id },
                |m: &mut CUserChatRoomGroupState| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_joined",
                |m: &CUserChatRoomGroupState| { &m.time_joined },
                |m: &mut CUserChatRoomGroupState| { &mut m.time_joined },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomState>>(
                "user_chat_room_state",
                |m: &CUserChatRoomGroupState| { &m.user_chat_room_state },
                |m: &mut CUserChatRoomGroupState| { &mut m.user_chat_room_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "desktop_notification_level",
                |m: &CUserChatRoomGroupState| { &m.desktop_notification_level },
                |m: &mut CUserChatRoomGroupState| { &mut m.desktop_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "mobile_notification_level",
                |m: &CUserChatRoomGroupState| { &m.mobile_notification_level },
                |m: &mut CUserChatRoomGroupState| { &mut m.mobile_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last_group_ack",
                |m: &CUserChatRoomGroupState| { &m.time_last_group_ack },
                |m: &mut CUserChatRoomGroupState| { &mut m.time_last_group_ack },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unread_indicator_muted",
                |m: &CUserChatRoomGroupState| { &m.unread_indicator_muted },
                |m: &mut CUserChatRoomGroupState| { &mut m.unread_indicator_muted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CUserChatRoomGroupState>(
                "CUserChatRoomGroupState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CUserChatRoomGroupState {
        static instance: ::protobuf::rt::LazyV2<CUserChatRoomGroupState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CUserChatRoomGroupState::new)
    }
}

impl ::protobuf::Clear for CUserChatRoomGroupState {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.user_chat_room_state.clear();
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_group_ack = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CUserChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserChatRoomGroupState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateChatRoomGroup_Response {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    pub state: ::protobuf::SingularPtrField<CChatRoomGroupState>,
    pub user_chat_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Response {
        <CChatRoom_CreateChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Response {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomGroupState state = 2;


    pub fn get_state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| <CChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }

    // optional .CUserChatRoomGroupState user_chat_state = 3;


    pub fn get_user_chat_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_chat_state(&mut self) {
        self.user_chat_state.clear();
    }

    pub fn has_user_chat_state(&self) -> bool {
        self.user_chat_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_state.is_none() {
            self.user_chat_state.set_default();
        }
        self.user_chat_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_chat_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        CChatRoom_CreateChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.chat_group_id },
                |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                "state",
                |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.state },
                |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                "user_chat_state",
                |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.user_chat_state },
                |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.user_chat_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateChatRoomGroup_Response>(
                "CChatRoom_CreateChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoomGroup_Response {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.state.clear();
        self.user_chat_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SaveChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Request {
        <CChatRoom_SaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        CChatRoom_SaveChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.name },
                |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SaveChatRoomGroup_Request>(
                "CChatRoom_SaveChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SaveChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SaveChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SaveChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SaveChatRoomGroup_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Response {
        <CChatRoom_SaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        CChatRoom_SaveChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SaveChatRoomGroup_Response>(
                "CChatRoom_SaveChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SaveChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SaveChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SaveChatRoomGroup_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RenameChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Request {
        <CChatRoom_RenameChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Request {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        CChatRoom_RenameChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.name },
                |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RenameChatRoomGroup_Request>(
                "CChatRoom_RenameChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RenameChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RenameChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RenameChatRoomGroup_Response {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Response {
        <CChatRoom_RenameChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Response {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        CChatRoom_RenameChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_RenameChatRoomGroup_Response| { &m.name },
                |m: &mut CChatRoom_RenameChatRoomGroup_Response| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RenameChatRoomGroup_Response>(
                "CChatRoom_RenameChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RenameChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RenameChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoomGroup_Response {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetChatRoomGroupTagline_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    tagline: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Request {
        <CChatRoom_SetChatRoomGroupTagline_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string tagline = 2;


    pub fn get_tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagline(&mut self) {
        self.tagline.clear();
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline.set_default();
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagline)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.tagline.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        CChatRoom_SetChatRoomGroupTagline_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tagline",
                |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.tagline },
                |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.tagline },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetChatRoomGroupTagline_Request>(
                "CChatRoom_SetChatRoomGroupTagline_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetChatRoomGroupTagline_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetChatRoomGroupTagline_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupTagline_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.tagline.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupTagline_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetChatRoomGroupTagline_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Response {
        <CChatRoom_SetChatRoomGroupTagline_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        CChatRoom_SetChatRoomGroupTagline_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetChatRoomGroupTagline_Response>(
                "CChatRoom_SetChatRoomGroupTagline_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetChatRoomGroupTagline_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetChatRoomGroupTagline_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupTagline_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupTagline_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    avatar_sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Request {
        <CChatRoom_SetChatRoomGroupAvatar_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional bytes avatar_sha = 2;


    pub fn get_avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha.clear();
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha.set_default();
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.avatar_sha)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        CChatRoom_SetChatRoomGroupAvatar_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "avatar_sha",
                |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.avatar_sha },
                |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.avatar_sha },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetChatRoomGroupAvatar_Request>(
                "CChatRoom_SetChatRoomGroupAvatar_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetChatRoomGroupAvatar_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetChatRoomGroupAvatar_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.avatar_sha.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Response {
        <CChatRoom_SetChatRoomGroupAvatar_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        CChatRoom_SetChatRoomGroupAvatar_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetChatRoomGroupAvatar_Response>(
                "CChatRoom_SetChatRoomGroupAvatar_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetChatRoomGroupAvatar_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetChatRoomGroupAvatar_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 2;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 3;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "watching_broadcast_accountid",
                |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_accountid },
                |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "watching_broadcast_channel_id",
                |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_channel_id },
                |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_channel_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Request>(
                "CChatRoom_SetChatRoomGroupWatchingBroadcast_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetChatRoomGroupWatchingBroadcast_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Response>(
                "CChatRoom_SetChatRoomGroupWatchingBroadcast_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetChatRoomGroupWatchingBroadcast_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        CChatRoom_JoinMiniGameForChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &m.chat_id },
                |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &mut m.chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_JoinMiniGameForChatRoomGroup_Request>(
                "CChatRoom_JoinMiniGameForChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_JoinMiniGameForChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_JoinMiniGameForChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    // message fields
    minigame_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 minigame_id = 1;


    pub fn get_minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }
    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minigame_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.minigame_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.minigame_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        CChatRoom_JoinMiniGameForChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minigame_id",
                |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Response| { &m.minigame_id },
                |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Response| { &mut m.minigame_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_JoinMiniGameForChatRoomGroup_Response>(
                "CChatRoom_JoinMiniGameForChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_JoinMiniGameForChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_JoinMiniGameForChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn clear(&mut self) {
        self.minigame_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    minigame_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
        <CChatRoom_EndMiniGameForChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 minigame_id = 3;


    pub fn get_minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }
    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minigame_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minigame_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.minigame_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        CChatRoom_EndMiniGameForChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.chat_id },
                |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minigame_id",
                |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.minigame_id },
                |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.minigame_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_EndMiniGameForChatRoomGroup_Request>(
                "CChatRoom_EndMiniGameForChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_EndMiniGameForChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_EndMiniGameForChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.minigame_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
        <CChatRoom_EndMiniGameForChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        CChatRoom_EndMiniGameForChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_EndMiniGameForChatRoomGroup_Response>(
                "CChatRoom_EndMiniGameForChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_EndMiniGameForChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_EndMiniGameForChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_MuteUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    expiration: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Request {
    fn default() -> &'a CChatRoom_MuteUser_Request {
        <CChatRoom_MuteUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Request {
    pub fn new() -> CChatRoom_MuteUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;


    pub fn get_expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }
    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_MuteUser_Request {
        CChatRoom_MuteUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_MuteUser_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_MuteUser_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_MuteUser_Request| { &m.steamid },
                |m: &mut CChatRoom_MuteUser_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expiration",
                |m: &CChatRoom_MuteUser_Request| { &m.expiration },
                |m: &mut CChatRoom_MuteUser_Request| { &mut m.expiration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_MuteUser_Request>(
                "CChatRoom_MuteUser_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_MuteUser_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_MuteUser_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_MuteUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_MuteUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MuteUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_MuteUser_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Response {
    fn default() -> &'a CChatRoom_MuteUser_Response {
        <CChatRoom_MuteUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Response {
    pub fn new() -> CChatRoom_MuteUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_MuteUser_Response {
        CChatRoom_MuteUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_MuteUser_Response>(
                "CChatRoom_MuteUser_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_MuteUser_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_MuteUser_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_MuteUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_MuteUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MuteUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_KickUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    expiration: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Request {
    fn default() -> &'a CChatRoom_KickUser_Request {
        <CChatRoom_KickUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Request {
    pub fn new() -> CChatRoom_KickUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;


    pub fn get_expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }
    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_KickUser_Request {
        CChatRoom_KickUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_KickUser_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_KickUser_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_KickUser_Request| { &m.steamid },
                |m: &mut CChatRoom_KickUser_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expiration",
                |m: &CChatRoom_KickUser_Request| { &m.expiration },
                |m: &mut CChatRoom_KickUser_Request| { &mut m.expiration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_KickUser_Request>(
                "CChatRoom_KickUser_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_KickUser_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_KickUser_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_KickUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_KickUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_KickUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_KickUser_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Response {
    fn default() -> &'a CChatRoom_KickUser_Response {
        <CChatRoom_KickUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Response {
    pub fn new() -> CChatRoom_KickUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_KickUser_Response {
        CChatRoom_KickUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_KickUser_Response>(
                "CChatRoom_KickUser_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_KickUser_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_KickUser_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_KickUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_KickUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_KickUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetUserBanState_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    ban_state: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Request {
    fn default() -> &'a CChatRoom_SetUserBanState_Request {
        <CChatRoom_SetUserBanState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Request {
    pub fn new() -> CChatRoom_SetUserBanState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool ban_state = 3;


    pub fn get_ban_state(&self) -> bool {
        self.ban_state.unwrap_or(false)
    }
    pub fn clear_ban_state(&mut self) {
        self.ban_state = ::std::option::Option::None;
    }

    pub fn has_ban_state(&self) -> bool {
        self.ban_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_state(&mut self, v: bool) {
        self.ban_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ban_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.ban_state {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ban_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserBanState_Request {
        CChatRoom_SetUserBanState_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SetUserBanState_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_SetUserBanState_Request| { &m.steamid },
                |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ban_state",
                |m: &CChatRoom_SetUserBanState_Request| { &m.ban_state },
                |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.ban_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetUserBanState_Request>(
                "CChatRoom_SetUserBanState_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetUserBanState_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetUserBanState_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserBanState_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ban_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserBanState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserBanState_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetUserBanState_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Response {
    fn default() -> &'a CChatRoom_SetUserBanState_Response {
        <CChatRoom_SetUserBanState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Response {
    pub fn new() -> CChatRoom_SetUserBanState_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserBanState_Response {
        CChatRoom_SetUserBanState_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetUserBanState_Response>(
                "CChatRoom_SetUserBanState_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetUserBanState_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetUserBanState_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserBanState_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserBanState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserBanState_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RevokeInvite_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Request {
    fn default() -> &'a CChatRoom_RevokeInvite_Request {
        <CChatRoom_RevokeInvite_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Request {
    pub fn new() -> CChatRoom_RevokeInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RevokeInvite_Request {
        CChatRoom_RevokeInvite_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_RevokeInvite_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_RevokeInvite_Request| { &m.steamid },
                |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RevokeInvite_Request>(
                "CChatRoom_RevokeInvite_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RevokeInvite_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RevokeInvite_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RevokeInvite_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RevokeInvite_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RevokeInvite_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RevokeInvite_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Response {
    fn default() -> &'a CChatRoom_RevokeInvite_Response {
        <CChatRoom_RevokeInvite_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Response {
    pub fn new() -> CChatRoom_RevokeInvite_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RevokeInvite_Response {
        CChatRoom_RevokeInvite_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RevokeInvite_Response>(
                "CChatRoom_RevokeInvite_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RevokeInvite_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RevokeInvite_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RevokeInvite_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RevokeInvite_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RevokeInvite_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Request {
    fn default() -> &'a CChatRoom_CreateRole_Request {
        <CChatRoom_CreateRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Request {
    pub fn new() -> CChatRoom_CreateRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateRole_Request {
        CChatRoom_CreateRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_CreateRole_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_CreateRole_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_CreateRole_Request| { &m.name },
                |m: &mut CChatRoom_CreateRole_Request| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateRole_Request>(
                "CChatRoom_CreateRole_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateRole_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateRole_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateRole_Response {
    // message fields
    pub actions: ::protobuf::SingularPtrField<CChatRoleActions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Response {
    fn default() -> &'a CChatRoom_CreateRole_Response {
        <CChatRoom_CreateRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Response {
    pub fn new() -> CChatRoom_CreateRole_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoleActions actions = 2;


    pub fn get_actions(&self) -> &CChatRoleActions {
        self.actions.as_ref().unwrap_or_else(|| <CChatRoleActions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    pub fn has_actions(&self) -> bool {
        self.actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: CChatRoleActions) {
        self.actions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut CChatRoleActions {
        if self.actions.is_none() {
            self.actions.set_default();
        }
        self.actions.as_mut().unwrap()
    }

    // Take field
    pub fn take_actions(&mut self) -> CChatRoleActions {
        self.actions.take().unwrap_or_else(|| CChatRoleActions::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.actions.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateRole_Response {
        CChatRoom_CreateRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                "actions",
                |m: &CChatRoom_CreateRole_Response| { &m.actions },
                |m: &mut CChatRoom_CreateRole_Response| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateRole_Response>(
                "CChatRoom_CreateRole_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateRole_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateRole_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateRole_Response {
    fn clear(&mut self) {
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetRoles_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Request {
    fn default() -> &'a CChatRoom_GetRoles_Request {
        <CChatRoom_GetRoles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Request {
    pub fn new() -> CChatRoom_GetRoles_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoles_Request {
        CChatRoom_GetRoles_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetRoles_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetRoles_Request| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetRoles_Request>(
                "CChatRoom_GetRoles_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetRoles_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetRoles_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoles_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoles_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetRoles_Response {
    // message fields
    pub roles: ::protobuf::RepeatedField<CChatRole>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Response {
    fn default() -> &'a CChatRoom_GetRoles_Response {
        <CChatRoom_GetRoles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Response {
    pub fn new() -> CChatRoom_GetRoles_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRole roles = 1;


    pub fn get_roles(&self) -> &[CChatRole] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<CChatRole>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<CChatRole> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<CChatRole> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.roles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.roles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoles_Response {
        CChatRoom_GetRoles_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRole>>(
                "roles",
                |m: &CChatRoom_GetRoles_Response| { &m.roles },
                |m: &mut CChatRoom_GetRoles_Response| { &mut m.roles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetRoles_Response>(
                "CChatRoom_GetRoles_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetRoles_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetRoles_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoles_Response {
    fn clear(&mut self) {
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoles_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RenameRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Request {
    fn default() -> &'a CChatRoom_RenameRole_Request {
        <CChatRoom_RenameRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Request {
    pub fn new() -> CChatRoom_RenameRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameRole_Request {
        CChatRoom_RenameRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_RenameRole_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_RenameRole_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoom_RenameRole_Request| { &m.role_id },
                |m: &mut CChatRoom_RenameRole_Request| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_RenameRole_Request| { &m.name },
                |m: &mut CChatRoom_RenameRole_Request| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RenameRole_Request>(
                "CChatRoom_RenameRole_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RenameRole_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RenameRole_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RenameRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RenameRole_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Response {
    fn default() -> &'a CChatRoom_RenameRole_Response {
        <CChatRoom_RenameRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Response {
    pub fn new() -> CChatRoom_RenameRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameRole_Response {
        CChatRoom_RenameRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RenameRole_Response>(
                "CChatRoom_RenameRole_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RenameRole_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RenameRole_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RenameRole_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ReorderRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Request {
    fn default() -> &'a CChatRoom_ReorderRole_Request {
        <CChatRoom_ReorderRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Request {
    pub fn new() -> CChatRoom_ReorderRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderRole_Request {
        CChatRoom_ReorderRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_ReorderRole_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_ReorderRole_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoom_ReorderRole_Request| { &m.role_id },
                |m: &mut CChatRoom_ReorderRole_Request| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_ReorderRole_Request| { &m.ordinal },
                |m: &mut CChatRoom_ReorderRole_Request| { &mut m.ordinal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ReorderRole_Request>(
                "CChatRoom_ReorderRole_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ReorderRole_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ReorderRole_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ReorderRole_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Response {
    fn default() -> &'a CChatRoom_ReorderRole_Response {
        <CChatRoom_ReorderRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Response {
    pub fn new() -> CChatRoom_ReorderRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderRole_Response {
        CChatRoom_ReorderRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ReorderRole_Response>(
                "CChatRoom_ReorderRole_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ReorderRole_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ReorderRole_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderRole_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Request {
    fn default() -> &'a CChatRoom_DeleteRole_Request {
        <CChatRoom_DeleteRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Request {
    pub fn new() -> CChatRoom_DeleteRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRole_Request {
        CChatRoom_DeleteRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_DeleteRole_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_DeleteRole_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoom_DeleteRole_Request| { &m.role_id },
                |m: &mut CChatRoom_DeleteRole_Request| { &mut m.role_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteRole_Request>(
                "CChatRoom_DeleteRole_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteRole_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteRole_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteRole_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Response {
    fn default() -> &'a CChatRoom_DeleteRole_Response {
        <CChatRoom_DeleteRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Response {
    pub fn new() -> CChatRoom_DeleteRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRole_Response {
        CChatRoom_DeleteRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteRole_Response>(
                "CChatRoom_DeleteRole_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteRole_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteRole_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRole_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetRoleActions_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Request {
    fn default() -> &'a CChatRoom_GetRoleActions_Request {
        <CChatRoom_GetRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Request {
    pub fn new() -> CChatRoom_GetRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoleActions_Request {
        CChatRoom_GetRoleActions_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetRoleActions_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoom_GetRoleActions_Request| { &m.role_id },
                |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.role_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetRoleActions_Request>(
                "CChatRoom_GetRoleActions_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetRoleActions_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetRoleActions_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoleActions_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoleActions_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetRoleActions_Response {
    // message fields
    pub actions: ::protobuf::RepeatedField<CChatRoleActions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Response {
    fn default() -> &'a CChatRoom_GetRoleActions_Response {
        <CChatRoom_GetRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Response {
    pub fn new() -> CChatRoom_GetRoleActions_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoleActions actions = 1;


    pub fn get_actions(&self) -> &[CChatRoleActions] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<CChatRoleActions>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoleActions> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<CChatRoleActions> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoleActions_Response {
        CChatRoom_GetRoleActions_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                "actions",
                |m: &CChatRoom_GetRoleActions_Response| { &m.actions },
                |m: &mut CChatRoom_GetRoleActions_Response| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetRoleActions_Response>(
                "CChatRoom_GetRoleActions_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetRoleActions_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetRoleActions_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoleActions_Response {
    fn clear(&mut self) {
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoleActions_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ReplaceRoleActions_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    pub actions: ::protobuf::SingularPtrField<CChatRoleActions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Request {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Request {
        <CChatRoom_ReplaceRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Request {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoleActions actions = 4;


    pub fn get_actions(&self) -> &CChatRoleActions {
        self.actions.as_ref().unwrap_or_else(|| <CChatRoleActions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    pub fn has_actions(&self) -> bool {
        self.actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: CChatRoleActions) {
        self.actions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut CChatRoleActions {
        if self.actions.is_none() {
            self.actions.set_default();
        }
        self.actions.as_mut().unwrap()
    }

    // Take field
    pub fn take_actions(&mut self) -> CChatRoleActions {
        self.actions.take().unwrap_or_else(|| CChatRoleActions::new())
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.actions.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Request {
        CChatRoom_ReplaceRoleActions_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_ReplaceRoleActions_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoom_ReplaceRoleActions_Request| { &m.role_id },
                |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                "actions",
                |m: &CChatRoom_ReplaceRoleActions_Request| { &m.actions },
                |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ReplaceRoleActions_Request>(
                "CChatRoom_ReplaceRoleActions_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ReplaceRoleActions_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ReplaceRoleActions_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ReplaceRoleActions_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReplaceRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ReplaceRoleActions_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Response {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Response {
        <CChatRoom_ReplaceRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Response {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Response {
        CChatRoom_ReplaceRoleActions_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ReplaceRoleActions_Response>(
                "CChatRoom_ReplaceRoleActions_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ReplaceRoleActions_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ReplaceRoleActions_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ReplaceRoleActions_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReplaceRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_AddRoleToUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Request {
    fn default() -> &'a CChatRoom_AddRoleToUser_Request {
        <CChatRoom_AddRoleToUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Request {
    pub fn new() -> CChatRoom_AddRoleToUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_AddRoleToUser_Request {
        CChatRoom_AddRoleToUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_AddRoleToUser_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoom_AddRoleToUser_Request| { &m.role_id },
                |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_AddRoleToUser_Request| { &m.steamid },
                |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_AddRoleToUser_Request>(
                "CChatRoom_AddRoleToUser_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_AddRoleToUser_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_AddRoleToUser_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_AddRoleToUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_AddRoleToUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_AddRoleToUser_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Response {
    fn default() -> &'a CChatRoom_AddRoleToUser_Response {
        <CChatRoom_AddRoleToUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Response {
    pub fn new() -> CChatRoom_AddRoleToUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_AddRoleToUser_Response {
        CChatRoom_AddRoleToUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_AddRoleToUser_Response>(
                "CChatRoom_AddRoleToUser_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_AddRoleToUser_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_AddRoleToUser_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_AddRoleToUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_AddRoleToUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetRolesForUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Request {
    fn default() -> &'a CChatRoom_GetRolesForUser_Request {
        <CChatRoom_GetRolesForUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Request {
    pub fn new() -> CChatRoom_GetRolesForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRolesForUser_Request {
        CChatRoom_GetRolesForUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetRolesForUser_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_GetRolesForUser_Request| { &m.steamid },
                |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetRolesForUser_Request>(
                "CChatRoom_GetRolesForUser_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetRolesForUser_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetRolesForUser_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetRolesForUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRolesForUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetRolesForUser_Response {
    // message fields
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Response {
    fn default() -> &'a CChatRoom_GetRolesForUser_Response {
        <CChatRoom_GetRolesForUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Response {
    pub fn new() -> CChatRoom_GetRolesForUser_Response {
        ::std::default::Default::default()
    }

    // repeated uint64 role_ids = 1;


    pub fn get_role_ids(&self) -> &[u64] {
        &self.role_ids
    }
    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.role_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.role_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.role_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRolesForUser_Response {
        CChatRoom_GetRolesForUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_ids",
                |m: &CChatRoom_GetRolesForUser_Response| { &m.role_ids },
                |m: &mut CChatRoom_GetRolesForUser_Response| { &mut m.role_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetRolesForUser_Response>(
                "CChatRoom_GetRolesForUser_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetRolesForUser_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetRolesForUser_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetRolesForUser_Response {
    fn clear(&mut self) {
        self.role_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRolesForUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteRoleFromUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Request {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Request {
        <CChatRoom_DeleteRoleFromUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Request {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        CChatRoom_DeleteRoleFromUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.role_id },
                |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.steamid },
                |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteRoleFromUser_Request>(
                "CChatRoom_DeleteRoleFromUser_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteRoleFromUser_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteRoleFromUser_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRoleFromUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRoleFromUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteRoleFromUser_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Response {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Response {
        <CChatRoom_DeleteRoleFromUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Response {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        CChatRoom_DeleteRoleFromUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteRoleFromUser_Response>(
                "CChatRoom_DeleteRoleFromUser_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteRoleFromUser_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteRoleFromUser_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRoleFromUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRoleFromUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_JoinChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    invite_code: ::protobuf::SingularField<::std::string::String>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Request {
        <CChatRoom_JoinChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        CChatRoom_JoinChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invite_code",
                |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.invite_code },
                |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.invite_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_id },
                |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_JoinChatRoomGroup_Request>(
                "CChatRoom_JoinChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_JoinChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_JoinChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_JoinChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code.clear();
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_JoinChatRoomGroup_Response {
    // message fields
    pub state: ::protobuf::SingularPtrField<CChatRoomGroupState>,
    pub user_chat_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    join_chat_id: ::std::option::Option<u64>,
    time_expire: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Response {
        <CChatRoom_JoinChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupState state = 1;


    pub fn get_state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| <CChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }

    // optional .CUserChatRoomGroupState user_chat_state = 3;


    pub fn get_user_chat_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_chat_state(&mut self) {
        self.user_chat_state.clear();
    }

    pub fn has_user_chat_state(&self) -> bool {
        self.user_chat_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_state.is_none() {
            self.user_chat_state.set_default();
        }
        self.user_chat_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional uint64 join_chat_id = 4;


    pub fn get_join_chat_id(&self) -> u64 {
        self.join_chat_id.unwrap_or(0)
    }
    pub fn clear_join_chat_id(&mut self) {
        self.join_chat_id = ::std::option::Option::None;
    }

    pub fn has_join_chat_id(&self) -> bool {
        self.join_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_chat_id(&mut self, v: u64) {
        self.join_chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expire = 5;


    pub fn get_time_expire(&self) -> u32 {
        self.time_expire.unwrap_or(0)
    }
    pub fn clear_time_expire(&mut self) {
        self.time_expire = ::std::option::Option::None;
    }

    pub fn has_time_expire(&self) -> bool {
        self.time_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expire(&mut self, v: u32) {
        self.time_expire = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_chat_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_state)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.join_chat_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_expire = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.join_chat_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_expire {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.join_chat_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.time_expire {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        CChatRoom_JoinChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                "state",
                |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.state },
                |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                "user_chat_state",
                |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.user_chat_state },
                |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.user_chat_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "join_chat_id",
                |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.join_chat_id },
                |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.join_chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_expire",
                |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.time_expire },
                |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.time_expire },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_JoinChatRoomGroup_Response>(
                "CChatRoom_JoinChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_JoinChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_JoinChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_JoinChatRoomGroup_Response {
    fn clear(&mut self) {
        self.state.clear();
        self.user_chat_state.clear();
        self.join_chat_id = ::std::option::Option::None;
        self.time_expire = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    skip_friendsui_check: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
        <CChatRoom_InviteFriendToChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Request {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional bool skip_friendsui_check = 4;


    pub fn get_skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.unwrap_or(false)
    }
    pub fn clear_skip_friendsui_check(&mut self) {
        self.skip_friendsui_check = ::std::option::Option::None;
    }

    pub fn has_skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_friendsui_check(&mut self, v: bool) {
        self.skip_friendsui_check = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_friendsui_check = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skip_friendsui_check {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.skip_friendsui_check {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        CChatRoom_InviteFriendToChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.steamid },
                |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_id },
                |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skip_friendsui_check",
                |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.skip_friendsui_check },
                |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.skip_friendsui_check },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_InviteFriendToChatRoomGroup_Request>(
                "CChatRoom_InviteFriendToChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_InviteFriendToChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_InviteFriendToChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.skip_friendsui_check = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
        <CChatRoom_InviteFriendToChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Response {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        CChatRoom_InviteFriendToChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_InviteFriendToChatRoomGroup_Response>(
                "CChatRoom_InviteFriendToChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_InviteFriendToChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_InviteFriendToChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_LeaveChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Request {
        <CChatRoom_LeaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        CChatRoom_LeaveChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_LeaveChatRoomGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_LeaveChatRoomGroup_Request| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_LeaveChatRoomGroup_Request>(
                "CChatRoom_LeaveChatRoomGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_LeaveChatRoomGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_LeaveChatRoomGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_LeaveChatRoomGroup_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Response {
        <CChatRoom_LeaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        CChatRoom_LeaveChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_LeaveChatRoomGroup_Response>(
                "CChatRoom_LeaveChatRoomGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_LeaveChatRoomGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_LeaveChatRoomGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveChatRoomGroup_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    allow_voice: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Request {
    fn default() -> &'a CChatRoom_CreateChatRoom_Request {
        <CChatRoom_CreateChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Request {
    pub fn new() -> CChatRoom_CreateChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_voice = 3;


    pub fn get_allow_voice(&self) -> bool {
        self.allow_voice.unwrap_or(false)
    }
    pub fn clear_allow_voice(&mut self) {
        self.allow_voice = ::std::option::Option::None;
    }

    pub fn has_allow_voice(&self) -> bool {
        self.allow_voice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_voice(&mut self, v: bool) {
        self.allow_voice = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_voice = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.allow_voice {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.allow_voice {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoom_Request {
        CChatRoom_CreateChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_CreateChatRoom_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_CreateChatRoom_Request| { &m.name },
                |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_voice",
                |m: &CChatRoom_CreateChatRoom_Request| { &m.allow_voice },
                |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.allow_voice },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateChatRoom_Request>(
                "CChatRoom_CreateChatRoom_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateChatRoom_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateChatRoom_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.allow_voice = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateChatRoom_Response {
    // message fields
    pub chat_room: ::protobuf::SingularPtrField<CChatRoomState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Response {
    fn default() -> &'a CChatRoom_CreateChatRoom_Response {
        <CChatRoom_CreateChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Response {
    pub fn new() -> CChatRoom_CreateChatRoom_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomState chat_room = 1;


    pub fn get_chat_room(&self) -> &CChatRoomState {
        self.chat_room.as_ref().unwrap_or_else(|| <CChatRoomState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chat_room(&mut self) {
        self.chat_room.clear();
    }

    pub fn has_chat_room(&self) -> bool {
        self.chat_room.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room(&mut self, v: CChatRoomState) {
        self.chat_room = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_room(&mut self) -> &mut CChatRoomState {
        if self.chat_room.is_none() {
            self.chat_room.set_default();
        }
        self.chat_room.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_room(&mut self) -> CChatRoomState {
        self.chat_room.take().unwrap_or_else(|| CChatRoomState::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_room {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chat_room)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chat_room.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chat_room.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoom_Response {
        CChatRoom_CreateChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                "chat_room",
                |m: &CChatRoom_CreateChatRoom_Response| { &m.chat_room },
                |m: &mut CChatRoom_CreateChatRoom_Response| { &mut m.chat_room },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateChatRoom_Response>(
                "CChatRoom_CreateChatRoom_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateChatRoom_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateChatRoom_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoom_Response {
    fn clear(&mut self) {
        self.chat_room.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Request {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Request {
        <CChatRoom_DeleteChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Request {
    pub fn new() -> CChatRoom_DeleteChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatRoom_Request {
        CChatRoom_DeleteChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_id },
                |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteChatRoom_Request>(
                "CChatRoom_DeleteChatRoom_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteChatRoom_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteChatRoom_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteChatRoom_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Response {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Response {
        <CChatRoom_DeleteChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Response {
    pub fn new() -> CChatRoom_DeleteChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatRoom_Response {
        CChatRoom_DeleteChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteChatRoom_Response>(
                "CChatRoom_DeleteChatRoom_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteChatRoom_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteChatRoom_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatRoom_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RenameChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Request {
    fn default() -> &'a CChatRoom_RenameChatRoom_Request {
        <CChatRoom_RenameChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Request {
    pub fn new() -> CChatRoom_RenameChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoom_Request {
        CChatRoom_RenameChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_id },
                |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CChatRoom_RenameChatRoom_Request| { &m.name },
                |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RenameChatRoom_Request>(
                "CChatRoom_RenameChatRoom_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RenameChatRoom_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RenameChatRoom_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_RenameChatRoom_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Response {
    fn default() -> &'a CChatRoom_RenameChatRoom_Response {
        <CChatRoom_RenameChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Response {
    pub fn new() -> CChatRoom_RenameChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoom_Response {
        CChatRoom_RenameChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_RenameChatRoom_Response>(
                "CChatRoom_RenameChatRoom_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_RenameChatRoom_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_RenameChatRoom_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoom_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ReorderChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    move_after_chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Request {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Request {
        <CChatRoom_ReorderChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Request {
    pub fn new() -> CChatRoom_ReorderChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 move_after_chat_id = 3;


    pub fn get_move_after_chat_id(&self) -> u64 {
        self.move_after_chat_id.unwrap_or(0)
    }
    pub fn clear_move_after_chat_id(&mut self) {
        self.move_after_chat_id = ::std::option::Option::None;
    }

    pub fn has_move_after_chat_id(&self) -> bool {
        self.move_after_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_after_chat_id(&mut self, v: u64) {
        self.move_after_chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.move_after_chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.move_after_chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.move_after_chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderChatRoom_Request {
        CChatRoom_ReorderChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_id },
                |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "move_after_chat_id",
                |m: &CChatRoom_ReorderChatRoom_Request| { &m.move_after_chat_id },
                |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.move_after_chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ReorderChatRoom_Request>(
                "CChatRoom_ReorderChatRoom_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ReorderChatRoom_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ReorderChatRoom_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.move_after_chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ReorderChatRoom_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Response {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Response {
        <CChatRoom_ReorderChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Response {
    pub fn new() -> CChatRoom_ReorderChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderChatRoom_Response {
        CChatRoom_ReorderChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ReorderChatRoom_Response>(
                "CChatRoom_ReorderChatRoom_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ReorderChatRoom_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ReorderChatRoom_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderChatRoom_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SendChatMessage_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    message: ::protobuf::SingularField<::std::string::String>,
    echo_to_sender: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Request {
    fn default() -> &'a CChatRoom_SendChatMessage_Request {
        <CChatRoom_SendChatMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Request {
    pub fn new() -> CChatRoom_SendChatMessage_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool echo_to_sender = 4;


    pub fn get_echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }
    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.echo_to_sender = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SendChatMessage_Request {
        CChatRoom_SendChatMessage_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SendChatMessage_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_SendChatMessage_Request| { &m.chat_id },
                |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CChatRoom_SendChatMessage_Request| { &m.message },
                |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "echo_to_sender",
                |m: &CChatRoom_SendChatMessage_Request| { &m.echo_to_sender },
                |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.echo_to_sender },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SendChatMessage_Request>(
                "CChatRoom_SendChatMessage_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SendChatMessage_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SendChatMessage_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SendChatMessage_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.message.clear();
        self.echo_to_sender = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SendChatMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SendChatMessage_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SendChatMessage_Response {
    // message fields
    modified_message: ::protobuf::SingularField<::std::string::String>,
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    message_without_bb_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Response {
    fn default() -> &'a CChatRoom_SendChatMessage_Response {
        <CChatRoom_SendChatMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Response {
    pub fn new() -> CChatRoom_SendChatMessage_Response {
        ::std::default::Default::default()
    }

    // optional string modified_message = 1;


    pub fn get_modified_message(&self) -> &str {
        match self.modified_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_modified_message(&mut self) {
        self.modified_message.clear();
    }

    pub fn has_modified_message(&self) -> bool {
        self.modified_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_message(&mut self, v: ::std::string::String) {
        self.modified_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_message(&mut self) -> &mut ::std::string::String {
        if self.modified_message.is_none() {
            self.modified_message.set_default();
        }
        self.modified_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_message(&mut self) -> ::std::string::String {
        self.modified_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_timestamp = 2;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional string message_without_bb_code = 4;


    pub fn get_message_without_bb_code(&self) -> &str {
        match self.message_without_bb_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_without_bb_code(&mut self) {
        self.message_without_bb_code.clear();
    }

    pub fn has_message_without_bb_code(&self) -> bool {
        self.message_without_bb_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_without_bb_code(&mut self, v: ::std::string::String) {
        self.message_without_bb_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_without_bb_code(&mut self) -> &mut ::std::string::String {
        if self.message_without_bb_code.is_none() {
            self.message_without_bb_code.set_default();
        }
        self.message_without_bb_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_without_bb_code(&mut self) -> ::std::string::String {
        self.message_without_bb_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.modified_message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_without_bb_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.modified_message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_without_bb_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.modified_message.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.message_without_bb_code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SendChatMessage_Response {
        CChatRoom_SendChatMessage_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "modified_message",
                |m: &CChatRoom_SendChatMessage_Response| { &m.modified_message },
                |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.modified_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CChatRoom_SendChatMessage_Response| { &m.server_timestamp },
                |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_SendChatMessage_Response| { &m.ordinal },
                |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_without_bb_code",
                |m: &CChatRoom_SendChatMessage_Response| { &m.message_without_bb_code },
                |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.message_without_bb_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SendChatMessage_Response>(
                "CChatRoom_SendChatMessage_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SendChatMessage_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SendChatMessage_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SendChatMessage_Response {
    fn clear(&mut self) {
        self.modified_message.clear();
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.message_without_bb_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SendChatMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SendChatMessage_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_JoinVoiceChat_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Request {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Request {
        <CChatRoom_JoinVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Request {
    pub fn new() -> CChatRoom_JoinVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinVoiceChat_Request {
        CChatRoom_JoinVoiceChat_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_id },
                |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_JoinVoiceChat_Request>(
                "CChatRoom_JoinVoiceChat_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_JoinVoiceChat_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_JoinVoiceChat_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_JoinVoiceChat_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_JoinVoiceChat_Response {
    // message fields
    voice_chatid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Response {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Response {
        <CChatRoom_JoinVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Response {
    pub fn new() -> CChatRoom_JoinVoiceChat_Response {
        ::std::default::Default::default()
    }

    // optional uint64 voice_chatid = 1;


    pub fn get_voice_chatid(&self) -> u64 {
        self.voice_chatid.unwrap_or(0)
    }
    pub fn clear_voice_chatid(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
    }

    pub fn has_voice_chatid(&self) -> bool {
        self.voice_chatid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chatid(&mut self, v: u64) {
        self.voice_chatid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.voice_chatid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.voice_chatid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.voice_chatid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinVoiceChat_Response {
        CChatRoom_JoinVoiceChat_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "voice_chatid",
                |m: &CChatRoom_JoinVoiceChat_Response| { &m.voice_chatid },
                |m: &mut CChatRoom_JoinVoiceChat_Response| { &mut m.voice_chatid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_JoinVoiceChat_Response>(
                "CChatRoom_JoinVoiceChat_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_JoinVoiceChat_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_JoinVoiceChat_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_JoinVoiceChat_Response {
    fn clear(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_LeaveVoiceChat_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Request {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Request {
        <CChatRoom_LeaveVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Request {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Request {
        CChatRoom_LeaveVoiceChat_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_id },
                |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_LeaveVoiceChat_Request>(
                "CChatRoom_LeaveVoiceChat_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_LeaveVoiceChat_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_LeaveVoiceChat_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveVoiceChat_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_LeaveVoiceChat_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Response {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Response {
        <CChatRoom_LeaveVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Response {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Response {
        CChatRoom_LeaveVoiceChat_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_LeaveVoiceChat_Response>(
                "CChatRoom_LeaveVoiceChat_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_LeaveVoiceChat_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_LeaveVoiceChat_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveVoiceChat_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMessageHistory_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    last_time: ::std::option::Option<u32>,
    last_ordinal: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    start_ordinal: ::std::option::Option<u32>,
    max_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Request {
    fn default() -> &'a CChatRoom_GetMessageHistory_Request {
        <CChatRoom_GetMessageHistory_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Request {
    pub fn new() -> CChatRoom_GetMessageHistory_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time = 3;


    pub fn get_last_time(&self) -> u32 {
        self.last_time.unwrap_or(0)
    }
    pub fn clear_last_time(&mut self) {
        self.last_time = ::std::option::Option::None;
    }

    pub fn has_last_time(&self) -> bool {
        self.last_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time(&mut self, v: u32) {
        self.last_time = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ordinal = 4;


    pub fn get_last_ordinal(&self) -> u32 {
        self.last_ordinal.unwrap_or(0)
    }
    pub fn clear_last_ordinal(&mut self) {
        self.last_ordinal = ::std::option::Option::None;
    }

    pub fn has_last_ordinal(&self) -> bool {
        self.last_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ordinal(&mut self, v: u32) {
        self.last_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 5;


    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 start_ordinal = 6;


    pub fn get_start_ordinal(&self) -> u32 {
        self.start_ordinal.unwrap_or(0)
    }
    pub fn clear_start_ordinal(&mut self) {
        self.start_ordinal = ::std::option::Option::None;
    }

    pub fn has_start_ordinal(&self) -> bool {
        self.start_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_ordinal(&mut self, v: u32) {
        self.start_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 max_count = 7;


    pub fn get_max_count(&self) -> u32 {
        self.max_count.unwrap_or(0)
    }
    pub fn clear_max_count(&mut self) {
        self.max_count = ::std::option::Option::None;
    }

    pub fn has_max_count(&self) -> bool {
        self.max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: u32) {
        self.max_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_ordinal = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_ordinal = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_ordinal {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_count {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.last_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.start_ordinal {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_count {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageHistory_Request {
        CChatRoom_GetMessageHistory_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_id },
                |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_time",
                |m: &CChatRoom_GetMessageHistory_Request| { &m.last_time },
                |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_ordinal",
                |m: &CChatRoom_GetMessageHistory_Request| { &m.last_ordinal },
                |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_time",
                |m: &CChatRoom_GetMessageHistory_Request| { &m.start_time },
                |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_ordinal",
                |m: &CChatRoom_GetMessageHistory_Request| { &m.start_ordinal },
                |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_count",
                |m: &CChatRoom_GetMessageHistory_Request| { &m.max_count },
                |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.max_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMessageHistory_Request>(
                "CChatRoom_GetMessageHistory_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMessageHistory_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMessageHistory_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageHistory_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.last_time = ::std::option::Option::None;
        self.last_ordinal = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.start_ordinal = ::std::option::Option::None;
        self.max_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageHistory_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerMessage {
    // message fields
    message: ::std::option::Option<EChatRoomServerMessage>,
    string_param: ::protobuf::SingularField<::std::string::String>,
    accountid_param: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerMessage {
    fn default() -> &'a ServerMessage {
        <ServerMessage as ::protobuf::Message>::default_instance()
    }
}

impl ServerMessage {
    pub fn new() -> ServerMessage {
        ::std::default::Default::default()
    }

    // optional .EChatRoomServerMessage message = 1;


    pub fn get_message(&self) -> EChatRoomServerMessage {
        self.message.unwrap_or(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid)
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: EChatRoomServerMessage) {
        self.message = ::std::option::Option::Some(v);
    }

    // optional string string_param = 2;


    pub fn get_string_param(&self) -> &str {
        match self.string_param.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_string_param(&mut self) {
        self.string_param.clear();
    }

    pub fn has_string_param(&self) -> bool {
        self.string_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param(&mut self, v: ::std::string::String) {
        self.string_param = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param(&mut self) -> &mut ::std::string::String {
        if self.string_param.is_none() {
            self.string_param.set_default();
        }
        self.string_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param(&mut self) -> ::std::string::String {
        self.string_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_param = 3;


    pub fn get_accountid_param(&self) -> u32 {
        self.accountid_param.unwrap_or(0)
    }
    pub fn clear_accountid_param(&mut self) {
        self.accountid_param = ::std::option::Option::None;
    }

    pub fn has_accountid_param(&self) -> bool {
        self.accountid_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_param(&mut self, v: u32) {
        self.accountid_param = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.message, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_param)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_param = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.message {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.string_param.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.accountid_param {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.string_param.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.accountid_param {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerMessage {
        ServerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomServerMessage>>(
                "message",
                |m: &ServerMessage| { &m.message },
                |m: &mut ServerMessage| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string_param",
                |m: &ServerMessage| { &m.string_param },
                |m: &mut ServerMessage| { &mut m.string_param },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_param",
                |m: &ServerMessage| { &m.accountid_param },
                |m: &mut ServerMessage| { &mut m.accountid_param },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerMessage>(
                "ServerMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerMessage {
        static instance: ::protobuf::rt::LazyV2<ServerMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerMessage::new)
    }
}

impl ::protobuf::Clear for ServerMessage {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.string_param.clear();
        self.accountid_param = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMessageHistory_Response {
    // message fields
    pub messages: ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage>,
    more_available: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response {
        <CChatRoom_GetMessageHistory_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response {
    pub fn new() -> CChatRoom_GetMessageHistory_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetMessageHistory_Response.ChatMessage messages = 1;


    pub fn get_messages(&self) -> &[CChatRoom_GetMessageHistory_Response_ChatMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }

    // optional bool more_available = 4;


    pub fn get_more_available(&self) -> bool {
        self.more_available.unwrap_or(false)
    }
    pub fn clear_more_available(&mut self) {
        self.more_available = ::std::option::Option::None;
    }

    pub fn has_more_available(&self) -> bool {
        self.more_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_more_available(&mut self, v: bool) {
        self.more_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.more_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.more_available {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.more_available {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageHistory_Response {
        CChatRoom_GetMessageHistory_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetMessageHistory_Response_ChatMessage>>(
                "messages",
                |m: &CChatRoom_GetMessageHistory_Response| { &m.messages },
                |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "more_available",
                |m: &CChatRoom_GetMessageHistory_Response| { &m.more_available },
                |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.more_available },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMessageHistory_Response>(
                "CChatRoom_GetMessageHistory_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMessageHistory_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMessageHistory_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageHistory_Response {
    fn clear(&mut self) {
        self.messages.clear();
        self.more_available = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageHistory_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMessageHistory_Response_ChatMessage {
    // message fields
    sender: ::std::option::Option<u32>,
    server_timestamp: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    ordinal: ::std::option::Option<u32>,
    pub server_message: ::protobuf::SingularPtrField<ServerMessage>,
    deleted: ::std::option::Option<bool>,
    pub reactions: ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response_ChatMessage {
        <CChatRoom_GetMessageHistory_Response_ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response_ChatMessage {
    pub fn new() -> CChatRoom_GetMessageHistory_Response_ChatMessage {
        ::std::default::Default::default()
    }

    // optional uint32 sender = 1;


    pub fn get_sender(&self) -> u32 {
        self.sender.unwrap_or(0)
    }
    pub fn clear_sender(&mut self) {
        self.sender = ::std::option::Option::None;
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: u32) {
        self.sender = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 2;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 4;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .ServerMessage server_message = 5;


    pub fn get_server_message(&self) -> &ServerMessage {
        self.server_message.as_ref().unwrap_or_else(|| <ServerMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_message(&mut self) {
        self.server_message.clear();
    }

    pub fn has_server_message(&self) -> bool {
        self.server_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_message(&mut self, v: ServerMessage) {
        self.server_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_message(&mut self) -> &mut ServerMessage {
        if self.server_message.is_none() {
            self.server_message.set_default();
        }
        self.server_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_message(&mut self) -> ServerMessage {
        self.server_message.take().unwrap_or_else(|| ServerMessage::new())
    }

    // optional bool deleted = 6;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction reactions = 7;


    pub fn get_reactions(&self) -> &[CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction] {
        &self.reactions
    }
    pub fn clear_reactions(&mut self) {
        self.reactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_reactions(&mut self, v: ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction>) {
        self.reactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reactions(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction> {
        &mut self.reactions
    }

    // Take field
    pub fn take_reactions(&mut self) -> ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction> {
        ::std::mem::replace(&mut self.reactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.server_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sender = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_message)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sender {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        for value in &self.reactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sender {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.server_message.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(6, v)?;
        }
        for v in &self.reactions {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageHistory_Response_ChatMessage {
        CChatRoom_GetMessageHistory_Response_ChatMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sender",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.sender },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.server_timestamp },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.message },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.ordinal },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerMessage>>(
                "server_message",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.server_message },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.server_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.deleted },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction>>(
                "reactions",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.reactions },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.reactions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMessageHistory_Response_ChatMessage>(
                "CChatRoom_GetMessageHistory_Response.ChatMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response_ChatMessage {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMessageHistory_Response_ChatMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMessageHistory_Response_ChatMessage::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn clear(&mut self) {
        self.sender = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.message.clear();
        self.ordinal = ::std::option::Option::None;
        self.server_message.clear();
        self.deleted = ::std::option::Option::None;
        self.reactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
    // message fields
    reaction_type: ::std::option::Option<EChatRoomMessageReactionType>,
    reaction: ::protobuf::SingularField<::std::string::String>,
    num_reactors: ::std::option::Option<u32>,
    has_user_reacted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
        <CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
    pub fn new() -> CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
        ::std::default::Default::default()
    }

    // optional .EChatRoomMessageReactionType reaction_type = 1;


    pub fn get_reaction_type(&self) -> EChatRoomMessageReactionType {
        self.reaction_type.unwrap_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid)
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(v);
    }

    // optional string reaction = 2;


    pub fn get_reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reaction(&mut self) {
        self.reaction.clear();
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction.set_default();
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_reactors = 3;


    pub fn get_num_reactors(&self) -> u32 {
        self.num_reactors.unwrap_or(0)
    }
    pub fn clear_num_reactors(&mut self) {
        self.num_reactors = ::std::option::Option::None;
    }

    pub fn has_num_reactors(&self) -> bool {
        self.num_reactors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reactors(&mut self, v: u32) {
        self.num_reactors = ::std::option::Option::Some(v);
    }

    // optional bool has_user_reacted = 4;


    pub fn get_has_user_reacted(&self) -> bool {
        self.has_user_reacted.unwrap_or(false)
    }
    pub fn clear_has_user_reacted(&mut self) {
        self.has_user_reacted = ::std::option::Option::None;
    }

    pub fn has_has_user_reacted(&self) -> bool {
        self.has_user_reacted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_user_reacted(&mut self, v: bool) {
        self.has_user_reacted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reaction)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_reactors = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_user_reacted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.num_reactors {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.has_user_reacted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reaction_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.reaction.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.num_reactors {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.has_user_reacted {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
        CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMessageReactionType>>(
                "reaction_type",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &m.reaction_type },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reaction",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &m.reaction },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &mut m.reaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_reactors",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &m.num_reactors },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &mut m.num_reactors },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_user_reacted",
                |m: &CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &m.has_user_reacted },
                |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction| { &mut m.has_user_reacted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction>(
                "CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
    fn clear(&mut self) {
        self.reaction_type = ::std::option::Option::None;
        self.reaction.clear();
        self.num_reactors = ::std::option::Option::None;
        self.has_user_reacted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Response_ChatMessage_MessageReaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMyChatRoomGroups_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Request {
        <CChatRoom_GetMyChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Request {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        CChatRoom_GetMyChatRoomGroups_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMyChatRoomGroups_Request>(
                "CChatRoom_GetMyChatRoomGroups_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMyChatRoomGroups_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMyChatRoomGroups_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMyChatRoomGroups_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMyChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetChatRoomGroupSummary_Response {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_group_name: ::protobuf::SingularField<::std::string::String>,
    active_member_count: ::std::option::Option<u32>,
    active_voice_member_count: ::std::option::Option<u32>,
    default_chat_id: ::std::option::Option<u64>,
    pub chat_rooms: ::protobuf::RepeatedField<CChatRoomState>,
    clanid: ::std::option::Option<u32>,
    chat_group_tagline: ::protobuf::SingularField<::std::string::String>,
    accountid_owner: ::std::option::Option<u32>,
    pub top_members: ::std::vec::Vec<u32>,
    chat_group_avatar_sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rank: ::std::option::Option<EChatRoomGroupRank>,
    default_role_id: ::std::option::Option<u64>,
    pub role_ids: ::std::vec::Vec<u64>,
    pub role_actions: ::protobuf::RepeatedField<CChatRoleActions>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    pub party_beacons: ::protobuf::RepeatedField<CChatPartyBeacon>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    active_minigame_id: ::std::option::Option<u64>,
    avatar_ugc_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Response {
        <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_group_name = 2;


    pub fn get_chat_group_name(&self) -> &str {
        match self.chat_group_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_group_name(&mut self) {
        self.chat_group_name.clear();
    }

    pub fn has_chat_group_name(&self) -> bool {
        self.chat_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_name(&mut self, v: ::std::string::String) {
        self.chat_group_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_name(&mut self) -> &mut ::std::string::String {
        if self.chat_group_name.is_none() {
            self.chat_group_name.set_default();
        }
        self.chat_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_name(&mut self) -> ::std::string::String {
        self.chat_group_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_member_count = 3;


    pub fn get_active_member_count(&self) -> u32 {
        self.active_member_count.unwrap_or(0)
    }
    pub fn clear_active_member_count(&mut self) {
        self.active_member_count = ::std::option::Option::None;
    }

    pub fn has_active_member_count(&self) -> bool {
        self.active_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_member_count(&mut self, v: u32) {
        self.active_member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_voice_member_count = 4;


    pub fn get_active_voice_member_count(&self) -> u32 {
        self.active_voice_member_count.unwrap_or(0)
    }
    pub fn clear_active_voice_member_count(&mut self) {
        self.active_voice_member_count = ::std::option::Option::None;
    }

    pub fn has_active_voice_member_count(&self) -> bool {
        self.active_voice_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_voice_member_count(&mut self, v: u32) {
        self.active_voice_member_count = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 5;


    pub fn get_default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }
    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 6;


    pub fn get_chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }
    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::protobuf::RepeatedField<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::protobuf::RepeatedField<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::protobuf::RepeatedField::new())
    }

    // optional uint32 clanid = 7;


    pub fn get_clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }
    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional string chat_group_tagline = 8;


    pub fn get_chat_group_tagline(&self) -> &str {
        match self.chat_group_tagline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_group_tagline(&mut self) {
        self.chat_group_tagline.clear();
    }

    pub fn has_chat_group_tagline(&self) -> bool {
        self.chat_group_tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_tagline(&mut self, v: ::std::string::String) {
        self.chat_group_tagline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_tagline(&mut self) -> &mut ::std::string::String {
        if self.chat_group_tagline.is_none() {
            self.chat_group_tagline.set_default();
        }
        self.chat_group_tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_tagline(&mut self) -> ::std::string::String {
        self.chat_group_tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_owner = 9;


    pub fn get_accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }
    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // repeated uint32 top_members = 10;


    pub fn get_top_members(&self) -> &[u32] {
        &self.top_members
    }
    pub fn clear_top_members(&mut self) {
        self.top_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_top_members(&mut self, v: ::std::vec::Vec<u32>) {
        self.top_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_top_members(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.top_members
    }

    // Take field
    pub fn take_top_members(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.top_members, ::std::vec::Vec::new())
    }

    // optional bytes chat_group_avatar_sha = 11;


    pub fn get_chat_group_avatar_sha(&self) -> &[u8] {
        match self.chat_group_avatar_sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_chat_group_avatar_sha(&mut self) {
        self.chat_group_avatar_sha.clear();
    }

    pub fn has_chat_group_avatar_sha(&self) -> bool {
        self.chat_group_avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.chat_group_avatar_sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chat_group_avatar_sha.is_none() {
            self.chat_group_avatar_sha.set_default();
        }
        self.chat_group_avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.chat_group_avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EChatRoomGroupRank rank = 12;


    pub fn get_rank(&self) -> EChatRoomGroupRank {
        self.rank.unwrap_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint64 default_role_id = 13;


    pub fn get_default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }
    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // repeated uint64 role_ids = 14;


    pub fn get_role_ids(&self) -> &[u64] {
        &self.role_ids
    }
    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }

    // repeated .CChatRoleActions role_actions = 15;


    pub fn get_role_actions(&self) -> &[CChatRoleActions] {
        &self.role_actions
    }
    pub fn clear_role_actions(&mut self) {
        self.role_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_actions(&mut self, v: ::protobuf::RepeatedField<CChatRoleActions>) {
        self.role_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_actions(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoleActions> {
        &mut self.role_actions
    }

    // Take field
    pub fn take_role_actions(&mut self) -> ::protobuf::RepeatedField<CChatRoleActions> {
        ::std::mem::replace(&mut self.role_actions, ::protobuf::RepeatedField::new())
    }

    // optional uint32 watching_broadcast_accountid = 16;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 17;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated .CChatPartyBeacon party_beacons = 18;


    pub fn get_party_beacons(&self) -> &[CChatPartyBeacon] {
        &self.party_beacons
    }
    pub fn clear_party_beacons(&mut self) {
        self.party_beacons.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_beacons(&mut self, v: ::protobuf::RepeatedField<CChatPartyBeacon>) {
        self.party_beacons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_beacons(&mut self) -> &mut ::protobuf::RepeatedField<CChatPartyBeacon> {
        &mut self.party_beacons
    }

    // Take field
    pub fn take_party_beacons(&mut self) -> ::protobuf::RepeatedField<CChatPartyBeacon> {
        ::std::mem::replace(&mut self.party_beacons, ::protobuf::RepeatedField::new())
    }

    // optional uint64 watching_broadcast_channel_id = 19;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 20;


    pub fn get_active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }
    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 21;


    pub fn get_avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url.clear();
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url.set_default();
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.role_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.party_beacons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_group_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_member_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_voice_member_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_chat_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_rooms)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clanid = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_group_tagline)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_owner = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.top_members)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.chat_group_avatar_sha)?;
                },
                12 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.rank, 12, &mut self.unknown_fields)?
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_role_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.role_ids)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_actions)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.party_beacons)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.active_minigame_id = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.avatar_ugc_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.active_member_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_voice_member_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_group_tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.top_members {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.chat_group_avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::enum_size(12, v);
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.avatar_ugc_url.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_group_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.active_member_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_voice_member_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.chat_rooms {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.clanid {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.chat_group_tagline.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(9, v)?;
        }
        for v in &self.top_members {
            os.write_uint32(10, *v)?;
        };
        if let Some(ref v) = self.chat_group_avatar_sha.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(v) = self.rank {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(14, *v)?;
        };
        for v in &self.role_actions {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(17, v)?;
        }
        for v in &self.party_beacons {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(20, v)?;
        }
        if let Some(ref v) = self.avatar_ugc_url.as_ref() {
            os.write_string(21, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        CChatRoom_GetChatRoomGroupSummary_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_id },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chat_group_name",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_name },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_member_count",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_member_count },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_member_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_voice_member_count",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_voice_member_count },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_voice_member_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "default_chat_id",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_chat_id },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                "chat_rooms",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_rooms },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_rooms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "clanid",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.clanid },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.clanid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chat_group_tagline",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_tagline },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_tagline },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_owner",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.accountid_owner },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.accountid_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "top_members",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.top_members },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.top_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chat_group_avatar_sha",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_avatar_sha },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_avatar_sha },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomGroupRank>>(
                "rank",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.rank },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "default_role_id",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_role_id },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_ids",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_ids },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                "role_actions",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_actions },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "watching_broadcast_accountid",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_accountid },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.appid },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatPartyBeacon>>(
                "party_beacons",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.party_beacons },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.party_beacons },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "watching_broadcast_channel_id",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_channel_id },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "active_minigame_id",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_minigame_id },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_minigame_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "avatar_ugc_url",
                |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.avatar_ugc_url },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.avatar_ugc_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetChatRoomGroupSummary_Response>(
                "CChatRoom_GetChatRoomGroupSummary_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetChatRoomGroupSummary_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetChatRoomGroupSummary_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupSummary_Response {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_name.clear();
        self.active_member_count = ::std::option::Option::None;
        self.active_voice_member_count = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.clanid = ::std::option::Option::None;
        self.chat_group_tagline.clear();
        self.accountid_owner = ::std::option::Option::None;
        self.top_members.clear();
        self.chat_group_avatar_sha.clear();
        self.rank = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.role_ids.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupSummary_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomSummaryPair {
    // message fields
    pub user_chat_group_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    pub group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomSummaryPair {
    fn default() -> &'a CChatRoomSummaryPair {
        <CChatRoomSummaryPair as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomSummaryPair {
    pub fn new() -> CChatRoomSummaryPair {
        ::std::default::Default::default()
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 1;


    pub fn get_user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_group_state.is_none() {
            self.user_chat_group_state.set_default();
        }
        self.user_chat_group_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 2;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }
}

impl ::protobuf::Message for CChatRoomSummaryPair {
    fn is_initialized(&self) -> bool {
        for v in &self.user_chat_group_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_group_state)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomSummaryPair {
        CChatRoomSummaryPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                "user_chat_group_state",
                |m: &CChatRoomSummaryPair| { &m.user_chat_group_state },
                |m: &mut CChatRoomSummaryPair| { &mut m.user_chat_group_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                "group_summary",
                |m: &CChatRoomSummaryPair| { &m.group_summary },
                |m: &mut CChatRoomSummaryPair| { &mut m.group_summary },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomSummaryPair>(
                "CChatRoomSummaryPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomSummaryPair {
        static instance: ::protobuf::rt::LazyV2<CChatRoomSummaryPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomSummaryPair::new)
    }
}

impl ::protobuf::Clear for CChatRoomSummaryPair {
    fn clear(&mut self) {
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomSummaryPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomSummaryPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMyChatRoomGroups_Response {
    // message fields
    pub chat_room_groups: ::protobuf::RepeatedField<CChatRoomSummaryPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Response {
        <CChatRoom_GetMyChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Response {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomSummaryPair chat_room_groups = 1;


    pub fn get_chat_room_groups(&self) -> &[CChatRoomSummaryPair] {
        &self.chat_room_groups
    }
    pub fn clear_chat_room_groups(&mut self) {
        self.chat_room_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_room_groups(&mut self, v: ::protobuf::RepeatedField<CChatRoomSummaryPair>) {
        self.chat_room_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_room_groups(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomSummaryPair> {
        &mut self.chat_room_groups
    }

    // Take field
    pub fn take_chat_room_groups(&mut self) -> ::protobuf::RepeatedField<CChatRoomSummaryPair> {
        ::std::mem::replace(&mut self.chat_room_groups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_room_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_room_groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chat_room_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chat_room_groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        CChatRoom_GetMyChatRoomGroups_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomSummaryPair>>(
                "chat_room_groups",
                |m: &CChatRoom_GetMyChatRoomGroups_Response| { &m.chat_room_groups },
                |m: &mut CChatRoom_GetMyChatRoomGroups_Response| { &mut m.chat_room_groups },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMyChatRoomGroups_Response>(
                "CChatRoom_GetMyChatRoomGroups_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMyChatRoomGroups_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMyChatRoomGroups_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMyChatRoomGroups_Response {
    fn clear(&mut self) {
        self.chat_room_groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMyChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetChatRoomGroupState_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Request {
        <CChatRoom_GetChatRoomGroupState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        CChatRoom_GetChatRoomGroupState_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetChatRoomGroupState_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetChatRoomGroupState_Request| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetChatRoomGroupState_Request>(
                "CChatRoom_GetChatRoomGroupState_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetChatRoomGroupState_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetChatRoomGroupState_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupState_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetChatRoomGroupState_Response {
    // message fields
    pub state: ::protobuf::SingularPtrField<CChatRoomGroupState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Response {
        <CChatRoom_GetChatRoomGroupState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupState state = 1;


    pub fn get_state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| <CChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        CChatRoom_GetChatRoomGroupState_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                "state",
                |m: &CChatRoom_GetChatRoomGroupState_Response| { &m.state },
                |m: &mut CChatRoom_GetChatRoomGroupState_Response| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetChatRoomGroupState_Response>(
                "CChatRoom_GetChatRoomGroupState_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetChatRoomGroupState_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetChatRoomGroupState_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupState_Response {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetChatRoomGroupSummary_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Request {
        <CChatRoom_GetChatRoomGroupSummary_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        CChatRoom_GetChatRoomGroupSummary_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetChatRoomGroupSummary_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetChatRoomGroupSummary_Request| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetChatRoomGroupSummary_Request>(
                "CChatRoom_GetChatRoomGroupSummary_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetChatRoomGroupSummary_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetChatRoomGroupSummary_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupSummary_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupSummary_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    requesting_app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
        <CChatRoom_SetAppChatRoomGroupForceActive_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Request {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;


    pub fn get_requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }
    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.requesting_app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        CChatRoom_SetAppChatRoomGroupForceActive_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SetAppChatRoomGroupForceActive_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "requesting_app_id",
                |m: &CChatRoom_SetAppChatRoomGroupForceActive_Request| { &m.requesting_app_id },
                |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Request| { &mut m.requesting_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetAppChatRoomGroupForceActive_Request>(
                "CChatRoom_SetAppChatRoomGroupForceActive_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetAppChatRoomGroupForceActive_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetAppChatRoomGroupForceActive_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Response {
    // message fields
    result: ::std::option::Option<u32>,
    pub accounts_in_channel: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
        <CChatRoom_SetAppChatRoomGroupForceActive_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Response {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // repeated uint32 accounts_in_channel = 2;


    pub fn get_accounts_in_channel(&self) -> &[u32] {
        &self.accounts_in_channel
    }
    pub fn clear_accounts_in_channel(&mut self) {
        self.accounts_in_channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts_in_channel(&mut self, v: ::std::vec::Vec<u32>) {
        self.accounts_in_channel = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts_in_channel(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accounts_in_channel
    }

    // Take field
    pub fn take_accounts_in_channel(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accounts_in_channel, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.accounts_in_channel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.accounts_in_channel {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.accounts_in_channel {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        CChatRoom_SetAppChatRoomGroupForceActive_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CChatRoom_SetAppChatRoomGroupForceActive_Response| { &m.result },
                |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Response| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accounts_in_channel",
                |m: &CChatRoom_SetAppChatRoomGroupForceActive_Response| { &m.accounts_in_channel },
                |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Response| { &mut m.accounts_in_channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetAppChatRoomGroupForceActive_Response>(
                "CChatRoom_SetAppChatRoomGroupForceActive_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetAppChatRoomGroupForceActive_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetAppChatRoomGroupForceActive_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.accounts_in_channel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    requesting_app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        <CChatRoom_SetAppChatRoomGroupStopForceActive_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;


    pub fn get_requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }
    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.requesting_app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        CChatRoom_SetAppChatRoomGroupStopForceActive_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "requesting_app_id",
                |m: &CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &m.requesting_app_id },
                |m: &mut CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &mut m.requesting_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetAppChatRoomGroupStopForceActive_Notification>(
                "CChatRoom_SetAppChatRoomGroupStopForceActive_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetAppChatRoomGroupStopForceActive_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetAppChatRoomGroupStopForceActive_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_AckChatMessage_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AckChatMessage_Notification {
    fn default() -> &'a CChatRoom_AckChatMessage_Notification {
        <CChatRoom_AckChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AckChatMessage_Notification {
    pub fn new() -> CChatRoom_AckChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_AckChatMessage_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_AckChatMessage_Notification {
        CChatRoom_AckChatMessage_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_id },
                |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CChatRoom_AckChatMessage_Notification| { &m.timestamp },
                |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_AckChatMessage_Notification>(
                "CChatRoom_AckChatMessage_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_AckChatMessage_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_AckChatMessage_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_AckChatMessage_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_AckChatMessage_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_AckChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AckChatMessage_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateInviteLink_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    seconds_valid: ::std::option::Option<u32>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Request {
    fn default() -> &'a CChatRoom_CreateInviteLink_Request {
        <CChatRoom_CreateInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Request {
    pub fn new() -> CChatRoom_CreateInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_valid = 2;


    pub fn get_seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }
    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_valid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateInviteLink_Request {
        CChatRoom_CreateInviteLink_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_valid",
                |m: &CChatRoom_CreateInviteLink_Request| { &m.seconds_valid },
                |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.seconds_valid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_id },
                |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateInviteLink_Request>(
                "CChatRoom_CreateInviteLink_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateInviteLink_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateInviteLink_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateInviteLink_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_CreateInviteLink_Response {
    // message fields
    invite_code: ::protobuf::SingularField<::std::string::String>,
    seconds_valid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Response {
    fn default() -> &'a CChatRoom_CreateInviteLink_Response {
        <CChatRoom_CreateInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Response {
    pub fn new() -> CChatRoom_CreateInviteLink_Response {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seconds_valid = 2;


    pub fn get_seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }
    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_valid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateInviteLink_Response {
        CChatRoom_CreateInviteLink_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invite_code",
                |m: &CChatRoom_CreateInviteLink_Response| { &m.invite_code },
                |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.invite_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_valid",
                |m: &CChatRoom_CreateInviteLink_Response| { &m.seconds_valid },
                |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.seconds_valid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_CreateInviteLink_Response>(
                "CChatRoom_CreateInviteLink_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_CreateInviteLink_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_CreateInviteLink_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_CreateInviteLink_Response {
    fn clear(&mut self) {
        self.invite_code.clear();
        self.seconds_valid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteLinkInfo_Request {
    // message fields
    invite_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Request {
        <CChatRoom_GetInviteLinkInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Request {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        CChatRoom_GetInviteLinkInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invite_code",
                |m: &CChatRoom_GetInviteLinkInfo_Request| { &m.invite_code },
                |m: &mut CChatRoom_GetInviteLinkInfo_Request| { &mut m.invite_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteLinkInfo_Request>(
                "CChatRoom_GetInviteLinkInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteLinkInfo_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteLinkInfo_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinkInfo_Request {
    fn clear(&mut self) {
        self.invite_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinkInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteLinkInfo_Response {
    // message fields
    steamid_sender: ::std::option::Option<u64>,
    time_expires: ::std::option::Option<u32>,
    chat_id: ::std::option::Option<u64>,
    pub group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    pub user_chat_group_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    time_kick_expire: ::std::option::Option<u32>,
    banned: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Response {
        <CChatRoom_GetInviteLinkInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Response {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_sender = 3;


    pub fn get_steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }
    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 4;


    pub fn get_time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }
    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 6;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 8;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 9;


    pub fn get_user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_group_state.is_none() {
            self.user_chat_group_state.set_default();
        }
        self.user_chat_group_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional uint32 time_kick_expire = 10;


    pub fn get_time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }
    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 11;


    pub fn get_banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }
    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_chat_group_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_sender = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_expires = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_group_state)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_kick_expire = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.banned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_sender {
            my_size += 9;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.banned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        CChatRoom_GetInviteLinkInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_sender",
                |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.steamid_sender },
                |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.steamid_sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_expires",
                |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_expires },
                |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_expires },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.chat_id },
                |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                "group_summary",
                |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.group_summary },
                |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.group_summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                "user_chat_group_state",
                |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.user_chat_group_state },
                |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.user_chat_group_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_kick_expire",
                |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_kick_expire },
                |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_kick_expire },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "banned",
                |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.banned },
                |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.banned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteLinkInfo_Response>(
                "CChatRoom_GetInviteLinkInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteLinkInfo_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteLinkInfo_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinkInfo_Response {
    fn clear(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.group_summary.clear();
        self.user_chat_group_state.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinkInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteInfo_Request {
    // message fields
    steamid_invitee: ::std::option::Option<u64>,
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    invite_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteInfo_Request {
        <CChatRoom_GetInviteInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Request {
    pub fn new() -> CChatRoom_GetInviteInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_invitee = 1;


    pub fn get_steamid_invitee(&self) -> u64 {
        self.steamid_invitee.unwrap_or(0)
    }
    pub fn clear_steamid_invitee(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
    }

    pub fn has_steamid_invitee(&self) -> bool {
        self.steamid_invitee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitee(&mut self, v: u64) {
        self.steamid_invitee = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 4;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_invitee = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_invitee {
            my_size += 9;
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_invitee {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteInfo_Request {
        CChatRoom_GetInviteInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_invitee",
                |m: &CChatRoom_GetInviteInfo_Request| { &m.steamid_invitee },
                |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.steamid_invitee },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_id },
                |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invite_code",
                |m: &CChatRoom_GetInviteInfo_Request| { &m.invite_code },
                |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.invite_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteInfo_Request>(
                "CChatRoom_GetInviteInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteInfo_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteInfo_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteInfo_Request {
    fn clear(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.invite_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteInfo_Response {
    // message fields
    pub group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    time_kick_expire: ::std::option::Option<u32>,
    banned: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteInfo_Response {
        <CChatRoom_GetInviteInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Response {
    pub fn new() -> CChatRoom_GetInviteInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 1;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional uint32 time_kick_expire = 2;


    pub fn get_time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }
    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 3;


    pub fn get_banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }
    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_kick_expire = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.banned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.banned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteInfo_Response {
        CChatRoom_GetInviteInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                "group_summary",
                |m: &CChatRoom_GetInviteInfo_Response| { &m.group_summary },
                |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.group_summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_kick_expire",
                |m: &CChatRoom_GetInviteInfo_Response| { &m.time_kick_expire },
                |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.time_kick_expire },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "banned",
                |m: &CChatRoom_GetInviteInfo_Response| { &m.banned },
                |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.banned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteInfo_Response>(
                "CChatRoom_GetInviteInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteInfo_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteInfo_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteInfo_Response {
    fn clear(&mut self) {
        self.group_summary.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteLinksForGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Request {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Request {
        <CChatRoom_GetInviteLinksForGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Request {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        CChatRoom_GetInviteLinksForGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetInviteLinksForGroup_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetInviteLinksForGroup_Request| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteLinksForGroup_Request>(
                "CChatRoom_GetInviteLinksForGroup_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteLinksForGroup_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteLinksForGroup_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinksForGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinksForGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteLinksForGroup_Response {
    // message fields
    pub invite_links: ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Response {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Response {
        <CChatRoom_GetInviteLinksForGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Response {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetInviteLinksForGroup_Response.LinkInfo invite_links = 1;


    pub fn get_invite_links(&self) -> &[CChatRoom_GetInviteLinksForGroup_Response_LinkInfo] {
        &self.invite_links
    }
    pub fn clear_invite_links(&mut self) {
        self.invite_links.clear();
    }

    // Param is passed by value, moved
    pub fn set_invite_links(&mut self, v: ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>) {
        self.invite_links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invite_links(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo> {
        &mut self.invite_links
    }

    // Take field
    pub fn take_invite_links(&mut self) -> ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo> {
        ::std::mem::replace(&mut self.invite_links, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.invite_links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invite_links)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invite_links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invite_links {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        CChatRoom_GetInviteLinksForGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>>(
                "invite_links",
                |m: &CChatRoom_GetInviteLinksForGroup_Response| { &m.invite_links },
                |m: &mut CChatRoom_GetInviteLinksForGroup_Response| { &mut m.invite_links },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteLinksForGroup_Response>(
                "CChatRoom_GetInviteLinksForGroup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteLinksForGroup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteLinksForGroup_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinksForGroup_Response {
    fn clear(&mut self) {
        self.invite_links.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinksForGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    // message fields
    invite_code: ::protobuf::SingularField<::std::string::String>,
    steamid_creator: ::std::option::Option<u64>,
    time_expires: ::std::option::Option<u32>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        <CChatRoom_GetInviteLinksForGroup_Response_LinkInfo as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid_creator = 2;


    pub fn get_steamid_creator(&self) -> u64 {
        self.steamid_creator.unwrap_or(0)
    }
    pub fn clear_steamid_creator(&mut self) {
        self.steamid_creator = ::std::option::Option::None;
    }

    pub fn has_steamid_creator(&self) -> bool {
        self.steamid_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_creator(&mut self, v: u64) {
        self.steamid_creator = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 3;


    pub fn get_time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }
    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 4;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_creator = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_expires = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid_creator {
            my_size += 9;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.steamid_creator {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        CChatRoom_GetInviteLinksForGroup_Response_LinkInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invite_code",
                |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.invite_code },
                |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.invite_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_creator",
                |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.steamid_creator },
                |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.steamid_creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_expires",
                |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.time_expires },
                |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.time_expires },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.chat_id },
                |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.chat_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>(
                "CChatRoom_GetInviteLinksForGroup_Response.LinkInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteLinksForGroup_Response_LinkInfo::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn clear(&mut self) {
        self.invite_code.clear();
        self.steamid_creator = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetBanList_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Request {
    fn default() -> &'a CChatRoom_GetBanList_Request {
        <CChatRoom_GetBanList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Request {
    pub fn new() -> CChatRoom_GetBanList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetBanList_Request {
        CChatRoom_GetBanList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetBanList_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetBanList_Request| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetBanList_Request>(
                "CChatRoom_GetBanList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetBanList_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetBanList_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetBanList_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetBanList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetBanList_Response {
    // message fields
    pub bans: ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Response {
    fn default() -> &'a CChatRoom_GetBanList_Response {
        <CChatRoom_GetBanList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Response {
    pub fn new() -> CChatRoom_GetBanList_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetBanList_Response.BanInfo bans = 1;


    pub fn get_bans(&self) -> &[CChatRoom_GetBanList_Response_BanInfo] {
        &self.bans
    }
    pub fn clear_bans(&mut self) {
        self.bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_bans(&mut self, v: ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo>) {
        self.bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bans(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo> {
        &mut self.bans
    }

    // Take field
    pub fn take_bans(&mut self) -> ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo> {
        ::std::mem::replace(&mut self.bans, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.bans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bans {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetBanList_Response {
        CChatRoom_GetBanList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetBanList_Response_BanInfo>>(
                "bans",
                |m: &CChatRoom_GetBanList_Response| { &m.bans },
                |m: &mut CChatRoom_GetBanList_Response| { &mut m.bans },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetBanList_Response>(
                "CChatRoom_GetBanList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetBanList_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetBanList_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetBanList_Response {
    fn clear(&mut self) {
        self.bans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetBanList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetBanList_Response_BanInfo {
    // message fields
    accountid: ::std::option::Option<u32>,
    accountid_actor: ::std::option::Option<u32>,
    time_banned: ::std::option::Option<u32>,
    ban_reason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Response_BanInfo {
    fn default() -> &'a CChatRoom_GetBanList_Response_BanInfo {
        <CChatRoom_GetBanList_Response_BanInfo as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Response_BanInfo {
    pub fn new() -> CChatRoom_GetBanList_Response_BanInfo {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_actor = 2;


    pub fn get_accountid_actor(&self) -> u32 {
        self.accountid_actor.unwrap_or(0)
    }
    pub fn clear_accountid_actor(&mut self) {
        self.accountid_actor = ::std::option::Option::None;
    }

    pub fn has_accountid_actor(&self) -> bool {
        self.accountid_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_actor(&mut self, v: u32) {
        self.accountid_actor = ::std::option::Option::Some(v);
    }

    // optional uint32 time_banned = 3;


    pub fn get_time_banned(&self) -> u32 {
        self.time_banned.unwrap_or(0)
    }
    pub fn clear_time_banned(&mut self) {
        self.time_banned = ::std::option::Option::None;
    }

    pub fn has_time_banned(&self) -> bool {
        self.time_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_banned(&mut self, v: u32) {
        self.time_banned = ::std::option::Option::Some(v);
    }

    // optional string ban_reason = 4;


    pub fn get_ban_reason(&self) -> &str {
        match self.ban_reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ban_reason(&mut self) {
        self.ban_reason.clear();
    }

    pub fn has_ban_reason(&self) -> bool {
        self.ban_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_reason(&mut self, v: ::std::string::String) {
        self.ban_reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ban_reason(&mut self) -> &mut ::std::string::String {
        if self.ban_reason.is_none() {
            self.ban_reason.set_default();
        }
        self.ban_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_ban_reason(&mut self) -> ::std::string::String {
        self.ban_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Response_BanInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_banned = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ban_reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_actor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_banned {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ban_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid_actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_banned {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.ban_reason.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetBanList_Response_BanInfo {
        CChatRoom_GetBanList_Response_BanInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.accountid },
                |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_actor",
                |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.accountid_actor },
                |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.accountid_actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_banned",
                |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.time_banned },
                |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.time_banned },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ban_reason",
                |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.ban_reason },
                |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.ban_reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetBanList_Response_BanInfo>(
                "CChatRoom_GetBanList_Response.BanInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Response_BanInfo {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetBanList_Response_BanInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetBanList_Response_BanInfo::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetBanList_Response_BanInfo {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.accountid_actor = ::std::option::Option::None;
        self.time_banned = ::std::option::Option::None;
        self.ban_reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetBanList_Response_BanInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Response_BanInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteList_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Request {
    fn default() -> &'a CChatRoom_GetInviteList_Request {
        <CChatRoom_GetInviteList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Request {
    pub fn new() -> CChatRoom_GetInviteList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteList_Request {
        CChatRoom_GetInviteList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetInviteList_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetInviteList_Request| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteList_Request>(
                "CChatRoom_GetInviteList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteList_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteList_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteList_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomGroupInvite {
    // message fields
    accountid: ::std::option::Option<u32>,
    accountid_actor: ::std::option::Option<u32>,
    time_invited: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupInvite {
    fn default() -> &'a CChatRoomGroupInvite {
        <CChatRoomGroupInvite as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupInvite {
    pub fn new() -> CChatRoomGroupInvite {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_actor = 2;


    pub fn get_accountid_actor(&self) -> u32 {
        self.accountid_actor.unwrap_or(0)
    }
    pub fn clear_accountid_actor(&mut self) {
        self.accountid_actor = ::std::option::Option::None;
    }

    pub fn has_accountid_actor(&self) -> bool {
        self.accountid_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_actor(&mut self, v: u32) {
        self.accountid_actor = ::std::option::Option::Some(v);
    }

    // optional uint32 time_invited = 3;


    pub fn get_time_invited(&self) -> u32 {
        self.time_invited.unwrap_or(0)
    }
    pub fn clear_time_invited(&mut self) {
        self.time_invited = ::std::option::Option::None;
    }

    pub fn has_time_invited(&self) -> bool {
        self.time_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_invited(&mut self, v: u32) {
        self.time_invited = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomGroupInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_invited = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_actor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_invited {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid_actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_invited {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomGroupInvite {
        CChatRoomGroupInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CChatRoomGroupInvite| { &m.accountid },
                |m: &mut CChatRoomGroupInvite| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_actor",
                |m: &CChatRoomGroupInvite| { &m.accountid_actor },
                |m: &mut CChatRoomGroupInvite| { &mut m.accountid_actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_invited",
                |m: &CChatRoomGroupInvite| { &m.time_invited },
                |m: &mut CChatRoomGroupInvite| { &mut m.time_invited },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomGroupInvite>(
                "CChatRoomGroupInvite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomGroupInvite {
        static instance: ::protobuf::rt::LazyV2<CChatRoomGroupInvite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomGroupInvite::new)
    }
}

impl ::protobuf::Clear for CChatRoomGroupInvite {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.accountid_actor = ::std::option::Option::None;
        self.time_invited = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomGroupInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetInviteList_Response {
    // message fields
    pub invites: ::protobuf::RepeatedField<CChatRoomGroupInvite>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Response {
    fn default() -> &'a CChatRoom_GetInviteList_Response {
        <CChatRoom_GetInviteList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Response {
    pub fn new() -> CChatRoom_GetInviteList_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomGroupInvite invites = 1;


    pub fn get_invites(&self) -> &[CChatRoomGroupInvite] {
        &self.invites
    }
    pub fn clear_invites(&mut self) {
        self.invites.clear();
    }

    // Param is passed by value, moved
    pub fn set_invites(&mut self, v: ::protobuf::RepeatedField<CChatRoomGroupInvite>) {
        self.invites = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invites(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomGroupInvite> {
        &mut self.invites
    }

    // Take field
    pub fn take_invites(&mut self) -> ::protobuf::RepeatedField<CChatRoomGroupInvite> {
        ::std::mem::replace(&mut self.invites, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.invites {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invites)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invites {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invites {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteList_Response {
        CChatRoom_GetInviteList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupInvite>>(
                "invites",
                |m: &CChatRoom_GetInviteList_Response| { &m.invites },
                |m: &mut CChatRoom_GetInviteList_Response| { &mut m.invites },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetInviteList_Response>(
                "CChatRoom_GetInviteList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetInviteList_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetInviteList_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteList_Response {
    fn clear(&mut self) {
        self.invites.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteInviteLink_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    invite_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Request {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Request {
        <CChatRoom_DeleteInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Request {
    pub fn new() -> CChatRoom_DeleteInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteInviteLink_Request {
        CChatRoom_DeleteInviteLink_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_DeleteInviteLink_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invite_code",
                |m: &CChatRoom_DeleteInviteLink_Request| { &m.invite_code },
                |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.invite_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteInviteLink_Request>(
                "CChatRoom_DeleteInviteLink_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteInviteLink_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteInviteLink_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteInviteLink_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteInviteLink_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Response {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Response {
        <CChatRoom_DeleteInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Response {
    pub fn new() -> CChatRoom_DeleteInviteLink_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteInviteLink_Response {
        CChatRoom_DeleteInviteLink_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteInviteLink_Response>(
                "CChatRoom_DeleteInviteLink_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteInviteLink_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteInviteLink_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteInviteLink_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Request {
    // message fields
    pub chat_group_ids: ::std::vec::Vec<u64>,
    pub chat_groups_data_requested: ::std::vec::Vec<u64>,
    virtualize_members_threshold: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
        <CChatRoom_SetSessionActiveChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Request {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        ::std::default::Default::default()
    }

    // repeated uint64 chat_group_ids = 1;


    pub fn get_chat_group_ids(&self) -> &[u64] {
        &self.chat_group_ids
    }
    pub fn clear_chat_group_ids(&mut self) {
        self.chat_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_group_ids
    }

    // Take field
    pub fn take_chat_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_group_ids, ::std::vec::Vec::new())
    }

    // repeated uint64 chat_groups_data_requested = 2;


    pub fn get_chat_groups_data_requested(&self) -> &[u64] {
        &self.chat_groups_data_requested
    }
    pub fn clear_chat_groups_data_requested(&mut self) {
        self.chat_groups_data_requested.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_groups_data_requested(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_groups_data_requested = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_groups_data_requested(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_groups_data_requested
    }

    // Take field
    pub fn take_chat_groups_data_requested(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_groups_data_requested, ::std::vec::Vec::new())
    }

    // optional int32 virtualize_members_threshold = 3;


    pub fn get_virtualize_members_threshold(&self) -> i32 {
        self.virtualize_members_threshold.unwrap_or(0)
    }
    pub fn clear_virtualize_members_threshold(&mut self) {
        self.virtualize_members_threshold = ::std::option::Option::None;
    }

    pub fn has_virtualize_members_threshold(&self) -> bool {
        self.virtualize_members_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualize_members_threshold(&mut self, v: i32) {
        self.virtualize_members_threshold = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.chat_group_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.chat_groups_data_requested)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.virtualize_members_threshold = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.chat_groups_data_requested {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.virtualize_members_threshold {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        for v in &self.chat_groups_data_requested {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.virtualize_members_threshold {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        CChatRoom_SetSessionActiveChatRoomGroups_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_ids",
                |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_group_ids },
                |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_group_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_groups_data_requested",
                |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_groups_data_requested },
                |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_groups_data_requested },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "virtualize_members_threshold",
                |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.virtualize_members_threshold },
                |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.virtualize_members_threshold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetSessionActiveChatRoomGroups_Request>(
                "CChatRoom_SetSessionActiveChatRoomGroups_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetSessionActiveChatRoomGroups_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetSessionActiveChatRoomGroups_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.chat_groups_data_requested.clear();
        self.virtualize_members_threshold = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Response {
    // message fields
    pub chat_states: ::protobuf::RepeatedField<CChatRoomGroupState>,
    pub virtualize_members_chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
        <CChatRoom_SetSessionActiveChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Response {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomGroupState chat_states = 1;


    pub fn get_chat_states(&self) -> &[CChatRoomGroupState] {
        &self.chat_states
    }
    pub fn clear_chat_states(&mut self) {
        self.chat_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_states(&mut self, v: ::protobuf::RepeatedField<CChatRoomGroupState>) {
        self.chat_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_states(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomGroupState> {
        &mut self.chat_states
    }

    // Take field
    pub fn take_chat_states(&mut self) -> ::protobuf::RepeatedField<CChatRoomGroupState> {
        ::std::mem::replace(&mut self.chat_states, ::protobuf::RepeatedField::new())
    }

    // repeated uint64 virtualize_members_chat_group_ids = 2;


    pub fn get_virtualize_members_chat_group_ids(&self) -> &[u64] {
        &self.virtualize_members_chat_group_ids
    }
    pub fn clear_virtualize_members_chat_group_ids(&mut self) {
        self.virtualize_members_chat_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualize_members_chat_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.virtualize_members_chat_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualize_members_chat_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.virtualize_members_chat_group_ids
    }

    // Take field
    pub fn take_virtualize_members_chat_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.virtualize_members_chat_group_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_states)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.virtualize_members_chat_group_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chat_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.virtualize_members_chat_group_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chat_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.virtualize_members_chat_group_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        CChatRoom_SetSessionActiveChatRoomGroups_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                "chat_states",
                |m: &CChatRoom_SetSessionActiveChatRoomGroups_Response| { &m.chat_states },
                |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Response| { &mut m.chat_states },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "virtualize_members_chat_group_ids",
                |m: &CChatRoom_SetSessionActiveChatRoomGroups_Response| { &m.virtualize_members_chat_group_ids },
                |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Response| { &mut m.virtualize_members_chat_group_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetSessionActiveChatRoomGroups_Response>(
                "CChatRoom_SetSessionActiveChatRoomGroups_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetSessionActiveChatRoomGroups_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetSessionActiveChatRoomGroups_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn clear(&mut self) {
        self.chat_states.clear();
        self.virtualize_members_chat_group_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetUserChatGroupPreferences_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    pub chat_group_preferences: ::protobuf::SingularPtrField<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences>,
    pub chat_room_preferences: ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request {
        <CChatRoom_SetUserChatGroupPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences chat_group_preferences = 2;


    pub fn get_chat_group_preferences(&self) -> &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        self.chat_group_preferences.as_ref().unwrap_or_else(|| <CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chat_group_preferences(&mut self) {
        self.chat_group_preferences.clear();
    }

    pub fn has_chat_group_preferences(&self) -> bool {
        self.chat_group_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_preferences(&mut self, v: CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences) {
        self.chat_group_preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_preferences(&mut self) -> &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        if self.chat_group_preferences.is_none() {
            self.chat_group_preferences.set_default();
        }
        self.chat_group_preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_preferences(&mut self) -> CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        self.chat_group_preferences.take().unwrap_or_else(|| CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences::new())
    }

    // repeated .CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences chat_room_preferences = 3;


    pub fn get_chat_room_preferences(&self) -> &[CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences] {
        &self.chat_room_preferences
    }
    pub fn clear_chat_room_preferences(&mut self) {
        self.chat_room_preferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_room_preferences(&mut self, v: ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>) {
        self.chat_room_preferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_room_preferences(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences> {
        &mut self.chat_room_preferences
    }

    // Take field
    pub fn take_chat_room_preferences(&mut self) -> ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences> {
        ::std::mem::replace(&mut self.chat_room_preferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_group_preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chat_room_preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chat_group_preferences)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_room_preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_group_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.chat_room_preferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_group_preferences.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.chat_room_preferences {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        CChatRoom_SetUserChatGroupPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences>>(
                "chat_group_preferences",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_preferences },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_preferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>>(
                "chat_room_preferences",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_room_preferences },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_room_preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetUserChatGroupPreferences_Request>(
                "CChatRoom_SetUserChatGroupPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetUserChatGroupPreferences_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetUserChatGroupPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_preferences.clear();
        self.chat_room_preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    // message fields
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        <CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        ::std::default::Default::default()
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 1;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 2;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 3;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "desktop_notification_level",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &m.desktop_notification_level },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &mut m.desktop_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "mobile_notification_level",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &m.mobile_notification_level },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &mut m.mobile_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unread_indicator_muted",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &m.unread_indicator_muted },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &mut m.unread_indicator_muted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences>(
                "CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn clear(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    // message fields
    chat_id: ::std::option::Option<u64>,
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        <CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 2;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 3;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 4;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.chat_id },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "desktop_notification_level",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.desktop_notification_level },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.desktop_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                "mobile_notification_level",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.mobile_notification_level },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.mobile_notification_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unread_indicator_muted",
                |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.unread_indicator_muted },
                |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.unread_indicator_muted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>(
                "CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SetUserChatGroupPreferences_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Response {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Response {
        <CChatRoom_SetUserChatGroupPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Response {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        CChatRoom_SetUserChatGroupPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SetUserChatGroupPreferences_Response>(
                "CChatRoom_SetUserChatGroupPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SetUserChatGroupPreferences_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SetUserChatGroupPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteChatMessages_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    pub messages: ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Request {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Request {
        <CChatRoom_DeleteChatMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Request {
    pub fn new() -> CChatRoom_DeleteChatMessages_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoom_DeleteChatMessages_Request.Message messages = 3;


    pub fn get_messages(&self) -> &[CChatRoom_DeleteChatMessages_Request_Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatMessages_Request {
        CChatRoom_DeleteChatMessages_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_id },
                |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_DeleteChatMessages_Request_Message>>(
                "messages",
                |m: &CChatRoom_DeleteChatMessages_Request| { &m.messages },
                |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteChatMessages_Request>(
                "CChatRoom_DeleteChatMessages_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteChatMessages_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteChatMessages_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatMessages_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteChatMessages_Request_Message {
    // message fields
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Request_Message {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Request_Message {
        <CChatRoom_DeleteChatMessages_Request_Message as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Request_Message {
    pub fn new() -> CChatRoom_DeleteChatMessages_Request_Message {
        ::std::default::Default::default()
    }

    // optional uint32 server_timestamp = 1;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 2;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Request_Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatMessages_Request_Message {
        CChatRoom_DeleteChatMessages_Request_Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CChatRoom_DeleteChatMessages_Request_Message| { &m.server_timestamp },
                |m: &mut CChatRoom_DeleteChatMessages_Request_Message| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_DeleteChatMessages_Request_Message| { &m.ordinal },
                |m: &mut CChatRoom_DeleteChatMessages_Request_Message| { &mut m.ordinal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteChatMessages_Request_Message>(
                "CChatRoom_DeleteChatMessages_Request.Message",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Request_Message {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteChatMessages_Request_Message> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteChatMessages_Request_Message::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatMessages_Request_Message {
    fn clear(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatMessages_Request_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Request_Message {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_DeleteChatMessages_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Response {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Response {
        <CChatRoom_DeleteChatMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Response {
    pub fn new() -> CChatRoom_DeleteChatMessages_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatMessages_Response {
        CChatRoom_DeleteChatMessages_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_DeleteChatMessages_Response>(
                "CChatRoom_DeleteChatMessages_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_DeleteChatMessages_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_DeleteChatMessages_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatMessages_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_UpdateMemberListView_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    view_id: ::std::option::Option<u64>,
    start: ::std::option::Option<i32>,
    end: ::std::option::Option<i32>,
    client_changenumber: ::std::option::Option<i32>,
    delete_view: ::std::option::Option<bool>,
    pub persona_subscribe_accountids: ::std::vec::Vec<i32>,
    pub persona_unsubscribe_accountids: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMemberListView_Notification {
    fn default() -> &'a CChatRoom_UpdateMemberListView_Notification {
        <CChatRoom_UpdateMemberListView_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMemberListView_Notification {
    pub fn new() -> CChatRoom_UpdateMemberListView_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;


    pub fn get_view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }
    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional int32 start = 3;


    pub fn get_start(&self) -> i32 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;


    pub fn get_end(&self) -> i32 {
        self.end.unwrap_or(0)
    }
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 5;


    pub fn get_client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }
    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional bool delete_view = 6;


    pub fn get_delete_view(&self) -> bool {
        self.delete_view.unwrap_or(false)
    }
    pub fn clear_delete_view(&mut self) {
        self.delete_view = ::std::option::Option::None;
    }

    pub fn has_delete_view(&self) -> bool {
        self.delete_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delete_view(&mut self, v: bool) {
        self.delete_view = ::std::option::Option::Some(v);
    }

    // repeated int32 persona_subscribe_accountids = 7;


    pub fn get_persona_subscribe_accountids(&self) -> &[i32] {
        &self.persona_subscribe_accountids
    }
    pub fn clear_persona_subscribe_accountids(&mut self) {
        self.persona_subscribe_accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_persona_subscribe_accountids(&mut self, v: ::std::vec::Vec<i32>) {
        self.persona_subscribe_accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_persona_subscribe_accountids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.persona_subscribe_accountids
    }

    // Take field
    pub fn take_persona_subscribe_accountids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.persona_subscribe_accountids, ::std::vec::Vec::new())
    }

    // repeated int32 persona_unsubscribe_accountids = 8;


    pub fn get_persona_unsubscribe_accountids(&self) -> &[i32] {
        &self.persona_unsubscribe_accountids
    }
    pub fn clear_persona_unsubscribe_accountids(&mut self) {
        self.persona_unsubscribe_accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_persona_unsubscribe_accountids(&mut self, v: ::std::vec::Vec<i32>) {
        self.persona_unsubscribe_accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_persona_unsubscribe_accountids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.persona_unsubscribe_accountids
    }

    // Take field
    pub fn take_persona_unsubscribe_accountids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.persona_unsubscribe_accountids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMemberListView_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.view_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.client_changenumber = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_view = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.persona_subscribe_accountids)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.persona_unsubscribe_accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.view_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_changenumber {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.delete_view {
            my_size += 2;
        }
        for value in &self.persona_subscribe_accountids {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.persona_unsubscribe_accountids {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delete_view {
            os.write_bool(6, v)?;
        }
        for v in &self.persona_subscribe_accountids {
            os.write_int32(7, *v)?;
        };
        for v in &self.persona_unsubscribe_accountids {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_UpdateMemberListView_Notification {
        CChatRoom_UpdateMemberListView_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "view_id",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.view_id },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.view_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.start },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "end",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.end },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "client_changenumber",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.client_changenumber },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.client_changenumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delete_view",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.delete_view },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.delete_view },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "persona_subscribe_accountids",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.persona_subscribe_accountids },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.persona_subscribe_accountids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "persona_unsubscribe_accountids",
                |m: &CChatRoom_UpdateMemberListView_Notification| { &m.persona_unsubscribe_accountids },
                |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.persona_unsubscribe_accountids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_UpdateMemberListView_Notification>(
                "CChatRoom_UpdateMemberListView_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_UpdateMemberListView_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_UpdateMemberListView_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_UpdateMemberListView_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_UpdateMemberListView_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.delete_view = ::std::option::Option::None;
        self.persona_subscribe_accountids.clear();
        self.persona_unsubscribe_accountids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_UpdateMemberListView_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_UpdateMemberListView_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SearchMembers_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    search_id: ::std::option::Option<u64>,
    search_text: ::protobuf::SingularField<::std::string::String>,
    max_results: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Request {
    fn default() -> &'a CChatRoom_SearchMembers_Request {
        <CChatRoom_SearchMembers_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Request {
    pub fn new() -> CChatRoom_SearchMembers_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 search_id = 2;


    pub fn get_search_id(&self) -> u64 {
        self.search_id.unwrap_or(0)
    }
    pub fn clear_search_id(&mut self) {
        self.search_id = ::std::option::Option::None;
    }

    pub fn has_search_id(&self) -> bool {
        self.search_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_id(&mut self, v: u64) {
        self.search_id = ::std::option::Option::Some(v);
    }

    // optional string search_text = 3;


    pub fn get_search_text(&self) -> &str {
        match self.search_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_search_text(&mut self) {
        self.search_text.clear();
    }

    pub fn has_search_text(&self) -> bool {
        self.search_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_text(&mut self, v: ::std::string::String) {
        self.search_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_text(&mut self) -> &mut ::std::string::String {
        if self.search_text.is_none() {
            self.search_text.set_default();
        }
        self.search_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_text(&mut self) -> ::std::string::String {
        self.search_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 max_results = 4;


    pub fn get_max_results(&self) -> i32 {
        self.max_results.unwrap_or(0)
    }
    pub fn clear_max_results(&mut self) {
        self.max_results = ::std::option::Option::None;
    }

    pub fn has_max_results(&self) -> bool {
        self.max_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SearchMembers_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.search_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.search_text)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_results = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.search_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.search_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.max_results {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.search_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.search_text.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.max_results {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SearchMembers_Request {
        CChatRoom_SearchMembers_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_SearchMembers_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_SearchMembers_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "search_id",
                |m: &CChatRoom_SearchMembers_Request| { &m.search_id },
                |m: &mut CChatRoom_SearchMembers_Request| { &mut m.search_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "search_text",
                |m: &CChatRoom_SearchMembers_Request| { &m.search_text },
                |m: &mut CChatRoom_SearchMembers_Request| { &mut m.search_text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_results",
                |m: &CChatRoom_SearchMembers_Request| { &m.max_results },
                |m: &mut CChatRoom_SearchMembers_Request| { &mut m.max_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SearchMembers_Request>(
                "CChatRoom_SearchMembers_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SearchMembers_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SearchMembers_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SearchMembers_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.search_id = ::std::option::Option::None;
        self.search_text.clear();
        self.max_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SearchMembers_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SearchMembers_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SearchMembers_Response {
    // message fields
    pub matching_members: ::protobuf::RepeatedField<CChatRoom_SearchMembers_Response_MemberMatch>,
    status_flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Response {
    fn default() -> &'a CChatRoom_SearchMembers_Response {
        <CChatRoom_SearchMembers_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Response {
    pub fn new() -> CChatRoom_SearchMembers_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_SearchMembers_Response.MemberMatch matching_members = 1;


    pub fn get_matching_members(&self) -> &[CChatRoom_SearchMembers_Response_MemberMatch] {
        &self.matching_members
    }
    pub fn clear_matching_members(&mut self) {
        self.matching_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_matching_members(&mut self, v: ::protobuf::RepeatedField<CChatRoom_SearchMembers_Response_MemberMatch>) {
        self.matching_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matching_members(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_SearchMembers_Response_MemberMatch> {
        &mut self.matching_members
    }

    // Take field
    pub fn take_matching_members(&mut self) -> ::protobuf::RepeatedField<CChatRoom_SearchMembers_Response_MemberMatch> {
        ::std::mem::replace(&mut self.matching_members, ::protobuf::RepeatedField::new())
    }

    // optional uint32 status_flags = 2;


    pub fn get_status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }
    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SearchMembers_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.matching_members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matching_members)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matching_members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matching_members {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SearchMembers_Response {
        CChatRoom_SearchMembers_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_SearchMembers_Response_MemberMatch>>(
                "matching_members",
                |m: &CChatRoom_SearchMembers_Response| { &m.matching_members },
                |m: &mut CChatRoom_SearchMembers_Response| { &mut m.matching_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status_flags",
                |m: &CChatRoom_SearchMembers_Response| { &m.status_flags },
                |m: &mut CChatRoom_SearchMembers_Response| { &mut m.status_flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SearchMembers_Response>(
                "CChatRoom_SearchMembers_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SearchMembers_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SearchMembers_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SearchMembers_Response {
    fn clear(&mut self) {
        self.matching_members.clear();
        self.status_flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SearchMembers_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SearchMembers_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_SearchMembers_Response_MemberMatch {
    // message fields
    accountid: ::std::option::Option<i32>,
    pub persona: ::protobuf::SingularPtrField<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Response_MemberMatch {
    fn default() -> &'a CChatRoom_SearchMembers_Response_MemberMatch {
        <CChatRoom_SearchMembers_Response_MemberMatch as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Response_MemberMatch {
    pub fn new() -> CChatRoom_SearchMembers_Response_MemberMatch {
        ::std::default::Default::default()
    }

    // optional int32 accountid = 1;


    pub fn get_accountid(&self) -> i32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: i32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .CMsgClientPersonaState.Friend persona = 2;


    pub fn get_persona(&self) -> &super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend {
        self.persona.as_ref().unwrap_or_else(|| <super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend as ::protobuf::Message>::default_instance())
    }
    pub fn clear_persona(&mut self) {
        self.persona.clear();
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend) {
        self.persona = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend {
        if self.persona.is_none() {
            self.persona.set_default();
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend {
        self.persona.take().unwrap_or_else(|| super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend::new())
    }
}

impl ::protobuf::Message for CChatRoom_SearchMembers_Response_MemberMatch {
    fn is_initialized(&self) -> bool {
        for v in &self.persona {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persona)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.persona.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.persona.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SearchMembers_Response_MemberMatch {
        CChatRoom_SearchMembers_Response_MemberMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "accountid",
                |m: &CChatRoom_SearchMembers_Response_MemberMatch| { &m.accountid },
                |m: &mut CChatRoom_SearchMembers_Response_MemberMatch| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend>>(
                "persona",
                |m: &CChatRoom_SearchMembers_Response_MemberMatch| { &m.persona },
                |m: &mut CChatRoom_SearchMembers_Response_MemberMatch| { &mut m.persona },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_SearchMembers_Response_MemberMatch>(
                "CChatRoom_SearchMembers_Response.MemberMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Response_MemberMatch {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_SearchMembers_Response_MemberMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_SearchMembers_Response_MemberMatch::new)
    }
}

impl ::protobuf::Clear for CChatRoom_SearchMembers_Response_MemberMatch {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.persona.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SearchMembers_Response_MemberMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SearchMembers_Response_MemberMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_UpdateMessageReaction_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    reaction_type: ::std::option::Option<EChatRoomMessageReactionType>,
    reaction: ::protobuf::SingularField<::std::string::String>,
    is_add: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Request {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Request {
        <CChatRoom_UpdateMessageReaction_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Request {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;


    pub fn get_reaction_type(&self) -> EChatRoomMessageReactionType {
        self.reaction_type.unwrap_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid)
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(v);
    }

    // optional string reaction = 6;


    pub fn get_reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reaction(&mut self) {
        self.reaction.clear();
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction.set_default();
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 7;


    pub fn get_is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }
    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMessageReaction_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reaction)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_add = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(ref v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.reaction.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Request {
        CChatRoom_UpdateMessageReaction_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_UpdateMessageReaction_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_UpdateMessageReaction_Request| { &m.chat_id },
                |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CChatRoom_UpdateMessageReaction_Request| { &m.server_timestamp },
                |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_UpdateMessageReaction_Request| { &m.ordinal },
                |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMessageReactionType>>(
                "reaction_type",
                |m: &CChatRoom_UpdateMessageReaction_Request| { &m.reaction_type },
                |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reaction",
                |m: &CChatRoom_UpdateMessageReaction_Request| { &m.reaction },
                |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.reaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_add",
                |m: &CChatRoom_UpdateMessageReaction_Request| { &m.is_add },
                |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.is_add },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_UpdateMessageReaction_Request>(
                "CChatRoom_UpdateMessageReaction_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_UpdateMessageReaction_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_UpdateMessageReaction_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_UpdateMessageReaction_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction.clear();
        self.is_add = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_UpdateMessageReaction_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_UpdateMessageReaction_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_UpdateMessageReaction_Response {
    // message fields
    num_reactors: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Response {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Response {
        <CChatRoom_UpdateMessageReaction_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Response {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Response {
        ::std::default::Default::default()
    }

    // optional uint32 num_reactors = 1;


    pub fn get_num_reactors(&self) -> u32 {
        self.num_reactors.unwrap_or(0)
    }
    pub fn clear_num_reactors(&mut self) {
        self.num_reactors = ::std::option::Option::None;
    }

    pub fn has_num_reactors(&self) -> bool {
        self.num_reactors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reactors(&mut self, v: u32) {
        self.num_reactors = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_UpdateMessageReaction_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_reactors = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num_reactors {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num_reactors {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Response {
        CChatRoom_UpdateMessageReaction_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_reactors",
                |m: &CChatRoom_UpdateMessageReaction_Response| { &m.num_reactors },
                |m: &mut CChatRoom_UpdateMessageReaction_Response| { &mut m.num_reactors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_UpdateMessageReaction_Response>(
                "CChatRoom_UpdateMessageReaction_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_UpdateMessageReaction_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_UpdateMessageReaction_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_UpdateMessageReaction_Response {
    fn clear(&mut self) {
        self.num_reactors = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_UpdateMessageReaction_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_UpdateMessageReaction_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMessageReactionReactors_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    reaction_type: ::std::option::Option<EChatRoomMessageReactionType>,
    reaction: ::protobuf::SingularField<::std::string::String>,
    limit: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Request {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Request {
        <CChatRoom_GetMessageReactionReactors_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Request {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;


    pub fn get_reaction_type(&self) -> EChatRoomMessageReactionType {
        self.reaction_type.unwrap_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid)
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(v);
    }

    // optional string reaction = 6;


    pub fn get_reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reaction(&mut self) {
        self.reaction.clear();
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction.set_default();
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 limit = 7;


    pub fn get_limit(&self) -> u32 {
        self.limit.unwrap_or(0)
    }
    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageReactionReactors_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reaction)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(ref v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.reaction.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.limit {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        CChatRoom_GetMessageReactionReactors_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.chat_group_id },
                |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.chat_id },
                |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.server_timestamp },
                |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.ordinal },
                |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMessageReactionType>>(
                "reaction_type",
                |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.reaction_type },
                |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reaction",
                |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.reaction },
                |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.reaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "limit",
                |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.limit },
                |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMessageReactionReactors_Request>(
                "CChatRoom_GetMessageReactionReactors_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Request {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMessageReactionReactors_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMessageReactionReactors_Request::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageReactionReactors_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction.clear();
        self.limit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageReactionReactors_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageReactionReactors_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_GetMessageReactionReactors_Response {
    // message fields
    pub reactors: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Response {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Response {
        <CChatRoom_GetMessageReactionReactors_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Response {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        ::std::default::Default::default()
    }

    // repeated uint32 reactors = 1;


    pub fn get_reactors(&self) -> &[u32] {
        &self.reactors
    }
    pub fn clear_reactors(&mut self) {
        self.reactors.clear();
    }

    // Param is passed by value, moved
    pub fn set_reactors(&mut self, v: ::std::vec::Vec<u32>) {
        self.reactors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reactors(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reactors
    }

    // Take field
    pub fn take_reactors(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.reactors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageReactionReactors_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.reactors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reactors {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reactors {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        CChatRoom_GetMessageReactionReactors_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reactors",
                |m: &CChatRoom_GetMessageReactionReactors_Response| { &m.reactors },
                |m: &mut CChatRoom_GetMessageReactionReactors_Response| { &mut m.reactors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_GetMessageReactionReactors_Response>(
                "CChatRoom_GetMessageReactionReactors_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Response {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_GetMessageReactionReactors_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_GetMessageReactionReactors_Response::new)
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageReactionReactors_Response {
    fn clear(&mut self) {
        self.reactors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageReactionReactors_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageReactionReactors_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    autocreate: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Request {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Request {
        <CClanChatRooms_GetClanChatRoomInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Request {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool autocreate = 2;


    pub fn get_autocreate(&self) -> bool {
        self.autocreate.unwrap_or(true)
    }
    pub fn clear_autocreate(&mut self) {
        self.autocreate = ::std::option::Option::None;
    }

    pub fn has_autocreate(&self) -> bool {
        self.autocreate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autocreate(&mut self, v: bool) {
        self.autocreate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autocreate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.autocreate {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.autocreate {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        CClanChatRooms_GetClanChatRoomInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.steamid },
                |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autocreate",
                |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.autocreate },
                |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.autocreate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClanChatRooms_GetClanChatRoomInfo_Request>(
                "CClanChatRooms_GetClanChatRoomInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Request {
        static instance: ::protobuf::rt::LazyV2<CClanChatRooms_GetClanChatRoomInfo_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClanChatRooms_GetClanChatRoomInfo_Request::new)
    }
}

impl ::protobuf::Clear for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.autocreate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Response {
    // message fields
    pub chat_group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Response {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Response {
        <CClanChatRooms_GetClanChatRoomInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Response {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response chat_group_summary = 1;


    pub fn get_chat_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.chat_group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chat_group_summary(&mut self) {
        self.chat_group_summary.clear();
    }

    pub fn has_chat_group_summary(&self) -> bool {
        self.chat_group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.chat_group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.chat_group_summary.is_none() {
            self.chat_group_summary.set_default();
        }
        self.chat_group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.chat_group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chat_group_summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chat_group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chat_group_summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        CClanChatRooms_GetClanChatRoomInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                "chat_group_summary",
                |m: &CClanChatRooms_GetClanChatRoomInfo_Response| { &m.chat_group_summary },
                |m: &mut CClanChatRooms_GetClanChatRoomInfo_Response| { &mut m.chat_group_summary },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClanChatRooms_GetClanChatRoomInfo_Response>(
                "CClanChatRooms_GetClanChatRoomInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Response {
        static instance: ::protobuf::rt::LazyV2<CClanChatRooms_GetClanChatRoomInfo_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClanChatRooms_GetClanChatRoomInfo_Response::new)
    }
}

impl ::protobuf::Clear for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn clear(&mut self) {
        self.chat_group_summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    chat_room_private: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
        <CClanChatRooms_SetClanChatRoomPrivate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Request {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 2;


    pub fn get_chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }
    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat_room_private = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_room_private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_room_private {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        CClanChatRooms_SetClanChatRoomPrivate_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.steamid },
                |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chat_room_private",
                |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.chat_room_private },
                |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.chat_room_private },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClanChatRooms_SetClanChatRoomPrivate_Request>(
                "CClanChatRooms_SetClanChatRoomPrivate_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Request {
        static instance: ::protobuf::rt::LazyV2<CClanChatRooms_SetClanChatRoomPrivate_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClanChatRooms_SetClanChatRoomPrivate_Request::new)
    }
}

impl ::protobuf::Clear for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_room_private = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Response {
    // message fields
    chat_room_private: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
        <CClanChatRooms_SetClanChatRoomPrivate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Response {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        ::std::default::Default::default()
    }

    // optional bool chat_room_private = 1;


    pub fn get_chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }
    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat_room_private = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room_private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_room_private {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        CClanChatRooms_SetClanChatRoomPrivate_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chat_room_private",
                |m: &CClanChatRooms_SetClanChatRoomPrivate_Response| { &m.chat_room_private },
                |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Response| { &mut m.chat_room_private },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClanChatRooms_SetClanChatRoomPrivate_Response>(
                "CClanChatRooms_SetClanChatRoomPrivate_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Response {
        static instance: ::protobuf::rt::LazyV2<CClanChatRooms_SetClanChatRoomPrivate_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClanChatRooms_SetClanChatRoomPrivate_Response::new)
    }
}

impl ::protobuf::Clear for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn clear(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatMentions {
    // message fields
    mention_all: ::std::option::Option<bool>,
    mention_here: ::std::option::Option<bool>,
    pub mention_accountids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatMentions {
    fn default() -> &'a CChatMentions {
        <CChatMentions as ::protobuf::Message>::default_instance()
    }
}

impl CChatMentions {
    pub fn new() -> CChatMentions {
        ::std::default::Default::default()
    }

    // optional bool mention_all = 1;


    pub fn get_mention_all(&self) -> bool {
        self.mention_all.unwrap_or(false)
    }
    pub fn clear_mention_all(&mut self) {
        self.mention_all = ::std::option::Option::None;
    }

    pub fn has_mention_all(&self) -> bool {
        self.mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_all(&mut self, v: bool) {
        self.mention_all = ::std::option::Option::Some(v);
    }

    // optional bool mention_here = 2;


    pub fn get_mention_here(&self) -> bool {
        self.mention_here.unwrap_or(false)
    }
    pub fn clear_mention_here(&mut self) {
        self.mention_here = ::std::option::Option::None;
    }

    pub fn has_mention_here(&self) -> bool {
        self.mention_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_here(&mut self, v: bool) {
        self.mention_here = ::std::option::Option::Some(v);
    }

    // repeated uint32 mention_accountids = 3;


    pub fn get_mention_accountids(&self) -> &[u32] {
        &self.mention_accountids
    }
    pub fn clear_mention_accountids(&mut self) {
        self.mention_accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_mention_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.mention_accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mention_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mention_accountids
    }

    // Take field
    pub fn take_mention_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mention_accountids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatMentions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mention_all = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mention_here = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mention_accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mention_all {
            my_size += 2;
        }
        if let Some(v) = self.mention_here {
            my_size += 2;
        }
        for value in &self.mention_accountids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mention_all {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.mention_here {
            os.write_bool(2, v)?;
        }
        for v in &self.mention_accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatMentions {
        CChatMentions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mention_all",
                |m: &CChatMentions| { &m.mention_all },
                |m: &mut CChatMentions| { &mut m.mention_all },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mention_here",
                |m: &CChatMentions| { &m.mention_here },
                |m: &mut CChatMentions| { &mut m.mention_here },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mention_accountids",
                |m: &CChatMentions| { &m.mention_accountids },
                |m: &mut CChatMentions| { &mut m.mention_accountids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatMentions>(
                "CChatMentions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatMentions {
        static instance: ::protobuf::rt::LazyV2<CChatMentions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatMentions::new)
    }
}

impl ::protobuf::Clear for CChatMentions {
    fn clear(&mut self) {
        self.mention_all = ::std::option::Option::None;
        self.mention_here = ::std::option::Option::None;
        self.mention_accountids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatMentions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatMentions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_IncomingChatMessage_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    steamid_sender: ::std::option::Option<u64>,
    message: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u32>,
    pub mentions: ::protobuf::SingularPtrField<CChatMentions>,
    ordinal: ::std::option::Option<u32>,
    pub server_message: ::protobuf::SingularPtrField<ServerMessage>,
    message_no_bbcode: ::protobuf::SingularField<::std::string::String>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_IncomingChatMessage_Notification {
    fn default() -> &'a CChatRoom_IncomingChatMessage_Notification {
        <CChatRoom_IncomingChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_IncomingChatMessage_Notification {
    pub fn new() -> CChatRoom_IncomingChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_sender = 3;


    pub fn get_steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }
    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional string message = 4;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 timestamp = 5;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .CChatMentions mentions = 6;


    pub fn get_mentions(&self) -> &CChatMentions {
        self.mentions.as_ref().unwrap_or_else(|| <CChatMentions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mentions(&mut self) {
        self.mentions.clear();
    }

    pub fn has_mentions(&self) -> bool {
        self.mentions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mentions(&mut self, v: CChatMentions) {
        self.mentions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mentions(&mut self) -> &mut CChatMentions {
        if self.mentions.is_none() {
            self.mentions.set_default();
        }
        self.mentions.as_mut().unwrap()
    }

    // Take field
    pub fn take_mentions(&mut self) -> CChatMentions {
        self.mentions.take().unwrap_or_else(|| CChatMentions::new())
    }

    // optional uint32 ordinal = 7;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .ServerMessage server_message = 8;


    pub fn get_server_message(&self) -> &ServerMessage {
        self.server_message.as_ref().unwrap_or_else(|| <ServerMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_message(&mut self) {
        self.server_message.clear();
    }

    pub fn has_server_message(&self) -> bool {
        self.server_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_message(&mut self, v: ServerMessage) {
        self.server_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_message(&mut self) -> &mut ServerMessage {
        if self.server_message.is_none() {
            self.server_message.set_default();
        }
        self.server_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_message(&mut self) -> ServerMessage {
        self.server_message.take().unwrap_or_else(|| ServerMessage::new())
    }

    // optional string message_no_bbcode = 9;


    pub fn get_message_no_bbcode(&self) -> &str {
        match self.message_no_bbcode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_no_bbcode(&mut self) {
        self.message_no_bbcode.clear();
    }

    pub fn has_message_no_bbcode(&self) -> bool {
        self.message_no_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_no_bbcode(&mut self, v: ::std::string::String) {
        self.message_no_bbcode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_no_bbcode(&mut self) -> &mut ::std::string::String {
        if self.message_no_bbcode.is_none() {
            self.message_no_bbcode.set_default();
        }
        self.message_no_bbcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_no_bbcode(&mut self) -> ::std::string::String {
        self.message_no_bbcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_name = 10;


    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_IncomingChatMessage_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.mentions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_sender = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mentions)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_message)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_no_bbcode)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_sender {
            my_size += 9;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mentions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message_no_bbcode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.mentions.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.server_message.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message_no_bbcode.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_IncomingChatMessage_Notification {
        CChatRoom_IncomingChatMessage_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_id },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_sender",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.steamid_sender },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.steamid_sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.timestamp },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatMentions>>(
                "mentions",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.mentions },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.mentions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.ordinal },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerMessage>>(
                "server_message",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.server_message },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.server_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_no_bbcode",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message_no_bbcode },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message_no_bbcode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chat_name",
                |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_name },
                |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_IncomingChatMessage_Notification>(
                "CChatRoom_IncomingChatMessage_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_IncomingChatMessage_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_IncomingChatMessage_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_IncomingChatMessage_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_IncomingChatMessage_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.steamid_sender = ::std::option::Option::None;
        self.message.clear();
        self.timestamp = ::std::option::Option::None;
        self.mentions.clear();
        self.ordinal = ::std::option::Option::None;
        self.server_message.clear();
        self.message_no_bbcode.clear();
        self.chat_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_IncomingChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_IncomingChatMessage_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ChatMessageModified_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    pub messages: ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatMessageModified_Notification {
    fn default() -> &'a CChatRoom_ChatMessageModified_Notification {
        <CChatRoom_ChatMessageModified_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatMessageModified_Notification {
    pub fn new() -> CChatRoom_ChatMessageModified_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoom_ChatMessageModified_Notification.ChatMessage messages = 3;


    pub fn get_messages(&self) -> &[CChatRoom_ChatMessageModified_Notification_ChatMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_ChatMessageModified_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatMessageModified_Notification {
        CChatRoom_ChatMessageModified_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_id },
                |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_ChatMessageModified_Notification_ChatMessage>>(
                "messages",
                |m: &CChatRoom_ChatMessageModified_Notification| { &m.messages },
                |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ChatMessageModified_Notification>(
                "CChatRoom_ChatMessageModified_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ChatMessageModified_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ChatMessageModified_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ChatMessageModified_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ChatMessageModified_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatMessageModified_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatMessageModified_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ChatMessageModified_Notification_ChatMessage {
    // message fields
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    deleted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn default() -> &'a CChatRoom_ChatMessageModified_Notification_ChatMessage {
        <CChatRoom_ChatMessageModified_Notification_ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatMessageModified_Notification_ChatMessage {
    pub fn new() -> CChatRoom_ChatMessageModified_Notification_ChatMessage {
        ::std::default::Default::default()
    }

    // optional uint32 server_timestamp = 1;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 2;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 3;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatMessageModified_Notification_ChatMessage {
        CChatRoom_ChatMessageModified_Notification_ChatMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CChatRoom_ChatMessageModified_Notification_ChatMessage| { &m.server_timestamp },
                |m: &mut CChatRoom_ChatMessageModified_Notification_ChatMessage| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_ChatMessageModified_Notification_ChatMessage| { &m.ordinal },
                |m: &mut CChatRoom_ChatMessageModified_Notification_ChatMessage| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &CChatRoom_ChatMessageModified_Notification_ChatMessage| { &m.deleted },
                |m: &mut CChatRoom_ChatMessageModified_Notification_ChatMessage| { &mut m.deleted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ChatMessageModified_Notification_ChatMessage>(
                "CChatRoom_ChatMessageModified_Notification.ChatMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ChatMessageModified_Notification_ChatMessage {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ChatMessageModified_Notification_ChatMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ChatMessageModified_Notification_ChatMessage::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn clear(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_MemberStateChange_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    pub member: ::protobuf::SingularPtrField<CChatRoomMember>,
    change: ::std::option::Option<EChatRoomMemberStateChange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MemberStateChange_Notification {
    fn default() -> &'a CChatRoom_MemberStateChange_Notification {
        <CChatRoom_MemberStateChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MemberStateChange_Notification {
    pub fn new() -> CChatRoom_MemberStateChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomMember member = 2;


    pub fn get_member(&self) -> &CChatRoomMember {
        self.member.as_ref().unwrap_or_else(|| <CChatRoomMember as ::protobuf::Message>::default_instance())
    }
    pub fn clear_member(&mut self) {
        self.member.clear();
    }

    pub fn has_member(&self) -> bool {
        self.member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: CChatRoomMember) {
        self.member = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member(&mut self) -> &mut CChatRoomMember {
        if self.member.is_none() {
            self.member.set_default();
        }
        self.member.as_mut().unwrap()
    }

    // Take field
    pub fn take_member(&mut self) -> CChatRoomMember {
        self.member.take().unwrap_or_else(|| CChatRoomMember::new())
    }

    // optional .EChatRoomMemberStateChange change = 3;


    pub fn get_change(&self) -> EChatRoomMemberStateChange {
        self.change.unwrap_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid)
    }
    pub fn clear_change(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_change(&self) -> bool {
        self.change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: EChatRoomMemberStateChange) {
        self.change = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_MemberStateChange_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.member {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.member)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.change, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.change {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.member.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.change {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_MemberStateChange_Notification {
        CChatRoom_MemberStateChange_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_MemberStateChange_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMember>>(
                "member",
                |m: &CChatRoom_MemberStateChange_Notification| { &m.member },
                |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.member },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMemberStateChange>>(
                "change",
                |m: &CChatRoom_MemberStateChange_Notification| { &m.change },
                |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.change },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_MemberStateChange_Notification>(
                "CChatRoom_MemberStateChange_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_MemberStateChange_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_MemberStateChange_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_MemberStateChange_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_MemberStateChange_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.member.clear();
        self.change = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_MemberStateChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MemberStateChange_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ChatRoomHeaderState_Notification {
    // message fields
    pub header_state: ::protobuf::SingularPtrField<CChatRoomGroupHeaderState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomHeaderState_Notification {
    fn default() -> &'a CChatRoom_ChatRoomHeaderState_Notification {
        <CChatRoom_ChatRoomHeaderState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomHeaderState_Notification {
    pub fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupHeaderState header_state = 1;


    pub fn get_header_state(&self) -> &CChatRoomGroupHeaderState {
        self.header_state.as_ref().unwrap_or_else(|| <CChatRoomGroupHeaderState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header_state(&mut self) {
        self.header_state.clear();
    }

    pub fn has_header_state(&self) -> bool {
        self.header_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_state(&mut self, v: CChatRoomGroupHeaderState) {
        self.header_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_state(&mut self) -> &mut CChatRoomGroupHeaderState {
        if self.header_state.is_none() {
            self.header_state.set_default();
        }
        self.header_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_state(&mut self) -> CChatRoomGroupHeaderState {
        self.header_state.take().unwrap_or_else(|| CChatRoomGroupHeaderState::new())
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomHeaderState_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.header_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        CChatRoom_ChatRoomHeaderState_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupHeaderState>>(
                "header_state",
                |m: &CChatRoom_ChatRoomHeaderState_Notification| { &m.header_state },
                |m: &mut CChatRoom_ChatRoomHeaderState_Notification| { &mut m.header_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ChatRoomHeaderState_Notification>(
                "CChatRoom_ChatRoomHeaderState_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomHeaderState_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ChatRoomHeaderState_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ChatRoomHeaderState_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ChatRoomHeaderState_Notification {
    fn clear(&mut self) {
        self.header_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatRoomHeaderState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatRoomHeaderState_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_ChatRoomGroupRoomsChange_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    default_chat_id: ::std::option::Option<u64>,
    pub chat_rooms: ::protobuf::RepeatedField<CChatRoomState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn default() -> &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
        <CChatRoom_ChatRoomGroupRoomsChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomGroupRoomsChange_Notification {
    pub fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 2;


    pub fn get_default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }
    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 3;


    pub fn get_chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }
    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::protobuf::RepeatedField<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::protobuf::RepeatedField<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_rooms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.chat_rooms {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        CChatRoom_ChatRoomGroupRoomsChange_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "default_chat_id",
                |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.default_chat_id },
                |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.default_chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                "chat_rooms",
                |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_rooms },
                |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_rooms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_ChatRoomGroupRoomsChange_Notification>(
                "CChatRoom_ChatRoomGroupRoomsChange_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomGroupRoomsChange_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_ChatRoomGroupRoomsChange_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_ChatRoomGroupRoomsChange_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    // message fields
    chat_id: ::std::option::Option<u64>,
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn default() -> &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        <CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    pub fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_id },
                |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification>(
                "CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    pub user_chat_group_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    pub group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    user_action: ::std::option::Option<EChatRoomMemberStateChange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        <ChatRoomClient_NotifyChatGroupUserStateChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 2;


    pub fn get_user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_group_state.is_none() {
            self.user_chat_group_state.set_default();
        }
        self.user_chat_group_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 3;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional .EChatRoomMemberStateChange user_action = 4;


    pub fn get_user_action(&self) -> EChatRoomMemberStateChange {
        self.user_action.unwrap_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid)
    }
    pub fn clear_user_action(&mut self) {
        self.user_action = ::std::option::Option::None;
    }

    pub fn has_user_action(&self) -> bool {
        self.user_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_action(&mut self, v: EChatRoomMemberStateChange) {
        self.user_action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.user_chat_group_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_group_state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.user_action, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.user_action {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.user_action {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.chat_group_id },
                |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                "user_chat_group_state",
                |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_chat_group_state },
                |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_chat_group_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                "group_summary",
                |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.group_summary },
                |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.group_summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMemberStateChange>>(
                "user_action",
                |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_action },
                |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChatRoomClient_NotifyChatGroupUserStateChanged_Notification>(
                "ChatRoomClient_NotifyChatGroupUserStateChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        static instance: ::protobuf::rt::LazyV2<ChatRoomClient_NotifyChatGroupUserStateChanged_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::new)
    }
}

impl ::protobuf::Clear for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.user_action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    // message fields
    pub chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        <ChatRoomClient_NotifyChatRoomDisconnect_Notification as ::protobuf::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ::std::default::Default::default()
    }

    // repeated uint64 chat_group_ids = 1;


    pub fn get_chat_group_ids(&self) -> &[u64] {
        &self.chat_group_ids
    }
    pub fn clear_chat_group_ids(&mut self) {
        self.chat_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_group_ids
    }

    // Take field
    pub fn take_chat_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_group_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.chat_group_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ChatRoomClient_NotifyChatRoomDisconnect_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_ids",
                |m: &ChatRoomClient_NotifyChatRoomDisconnect_Notification| { &m.chat_group_ids },
                |m: &mut ChatRoomClient_NotifyChatRoomDisconnect_Notification| { &mut m.chat_group_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChatRoomClient_NotifyChatRoomDisconnect_Notification>(
                "ChatRoomClient_NotifyChatRoomDisconnect_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        static instance: ::protobuf::rt::LazyV2<ChatRoomClient_NotifyChatRoomDisconnect_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChatRoomClient_NotifyChatRoomDisconnect_Notification::new)
    }
}

impl ::protobuf::Clear for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomMemberListView {
    // message fields
    start: ::std::option::Option<i32>,
    end: ::std::option::Option<i32>,
    total_count: ::std::option::Option<i32>,
    client_changenumber: ::std::option::Option<i32>,
    server_changenumber: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberListView {
    fn default() -> &'a CChatRoomMemberListView {
        <CChatRoomMemberListView as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMemberListView {
    pub fn new() -> CChatRoomMemberListView {
        ::std::default::Default::default()
    }

    // optional int32 start = 3;


    pub fn get_start(&self) -> i32 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;


    pub fn get_end(&self) -> i32 {
        self.end.unwrap_or(0)
    }
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 total_count = 5;


    pub fn get_total_count(&self) -> i32 {
        self.total_count.unwrap_or(0)
    }
    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i32) {
        self.total_count = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 6;


    pub fn get_client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }
    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional int32 server_changenumber = 7;


    pub fn get_server_changenumber(&self) -> i32 {
        self.server_changenumber.unwrap_or(0)
    }
    pub fn clear_server_changenumber(&mut self) {
        self.server_changenumber = ::std::option::Option::None;
    }

    pub fn has_server_changenumber(&self) -> bool {
        self.server_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_changenumber(&mut self, v: i32) {
        self.server_changenumber = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomMemberListView {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.client_changenumber = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.server_changenumber = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_changenumber {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_changenumber {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.total_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.server_changenumber {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomMemberListView {
        CChatRoomMemberListView::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start",
                |m: &CChatRoomMemberListView| { &m.start },
                |m: &mut CChatRoomMemberListView| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "end",
                |m: &CChatRoomMemberListView| { &m.end },
                |m: &mut CChatRoomMemberListView| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_count",
                |m: &CChatRoomMemberListView| { &m.total_count },
                |m: &mut CChatRoomMemberListView| { &mut m.total_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "client_changenumber",
                |m: &CChatRoomMemberListView| { &m.client_changenumber },
                |m: &mut CChatRoomMemberListView| { &mut m.client_changenumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "server_changenumber",
                |m: &CChatRoomMemberListView| { &m.server_changenumber },
                |m: &mut CChatRoomMemberListView| { &mut m.server_changenumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomMemberListView>(
                "CChatRoomMemberListView",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomMemberListView {
        static instance: ::protobuf::rt::LazyV2<CChatRoomMemberListView> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomMemberListView::new)
    }
}

impl ::protobuf::Clear for CChatRoomMemberListView {
    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.total_count = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.server_changenumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomMemberListView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomMemberListView {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomMemberSummaryCounts {
    // message fields
    ingame: ::std::option::Option<i32>,
    online: ::std::option::Option<i32>,
    offline: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberSummaryCounts {
    fn default() -> &'a CChatRoomMemberSummaryCounts {
        <CChatRoomMemberSummaryCounts as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMemberSummaryCounts {
    pub fn new() -> CChatRoomMemberSummaryCounts {
        ::std::default::Default::default()
    }

    // optional int32 ingame = 1;


    pub fn get_ingame(&self) -> i32 {
        self.ingame.unwrap_or(0)
    }
    pub fn clear_ingame(&mut self) {
        self.ingame = ::std::option::Option::None;
    }

    pub fn has_ingame(&self) -> bool {
        self.ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingame(&mut self, v: i32) {
        self.ingame = ::std::option::Option::Some(v);
    }

    // optional int32 online = 2;


    pub fn get_online(&self) -> i32 {
        self.online.unwrap_or(0)
    }
    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: i32) {
        self.online = ::std::option::Option::Some(v);
    }

    // optional int32 offline = 3;


    pub fn get_offline(&self) -> i32 {
        self.offline.unwrap_or(0)
    }
    pub fn clear_offline(&mut self) {
        self.offline = ::std::option::Option::None;
    }

    pub fn has_offline(&self) -> bool {
        self.offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline(&mut self, v: i32) {
        self.offline = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomMemberSummaryCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ingame = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.online = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offline = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ingame {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.online {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offline {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ingame {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.online {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.offline {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomMemberSummaryCounts {
        CChatRoomMemberSummaryCounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ingame",
                |m: &CChatRoomMemberSummaryCounts| { &m.ingame },
                |m: &mut CChatRoomMemberSummaryCounts| { &mut m.ingame },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "online",
                |m: &CChatRoomMemberSummaryCounts| { &m.online },
                |m: &mut CChatRoomMemberSummaryCounts| { &mut m.online },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offline",
                |m: &CChatRoomMemberSummaryCounts| { &m.offline },
                |m: &mut CChatRoomMemberSummaryCounts| { &mut m.offline },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomMemberSummaryCounts>(
                "CChatRoomMemberSummaryCounts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomMemberSummaryCounts {
        static instance: ::protobuf::rt::LazyV2<CChatRoomMemberSummaryCounts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomMemberSummaryCounts::new)
    }
}

impl ::protobuf::Clear for CChatRoomMemberSummaryCounts {
    fn clear(&mut self) {
        self.ingame = ::std::option::Option::None;
        self.online = ::std::option::Option::None;
        self.offline = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomMemberSummaryCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomMemberSummaryCounts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomClient_MemberListViewUpdated_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    view_id: ::std::option::Option<u64>,
    pub view: ::protobuf::SingularPtrField<CChatRoomMemberListView>,
    pub members: ::protobuf::RepeatedField<CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry>,
    status_flags: ::std::option::Option<u32>,
    pub member_summary: ::protobuf::SingularPtrField<CChatRoomMemberSummaryCounts>,
    pub subscribed_personas: ::protobuf::RepeatedField<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomClient_MemberListViewUpdated_Notification {
    fn default() -> &'a CChatRoomClient_MemberListViewUpdated_Notification {
        <CChatRoomClient_MemberListViewUpdated_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomClient_MemberListViewUpdated_Notification {
    pub fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;


    pub fn get_view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }
    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomMemberListView view = 3;


    pub fn get_view(&self) -> &CChatRoomMemberListView {
        self.view.as_ref().unwrap_or_else(|| <CChatRoomMemberListView as ::protobuf::Message>::default_instance())
    }
    pub fn clear_view(&mut self) {
        self.view.clear();
    }

    pub fn has_view(&self) -> bool {
        self.view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view(&mut self, v: CChatRoomMemberListView) {
        self.view = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view(&mut self) -> &mut CChatRoomMemberListView {
        if self.view.is_none() {
            self.view.set_default();
        }
        self.view.as_mut().unwrap()
    }

    // Take field
    pub fn take_view(&mut self) -> CChatRoomMemberListView {
        self.view.take().unwrap_or_else(|| CChatRoomMemberListView::new())
    }

    // repeated .CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry members = 4;


    pub fn get_members(&self) -> &[CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional uint32 status_flags = 5;


    pub fn get_status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }
    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomMemberSummaryCounts member_summary = 6;


    pub fn get_member_summary(&self) -> &CChatRoomMemberSummaryCounts {
        self.member_summary.as_ref().unwrap_or_else(|| <CChatRoomMemberSummaryCounts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_member_summary(&mut self) {
        self.member_summary.clear();
    }

    pub fn has_member_summary(&self) -> bool {
        self.member_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_summary(&mut self, v: CChatRoomMemberSummaryCounts) {
        self.member_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member_summary(&mut self) -> &mut CChatRoomMemberSummaryCounts {
        if self.member_summary.is_none() {
            self.member_summary.set_default();
        }
        self.member_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_member_summary(&mut self) -> CChatRoomMemberSummaryCounts {
        self.member_summary.take().unwrap_or_else(|| CChatRoomMemberSummaryCounts::new())
    }

    // repeated .CMsgClientPersonaState.Friend subscribed_personas = 7;


    pub fn get_subscribed_personas(&self) -> &[super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend] {
        &self.subscribed_personas
    }
    pub fn clear_subscribed_personas(&mut self) {
        self.subscribed_personas.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscribed_personas(&mut self, v: ::protobuf::RepeatedField<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend>) {
        self.subscribed_personas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscribed_personas(&mut self) -> &mut ::protobuf::RepeatedField<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend> {
        &mut self.subscribed_personas
    }

    // Take field
    pub fn take_subscribed_personas(&mut self) -> ::protobuf::RepeatedField<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend> {
        ::std::mem::replace(&mut self.subscribed_personas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoomClient_MemberListViewUpdated_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.view {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.member_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscribed_personas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.view_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.view)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status_flags = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.member_summary)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscribed_personas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.view_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.view.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.member_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.subscribed_personas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.view.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.member_summary.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.subscribed_personas {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        CChatRoomClient_MemberListViewUpdated_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.chat_group_id },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "view_id",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.view_id },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.view_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMemberListView>>(
                "view",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.view },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.view },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry>>(
                "members",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.members },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status_flags",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.status_flags },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.status_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMemberSummaryCounts>>(
                "member_summary",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.member_summary },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.member_summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend>>(
                "subscribed_personas",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.subscribed_personas },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.subscribed_personas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomClient_MemberListViewUpdated_Notification>(
                "CChatRoomClient_MemberListViewUpdated_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomClient_MemberListViewUpdated_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoomClient_MemberListViewUpdated_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomClient_MemberListViewUpdated_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoomClient_MemberListViewUpdated_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.view.clear();
        self.members.clear();
        self.status_flags = ::std::option::Option::None;
        self.member_summary.clear();
        self.subscribed_personas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomClient_MemberListViewUpdated_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomClient_MemberListViewUpdated_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
    // message fields
    rank: ::std::option::Option<i32>,
    accountid: ::std::option::Option<u32>,
    pub persona: ::protobuf::SingularPtrField<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
    fn default() -> &'a CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
        <CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
    pub fn new() -> CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
        ::std::default::Default::default()
    }

    // optional int32 rank = 1;


    pub fn get_rank(&self) -> i32 {
        self.rank.unwrap_or(0)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: i32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .CMsgClientPersonaState.Friend persona = 3;


    pub fn get_persona(&self) -> &super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend {
        self.persona.as_ref().unwrap_or_else(|| <super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend as ::protobuf::Message>::default_instance())
    }
    pub fn clear_persona(&mut self) {
        self.persona.clear();
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend) {
        self.persona = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend {
        if self.persona.is_none() {
            self.persona.set_default();
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend {
        self.persona.take().unwrap_or_else(|| super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend::new())
    }
}

impl ::protobuf::Message for CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.persona {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persona)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.persona.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rank {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.persona.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
        CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rank",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry| { &m.rank },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry| { &m.accountid },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_clientserver_friends::CMsgClientPersonaState_Friend>>(
                "persona",
                |m: &CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry| { &m.persona },
                |m: &mut CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry| { &mut m.persona },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry>(
                "CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
        static instance: ::protobuf::rt::LazyV2<CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry::new)
    }
}

impl ::protobuf::Clear for CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
    fn clear(&mut self) {
        self.rank = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.persona.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatRoom_MessageReaction_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    reactor: ::std::option::Option<u64>,
    reaction_type: ::std::option::Option<EChatRoomMessageReactionType>,
    reaction: ::protobuf::SingularField<::std::string::String>,
    is_add: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MessageReaction_Notification {
    fn default() -> &'a CChatRoom_MessageReaction_Notification {
        <CChatRoom_MessageReaction_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MessageReaction_Notification {
    pub fn new() -> CChatRoom_MessageReaction_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional fixed64 reactor = 5;


    pub fn get_reactor(&self) -> u64 {
        self.reactor.unwrap_or(0)
    }
    pub fn clear_reactor(&mut self) {
        self.reactor = ::std::option::Option::None;
    }

    pub fn has_reactor(&self) -> bool {
        self.reactor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactor(&mut self, v: u64) {
        self.reactor = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 6;


    pub fn get_reaction_type(&self) -> EChatRoomMessageReactionType {
        self.reaction_type.unwrap_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid)
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(v);
    }

    // optional string reaction = 7;


    pub fn get_reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reaction(&mut self) {
        self.reaction.clear();
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction.set_default();
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 8;


    pub fn get_is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }
    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_MessageReaction_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.reactor = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reaction)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_add = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reactor {
            my_size += 9;
        }
        if let Some(v) = self.reaction_type {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(ref v) = self.reaction.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reactor {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.reaction.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_MessageReaction_Notification {
        CChatRoom_MessageReaction_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CChatRoom_MessageReaction_Notification| { &m.chat_group_id },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.chat_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_id",
                |m: &CChatRoom_MessageReaction_Notification| { &m.chat_id },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CChatRoom_MessageReaction_Notification| { &m.server_timestamp },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CChatRoom_MessageReaction_Notification| { &m.ordinal },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "reactor",
                |m: &CChatRoom_MessageReaction_Notification| { &m.reactor },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reactor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMessageReactionType>>(
                "reaction_type",
                |m: &CChatRoom_MessageReaction_Notification| { &m.reaction_type },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reaction",
                |m: &CChatRoom_MessageReaction_Notification| { &m.reaction },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_add",
                |m: &CChatRoom_MessageReaction_Notification| { &m.is_add },
                |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.is_add },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatRoom_MessageReaction_Notification>(
                "CChatRoom_MessageReaction_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatRoom_MessageReaction_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatRoom_MessageReaction_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatRoom_MessageReaction_Notification::new)
    }
}

impl ::protobuf::Clear for CChatRoom_MessageReaction_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reactor = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction.clear();
        self.is_add = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_MessageReaction_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MessageReaction_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification {
    // message fields
    metrics_run_id: ::std::option::Option<u32>,
    client_build: ::std::option::Option<u32>,
    metrics_version: ::std::option::Option<u32>,
    in_web: ::std::option::Option<bool>,
    pub settings: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_Settings>,
    pub voice_settings: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings>,
    pub ui_state: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_UIState>,
    pub metrics: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_Metrics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification {
        <CChatUsability_ClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;


    pub fn get_metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }
    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_build = 2;


    pub fn get_client_build(&self) -> u32 {
        self.client_build.unwrap_or(0)
    }
    pub fn clear_client_build(&mut self) {
        self.client_build = ::std::option::Option::None;
    }

    pub fn has_client_build(&self) -> bool {
        self.client_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_build(&mut self, v: u32) {
        self.client_build = ::std::option::Option::Some(v);
    }

    // optional uint32 metrics_version = 3;


    pub fn get_metrics_version(&self) -> u32 {
        self.metrics_version.unwrap_or(0)
    }
    pub fn clear_metrics_version(&mut self) {
        self.metrics_version = ::std::option::Option::None;
    }

    pub fn has_metrics_version(&self) -> bool {
        self.metrics_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_version(&mut self, v: u32) {
        self.metrics_version = ::std::option::Option::Some(v);
    }

    // optional bool in_web = 4;


    pub fn get_in_web(&self) -> bool {
        self.in_web.unwrap_or(false)
    }
    pub fn clear_in_web(&mut self) {
        self.in_web = ::std::option::Option::None;
    }

    pub fn has_in_web(&self) -> bool {
        self.in_web.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_web(&mut self, v: bool) {
        self.in_web = ::std::option::Option::Some(v);
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.Settings settings = 10;


    pub fn get_settings(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        self.settings.as_ref().unwrap_or_else(|| <CChatUsability_ClientUsabilityMetrics_Notification_Settings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    pub fn has_settings(&self) -> bool {
        self.settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_Settings) {
        self.settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        if self.settings.is_none() {
            self.settings.set_default();
        }
        self.settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_settings(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        self.settings.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_Settings::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings voice_settings = 11;


    pub fn get_voice_settings(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        self.voice_settings.as_ref().unwrap_or_else(|| <CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voice_settings(&mut self) {
        self.voice_settings.clear();
    }

    pub fn has_voice_settings(&self) -> bool {
        self.voice_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_settings(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings) {
        self.voice_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_settings(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        if self.voice_settings.is_none() {
            self.voice_settings.set_default();
        }
        self.voice_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_settings(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        self.voice_settings.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.UIState ui_state = 12;


    pub fn get_ui_state(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        self.ui_state.as_ref().unwrap_or_else(|| <CChatUsability_ClientUsabilityMetrics_Notification_UIState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ui_state(&mut self) {
        self.ui_state.clear();
    }

    pub fn has_ui_state(&self) -> bool {
        self.ui_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_state(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_UIState) {
        self.ui_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ui_state(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        if self.ui_state.is_none() {
            self.ui_state.set_default();
        }
        self.ui_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_ui_state(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        self.ui_state.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_UIState::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.Metrics metrics = 13;


    pub fn get_metrics(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        self.metrics.as_ref().unwrap_or_else(|| <CChatUsability_ClientUsabilityMetrics_Notification_Metrics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    pub fn has_metrics(&self) -> bool {
        self.metrics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_Metrics) {
        self.metrics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metrics(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        if self.metrics.is_none() {
            self.metrics.set_default();
        }
        self.metrics.as_mut().unwrap()
    }

    // Take field
    pub fn take_metrics(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        self.metrics.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_Metrics::new())
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.settings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voice_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ui_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.metrics_run_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_build = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.metrics_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_web = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.settings)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voice_settings)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ui_state)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_build {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.metrics_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_web {
            my_size += 2;
        }
        if let Some(ref v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voice_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_build {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.metrics_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_web {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.settings.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voice_settings.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ui_state.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        CChatUsability_ClientUsabilityMetrics_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "metrics_run_id",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_run_id },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_build",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.client_build },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.client_build },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "metrics_version",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_version },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_web",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.in_web },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.in_web },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_Settings>>(
                "settings",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.settings },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.settings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings>>(
                "voice_settings",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.voice_settings },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.voice_settings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_UIState>>(
                "ui_state",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.ui_state },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.ui_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_Metrics>>(
                "metrics",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatUsability_ClientUsabilityMetrics_Notification>(
                "CChatUsability_ClientUsabilityMetrics_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatUsability_ClientUsabilityMetrics_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatUsability_ClientUsabilityMetrics_Notification::new)
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification {
    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.client_build = ::std::option::Option::None;
        self.metrics_version = ::std::option::Option::None;
        self.in_web = ::std::option::Option::None;
        self.settings.clear();
        self.voice_settings.clear();
        self.ui_state.clear();
        self.metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    // message fields
    notifications_show_ingame: ::std::option::Option<bool>,
    notifications_show_online: ::std::option::Option<bool>,
    notifications_show_message: ::std::option::Option<bool>,
    notifications_events_and_announcements: ::std::option::Option<bool>,
    sounds_play_ingame: ::std::option::Option<bool>,
    sounds_play_online: ::std::option::Option<bool>,
    sounds_play_message: ::std::option::Option<bool>,
    sounds_events_and_announcements: ::std::option::Option<bool>,
    always_new_chat_window: ::std::option::Option<bool>,
    force_alphabetic_friend_sorting: ::std::option::Option<bool>,
    chat_flash_mode: ::std::option::Option<i32>,
    remember_open_chats: ::std::option::Option<bool>,
    compact_quick_access: ::std::option::Option<bool>,
    compact_friends_list: ::std::option::Option<bool>,
    notifications_show_chat_room_notification: ::std::option::Option<bool>,
    sounds_play_chat_room_notification: ::std::option::Option<bool>,
    hide_offline_friends_in_tag_groups: ::std::option::Option<bool>,
    hide_categorized_friends: ::std::option::Option<bool>,
    categorize_in_game_friends_by_game: ::std::option::Option<bool>,
    chat_font_size: ::std::option::Option<i32>,
    use24hour_clock: ::std::option::Option<bool>,
    do_not_disturb_mode: ::std::option::Option<bool>,
    disable_embed_inlining: ::std::option::Option<bool>,
    sign_into_friends: ::std::option::Option<bool>,
    animated_avatars: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        <CChatUsability_ClientUsabilityMetrics_Notification_Settings as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        ::std::default::Default::default()
    }

    // optional bool notifications_show_ingame = 1;


    pub fn get_notifications_show_ingame(&self) -> bool {
        self.notifications_show_ingame.unwrap_or(false)
    }
    pub fn clear_notifications_show_ingame(&mut self) {
        self.notifications_show_ingame = ::std::option::Option::None;
    }

    pub fn has_notifications_show_ingame(&self) -> bool {
        self.notifications_show_ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_ingame(&mut self, v: bool) {
        self.notifications_show_ingame = ::std::option::Option::Some(v);
    }

    // optional bool notifications_show_online = 2;


    pub fn get_notifications_show_online(&self) -> bool {
        self.notifications_show_online.unwrap_or(false)
    }
    pub fn clear_notifications_show_online(&mut self) {
        self.notifications_show_online = ::std::option::Option::None;
    }

    pub fn has_notifications_show_online(&self) -> bool {
        self.notifications_show_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_online(&mut self, v: bool) {
        self.notifications_show_online = ::std::option::Option::Some(v);
    }

    // optional bool notifications_show_message = 3;


    pub fn get_notifications_show_message(&self) -> bool {
        self.notifications_show_message.unwrap_or(false)
    }
    pub fn clear_notifications_show_message(&mut self) {
        self.notifications_show_message = ::std::option::Option::None;
    }

    pub fn has_notifications_show_message(&self) -> bool {
        self.notifications_show_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_message(&mut self, v: bool) {
        self.notifications_show_message = ::std::option::Option::Some(v);
    }

    // optional bool notifications_events_and_announcements = 4;


    pub fn get_notifications_events_and_announcements(&self) -> bool {
        self.notifications_events_and_announcements.unwrap_or(false)
    }
    pub fn clear_notifications_events_and_announcements(&mut self) {
        self.notifications_events_and_announcements = ::std::option::Option::None;
    }

    pub fn has_notifications_events_and_announcements(&self) -> bool {
        self.notifications_events_and_announcements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_events_and_announcements(&mut self, v: bool) {
        self.notifications_events_and_announcements = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_ingame = 5;


    pub fn get_sounds_play_ingame(&self) -> bool {
        self.sounds_play_ingame.unwrap_or(false)
    }
    pub fn clear_sounds_play_ingame(&mut self) {
        self.sounds_play_ingame = ::std::option::Option::None;
    }

    pub fn has_sounds_play_ingame(&self) -> bool {
        self.sounds_play_ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_ingame(&mut self, v: bool) {
        self.sounds_play_ingame = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_online = 6;


    pub fn get_sounds_play_online(&self) -> bool {
        self.sounds_play_online.unwrap_or(false)
    }
    pub fn clear_sounds_play_online(&mut self) {
        self.sounds_play_online = ::std::option::Option::None;
    }

    pub fn has_sounds_play_online(&self) -> bool {
        self.sounds_play_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_online(&mut self, v: bool) {
        self.sounds_play_online = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_message = 7;


    pub fn get_sounds_play_message(&self) -> bool {
        self.sounds_play_message.unwrap_or(false)
    }
    pub fn clear_sounds_play_message(&mut self) {
        self.sounds_play_message = ::std::option::Option::None;
    }

    pub fn has_sounds_play_message(&self) -> bool {
        self.sounds_play_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_message(&mut self, v: bool) {
        self.sounds_play_message = ::std::option::Option::Some(v);
    }

    // optional bool sounds_events_and_announcements = 8;


    pub fn get_sounds_events_and_announcements(&self) -> bool {
        self.sounds_events_and_announcements.unwrap_or(false)
    }
    pub fn clear_sounds_events_and_announcements(&mut self) {
        self.sounds_events_and_announcements = ::std::option::Option::None;
    }

    pub fn has_sounds_events_and_announcements(&self) -> bool {
        self.sounds_events_and_announcements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_events_and_announcements(&mut self, v: bool) {
        self.sounds_events_and_announcements = ::std::option::Option::Some(v);
    }

    // optional bool always_new_chat_window = 9;


    pub fn get_always_new_chat_window(&self) -> bool {
        self.always_new_chat_window.unwrap_or(false)
    }
    pub fn clear_always_new_chat_window(&mut self) {
        self.always_new_chat_window = ::std::option::Option::None;
    }

    pub fn has_always_new_chat_window(&self) -> bool {
        self.always_new_chat_window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_new_chat_window(&mut self, v: bool) {
        self.always_new_chat_window = ::std::option::Option::Some(v);
    }

    // optional bool force_alphabetic_friend_sorting = 10;


    pub fn get_force_alphabetic_friend_sorting(&self) -> bool {
        self.force_alphabetic_friend_sorting.unwrap_or(false)
    }
    pub fn clear_force_alphabetic_friend_sorting(&mut self) {
        self.force_alphabetic_friend_sorting = ::std::option::Option::None;
    }

    pub fn has_force_alphabetic_friend_sorting(&self) -> bool {
        self.force_alphabetic_friend_sorting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_alphabetic_friend_sorting(&mut self, v: bool) {
        self.force_alphabetic_friend_sorting = ::std::option::Option::Some(v);
    }

    // optional int32 chat_flash_mode = 11;


    pub fn get_chat_flash_mode(&self) -> i32 {
        self.chat_flash_mode.unwrap_or(0)
    }
    pub fn clear_chat_flash_mode(&mut self) {
        self.chat_flash_mode = ::std::option::Option::None;
    }

    pub fn has_chat_flash_mode(&self) -> bool {
        self.chat_flash_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_flash_mode(&mut self, v: i32) {
        self.chat_flash_mode = ::std::option::Option::Some(v);
    }

    // optional bool remember_open_chats = 12;


    pub fn get_remember_open_chats(&self) -> bool {
        self.remember_open_chats.unwrap_or(false)
    }
    pub fn clear_remember_open_chats(&mut self) {
        self.remember_open_chats = ::std::option::Option::None;
    }

    pub fn has_remember_open_chats(&self) -> bool {
        self.remember_open_chats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remember_open_chats(&mut self, v: bool) {
        self.remember_open_chats = ::std::option::Option::Some(v);
    }

    // optional bool compact_quick_access = 13;


    pub fn get_compact_quick_access(&self) -> bool {
        self.compact_quick_access.unwrap_or(false)
    }
    pub fn clear_compact_quick_access(&mut self) {
        self.compact_quick_access = ::std::option::Option::None;
    }

    pub fn has_compact_quick_access(&self) -> bool {
        self.compact_quick_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compact_quick_access(&mut self, v: bool) {
        self.compact_quick_access = ::std::option::Option::Some(v);
    }

    // optional bool compact_friends_list = 14;


    pub fn get_compact_friends_list(&self) -> bool {
        self.compact_friends_list.unwrap_or(false)
    }
    pub fn clear_compact_friends_list(&mut self) {
        self.compact_friends_list = ::std::option::Option::None;
    }

    pub fn has_compact_friends_list(&self) -> bool {
        self.compact_friends_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compact_friends_list(&mut self, v: bool) {
        self.compact_friends_list = ::std::option::Option::Some(v);
    }

    // optional bool notifications_show_chat_room_notification = 15;


    pub fn get_notifications_show_chat_room_notification(&self) -> bool {
        self.notifications_show_chat_room_notification.unwrap_or(false)
    }
    pub fn clear_notifications_show_chat_room_notification(&mut self) {
        self.notifications_show_chat_room_notification = ::std::option::Option::None;
    }

    pub fn has_notifications_show_chat_room_notification(&self) -> bool {
        self.notifications_show_chat_room_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_chat_room_notification(&mut self, v: bool) {
        self.notifications_show_chat_room_notification = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_chat_room_notification = 16;


    pub fn get_sounds_play_chat_room_notification(&self) -> bool {
        self.sounds_play_chat_room_notification.unwrap_or(false)
    }
    pub fn clear_sounds_play_chat_room_notification(&mut self) {
        self.sounds_play_chat_room_notification = ::std::option::Option::None;
    }

    pub fn has_sounds_play_chat_room_notification(&self) -> bool {
        self.sounds_play_chat_room_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_chat_room_notification(&mut self, v: bool) {
        self.sounds_play_chat_room_notification = ::std::option::Option::Some(v);
    }

    // optional bool hide_offline_friends_in_tag_groups = 17;


    pub fn get_hide_offline_friends_in_tag_groups(&self) -> bool {
        self.hide_offline_friends_in_tag_groups.unwrap_or(false)
    }
    pub fn clear_hide_offline_friends_in_tag_groups(&mut self) {
        self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
    }

    pub fn has_hide_offline_friends_in_tag_groups(&self) -> bool {
        self.hide_offline_friends_in_tag_groups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_offline_friends_in_tag_groups(&mut self, v: bool) {
        self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(v);
    }

    // optional bool hide_categorized_friends = 18;


    pub fn get_hide_categorized_friends(&self) -> bool {
        self.hide_categorized_friends.unwrap_or(false)
    }
    pub fn clear_hide_categorized_friends(&mut self) {
        self.hide_categorized_friends = ::std::option::Option::None;
    }

    pub fn has_hide_categorized_friends(&self) -> bool {
        self.hide_categorized_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_categorized_friends(&mut self, v: bool) {
        self.hide_categorized_friends = ::std::option::Option::Some(v);
    }

    // optional bool categorize_in_game_friends_by_game = 19;


    pub fn get_categorize_in_game_friends_by_game(&self) -> bool {
        self.categorize_in_game_friends_by_game.unwrap_or(false)
    }
    pub fn clear_categorize_in_game_friends_by_game(&mut self) {
        self.categorize_in_game_friends_by_game = ::std::option::Option::None;
    }

    pub fn has_categorize_in_game_friends_by_game(&self) -> bool {
        self.categorize_in_game_friends_by_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_categorize_in_game_friends_by_game(&mut self, v: bool) {
        self.categorize_in_game_friends_by_game = ::std::option::Option::Some(v);
    }

    // optional int32 chat_font_size = 20;


    pub fn get_chat_font_size(&self) -> i32 {
        self.chat_font_size.unwrap_or(0)
    }
    pub fn clear_chat_font_size(&mut self) {
        self.chat_font_size = ::std::option::Option::None;
    }

    pub fn has_chat_font_size(&self) -> bool {
        self.chat_font_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_font_size(&mut self, v: i32) {
        self.chat_font_size = ::std::option::Option::Some(v);
    }

    // optional bool use24hour_clock = 21;


    pub fn get_use24hour_clock(&self) -> bool {
        self.use24hour_clock.unwrap_or(false)
    }
    pub fn clear_use24hour_clock(&mut self) {
        self.use24hour_clock = ::std::option::Option::None;
    }

    pub fn has_use24hour_clock(&self) -> bool {
        self.use24hour_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use24hour_clock(&mut self, v: bool) {
        self.use24hour_clock = ::std::option::Option::Some(v);
    }

    // optional bool do_not_disturb_mode = 22;


    pub fn get_do_not_disturb_mode(&self) -> bool {
        self.do_not_disturb_mode.unwrap_or(false)
    }
    pub fn clear_do_not_disturb_mode(&mut self) {
        self.do_not_disturb_mode = ::std::option::Option::None;
    }

    pub fn has_do_not_disturb_mode(&self) -> bool {
        self.do_not_disturb_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_not_disturb_mode(&mut self, v: bool) {
        self.do_not_disturb_mode = ::std::option::Option::Some(v);
    }

    // optional bool disable_embed_inlining = 23;


    pub fn get_disable_embed_inlining(&self) -> bool {
        self.disable_embed_inlining.unwrap_or(false)
    }
    pub fn clear_disable_embed_inlining(&mut self) {
        self.disable_embed_inlining = ::std::option::Option::None;
    }

    pub fn has_disable_embed_inlining(&self) -> bool {
        self.disable_embed_inlining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_embed_inlining(&mut self, v: bool) {
        self.disable_embed_inlining = ::std::option::Option::Some(v);
    }

    // optional bool sign_into_friends = 24;


    pub fn get_sign_into_friends(&self) -> bool {
        self.sign_into_friends.unwrap_or(false)
    }
    pub fn clear_sign_into_friends(&mut self) {
        self.sign_into_friends = ::std::option::Option::None;
    }

    pub fn has_sign_into_friends(&self) -> bool {
        self.sign_into_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_into_friends(&mut self, v: bool) {
        self.sign_into_friends = ::std::option::Option::Some(v);
    }

    // optional bool animated_avatars = 25;


    pub fn get_animated_avatars(&self) -> bool {
        self.animated_avatars.unwrap_or(false)
    }
    pub fn clear_animated_avatars(&mut self) {
        self.animated_avatars = ::std::option::Option::None;
    }

    pub fn has_animated_avatars(&self) -> bool {
        self.animated_avatars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animated_avatars(&mut self, v: bool) {
        self.animated_avatars = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_ingame = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_online = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_message = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_events_and_announcements = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_ingame = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_online = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_message = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_events_and_announcements = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.always_new_chat_window = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_alphabetic_friend_sorting = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_flash_mode = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remember_open_chats = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compact_quick_access = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compact_friends_list = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_chat_room_notification = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_chat_room_notification = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_categorized_friends = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.categorize_in_game_friends_by_game = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_font_size = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use24hour_clock = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.do_not_disturb_mode = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_embed_inlining = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sign_into_friends = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.animated_avatars = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.notifications_show_ingame {
            my_size += 2;
        }
        if let Some(v) = self.notifications_show_online {
            my_size += 2;
        }
        if let Some(v) = self.notifications_show_message {
            my_size += 2;
        }
        if let Some(v) = self.notifications_events_and_announcements {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_ingame {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_online {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_message {
            my_size += 2;
        }
        if let Some(v) = self.sounds_events_and_announcements {
            my_size += 2;
        }
        if let Some(v) = self.always_new_chat_window {
            my_size += 2;
        }
        if let Some(v) = self.force_alphabetic_friend_sorting {
            my_size += 2;
        }
        if let Some(v) = self.chat_flash_mode {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remember_open_chats {
            my_size += 2;
        }
        if let Some(v) = self.compact_quick_access {
            my_size += 2;
        }
        if let Some(v) = self.compact_friends_list {
            my_size += 2;
        }
        if let Some(v) = self.notifications_show_chat_room_notification {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_chat_room_notification {
            my_size += 3;
        }
        if let Some(v) = self.hide_offline_friends_in_tag_groups {
            my_size += 3;
        }
        if let Some(v) = self.hide_categorized_friends {
            my_size += 3;
        }
        if let Some(v) = self.categorize_in_game_friends_by_game {
            my_size += 3;
        }
        if let Some(v) = self.chat_font_size {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use24hour_clock {
            my_size += 3;
        }
        if let Some(v) = self.do_not_disturb_mode {
            my_size += 3;
        }
        if let Some(v) = self.disable_embed_inlining {
            my_size += 3;
        }
        if let Some(v) = self.sign_into_friends {
            my_size += 3;
        }
        if let Some(v) = self.animated_avatars {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.notifications_show_ingame {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.notifications_show_online {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.notifications_show_message {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.notifications_events_and_announcements {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.sounds_play_ingame {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.sounds_play_online {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.sounds_play_message {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sounds_events_and_announcements {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.always_new_chat_window {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.force_alphabetic_friend_sorting {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.chat_flash_mode {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.remember_open_chats {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.compact_quick_access {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.compact_friends_list {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.notifications_show_chat_room_notification {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.sounds_play_chat_room_notification {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.hide_offline_friends_in_tag_groups {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.hide_categorized_friends {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.categorize_in_game_friends_by_game {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.chat_font_size {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.use24hour_clock {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.do_not_disturb_mode {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.disable_embed_inlining {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.sign_into_friends {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.animated_avatars {
            os.write_bool(25, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        CChatUsability_ClientUsabilityMetrics_Notification_Settings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "notifications_show_ingame",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_ingame },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_ingame },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "notifications_show_online",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_online },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_online },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "notifications_show_message",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_message },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "notifications_events_and_announcements",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_events_and_announcements },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_events_and_announcements },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sounds_play_ingame",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_ingame },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_ingame },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sounds_play_online",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_online },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_online },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sounds_play_message",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_message },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sounds_events_and_announcements",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_events_and_announcements },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_events_and_announcements },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "always_new_chat_window",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.always_new_chat_window },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.always_new_chat_window },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_alphabetic_friend_sorting",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.force_alphabetic_friend_sorting },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.force_alphabetic_friend_sorting },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_flash_mode",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.chat_flash_mode },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.chat_flash_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remember_open_chats",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.remember_open_chats },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.remember_open_chats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "compact_quick_access",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.compact_quick_access },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.compact_quick_access },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "compact_friends_list",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.compact_friends_list },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.compact_friends_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "notifications_show_chat_room_notification",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_chat_room_notification },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_chat_room_notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sounds_play_chat_room_notification",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_chat_room_notification },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_chat_room_notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hide_offline_friends_in_tag_groups",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.hide_offline_friends_in_tag_groups },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.hide_offline_friends_in_tag_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hide_categorized_friends",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.hide_categorized_friends },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.hide_categorized_friends },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "categorize_in_game_friends_by_game",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.categorize_in_game_friends_by_game },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.categorize_in_game_friends_by_game },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_font_size",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.chat_font_size },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.chat_font_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use24hour_clock",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.use24hour_clock },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.use24hour_clock },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "do_not_disturb_mode",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.do_not_disturb_mode },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.do_not_disturb_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_embed_inlining",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.disable_embed_inlining },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.disable_embed_inlining },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sign_into_friends",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sign_into_friends },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sign_into_friends },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "animated_avatars",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.animated_avatars },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.animated_avatars },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatUsability_ClientUsabilityMetrics_Notification_Settings>(
                "CChatUsability_ClientUsabilityMetrics_Notification.Settings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        static instance: ::protobuf::rt::LazyV2<CChatUsability_ClientUsabilityMetrics_Notification_Settings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatUsability_ClientUsabilityMetrics_Notification_Settings::new)
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn clear(&mut self) {
        self.notifications_show_ingame = ::std::option::Option::None;
        self.notifications_show_online = ::std::option::Option::None;
        self.notifications_show_message = ::std::option::Option::None;
        self.notifications_events_and_announcements = ::std::option::Option::None;
        self.sounds_play_ingame = ::std::option::Option::None;
        self.sounds_play_online = ::std::option::Option::None;
        self.sounds_play_message = ::std::option::Option::None;
        self.sounds_events_and_announcements = ::std::option::Option::None;
        self.always_new_chat_window = ::std::option::Option::None;
        self.force_alphabetic_friend_sorting = ::std::option::Option::None;
        self.chat_flash_mode = ::std::option::Option::None;
        self.remember_open_chats = ::std::option::Option::None;
        self.compact_quick_access = ::std::option::Option::None;
        self.compact_friends_list = ::std::option::Option::None;
        self.notifications_show_chat_room_notification = ::std::option::Option::None;
        self.sounds_play_chat_room_notification = ::std::option::Option::None;
        self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
        self.hide_categorized_friends = ::std::option::Option::None;
        self.categorize_in_game_friends_by_game = ::std::option::Option::None;
        self.chat_font_size = ::std::option::Option::None;
        self.use24hour_clock = ::std::option::Option::None;
        self.do_not_disturb_mode = ::std::option::Option::None;
        self.disable_embed_inlining = ::std::option::Option::None;
        self.sign_into_friends = ::std::option::Option::None;
        self.animated_avatars = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    // message fields
    voice_input_gain: ::std::option::Option<f32>,
    voice_output_gain: ::std::option::Option<f32>,
    noise_gate_level: ::std::option::Option<i32>,
    voice_use_echo_cancellation: ::std::option::Option<bool>,
    voice_use_noise_cancellation: ::std::option::Option<bool>,
    voice_use_auto_gain_control: ::std::option::Option<bool>,
    selected_non_default_mic: ::std::option::Option<bool>,
    selected_non_default_output: ::std::option::Option<bool>,
    push_to_talk_enabled: ::std::option::Option<bool>,
    push_to_mute_enabled: ::std::option::Option<bool>,
    play_ptt_sounds: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        <CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        ::std::default::Default::default()
    }

    // optional float voice_input_gain = 1;


    pub fn get_voice_input_gain(&self) -> f32 {
        self.voice_input_gain.unwrap_or(0.)
    }
    pub fn clear_voice_input_gain(&mut self) {
        self.voice_input_gain = ::std::option::Option::None;
    }

    pub fn has_voice_input_gain(&self) -> bool {
        self.voice_input_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_input_gain(&mut self, v: f32) {
        self.voice_input_gain = ::std::option::Option::Some(v);
    }

    // optional float voice_output_gain = 2;


    pub fn get_voice_output_gain(&self) -> f32 {
        self.voice_output_gain.unwrap_or(0.)
    }
    pub fn clear_voice_output_gain(&mut self) {
        self.voice_output_gain = ::std::option::Option::None;
    }

    pub fn has_voice_output_gain(&self) -> bool {
        self.voice_output_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_output_gain(&mut self, v: f32) {
        self.voice_output_gain = ::std::option::Option::Some(v);
    }

    // optional int32 noise_gate_level = 3;


    pub fn get_noise_gate_level(&self) -> i32 {
        self.noise_gate_level.unwrap_or(0)
    }
    pub fn clear_noise_gate_level(&mut self) {
        self.noise_gate_level = ::std::option::Option::None;
    }

    pub fn has_noise_gate_level(&self) -> bool {
        self.noise_gate_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_noise_gate_level(&mut self, v: i32) {
        self.noise_gate_level = ::std::option::Option::Some(v);
    }

    // optional bool voice_use_echo_cancellation = 4;


    pub fn get_voice_use_echo_cancellation(&self) -> bool {
        self.voice_use_echo_cancellation.unwrap_or(false)
    }
    pub fn clear_voice_use_echo_cancellation(&mut self) {
        self.voice_use_echo_cancellation = ::std::option::Option::None;
    }

    pub fn has_voice_use_echo_cancellation(&self) -> bool {
        self.voice_use_echo_cancellation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_use_echo_cancellation(&mut self, v: bool) {
        self.voice_use_echo_cancellation = ::std::option::Option::Some(v);
    }

    // optional bool voice_use_noise_cancellation = 5;


    pub fn get_voice_use_noise_cancellation(&self) -> bool {
        self.voice_use_noise_cancellation.unwrap_or(false)
    }
    pub fn clear_voice_use_noise_cancellation(&mut self) {
        self.voice_use_noise_cancellation = ::std::option::Option::None;
    }

    pub fn has_voice_use_noise_cancellation(&self) -> bool {
        self.voice_use_noise_cancellation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_use_noise_cancellation(&mut self, v: bool) {
        self.voice_use_noise_cancellation = ::std::option::Option::Some(v);
    }

    // optional bool voice_use_auto_gain_control = 6;


    pub fn get_voice_use_auto_gain_control(&self) -> bool {
        self.voice_use_auto_gain_control.unwrap_or(false)
    }
    pub fn clear_voice_use_auto_gain_control(&mut self) {
        self.voice_use_auto_gain_control = ::std::option::Option::None;
    }

    pub fn has_voice_use_auto_gain_control(&self) -> bool {
        self.voice_use_auto_gain_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_use_auto_gain_control(&mut self, v: bool) {
        self.voice_use_auto_gain_control = ::std::option::Option::Some(v);
    }

    // optional bool selected_non_default_mic = 7;


    pub fn get_selected_non_default_mic(&self) -> bool {
        self.selected_non_default_mic.unwrap_or(false)
    }
    pub fn clear_selected_non_default_mic(&mut self) {
        self.selected_non_default_mic = ::std::option::Option::None;
    }

    pub fn has_selected_non_default_mic(&self) -> bool {
        self.selected_non_default_mic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_non_default_mic(&mut self, v: bool) {
        self.selected_non_default_mic = ::std::option::Option::Some(v);
    }

    // optional bool selected_non_default_output = 8;


    pub fn get_selected_non_default_output(&self) -> bool {
        self.selected_non_default_output.unwrap_or(false)
    }
    pub fn clear_selected_non_default_output(&mut self) {
        self.selected_non_default_output = ::std::option::Option::None;
    }

    pub fn has_selected_non_default_output(&self) -> bool {
        self.selected_non_default_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_non_default_output(&mut self, v: bool) {
        self.selected_non_default_output = ::std::option::Option::Some(v);
    }

    // optional bool push_to_talk_enabled = 9;


    pub fn get_push_to_talk_enabled(&self) -> bool {
        self.push_to_talk_enabled.unwrap_or(false)
    }
    pub fn clear_push_to_talk_enabled(&mut self) {
        self.push_to_talk_enabled = ::std::option::Option::None;
    }

    pub fn has_push_to_talk_enabled(&self) -> bool {
        self.push_to_talk_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_to_talk_enabled(&mut self, v: bool) {
        self.push_to_talk_enabled = ::std::option::Option::Some(v);
    }

    // optional bool push_to_mute_enabled = 10;


    pub fn get_push_to_mute_enabled(&self) -> bool {
        self.push_to_mute_enabled.unwrap_or(false)
    }
    pub fn clear_push_to_mute_enabled(&mut self) {
        self.push_to_mute_enabled = ::std::option::Option::None;
    }

    pub fn has_push_to_mute_enabled(&self) -> bool {
        self.push_to_mute_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_to_mute_enabled(&mut self, v: bool) {
        self.push_to_mute_enabled = ::std::option::Option::Some(v);
    }

    // optional bool play_ptt_sounds = 11;


    pub fn get_play_ptt_sounds(&self) -> bool {
        self.play_ptt_sounds.unwrap_or(false)
    }
    pub fn clear_play_ptt_sounds(&mut self) {
        self.play_ptt_sounds = ::std::option::Option::None;
    }

    pub fn has_play_ptt_sounds(&self) -> bool {
        self.play_ptt_sounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_ptt_sounds(&mut self, v: bool) {
        self.play_ptt_sounds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.voice_input_gain = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.voice_output_gain = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.noise_gate_level = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_use_echo_cancellation = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_use_noise_cancellation = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_use_auto_gain_control = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selected_non_default_mic = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selected_non_default_output = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.push_to_talk_enabled = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.push_to_mute_enabled = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.play_ptt_sounds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.voice_input_gain {
            my_size += 5;
        }
        if let Some(v) = self.voice_output_gain {
            my_size += 5;
        }
        if let Some(v) = self.noise_gate_level {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.voice_use_echo_cancellation {
            my_size += 2;
        }
        if let Some(v) = self.voice_use_noise_cancellation {
            my_size += 2;
        }
        if let Some(v) = self.voice_use_auto_gain_control {
            my_size += 2;
        }
        if let Some(v) = self.selected_non_default_mic {
            my_size += 2;
        }
        if let Some(v) = self.selected_non_default_output {
            my_size += 2;
        }
        if let Some(v) = self.push_to_talk_enabled {
            my_size += 2;
        }
        if let Some(v) = self.push_to_mute_enabled {
            my_size += 2;
        }
        if let Some(v) = self.play_ptt_sounds {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.voice_input_gain {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.voice_output_gain {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.noise_gate_level {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.voice_use_echo_cancellation {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.voice_use_noise_cancellation {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.voice_use_auto_gain_control {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.selected_non_default_mic {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.selected_non_default_output {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.push_to_talk_enabled {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.push_to_mute_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.play_ptt_sounds {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "voice_input_gain",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_input_gain },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_input_gain },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "voice_output_gain",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_output_gain },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_output_gain },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "noise_gate_level",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.noise_gate_level },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.noise_gate_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "voice_use_echo_cancellation",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_use_echo_cancellation },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_use_echo_cancellation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "voice_use_noise_cancellation",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_use_noise_cancellation },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_use_noise_cancellation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "voice_use_auto_gain_control",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_use_auto_gain_control },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_use_auto_gain_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selected_non_default_mic",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.selected_non_default_mic },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.selected_non_default_mic },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selected_non_default_output",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.selected_non_default_output },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.selected_non_default_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "push_to_talk_enabled",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.push_to_talk_enabled },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.push_to_talk_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "push_to_mute_enabled",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.push_to_mute_enabled },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.push_to_mute_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "play_ptt_sounds",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.play_ptt_sounds },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.play_ptt_sounds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings>(
                "CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        static instance: ::protobuf::rt::LazyV2<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings::new)
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn clear(&mut self) {
        self.voice_input_gain = ::std::option::Option::None;
        self.voice_output_gain = ::std::option::Option::None;
        self.noise_gate_level = ::std::option::Option::None;
        self.voice_use_echo_cancellation = ::std::option::Option::None;
        self.voice_use_noise_cancellation = ::std::option::Option::None;
        self.voice_use_auto_gain_control = ::std::option::Option::None;
        self.selected_non_default_mic = ::std::option::Option::None;
        self.selected_non_default_output = ::std::option::Option::None;
        self.push_to_talk_enabled = ::std::option::Option::None;
        self.push_to_mute_enabled = ::std::option::Option::None;
        self.play_ptt_sounds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    // message fields
    friends_list_height: ::std::option::Option<i32>,
    friends_list_width: ::std::option::Option<i32>,
    friends_list_docked: ::std::option::Option<bool>,
    friends_list_collapsed: ::std::option::Option<bool>,
    friends_list_group_chats_height: ::std::option::Option<i32>,
    friends_list_visible: ::std::option::Option<bool>,
    chat_popups_opened: ::std::option::Option<i32>,
    group_chat_tabs_opened: ::std::option::Option<i32>,
    friend_chat_tabs_opened: ::std::option::Option<i32>,
    chat_window_width: ::std::option::Option<i32>,
    chat_window_height: ::std::option::Option<i32>,
    pub category_collapse: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState>,
    group_chat_left_col_collapsed: ::std::option::Option<i32>,
    group_chat_right_col_collapsed: ::std::option::Option<i32>,
    in_one_on_one_voice_chat: ::std::option::Option<bool>,
    in_group_voice_chat: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        <CChatUsability_ClientUsabilityMetrics_Notification_UIState as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        ::std::default::Default::default()
    }

    // optional int32 friends_list_height = 1;


    pub fn get_friends_list_height(&self) -> i32 {
        self.friends_list_height.unwrap_or(0)
    }
    pub fn clear_friends_list_height(&mut self) {
        self.friends_list_height = ::std::option::Option::None;
    }

    pub fn has_friends_list_height(&self) -> bool {
        self.friends_list_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_height(&mut self, v: i32) {
        self.friends_list_height = ::std::option::Option::Some(v);
    }

    // optional int32 friends_list_width = 2;


    pub fn get_friends_list_width(&self) -> i32 {
        self.friends_list_width.unwrap_or(0)
    }
    pub fn clear_friends_list_width(&mut self) {
        self.friends_list_width = ::std::option::Option::None;
    }

    pub fn has_friends_list_width(&self) -> bool {
        self.friends_list_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_width(&mut self, v: i32) {
        self.friends_list_width = ::std::option::Option::Some(v);
    }

    // optional bool friends_list_docked = 3;


    pub fn get_friends_list_docked(&self) -> bool {
        self.friends_list_docked.unwrap_or(false)
    }
    pub fn clear_friends_list_docked(&mut self) {
        self.friends_list_docked = ::std::option::Option::None;
    }

    pub fn has_friends_list_docked(&self) -> bool {
        self.friends_list_docked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_docked(&mut self, v: bool) {
        self.friends_list_docked = ::std::option::Option::Some(v);
    }

    // optional bool friends_list_collapsed = 4;


    pub fn get_friends_list_collapsed(&self) -> bool {
        self.friends_list_collapsed.unwrap_or(false)
    }
    pub fn clear_friends_list_collapsed(&mut self) {
        self.friends_list_collapsed = ::std::option::Option::None;
    }

    pub fn has_friends_list_collapsed(&self) -> bool {
        self.friends_list_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_collapsed(&mut self, v: bool) {
        self.friends_list_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 friends_list_group_chats_height = 5;


    pub fn get_friends_list_group_chats_height(&self) -> i32 {
        self.friends_list_group_chats_height.unwrap_or(0)
    }
    pub fn clear_friends_list_group_chats_height(&mut self) {
        self.friends_list_group_chats_height = ::std::option::Option::None;
    }

    pub fn has_friends_list_group_chats_height(&self) -> bool {
        self.friends_list_group_chats_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_group_chats_height(&mut self, v: i32) {
        self.friends_list_group_chats_height = ::std::option::Option::Some(v);
    }

    // optional bool friends_list_visible = 6;


    pub fn get_friends_list_visible(&self) -> bool {
        self.friends_list_visible.unwrap_or(false)
    }
    pub fn clear_friends_list_visible(&mut self) {
        self.friends_list_visible = ::std::option::Option::None;
    }

    pub fn has_friends_list_visible(&self) -> bool {
        self.friends_list_visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_visible(&mut self, v: bool) {
        self.friends_list_visible = ::std::option::Option::Some(v);
    }

    // optional int32 chat_popups_opened = 7;


    pub fn get_chat_popups_opened(&self) -> i32 {
        self.chat_popups_opened.unwrap_or(0)
    }
    pub fn clear_chat_popups_opened(&mut self) {
        self.chat_popups_opened = ::std::option::Option::None;
    }

    pub fn has_chat_popups_opened(&self) -> bool {
        self.chat_popups_opened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_popups_opened(&mut self, v: i32) {
        self.chat_popups_opened = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_tabs_opened = 8;


    pub fn get_group_chat_tabs_opened(&self) -> i32 {
        self.group_chat_tabs_opened.unwrap_or(0)
    }
    pub fn clear_group_chat_tabs_opened(&mut self) {
        self.group_chat_tabs_opened = ::std::option::Option::None;
    }

    pub fn has_group_chat_tabs_opened(&self) -> bool {
        self.group_chat_tabs_opened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_tabs_opened(&mut self, v: i32) {
        self.group_chat_tabs_opened = ::std::option::Option::Some(v);
    }

    // optional int32 friend_chat_tabs_opened = 9;


    pub fn get_friend_chat_tabs_opened(&self) -> i32 {
        self.friend_chat_tabs_opened.unwrap_or(0)
    }
    pub fn clear_friend_chat_tabs_opened(&mut self) {
        self.friend_chat_tabs_opened = ::std::option::Option::None;
    }

    pub fn has_friend_chat_tabs_opened(&self) -> bool {
        self.friend_chat_tabs_opened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_chat_tabs_opened(&mut self, v: i32) {
        self.friend_chat_tabs_opened = ::std::option::Option::Some(v);
    }

    // optional int32 chat_window_width = 10;


    pub fn get_chat_window_width(&self) -> i32 {
        self.chat_window_width.unwrap_or(0)
    }
    pub fn clear_chat_window_width(&mut self) {
        self.chat_window_width = ::std::option::Option::None;
    }

    pub fn has_chat_window_width(&self) -> bool {
        self.chat_window_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_window_width(&mut self, v: i32) {
        self.chat_window_width = ::std::option::Option::Some(v);
    }

    // optional int32 chat_window_height = 11;


    pub fn get_chat_window_height(&self) -> i32 {
        self.chat_window_height.unwrap_or(0)
    }
    pub fn clear_chat_window_height(&mut self) {
        self.chat_window_height = ::std::option::Option::None;
    }

    pub fn has_chat_window_height(&self) -> bool {
        self.chat_window_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_window_height(&mut self, v: i32) {
        self.chat_window_height = ::std::option::Option::Some(v);
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState category_collapse = 12;


    pub fn get_category_collapse(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        self.category_collapse.as_ref().unwrap_or_else(|| <CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_category_collapse(&mut self) {
        self.category_collapse.clear();
    }

    pub fn has_category_collapse(&self) -> bool {
        self.category_collapse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_collapse(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState) {
        self.category_collapse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category_collapse(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        if self.category_collapse.is_none() {
            self.category_collapse.set_default();
        }
        self.category_collapse.as_mut().unwrap()
    }

    // Take field
    pub fn take_category_collapse(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        self.category_collapse.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState::new())
    }

    // optional int32 group_chat_left_col_collapsed = 13;


    pub fn get_group_chat_left_col_collapsed(&self) -> i32 {
        self.group_chat_left_col_collapsed.unwrap_or(0)
    }
    pub fn clear_group_chat_left_col_collapsed(&mut self) {
        self.group_chat_left_col_collapsed = ::std::option::Option::None;
    }

    pub fn has_group_chat_left_col_collapsed(&self) -> bool {
        self.group_chat_left_col_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_left_col_collapsed(&mut self, v: i32) {
        self.group_chat_left_col_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_right_col_collapsed = 14;


    pub fn get_group_chat_right_col_collapsed(&self) -> i32 {
        self.group_chat_right_col_collapsed.unwrap_or(0)
    }
    pub fn clear_group_chat_right_col_collapsed(&mut self) {
        self.group_chat_right_col_collapsed = ::std::option::Option::None;
    }

    pub fn has_group_chat_right_col_collapsed(&self) -> bool {
        self.group_chat_right_col_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_right_col_collapsed(&mut self, v: i32) {
        self.group_chat_right_col_collapsed = ::std::option::Option::Some(v);
    }

    // optional bool in_one_on_one_voice_chat = 15;


    pub fn get_in_one_on_one_voice_chat(&self) -> bool {
        self.in_one_on_one_voice_chat.unwrap_or(false)
    }
    pub fn clear_in_one_on_one_voice_chat(&mut self) {
        self.in_one_on_one_voice_chat = ::std::option::Option::None;
    }

    pub fn has_in_one_on_one_voice_chat(&self) -> bool {
        self.in_one_on_one_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_one_on_one_voice_chat(&mut self, v: bool) {
        self.in_one_on_one_voice_chat = ::std::option::Option::Some(v);
    }

    // optional bool in_group_voice_chat = 16;


    pub fn get_in_group_voice_chat(&self) -> bool {
        self.in_group_voice_chat.unwrap_or(false)
    }
    pub fn clear_in_group_voice_chat(&mut self) {
        self.in_group_voice_chat = ::std::option::Option::None;
    }

    pub fn has_in_group_voice_chat(&self) -> bool {
        self.in_group_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_group_voice_chat(&mut self, v: bool) {
        self.in_group_voice_chat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn is_initialized(&self) -> bool {
        for v in &self.category_collapse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_list_height = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_list_width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.friends_list_docked = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.friends_list_collapsed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_list_group_chats_height = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.friends_list_visible = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_popups_opened = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_tabs_opened = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friend_chat_tabs_opened = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_window_width = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_window_height = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.category_collapse)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_left_col_collapsed = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_right_col_collapsed = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_one_on_one_voice_chat = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_group_voice_chat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friends_list_height {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_list_width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_list_docked {
            my_size += 2;
        }
        if let Some(v) = self.friends_list_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.friends_list_group_chats_height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_list_visible {
            my_size += 2;
        }
        if let Some(v) = self.chat_popups_opened {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_tabs_opened {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friend_chat_tabs_opened {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_window_width {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_window_height {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.category_collapse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.group_chat_left_col_collapsed {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_right_col_collapsed {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_one_on_one_voice_chat {
            my_size += 2;
        }
        if let Some(v) = self.in_group_voice_chat {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friends_list_height {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.friends_list_width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.friends_list_docked {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.friends_list_collapsed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.friends_list_group_chats_height {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.friends_list_visible {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.chat_popups_opened {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.group_chat_tabs_opened {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.friend_chat_tabs_opened {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.chat_window_width {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.chat_window_height {
            os.write_int32(11, v)?;
        }
        if let Some(ref v) = self.category_collapse.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.group_chat_left_col_collapsed {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.group_chat_right_col_collapsed {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.in_one_on_one_voice_chat {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.in_group_voice_chat {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        CChatUsability_ClientUsabilityMetrics_Notification_UIState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_list_height",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_height },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_list_width",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_width },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "friends_list_docked",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_docked },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_docked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "friends_list_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_collapsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_list_group_chats_height",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_group_chats_height },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_group_chats_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "friends_list_visible",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_visible },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_visible },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_popups_opened",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.chat_popups_opened },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.chat_popups_opened },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_chat_tabs_opened",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.group_chat_tabs_opened },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.group_chat_tabs_opened },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friend_chat_tabs_opened",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friend_chat_tabs_opened },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friend_chat_tabs_opened },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_window_width",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.chat_window_width },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.chat_window_width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_window_height",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.chat_window_height },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.chat_window_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState>>(
                "category_collapse",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.category_collapse },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.category_collapse },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_chat_left_col_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.group_chat_left_col_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.group_chat_left_col_collapsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_chat_right_col_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.group_chat_right_col_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.group_chat_right_col_collapsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_one_on_one_voice_chat",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.in_one_on_one_voice_chat },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.in_one_on_one_voice_chat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_group_voice_chat",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.in_group_voice_chat },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.in_group_voice_chat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatUsability_ClientUsabilityMetrics_Notification_UIState>(
                "CChatUsability_ClientUsabilityMetrics_Notification.UIState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        static instance: ::protobuf::rt::LazyV2<CChatUsability_ClientUsabilityMetrics_Notification_UIState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatUsability_ClientUsabilityMetrics_Notification_UIState::new)
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn clear(&mut self) {
        self.friends_list_height = ::std::option::Option::None;
        self.friends_list_width = ::std::option::Option::None;
        self.friends_list_docked = ::std::option::Option::None;
        self.friends_list_collapsed = ::std::option::Option::None;
        self.friends_list_group_chats_height = ::std::option::Option::None;
        self.friends_list_visible = ::std::option::Option::None;
        self.chat_popups_opened = ::std::option::Option::None;
        self.group_chat_tabs_opened = ::std::option::Option::None;
        self.friend_chat_tabs_opened = ::std::option::Option::None;
        self.chat_window_width = ::std::option::Option::None;
        self.chat_window_height = ::std::option::Option::None;
        self.category_collapse.clear();
        self.group_chat_left_col_collapsed = ::std::option::Option::None;
        self.group_chat_right_col_collapsed = ::std::option::Option::None;
        self.in_one_on_one_voice_chat = ::std::option::Option::None;
        self.in_group_voice_chat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    // message fields
    in_game_collapsed: ::std::option::Option<bool>,
    online_collapsed: ::std::option::Option<bool>,
    offline_collapsed: ::std::option::Option<bool>,
    game_groups_collapsed: ::std::option::Option<i32>,
    categories_collapsed: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        <CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        ::std::default::Default::default()
    }

    // optional bool in_game_collapsed = 1;


    pub fn get_in_game_collapsed(&self) -> bool {
        self.in_game_collapsed.unwrap_or(false)
    }
    pub fn clear_in_game_collapsed(&mut self) {
        self.in_game_collapsed = ::std::option::Option::None;
    }

    pub fn has_in_game_collapsed(&self) -> bool {
        self.in_game_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_collapsed(&mut self, v: bool) {
        self.in_game_collapsed = ::std::option::Option::Some(v);
    }

    // optional bool online_collapsed = 2;


    pub fn get_online_collapsed(&self) -> bool {
        self.online_collapsed.unwrap_or(false)
    }
    pub fn clear_online_collapsed(&mut self) {
        self.online_collapsed = ::std::option::Option::None;
    }

    pub fn has_online_collapsed(&self) -> bool {
        self.online_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online_collapsed(&mut self, v: bool) {
        self.online_collapsed = ::std::option::Option::Some(v);
    }

    // optional bool offline_collapsed = 3;


    pub fn get_offline_collapsed(&self) -> bool {
        self.offline_collapsed.unwrap_or(false)
    }
    pub fn clear_offline_collapsed(&mut self) {
        self.offline_collapsed = ::std::option::Option::None;
    }

    pub fn has_offline_collapsed(&self) -> bool {
        self.offline_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline_collapsed(&mut self, v: bool) {
        self.offline_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 game_groups_collapsed = 4;


    pub fn get_game_groups_collapsed(&self) -> i32 {
        self.game_groups_collapsed.unwrap_or(0)
    }
    pub fn clear_game_groups_collapsed(&mut self) {
        self.game_groups_collapsed = ::std::option::Option::None;
    }

    pub fn has_game_groups_collapsed(&self) -> bool {
        self.game_groups_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_groups_collapsed(&mut self, v: i32) {
        self.game_groups_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 categories_collapsed = 5;


    pub fn get_categories_collapsed(&self) -> i32 {
        self.categories_collapsed.unwrap_or(0)
    }
    pub fn clear_categories_collapsed(&mut self) {
        self.categories_collapsed = ::std::option::Option::None;
    }

    pub fn has_categories_collapsed(&self) -> bool {
        self.categories_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_categories_collapsed(&mut self, v: i32) {
        self.categories_collapsed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_game_collapsed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.online_collapsed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.offline_collapsed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_groups_collapsed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.categories_collapsed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.in_game_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.online_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.offline_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.game_groups_collapsed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.categories_collapsed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.in_game_collapsed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.online_collapsed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.offline_collapsed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.game_groups_collapsed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.categories_collapsed {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_game_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.in_game_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.in_game_collapsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "online_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.online_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.online_collapsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "offline_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.offline_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.offline_collapsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_groups_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.game_groups_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.game_groups_collapsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "categories_collapsed",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.categories_collapsed },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.categories_collapsed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState>(
                "CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        static instance: ::protobuf::rt::LazyV2<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState::new)
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn clear(&mut self) {
        self.in_game_collapsed = ::std::option::Option::None;
        self.online_collapsed = ::std::option::Option::None;
        self.offline_collapsed = ::std::option::Option::None;
        self.game_groups_collapsed = ::std::option::Option::None;
        self.categories_collapsed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    // message fields
    friends_count: ::std::option::Option<i32>,
    friends_category_count: ::std::option::Option<i32>,
    friends_categorized_count: ::std::option::Option<i32>,
    friends_online_count: ::std::option::Option<i32>,
    friends_in_game_count: ::std::option::Option<i32>,
    friends_in_game_singleton_count: ::std::option::Option<i32>,
    game_group_count: ::std::option::Option<i32>,
    friends_favorite_count: ::std::option::Option<i32>,
    group_chat_count: ::std::option::Option<i32>,
    group_chat_favorite_count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        <CChatUsability_ClientUsabilityMetrics_Notification_Metrics as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        ::std::default::Default::default()
    }

    // optional int32 friends_count = 1;


    pub fn get_friends_count(&self) -> i32 {
        self.friends_count.unwrap_or(0)
    }
    pub fn clear_friends_count(&mut self) {
        self.friends_count = ::std::option::Option::None;
    }

    pub fn has_friends_count(&self) -> bool {
        self.friends_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_count(&mut self, v: i32) {
        self.friends_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_category_count = 2;


    pub fn get_friends_category_count(&self) -> i32 {
        self.friends_category_count.unwrap_or(0)
    }
    pub fn clear_friends_category_count(&mut self) {
        self.friends_category_count = ::std::option::Option::None;
    }

    pub fn has_friends_category_count(&self) -> bool {
        self.friends_category_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_category_count(&mut self, v: i32) {
        self.friends_category_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_categorized_count = 3;


    pub fn get_friends_categorized_count(&self) -> i32 {
        self.friends_categorized_count.unwrap_or(0)
    }
    pub fn clear_friends_categorized_count(&mut self) {
        self.friends_categorized_count = ::std::option::Option::None;
    }

    pub fn has_friends_categorized_count(&self) -> bool {
        self.friends_categorized_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_categorized_count(&mut self, v: i32) {
        self.friends_categorized_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_online_count = 4;


    pub fn get_friends_online_count(&self) -> i32 {
        self.friends_online_count.unwrap_or(0)
    }
    pub fn clear_friends_online_count(&mut self) {
        self.friends_online_count = ::std::option::Option::None;
    }

    pub fn has_friends_online_count(&self) -> bool {
        self.friends_online_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_online_count(&mut self, v: i32) {
        self.friends_online_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_in_game_count = 5;


    pub fn get_friends_in_game_count(&self) -> i32 {
        self.friends_in_game_count.unwrap_or(0)
    }
    pub fn clear_friends_in_game_count(&mut self) {
        self.friends_in_game_count = ::std::option::Option::None;
    }

    pub fn has_friends_in_game_count(&self) -> bool {
        self.friends_in_game_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_in_game_count(&mut self, v: i32) {
        self.friends_in_game_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_in_game_singleton_count = 6;


    pub fn get_friends_in_game_singleton_count(&self) -> i32 {
        self.friends_in_game_singleton_count.unwrap_or(0)
    }
    pub fn clear_friends_in_game_singleton_count(&mut self) {
        self.friends_in_game_singleton_count = ::std::option::Option::None;
    }

    pub fn has_friends_in_game_singleton_count(&self) -> bool {
        self.friends_in_game_singleton_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_in_game_singleton_count(&mut self, v: i32) {
        self.friends_in_game_singleton_count = ::std::option::Option::Some(v);
    }

    // optional int32 game_group_count = 7;


    pub fn get_game_group_count(&self) -> i32 {
        self.game_group_count.unwrap_or(0)
    }
    pub fn clear_game_group_count(&mut self) {
        self.game_group_count = ::std::option::Option::None;
    }

    pub fn has_game_group_count(&self) -> bool {
        self.game_group_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_group_count(&mut self, v: i32) {
        self.game_group_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_favorite_count = 8;


    pub fn get_friends_favorite_count(&self) -> i32 {
        self.friends_favorite_count.unwrap_or(0)
    }
    pub fn clear_friends_favorite_count(&mut self) {
        self.friends_favorite_count = ::std::option::Option::None;
    }

    pub fn has_friends_favorite_count(&self) -> bool {
        self.friends_favorite_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_favorite_count(&mut self, v: i32) {
        self.friends_favorite_count = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_count = 9;


    pub fn get_group_chat_count(&self) -> i32 {
        self.group_chat_count.unwrap_or(0)
    }
    pub fn clear_group_chat_count(&mut self) {
        self.group_chat_count = ::std::option::Option::None;
    }

    pub fn has_group_chat_count(&self) -> bool {
        self.group_chat_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_count(&mut self, v: i32) {
        self.group_chat_count = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_favorite_count = 10;


    pub fn get_group_chat_favorite_count(&self) -> i32 {
        self.group_chat_favorite_count.unwrap_or(0)
    }
    pub fn clear_group_chat_favorite_count(&mut self) {
        self.group_chat_favorite_count = ::std::option::Option::None;
    }

    pub fn has_group_chat_favorite_count(&self) -> bool {
        self.group_chat_favorite_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_favorite_count(&mut self, v: i32) {
        self.group_chat_favorite_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_category_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_categorized_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_online_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_in_game_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_in_game_singleton_count = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_group_count = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_favorite_count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_count = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_favorite_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friends_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_category_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_categorized_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_online_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_in_game_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_in_game_singleton_count {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_group_count {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_favorite_count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_favorite_count {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friends_count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.friends_category_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.friends_categorized_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.friends_online_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.friends_in_game_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.friends_in_game_singleton_count {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.game_group_count {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.friends_favorite_count {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.group_chat_count {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.group_chat_favorite_count {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        CChatUsability_ClientUsabilityMetrics_Notification_Metrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_category_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_category_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_category_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_categorized_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_categorized_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_categorized_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_online_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_online_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_online_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_in_game_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_in_game_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_in_game_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_in_game_singleton_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_in_game_singleton_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_in_game_singleton_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_group_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.game_group_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.game_group_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "friends_favorite_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_favorite_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_favorite_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_chat_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.group_chat_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.group_chat_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_chat_favorite_count",
                |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.group_chat_favorite_count },
                |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.group_chat_favorite_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatUsability_ClientUsabilityMetrics_Notification_Metrics>(
                "CChatUsability_ClientUsabilityMetrics_Notification.Metrics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        static instance: ::protobuf::rt::LazyV2<CChatUsability_ClientUsabilityMetrics_Notification_Metrics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatUsability_ClientUsabilityMetrics_Notification_Metrics::new)
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn clear(&mut self) {
        self.friends_count = ::std::option::Option::None;
        self.friends_category_count = ::std::option::Option::None;
        self.friends_categorized_count = ::std::option::Option::None;
        self.friends_online_count = ::std::option::Option::None;
        self.friends_in_game_count = ::std::option::Option::None;
        self.friends_in_game_singleton_count = ::std::option::Option::None;
        self.game_group_count = ::std::option::Option::None;
        self.friends_favorite_count = ::std::option::Option::None;
        self.group_chat_count = ::std::option::Option::None;
        self.group_chat_favorite_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CChatUsability_RequestClientUsabilityMetrics_Notification {
    // message fields
    metrics_run_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
        <CChatUsability_RequestClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_RequestClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;


    pub fn get_metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }
    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.metrics_run_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        CChatUsability_RequestClientUsabilityMetrics_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "metrics_run_id",
                |m: &CChatUsability_RequestClientUsabilityMetrics_Notification| { &m.metrics_run_id },
                |m: &mut CChatUsability_RequestClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CChatUsability_RequestClientUsabilityMetrics_Notification>(
                "CChatUsability_RequestClientUsabilityMetrics_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CChatUsability_RequestClientUsabilityMetrics_Notification {
        static instance: ::protobuf::rt::LazyV2<CChatUsability_RequestClientUsabilityMetrics_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CChatUsability_RequestClientUsabilityMetrics_Notification::new)
    }
}

impl ::protobuf::Clear for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EChatRoomJoinState {
    k_EChatRoomJoinState_Default = 0,
    k_EChatRoomJoinState_None = 1,
    k_EChatRoomJoinState_Joined = 2,
    k_EChatRoomJoinState_TestInvalid = 99,
}

impl ::protobuf::ProtobufEnum for EChatRoomJoinState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomJoinState> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            1 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            2 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            99 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomJoinState] = &[
            EChatRoomJoinState::k_EChatRoomJoinState_Default,
            EChatRoomJoinState::k_EChatRoomJoinState_None,
            EChatRoomJoinState::k_EChatRoomJoinState_Joined,
            EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EChatRoomJoinState>("EChatRoomJoinState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EChatRoomJoinState {
}

impl ::std::default::Default for EChatRoomJoinState {
    fn default() -> Self {
        EChatRoomJoinState::k_EChatRoomJoinState_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomJoinState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EChatRoomGroupRank {
    k_EChatRoomGroupRank_Default = 0,
    k_EChatRoomGroupRank_Viewer = 10,
    k_EChatRoomGroupRank_Guest = 15,
    k_EChatRoomGroupRank_Member = 20,
    k_EChatRoomGroupRank_Moderator = 30,
    k_EChatRoomGroupRank_Officer = 40,
    k_EChatRoomGroupRank_Owner = 50,
    k_EChatRoomGroupRank_TestInvalid = 99,
}

impl ::protobuf::ProtobufEnum for EChatRoomGroupRank {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomGroupRank> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            10 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            15 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            20 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            30 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            40 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            50 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            99 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomGroupRank] = &[
            EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Guest,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Member,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Officer,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Owner,
            EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EChatRoomGroupRank>("EChatRoomGroupRank", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EChatRoomGroupRank {
}

impl ::std::default::Default for EChatRoomGroupRank {
    fn default() -> Self {
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomGroupRank {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EChatRoomNotificationLevel {
    k_EChatroomNotificationLevel_Invalid = 0,
    k_EChatroomNotificationLevel_None = 1,
    k_EChatroomNotificationLevel_MentionMe = 2,
    k_EChatroomNotificationLevel_MentionAll = 3,
    k_EChatroomNotificationLevel_AllMessages = 4,
}

impl ::protobuf::ProtobufEnum for EChatRoomNotificationLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            1 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            2 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            3 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            4 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomNotificationLevel] = &[
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EChatRoomNotificationLevel>("EChatRoomNotificationLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EChatRoomNotificationLevel {
}

impl ::std::default::Default for EChatRoomNotificationLevel {
    fn default() -> Self {
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomNotificationLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EChatRoomServerMessage {
    k_EChatRoomServerMsg_Invalid = 0,
    k_EChatRoomServerMsg_RenameChatRoom = 1,
    k_EChatRoomServerMsg_Joined = 2,
    k_EChatRoomServerMsg_Parted = 3,
    k_EChatRoomServerMsg_Kicked = 4,
    k_EChatRoomServerMsg_Invited = 5,
    k_EChatRoomServerMsg_InviteDismissed = 8,
    k_EChatRoomServerMsg_ChatRoomTaglineChanged = 9,
    k_EChatRoomServerMsg_ChatRoomAvatarChanged = 10,
    k_EChatRoomServerMsg_AppCustom = 11,
}

impl ::protobuf::ProtobufEnum for EChatRoomServerMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomServerMessage> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            1 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            2 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            3 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            4 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            5 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            8 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            10 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            11 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomServerMessage] = &[
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
            EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Joined,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Parted,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invited,
            EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged,
            EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EChatRoomServerMessage>("EChatRoomServerMessage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EChatRoomServerMessage {
}

impl ::std::default::Default for EChatRoomServerMessage {
    fn default() -> Self {
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomServerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EChatRoomMessageReactionType {
    k_EChatRoomMessageReactionType_Invalid = 0,
    k_EChatRoomMessageReactionType_Emoticon = 1,
}

impl ::protobuf::ProtobufEnum for EChatRoomMessageReactionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMessageReactionType> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomMessageReactionType] = &[
            EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
            EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EChatRoomMessageReactionType>("EChatRoomMessageReactionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EChatRoomMessageReactionType {
}

impl ::std::default::Default for EChatRoomMessageReactionType {
    fn default() -> Self {
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomMessageReactionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EChatRoomMemberStateChange {
    k_EChatRoomMemberStateChange_Invalid = 0,
    k_EChatRoomMemberStateChange_Joined = 1,
    k_EChatRoomMemberStateChange_Parted = 2,
    k_EChatRoomMemberStateChange_Kicked = 3,
    k_EChatRoomMemberStateChange_Invited = 4,
    k_EChatRoomMemberStateChange_RankChanged = 7,
    k_EChatRoomMemberStateChange_InviteDismissed = 8,
    k_EChatRoomMemberStateChange_Muted = 9,
    k_EChatRoomMemberStateChange_Banned = 10,
    k_EChatRoomMemberStateChange_RolesChanged = 12,
}

impl ::protobuf::ProtobufEnum for EChatRoomMemberStateChange {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            2 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            3 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            4 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            7 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            8 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            10 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            12 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomMemberStateChange] = &[
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EChatRoomMemberStateChange>("EChatRoomMemberStateChange", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EChatRoomMemberStateChange {
}

impl ::std::default::Default for EChatRoomMemberStateChange {
    fn default() -> Self {
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomMemberStateChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_chat.steamclient.proto\x1a,steammessages_unified_base.s\
    teamclient.proto\x1a(steammessages_clientserver_friends.proto\"*\n(CChat\
    _RequestFriendPersonaStates_Request\"+\n)CChat_RequestFriendPersonaState\
    s_Response\"\xbd\x02\n%CChatRoom_CreateChatRoomGroup_Request\x12'\n\x0fs\
    teamid_partner\x18\x01\x20\x01(\x06R\x0esteamidPartner\x12'\n\x0fsteamid\
    _invited\x18\x02\x20\x01(\x06R\x0esteamidInvited\x12\x12\n\x04name\x18\
    \x03\x20\x01(\tR\x04name\x12)\n\x10steamid_invitees\x18\x04\x20\x03(\x06\
    R\x0fsteamidInvitees\x12@\n\x1cwatching_broadcast_accountid\x18\x06\x20\
    \x01(\rR\x1awatchingBroadcastAccountid\x12A\n\x1dwatching_broadcast_chan\
    nel_id\x18\x07\x20\x01(\x04R\x1awatchingBroadcastChannelId\"R\n\tCChatRo\
    le\x12\x17\n\x07role_id\x18\x01\x20\x01(\x04R\x06roleId\x12\x12\n\x04nam\
    e\x18\x02\x20\x01(\tR\x04name\x12\x18\n\x07ordinal\x18\x03\x20\x01(\rR\
    \x07ordinal\"\x9c\x04\n\x10CChatRoleActions\x12\x17\n\x07role_id\x18\x01\
    \x20\x01(\x04R\x06roleId\x12F\n\x20can_create_rename_delete_channel\x18\
    \x02\x20\x01(\x08R\x1ccanCreateRenameDeleteChannel\x12\x19\n\x08can_kick\
    \x18\x03\x20\x01(\x08R\x07canKick\x12\x17\n\x07can_ban\x18\x04\x20\x01(\
    \x08R\x06canBan\x12\x1d\n\ncan_invite\x18\x05\x20\x01(\x08R\tcanInvite\
    \x12B\n\x1ecan_change_tagline_avatar_name\x18\x06\x20\x01(\x08R\x1acanCh\
    angeTaglineAvatarName\x12\x19\n\x08can_chat\x18\x07\x20\x01(\x08R\x07can\
    Chat\x12(\n\x10can_view_history\x18\x08\x20\x01(\x08R\x0ecanViewHistory\
    \x123\n\x16can_change_group_roles\x18\t\x20\x01(\x08R\x13canChangeGroupR\
    oles\x121\n\x15can_change_user_roles\x18\n\x20\x01(\x08R\x12canChangeUse\
    rRoles\x12&\n\x0fcan_mention_all\x18\x0b\x20\x01(\x08R\rcanMentionAll\
    \x12;\n\x1acan_set_watching_broadcast\x18\x0c\x20\x01(\x08R\x17canSetWat\
    chingBroadcast\"\x90\x01\n\x10CChatPartyBeacon\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12#\n\rsteamid_owner\x18\x02\x20\x01(\x06R\
    \x0csteamidOwner\x12\x1b\n\tbeacon_id\x18\x03\x20\x01(\x06R\x08beaconId\
    \x12#\n\rgame_metadata\x18\x04\x20\x01(\tR\x0cgameMetadata\"\xfd\x04\n\
    \x19CChatRoomGroupHeaderState\x12\"\n\rchat_group_id\x18\x01\x20\x01(\
    \x04R\x0bchatGroupId\x12\x1b\n\tchat_name\x18\x02\x20\x01(\tR\x08chatNam\
    e\x12\x16\n\x06clanid\x18\r\x20\x01(\rR\x06clanid\x12'\n\x0faccountid_ow\
    ner\x18\x0e\x20\x01(\rR\x0eaccountidOwner\x12\x14\n\x05appid\x18\x15\x20\
    \x01(\rR\x05appid\x12\x18\n\x07tagline\x18\x0f\x20\x01(\tR\x07tagline\
    \x12\x1d\n\navatar_sha\x18\x10\x20\x01(\x0cR\tavatarSha\x12&\n\x0fdefaul\
    t_role_id\x18\x11\x20\x01(\x04R\rdefaultRoleId\x12\x20\n\x05roles\x18\
    \x12\x20\x03(\x0b2\n.CChatRoleR\x05roles\x124\n\x0crole_actions\x18\x13\
    \x20\x03(\x0b2\x11.CChatRoleActionsR\x0broleActions\x12@\n\x1cwatching_b\
    roadcast_accountid\x18\x14\x20\x01(\rR\x1awatchingBroadcastAccountid\x12\
    6\n\rparty_beacons\x18\x16\x20\x03(\x0b2\x11.CChatPartyBeaconR\x0cpartyB\
    eacons\x12A\n\x1dwatching_broadcast_channel_id\x18\x17\x20\x01(\x04R\x1a\
    watchingBroadcastChannelId\x12,\n\x12active_minigame_id\x18\x18\x20\x01(\
    \x04R\x10activeMinigameId\x12$\n\x0eavatar_ugc_url\x18\x19\x20\x01(\tR\
    \x0cavatarUgcUrl\"\x84\x02\n\x0fCChatRoomMember\x12\x1c\n\taccountid\x18\
    \x01\x20\x01(\rR\taccountid\x12G\n\x05state\x18\x03\x20\x01(\x0e2\x13.EC\
    hatRoomJoinState:\x1ck_EChatRoomJoinState_DefaultR\x05state\x12E\n\x04ra\
    nk\x18\x04\x20\x01(\x0e2\x13.EChatRoomGroupRank:\x1ck_EChatRoomGroupRank\
    _DefaultR\x04rank\x12(\n\x10time_kick_expire\x18\x06\x20\x01(\rR\x0etime\
    KickExpire\x12\x19\n\x08role_ids\x18\x07\x20\x03(\x04R\x07roleIds\"\xb9\
    \x02\n\x0eCChatRoomState\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x04R\x06c\
    hatId\x12\x1b\n\tchat_name\x18\x02\x20\x01(\tR\x08chatName\x12#\n\rvoice\
    _allowed\x18\x03\x20\x01(\x08R\x0cvoiceAllowed\x12(\n\x10members_in_voic\
    e\x18\x04\x20\x03(\rR\x0emembersInVoice\x12*\n\x11time_last_message\x18\
    \x05\x20\x01(\rR\x0ftimeLastMessage\x12\x1d\n\nsort_order\x18\x06\x20\
    \x01(\rR\tsortOrder\x12!\n\x0clast_message\x18\x07\x20\x01(\tR\x0blastMe\
    ssage\x124\n\x16accountid_last_message\x18\x08\x20\x01(\rR\x14accountidL\
    astMessage\"\x82\x02\n\x13CChatRoomGroupState\x12=\n\x0cheader_state\x18\
    \x01\x20\x01(\x0b2\x1a.CChatRoomGroupHeaderStateR\x0bheaderState\x12*\n\
    \x07members\x18\x02\x20\x03(\x0b2\x10.CChatRoomMemberR\x07members\x12&\n\
    \x0fdefault_chat_id\x18\x04\x20\x01(\x04R\rdefaultChatId\x12.\n\nchat_ro\
    oms\x18\x05\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatRooms\x12(\n\x06kicke\
    d\x18\x07\x20\x03(\x0b2\x10.CChatRoomMemberR\x06kicked\"\x87\x04\n\x12CU\
    serChatRoomState\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x04R\x06chatId\
    \x12\x1f\n\x0btime_joined\x18\x02\x20\x01(\rR\ntimeJoined\x12\"\n\rtime_\
    last_ack\x18\x03\x20\x01(\rR\x0btimeLastAck\x12\x7f\n\x1adesktop_notific\
    ation_level\x18\x04\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_ECha\
    troomNotificationLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mo\
    bile_notification_level\x18\x05\x20\x01(\x0e2\x1b.EChatRoomNotificationL\
    evel:$k_EChatroomNotificationLevel_InvalidR\x17mobileNotificationLevel\
    \x12*\n\x11time_last_mention\x18\x06\x20\x01(\rR\x0ftimeLastMention\x12;\
    \n\x16unread_indicator_muted\x18\x07\x20\x01(\x08:\x05falseR\x14unreadIn\
    dicatorMuted\x12*\n\x11time_first_unread\x18\x08\x20\x01(\rR\x0ftimeFirs\
    tUnread\"\x90\x04\n\x17CUserChatRoomGroupState\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1f\n\x0btime_joined\x18\x02\
    \x20\x01(\rR\ntimeJoined\x12D\n\x14user_chat_room_state\x18\x03\x20\x03(\
    \x0b2\x13.CUserChatRoomStateR\x11userChatRoomState\x12\x7f\n\x1adesktop_\
    notification_level\x18\x04\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:\
    $k_EChatroomNotificationLevel_InvalidR\x18desktopNotificationLevel\x12}\
    \n\x19mobile_notification_level\x18\x05\x20\x01(\x0e2\x1b.EChatRoomNotif\
    icationLevel:$k_EChatroomNotificationLevel_InvalidR\x17mobileNotificatio\
    nLevel\x12-\n\x13time_last_group_ack\x18\x06\x20\x01(\rR\x10timeLastGrou\
    pAck\x12;\n\x16unread_indicator_muted\x18\x07\x20\x01(\x08:\x05falseR\
    \x14unreadIndicatorMuted\"\xba\x01\n&CChatRoom_CreateChatRoomGroup_Respo\
    nse\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12*\n\
    \x05state\x18\x02\x20\x01(\x0b2\x14.CChatRoomGroupStateR\x05state\x12@\n\
    \x0fuser_chat_state\x18\x03\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\r\
    userChatState\"]\n#CChatRoom_SaveChatRoomGroup_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\"&\n$CChatRoom_SaveChatRoomGroup_Response\"_\n%CChatRoo\
    m_RenameChatRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\
    \x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"<\n&\
    CChatRoom_RenameChatRoomGroup_Response\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\"i\n)CChatRoom_SetChatRoomGroupTagline_Request\x12\"\n\rcha\
    t_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07tagline\x18\
    \x02\x20\x01(\tR\x07tagline\",\n*CChatRoom_SetChatRoomGroupTagline_Respo\
    nse\"m\n(CChatRoom_SetChatRoomGroupAvatar_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1d\n\navatar_sha\x18\x02\x20\
    \x01(\x0cR\tavatarSha\"+\n)CChatRoom_SetChatRoomGroupAvatar_Response\"\
    \xde\x01\n3CChatRoom_SetChatRoomGroupWatchingBroadcast_Request\x12\"\n\r\
    chat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12@\n\x1cwatching_br\
    oadcast_accountid\x18\x02\x20\x01(\rR\x1awatchingBroadcastAccountid\x12A\
    \n\x1dwatching_broadcast_channel_id\x18\x03\x20\x01(\x04R\x1awatchingBro\
    adcastChannelId\"6\n4CChatRoom_SetChatRoomGroupWatchingBroadcast_Respons\
    e\"m\n.CChatRoom_JoinMiniGameForChatRoomGroup_Request\x12\"\n\rchat_grou\
    p_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\
    \x20\x01(\x04R\x06chatId\"R\n/CChatRoom_JoinMiniGameForChatRoomGroup_Res\
    ponse\x12\x1f\n\x0bminigame_id\x18\x01\x20\x01(\x04R\nminigameId\"\x8d\
    \x01\n-CChatRoom_EndMiniGameForChatRoomGroup_Request\x12\"\n\rchat_group\
    _id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\
    \x20\x01(\x04R\x06chatId\x12\x1f\n\x0bminigame_id\x18\x03\x20\x01(\x04R\
    \nminigameId\"0\n.CChatRoom_EndMiniGameForChatRoomGroup_Response\"z\n\
    \x1aCChatRoom_MuteUser_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\
    \x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steam\
    id\x12\x1e\n\nexpiration\x18\x03\x20\x01(\x05R\nexpiration\"\x1d\n\x1bCC\
    hatRoom_MuteUser_Response\"z\n\x1aCChatRoom_KickUser_Request\x12\"\n\rch\
    at_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\
    \x18\x02\x20\x01(\x06R\x07steamid\x12\x1e\n\nexpiration\x18\x03\x20\x01(\
    \x05R\nexpiration\"\x1d\n\x1bCChatRoom_KickUser_Response\"~\n!CChatRoom_\
    SetUserBanState_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0b\
    chatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\x12\
    \x1b\n\tban_state\x18\x03\x20\x01(\x08R\x08banState\"$\n\"CChatRoom_SetU\
    serBanState_Response\"^\n\x1eCChatRoom_RevokeInvite_Request\x12\"\n\rcha\
    t_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\
    \x02\x20\x01(\x06R\x07steamid\"!\n\x1fCChatRoom_RevokeInvite_Response\"V\
    \n\x1cCChatRoom_CreateRole_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \"L\n\x1dCChatRoom_CreateRole_Response\x12+\n\x07actions\x18\x02\x20\x01\
    (\x0b2\x11.CChatRoleActionsR\x07actions\"@\n\x1aCChatRoom_GetRoles_Reque\
    st\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"?\n\x1bC\
    ChatRoom_GetRoles_Response\x12\x20\n\x05roles\x18\x01\x20\x03(\x0b2\n.CC\
    hatRoleR\x05roles\"o\n\x1cCChatRoom_RenameRole_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\
    \x20\x01(\x04R\x06roleId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"\
    \x1f\n\x1dCChatRoom_RenameRole_Response\"v\n\x1dCChatRoom_ReorderRole_Re\
    quest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12\x18\n\x07ordinal\
    \x18\x03\x20\x01(\rR\x07ordinal\"\x20\n\x1eCChatRoom_ReorderRole_Respons\
    e\"[\n\x1cCChatRoom_DeleteRole_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\
    \x06roleId\"\x1f\n\x1dCChatRoom_DeleteRole_Response\"_\n\x20CChatRoom_Ge\
    tRoleActions_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bcha\
    tGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\"P\n!CChat\
    Room_GetRoleActions_Response\x12+\n\x07actions\x18\x01\x20\x03(\x0b2\x11\
    .CChatRoleActionsR\x07actions\"\x90\x01\n$CChatRoom_ReplaceRoleActions_R\
    equest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12+\n\x07actions\x18\
    \x04\x20\x01(\x0b2\x11.CChatRoleActionsR\x07actions\"'\n%CChatRoom_Repla\
    ceRoleActions_Response\"x\n\x1fCChatRoom_AddRoleToUser_Request\x12\"\n\r\
    chat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\
    \x18\x03\x20\x01(\x04R\x06roleId\x12\x18\n\x07steamid\x18\x04\x20\x01(\
    \x06R\x07steamid\"\"\n\x20CChatRoom_AddRoleToUser_Response\"a\n!CChatRoo\
    m_GetRolesForUser_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x18\n\x07steamid\x18\x03\x20\x01(\x06R\x07steamid\"?\
    \n\"CChatRoom_GetRolesForUser_Response\x12\x19\n\x08role_ids\x18\x01\x20\
    \x03(\x04R\x07roleIds\"}\n$CChatRoom_DeleteRoleFromUser_Request\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_i\
    d\x18\x03\x20\x01(\x04R\x06roleId\x12\x18\n\x07steamid\x18\x04\x20\x01(\
    \x06R\x07steamid\"'\n%CChatRoom_DeleteRoleFromUser_Response\"\x83\x01\n#\
    CChatRoom_JoinChatRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x1f\n\x0binvite_code\x18\x02\x20\x01(\tR\n\
    inviteCode\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\"\xd7\
    \x01\n$CChatRoom_JoinChatRoomGroup_Response\x12*\n\x05state\x18\x01\x20\
    \x01(\x0b2\x14.CChatRoomGroupStateR\x05state\x12@\n\x0fuser_chat_state\
    \x18\x03\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\ruserChatState\x12\
    \x20\n\x0cjoin_chat_id\x18\x04\x20\x01(\x04R\njoinChatId\x12\x1f\n\x0bti\
    me_expire\x18\x05\x20\x01(\rR\ntimeExpire\"\xb8\x01\n-CChatRoom_InviteFr\
    iendToChatRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\
    \x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\x120\n\x14skip_fri\
    endsui_check\x18\x04\x20\x01(\x08R\x12skipFriendsuiCheck\"0\n.CChatRoom_\
    InviteFriendToChatRoomGroup_Response\"J\n$CChatRoom_LeaveChatRoomGroup_R\
    equest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"'\n%\
    CChatRoom_LeaveChatRoomGroup_Response\"{\n\x20CChatRoom_CreateChatRoom_R\
    equest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1f\n\x0ballow_voice\x18\
    \x03\x20\x01(\x08R\nallowVoice\"Q\n!CChatRoom_CreateChatRoom_Response\
    \x12,\n\tchat_room\x18\x01\x20\x01(\x0b2\x0f.CChatRoomStateR\x08chatRoom\
    \"_\n\x20CChatRoom_DeleteChatRoom_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\
    \x06chatId\"#\n!CChatRoom_DeleteChatRoom_Response\"s\n\x20CChatRoom_Rena\
    meChatRoom_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatG\
    roupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\"#\n!CChatRoom_RenameChatRoom_Respo\
    nse\"\x8d\x01\n!CChatRoom_ReorderChatRoom_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\x12+\n\x12move_after_chat_id\x18\x03\x20\x01(\x04R\
    \x0fmoveAfterChatId\"$\n\"CChatRoom_ReorderChatRoom_Response\"\xa0\x01\n\
    !CChatRoom_SendChatMessage_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06\
    chatId\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12$\n\x0eech\
    o_to_sender\x18\x04\x20\x01(\x08R\x0cechoToSender\"\xcb\x01\n\"CChatRoom\
    _SendChatMessage_Response\x12)\n\x10modified_message\x18\x01\x20\x01(\tR\
    \x0fmodifiedMessage\x12)\n\x10server_timestamp\x18\x02\x20\x01(\rR\x0fse\
    rverTimestamp\x12\x18\n\x07ordinal\x18\x03\x20\x01(\rR\x07ordinal\x125\n\
    \x17message_without_bb_code\x18\x04\x20\x01(\tR\x14messageWithoutBbCode\
    \"^\n\x1fCChatRoom_JoinVoiceChat_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\
    \x06chatId\"E\n\x20CChatRoom_JoinVoiceChat_Response\x12!\n\x0cvoice_chat\
    id\x18\x01\x20\x01(\x04R\x0bvoiceChatid\"_\n\x20CChatRoom_LeaveVoiceChat\
    _Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\"#\n!CChatRoom_LeaveVo\
    iceChat_Response\"\x83\x02\n#CChatRoom_GetMessageHistory_Request\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_i\
    d\x18\x02\x20\x01(\x04R\x06chatId\x12\x1b\n\tlast_time\x18\x03\x20\x01(\
    \rR\x08lastTime\x12!\n\x0clast_ordinal\x18\x04\x20\x01(\rR\x0blastOrdina\
    l\x12\x1d\n\nstart_time\x18\x05\x20\x01(\rR\tstartTime\x12#\n\rstart_ord\
    inal\x18\x06\x20\x01(\rR\x0cstartOrdinal\x12\x1b\n\tmax_count\x18\x07\
    \x20\x01(\rR\x08maxCount\"\xac\x01\n\rServerMessage\x12O\n\x07message\
    \x18\x01\x20\x01(\x0e2\x17.EChatRoomServerMessage:\x1ck_EChatRoomServerM\
    sg_InvalidR\x07message\x12!\n\x0cstring_param\x18\x02\x20\x01(\tR\x0bstr\
    ingParam\x12'\n\x0faccountid_param\x18\x03\x20\x01(\rR\x0eaccountidParam\
    \"\xbe\x05\n$CChatRoom_GetMessageHistory_Response\x12M\n\x08messages\x18\
    \x01\x20\x03(\x0b21.CChatRoom_GetMessageHistory_Response.ChatMessageR\
    \x08messages\x12%\n\x0emore_available\x18\x04\x20\x01(\x08R\rmoreAvailab\
    le\x1a\x9f\x04\n\x0bChatMessage\x12\x16\n\x06sender\x18\x01\x20\x01(\rR\
    \x06sender\x12)\n\x10server_timestamp\x18\x02\x20\x01(\rR\x0fserverTimes\
    tamp\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x18\n\x07or\
    dinal\x18\x04\x20\x01(\rR\x07ordinal\x125\n\x0eserver_message\x18\x05\
    \x20\x01(\x0b2\x0e.ServerMessageR\rserverMessage\x12\x18\n\x07deleted\
    \x18\x06\x20\x01(\x08R\x07deleted\x12_\n\treactions\x18\x07\x20\x03(\x0b\
    2A.CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReactionR\tre\
    actions\x1a\xe6\x01\n\x0fMessageReaction\x12j\n\rreaction_type\x18\x01\
    \x20\x01(\x0e2\x1d.EChatRoomMessageReactionType:&k_EChatRoomMessageReact\
    ionType_InvalidR\x0creactionType\x12\x1a\n\x08reaction\x18\x02\x20\x01(\
    \tR\x08reaction\x12!\n\x0cnum_reactors\x18\x03\x20\x01(\rR\x0bnumReactor\
    s\x12(\n\x10has_user_reacted\x18\x04\x20\x01(\x08R\x0ehasUserReacted\"'\
    \n%CChatRoom_GetMyChatRoomGroups_Request\"\xe5\x07\n*CChatRoom_GetChatRo\
    omGroupSummary_Response\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0b\
    chatGroupId\x12&\n\x0fchat_group_name\x18\x02\x20\x01(\tR\rchatGroupName\
    \x12.\n\x13active_member_count\x18\x03\x20\x01(\rR\x11activeMemberCount\
    \x129\n\x19active_voice_member_count\x18\x04\x20\x01(\rR\x16activeVoiceM\
    emberCount\x12&\n\x0fdefault_chat_id\x18\x05\x20\x01(\x04R\rdefaultChatI\
    d\x12.\n\nchat_rooms\x18\x06\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatRoom\
    s\x12\x16\n\x06clanid\x18\x07\x20\x01(\rR\x06clanid\x12,\n\x12chat_group\
    _tagline\x18\x08\x20\x01(\tR\x10chatGroupTagline\x12'\n\x0faccountid_own\
    er\x18\t\x20\x01(\rR\x0eaccountidOwner\x12\x1f\n\x0btop_members\x18\n\
    \x20\x03(\rR\ntopMembers\x121\n\x15chat_group_avatar_sha\x18\x0b\x20\x01\
    (\x0cR\x12chatGroupAvatarSha\x12E\n\x04rank\x18\x0c\x20\x01(\x0e2\x13.EC\
    hatRoomGroupRank:\x1ck_EChatRoomGroupRank_DefaultR\x04rank\x12&\n\x0fdef\
    ault_role_id\x18\r\x20\x01(\x04R\rdefaultRoleId\x12\x19\n\x08role_ids\
    \x18\x0e\x20\x03(\x04R\x07roleIds\x124\n\x0crole_actions\x18\x0f\x20\x03\
    (\x0b2\x11.CChatRoleActionsR\x0broleActions\x12@\n\x1cwatching_broadcast\
    _accountid\x18\x10\x20\x01(\rR\x1awatchingBroadcastAccountid\x12\x14\n\
    \x05appid\x18\x11\x20\x01(\rR\x05appid\x126\n\rparty_beacons\x18\x12\x20\
    \x03(\x0b2\x11.CChatPartyBeaconR\x0cpartyBeacons\x12A\n\x1dwatching_broa\
    dcast_channel_id\x18\x13\x20\x01(\x04R\x1awatchingBroadcastChannelId\x12\
    ,\n\x12active_minigame_id\x18\x14\x20\x01(\x04R\x10activeMinigameId\x12$\
    \n\x0eavatar_ugc_url\x18\x15\x20\x01(\tR\x0cavatarUgcUrl\"\xb5\x01\n\x14\
    CChatRoomSummaryPair\x12K\n\x15user_chat_group_state\x18\x01\x20\x01(\
    \x0b2\x18.CUserChatRoomGroupStateR\x12userChatGroupState\x12P\n\rgroup_s\
    ummary\x18\x02\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_Response\
    R\x0cgroupSummary\"i\n&CChatRoom_GetMyChatRoomGroups_Response\x12?\n\x10\
    chat_room_groups\x18\x01\x20\x03(\x0b2\x15.CChatRoomSummaryPairR\x0echat\
    RoomGroups\"M\n'CChatRoom_GetChatRoomGroupState_Request\x12\"\n\rchat_gr\
    oup_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"V\n(CChatRoom_GetChatRoomGr\
    oupState_Response\x12*\n\x05state\x18\x01\x20\x01(\x0b2\x14.CChatRoomGro\
    upStateR\x05state\"O\n)CChatRoom_GetChatRoomGroupSummary_Request\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"\x82\x01\n0CChatRo\
    om_SetAppChatRoomGroupForceActive_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12*\n\x11requesting_app_id\x18\x02\x20\
    \x01(\rR\x0frequestingAppId\"{\n1CChatRoom_SetAppChatRoomGroupForceActiv\
    e_Response\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\x12.\n\x13a\
    ccounts_in_channel\x18\x02\x20\x03(\rR\x11accountsInChannel\"\x8b\x01\n9\
    CChatRoom_SetAppChatRoomGroupStopForceActive_Notification\x12\"\n\rchat_\
    group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12*\n\x11requesting_app_i\
    d\x18\x02\x20\x01(\rR\x0frequestingAppId\"\x82\x01\n%CChatRoom_AckChatMe\
    ssage_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatG\
    roupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\x1c\n\tt\
    imestamp\x18\x03\x20\x01(\rR\ttimestamp\"\x86\x01\n\"CChatRoom_CreateInv\
    iteLink_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGrou\
    pId\x12#\n\rseconds_valid\x18\x02\x20\x01(\rR\x0csecondsValid\x12\x17\n\
    \x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\"k\n#CChatRoom_CreateInviteL\
    ink_Response\x12\x1f\n\x0binvite_code\x18\x01\x20\x01(\tR\ninviteCode\
    \x12#\n\rseconds_valid\x18\x02\x20\x01(\rR\x0csecondsValid\"F\n#CChatRoo\
    m_GetInviteLinkInfo_Request\x12\x1f\n\x0binvite_code\x18\x01\x20\x01(\tR\
    \ninviteCode\"\xea\x02\n$CChatRoom_GetInviteLinkInfo_Response\x12%\n\x0e\
    steamid_sender\x18\x03\x20\x01(\x06R\rsteamidSender\x12!\n\x0ctime_expir\
    es\x18\x04\x20\x01(\rR\x0btimeExpires\x12\x17\n\x07chat_id\x18\x06\x20\
    \x01(\x04R\x06chatId\x12P\n\rgroup_summary\x18\x08\x20\x01(\x0b2+.CChatR\
    oom_GetChatRoomGroupSummary_ResponseR\x0cgroupSummary\x12K\n\x15user_cha\
    t_group_state\x18\t\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\x12userCh\
    atGroupState\x12(\n\x10time_kick_expire\x18\n\x20\x01(\rR\x0etimeKickExp\
    ire\x12\x16\n\x06banned\x18\x0b\x20\x01(\x08R\x06banned\"\xa8\x01\n\x1fC\
    ChatRoom_GetInviteInfo_Request\x12'\n\x0fsteamid_invitee\x18\x01\x20\x01\
    (\x06R\x0esteamidInvitee\x12\"\n\rchat_group_id\x18\x02\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\x12\
    \x1f\n\x0binvite_code\x18\x04\x20\x01(\tR\ninviteCode\"\xb6\x01\n\x20CCh\
    atRoom_GetInviteInfo_Response\x12P\n\rgroup_summary\x18\x01\x20\x01(\x0b\
    2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\x0cgroupSummary\x12(\n\
    \x10time_kick_expire\x18\x02\x20\x01(\rR\x0etimeKickExpire\x12\x16\n\x06\
    banned\x18\x03\x20\x01(\x08R\x06banned\"N\n(CChatRoom_GetInviteLinksForG\
    roup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \"\x96\x02\n)CChatRoom_GetInviteLinksForGroup_Response\x12V\n\x0cinvite_\
    links\x18\x01\x20\x03(\x0b23.CChatRoom_GetInviteLinksForGroup_Response.L\
    inkInfoR\x0binviteLinks\x1a\x90\x01\n\x08LinkInfo\x12\x1f\n\x0binvite_co\
    de\x18\x01\x20\x01(\tR\ninviteCode\x12'\n\x0fsteamid_creator\x18\x02\x20\
    \x01(\x06R\x0esteamidCreator\x12!\n\x0ctime_expires\x18\x03\x20\x01(\rR\
    \x0btimeExpires\x12\x17\n\x07chat_id\x18\x04\x20\x01(\x04R\x06chatId\"B\
    \n\x1cCChatRoom_GetBanList_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\"\xee\x01\n\x1dCChatRoom_GetBanList_Response\
    \x12:\n\x04bans\x18\x01\x20\x03(\x0b2&.CChatRoom_GetBanList_Response.Ban\
    InfoR\x04bans\x1a\x90\x01\n\x07BanInfo\x12\x1c\n\taccountid\x18\x01\x20\
    \x01(\rR\taccountid\x12'\n\x0faccountid_actor\x18\x02\x20\x01(\rR\x0eacc\
    ountidActor\x12\x1f\n\x0btime_banned\x18\x03\x20\x01(\rR\ntimeBanned\x12\
    \x1d\n\nban_reason\x18\x04\x20\x01(\tR\tbanReason\"E\n\x1fCChatRoom_GetI\
    nviteList_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGr\
    oupId\"\x80\x01\n\x14CChatRoomGroupInvite\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\rR\taccountid\x12'\n\x0faccountid_actor\x18\x02\x20\x01(\rR\
    \x0eaccountidActor\x12!\n\x0ctime_invited\x18\x03\x20\x01(\rR\x0btimeInv\
    ited\"S\n\x20CChatRoom_GetInviteList_Response\x12/\n\x07invites\x18\x01\
    \x20\x03(\x0b2\x15.CChatRoomGroupInviteR\x07invites\"i\n\"CChatRoom_Dele\
    teInviteLink_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bcha\
    tGroupId\x12\x1f\n\x0binvite_code\x18\x02\x20\x01(\tR\ninviteCode\"%\n#C\
    ChatRoom_DeleteInviteLink_Response\"\xb7\x02\n0CChatRoom_SetSessionActiv\
    eChatRoomGroups_Request\x12$\n\x0echat_group_ids\x18\x01\x20\x03(\x04R\
    \x0cchatGroupIds\x12;\n\x1achat_groups_data_requested\x18\x02\x20\x03(\
    \x04R\x17chatGroupsDataRequested\x12\x9f\x01\n\x1cvirtualize_members_thr\
    eshold\x18\x03\x20\x01(\x05R\x1avirtualizeMembersThresholdB]\x82\xb5\x18\
    YIf\x20a\x20chat\x20room\x20has\x20more\x20members\x20than\x20this\x20th\
    reshold,\x20we\x20will\x20opt\x20in\x20to\x20a\x20virtualized\x20list\"\
    \xb4\x01\n1CChatRoom_SetSessionActiveChatRoomGroups_Response\x125\n\x0bc\
    hat_states\x18\x01\x20\x03(\x0b2\x14.CChatRoomGroupStateR\nchatStates\
    \x12H\n!virtualize_members_chat_group_ids\x18\x02\x20\x03(\x04R\x1dvirtu\
    alizeMembersChatGroupIds\"\xfc\x07\n-CChatRoom_SetUserChatGroupPreferenc\
    es_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12y\n\x16chat_group_preferences\x18\x02\x20\x01(\x0b2C.CChatRoom_SetUs\
    erChatGroupPreferences_Request.ChatGroupPreferencesR\x14chatGroupPrefere\
    nces\x12v\n\x15chat_room_preferences\x18\x03\x20\x03(\x0b2B.CChatRoom_Se\
    tUserChatGroupPreferences_Request.ChatRoomPreferencesR\x13chatRoomPrefer\
    ences\x1a\xcc\x02\n\x14ChatGroupPreferences\x12\x7f\n\x1adesktop_notific\
    ation_level\x18\x01\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_ECha\
    troomNotificationLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mo\
    bile_notification_level\x18\x02\x20\x01(\x0e2\x1b.EChatRoomNotificationL\
    evel:$k_EChatroomNotificationLevel_InvalidR\x17mobileNotificationLevel\
    \x124\n\x16unread_indicator_muted\x18\x03\x20\x01(\x08R\x14unreadIndicat\
    orMuted\x1a\xe4\x02\n\x13ChatRoomPreferences\x12\x17\n\x07chat_id\x18\
    \x01\x20\x01(\x04R\x06chatId\x12\x7f\n\x1adesktop_notification_level\x18\
    \x02\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificati\
    onLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mobile_notificati\
    on_level\x18\x03\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatro\
    omNotificationLevel_InvalidR\x17mobileNotificationLevel\x124\n\x16unread\
    _indicator_muted\x18\x04\x20\x01(\x08R\x14unreadIndicatorMuted\"0\n.CCha\
    tRoom_SetUserChatGroupPreferences_Response\"\xfe\x01\n$CChatRoom_DeleteC\
    hatMessages_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchat\
    GroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12I\n\x08m\
    essages\x18\x03\x20\x03(\x0b2-.CChatRoom_DeleteChatMessages_Request.Mess\
    ageR\x08messages\x1aN\n\x07Message\x12)\n\x10server_timestamp\x18\x01\
    \x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x02\x20\x01(\rR\
    \x07ordinal\"'\n%CChatRoom_DeleteChatMessages_Response\"\xe4\x04\n+CChat\
    Room_UpdateMemberListView_Notification\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12o\n\x07view_id\x18\x02\x20\x01(\x04R\
    \x06viewIdBV\x82\xb5\x18RClient-generated\x20ID.\x20\x20Should\x20send\
    \x20the\x20same\x20value\x20on\x20all\x20requests\x20for\x20the\x20same\
    \x20view\x12\x14\n\x05start\x18\x03\x20\x01(\x05R\x05start\x12\x10\n\x03\
    end\x18\x04\x20\x01(\x05R\x03end\x12\xa3\x01\n\x13client_changenumber\
    \x18\x05\x20\x01(\x05R\x12clientChangenumberBr\x82\xb5\x18nAny\x20update\
    s\x20from\x20this\x20call\x20on\x20will\x20have\x20this\x20changenumber\
    \x20present.\x20\x20Can\x20be\x20used\x20to\x20guarantee\x20in-order\x20\
    updates.\x12J\n\x0bdelete_view\x18\x06\x20\x01(\x08R\ndeleteViewB)\x82\
    \xb5\x18%Indicates\x20this\x20view\x20has\x20been\x20deleted.\x12@\n\x1c\
    persona_subscribe_accountids\x18\x07\x20\x03(\x05R\x1apersonaSubscribeAc\
    countids\x12D\n\x1epersona_unsubscribe_accountids\x18\x08\x20\x03(\x05R\
    \x1cpersonaUnsubscribeAccountids\"\xc6\x02\n\x1fCChatRoom_SearchMembers_\
    Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \xbc\x01\n\tsearch_id\x18\x02\x20\x01(\x04R\x08searchIdB\x9e\x01\x82\xb5\
    \x18\x99\x01Client-supplied\x20id.\x20\x20For\x20find-as-you-type\x20sea\
    rches,\x20as\x20search\x20narrows\x20the\x20server\x20will\x20not\x20ret\
    urn\x20persona\x20states\x20previously\x20returned\x20for\x20a\x20given\
    \x20searchid.\x12\x1f\n\x0bsearch_text\x18\x03\x20\x01(\tR\nsearchText\
    \x12\x1f\n\x0bmax_results\x18\x04\x20\x01(\x05R\nmaxResults\"\x86\x02\n\
    \x20CChatRoom_SearchMembers_Response\x12X\n\x10matching_members\x18\x01\
    \x20\x03(\x0b2-.CChatRoom_SearchMembers_Response.MemberMatchR\x0fmatchin\
    gMembers\x12!\n\x0cstatus_flags\x18\x02\x20\x01(\rR\x0bstatusFlags\x1ae\
    \n\x0bMemberMatch\x12\x1c\n\taccountid\x18\x01\x20\x01(\x05R\taccountid\
    \x128\n\x07persona\x18\x02\x20\x01(\x0b2\x1e.CMsgClientPersonaState.Frie\
    ndR\x07persona\"\xca\x02\n'CChatRoom_UpdateMessageReaction_Request\x12\"\
    \n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat\
    _id\x18\x02\x20\x01(\x04R\x06chatId\x12)\n\x10server_timestamp\x18\x03\
    \x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x04\x20\x01(\rR\
    \x07ordinal\x12j\n\rreaction_type\x18\x05\x20\x01(\x0e2\x1d.EChatRoomMes\
    sageReactionType:&k_EChatRoomMessageReactionType_InvalidR\x0creactionTyp\
    e\x12\x1a\n\x08reaction\x18\x06\x20\x01(\tR\x08reaction\x12\x15\n\x06is_\
    add\x18\x07\x20\x01(\x08R\x05isAdd\"M\n(CChatRoom_UpdateMessageReaction_\
    Response\x12!\n\x0cnum_reactors\x18\x01\x20\x01(\rR\x0bnumReactors\"\xce\
    \x02\n,CChatRoom_GetMessageReactionReactors_Request\x12\"\n\rchat_group_\
    id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\x12)\n\x10server_timestamp\x18\x03\x20\x01(\rR\x0fs\
    erverTimestamp\x12\x18\n\x07ordinal\x18\x04\x20\x01(\rR\x07ordinal\x12j\
    \n\rreaction_type\x18\x05\x20\x01(\x0e2\x1d.EChatRoomMessageReactionType\
    :&k_EChatRoomMessageReactionType_InvalidR\x0creactionType\x12\x1a\n\x08r\
    eaction\x18\x06\x20\x01(\tR\x08reaction\x12\x14\n\x05limit\x18\x07\x20\
    \x01(\rR\x05limit\"K\n-CChatRoom_GetMessageReactionReactors_Response\x12\
    \x1a\n\x08reactors\x18\x01\x20\x03(\rR\x08reactors\"\xad\x01\n*CClanChat\
    Rooms_GetClanChatRoomInfo_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\
    \x06R\x07steamid\x12e\n\nautocreate\x18\x02\x20\x01(\x08:\x04trueR\nauto\
    createB?\x82\xb5\x18;Create\x20a\x20default\x20chat\x20room\x20if\x20non\
    e\x20has\x20been\x20created\x20before.\"\x88\x01\n+CClanChatRooms_GetCla\
    nChatRoomInfo_Response\x12Y\n\x12chat_group_summary\x18\x01\x20\x01(\x0b\
    2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\x10chatGroupSummary\"u\n-\
    CClanChatRooms_SetClanChatRoomPrivate_Request\x12\x18\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamid\x12*\n\x11chat_room_private\x18\x02\x20\
    \x01(\x08R\x0fchatRoomPrivate\"\\\n.CClanChatRooms_SetClanChatRoomPrivat\
    e_Response\x12*\n\x11chat_room_private\x18\x01\x20\x01(\x08R\x0fchatRoom\
    Private\"\x82\x01\n\rCChatMentions\x12\x1f\n\x0bmention_all\x18\x01\x20\
    \x01(\x08R\nmentionAll\x12!\n\x0cmention_here\x18\x02\x20\x01(\x08R\x0bm\
    entionHere\x12-\n\x12mention_accountids\x18\x03\x20\x03(\rR\x11mentionAc\
    countids\"\xca\x03\n*CChatRoom_IncomingChatMessage_Notification\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_i\
    d\x18\x02\x20\x01(\x04R\x06chatId\x12%\n\x0esteamid_sender\x18\x03\x20\
    \x01(\x06R\rsteamidSender\x12\x18\n\x07message\x18\x04\x20\x01(\tR\x07me\
    ssage\x12\x1c\n\ttimestamp\x18\x05\x20\x01(\rR\ttimestamp\x12*\n\x08ment\
    ions\x18\x06\x20\x01(\x0b2\x0e.CChatMentionsR\x08mentions\x12\x18\n\x07o\
    rdinal\x18\x07\x20\x01(\rR\x07ordinal\x125\n\x0eserver_message\x18\x08\
    \x20\x01(\x0b2\x0e.ServerMessageR\rserverMessage\x12*\n\x11message_no_bb\
    code\x18\t\x20\x01(\tR\x0fmessageNoBbcode\x12W\n\tchat_name\x18\n\x20\
    \x01(\tR\x08chatNameB:\x82\xb5\x186A\x20name\x20to\x20use\x20for\x20the\
    \x20chat,\x20intended\x20for\x20notifications\"\xac\x02\n*CChatRoom_Chat\
    MessageModified_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04\
    R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\
    \x12S\n\x08messages\x18\x03\x20\x03(\x0b27.CChatRoom_ChatMessageModified\
    _Notification.ChatMessageR\x08messages\x1al\n\x0bChatMessage\x12)\n\x10s\
    erver_timestamp\x18\x01\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordi\
    nal\x18\x02\x20\x01(\rR\x07ordinal\x12\x18\n\x07deleted\x18\x03\x20\x01(\
    \x08R\x07deleted\"\xd3\x01\n(CChatRoom_MemberStateChange_Notification\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12(\n\x06m\
    ember\x18\x02\x20\x01(\x0b2\x10.CChatRoomMemberR\x06member\x12Y\n\x06cha\
    nge\x18\x03\x20\x01(\x0e2\x1b.EChatRoomMemberStateChange:$k_EChatRoomMem\
    berStateChange_InvalidR\x06change\"k\n*CChatRoom_ChatRoomHeaderState_Not\
    ification\x12=\n\x0cheader_state\x18\x01\x20\x01(\x0b2\x1a.CChatRoomGrou\
    pHeaderStateR\x0bheaderState\"\xad\x01\n/CChatRoom_ChatRoomGroupRoomsCha\
    nge_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGro\
    upId\x12&\n\x0fdefault_chat_id\x18\x02\x20\x01(\x04R\rdefaultChatId\x12.\
    \n\nchat_rooms\x18\x03\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatRooms\"y\n\
    :CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification\x12\x17\n\
    \x07chat_id\x18\x01\x20\x01(\x04R\x06chatId\x12\"\n\rchat_group_id\x18\
    \x02\x20\x01(\x04R\x0bchatGroupId\"\xe4\x02\n;ChatRoomClient_NotifyChatG\
    roupUserStateChanged_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01\
    (\x04R\x0bchatGroupId\x12K\n\x15user_chat_group_state\x18\x02\x20\x01(\
    \x0b2\x18.CUserChatRoomGroupStateR\x12userChatGroupState\x12P\n\rgroup_s\
    ummary\x18\x03\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_Response\
    R\x0cgroupSummary\x12b\n\x0buser_action\x18\x04\x20\x01(\x0e2\x1b.EChatR\
    oomMemberStateChange:$k_EChatRoomMemberStateChange_InvalidR\nuserAction\
    \"\\\n4ChatRoomClient_NotifyChatRoomDisconnect_Notification\x12$\n\x0ech\
    at_group_ids\x18\x01\x20\x03(\x04R\x0cchatGroupIds\"\xd4\x02\n\x17CChatR\
    oomMemberListView\x12\x14\n\x05start\x18\x03\x20\x01(\x05R\x05start\x12\
    \x10\n\x03end\x18\x04\x20\x01(\x05R\x03end\x12\x1f\n\x0btotal_count\x18\
    \x05\x20\x01(\x05R\ntotalCount\x12u\n\x13client_changenumber\x18\x06\x20\
    \x01(\x05R\x12clientChangenumberBD\x82\xb5\x18@Value\x20sent\x20by\x20th\
    e\x20client\x20on\x20the\x20last\x20UpdateMemberListView\x20call.\x20\
    \x12y\n\x13server_changenumber\x18\x07\x20\x01(\x05R\x12serverChangenumb\
    erBH\x82\xb5\x18DValue\x20incremented\x20by\x20the\x20server\x20on\x20ea\
    ch\x20MemberListViewUpdated\x20call.\x20\"h\n\x1cCChatRoomMemberSummaryC\
    ounts\x12\x16\n\x06ingame\x18\x01\x20\x01(\x05R\x06ingame\x12\x16\n\x06o\
    nline\x18\x02\x20\x01(\x05R\x06online\x12\x18\n\x07offline\x18\x03\x20\
    \x01(\x05R\x07offline\"\xfe\x04\n2CChatRoomClient_MemberListViewUpdated_\
    Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12U\n\x07view_id\x18\x02\x20\x01(\x04R\x06viewIdB<\x82\xb5\x188Thew\
    \x20view_id\x20supplied\x20when\x20the\x20client\x20created\x20the\x20vi\
    ew.\x20\x12,\n\x04view\x18\x03\x20\x01(\x0b2\x18.CChatRoomMemberListView\
    R\x04view\x12a\n\x07members\x18\x04\x20\x03(\x0b2G.CChatRoomClient_Membe\
    rListViewUpdated_Notification.MemberListViewEntryR\x07members\x12!\n\x0c\
    status_flags\x18\x05\x20\x01(\rR\x0bstatusFlags\x12D\n\x0emember_summary\
    \x18\x06\x20\x01(\x0b2\x1d.CChatRoomMemberSummaryCountsR\rmemberSummary\
    \x12O\n\x13subscribed_personas\x18\x07\x20\x03(\x0b2\x1e.CMsgClientPerso\
    naState.FriendR\x12subscribedPersonas\x1a\x81\x01\n\x13MemberListViewEnt\
    ry\x12\x12\n\x04rank\x18\x01\x20\x01(\x05R\x04rank\x12\x1c\n\taccountid\
    \x18\x02\x20\x01(\rR\taccountid\x128\n\x07persona\x18\x03\x20\x01(\x0b2\
    \x1e.CMsgClientPersonaState.FriendR\x07persona\"\xe3\x02\n&CChatRoom_Mes\
    sageReaction_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\
    )\n\x10server_timestamp\x18\x03\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\
    \x07ordinal\x18\x04\x20\x01(\rR\x07ordinal\x12\x18\n\x07reactor\x18\x05\
    \x20\x01(\x06R\x07reactor\x12j\n\rreaction_type\x18\x06\x20\x01(\x0e2\
    \x1d.EChatRoomMessageReactionType:&k_EChatRoomMessageReactionType_Invali\
    dR\x0creactionType\x12\x1a\n\x08reaction\x18\x07\x20\x01(\tR\x08reaction\
    \x12\x15\n\x06is_add\x18\x08\x20\x01(\x08R\x05isAdd\"\xe6!\n2CChatUsabil\
    ity_ClientUsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\x01\
    \x20\x01(\rR\x0cmetricsRunId\x12!\n\x0cclient_build\x18\x02\x20\x01(\rR\
    \x0bclientBuild\x12'\n\x0fmetrics_version\x18\x03\x20\x01(\rR\x0emetrics\
    Version\x12\x15\n\x06in_web\x18\x04\x20\x01(\x08R\x05inWeb\x12X\n\x08set\
    tings\x18\n\x20\x01(\x0b2<.CChatUsability_ClientUsabilityMetrics_Notific\
    ation.SettingsR\x08settings\x12h\n\x0evoice_settings\x18\x0b\x20\x01(\
    \x0b2A.CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettingsR\
    \rvoiceSettings\x12V\n\x08ui_state\x18\x0c\x20\x01(\x0b2;.CChatUsability\
    _ClientUsabilityMetrics_Notification.UIStateR\x07uiState\x12U\n\x07metri\
    cs\x18\r\x20\x01(\x0b2;.CChatUsability_ClientUsabilityMetrics_Notificati\
    on.MetricsR\x07metrics\x1a\xa1\x0b\n\x08Settings\x12:\n\x19notifications\
    _show_ingame\x18\x01\x20\x01(\x08R\x17notificationsShowIngame\x12:\n\x19\
    notifications_show_online\x18\x02\x20\x01(\x08R\x17notificationsShowOnli\
    ne\x12<\n\x1anotifications_show_message\x18\x03\x20\x01(\x08R\x18notific\
    ationsShowMessage\x12S\n&notifications_events_and_announcements\x18\x04\
    \x20\x01(\x08R#notificationsEventsAndAnnouncements\x12,\n\x12sounds_play\
    _ingame\x18\x05\x20\x01(\x08R\x10soundsPlayIngame\x12,\n\x12sounds_play_\
    online\x18\x06\x20\x01(\x08R\x10soundsPlayOnline\x12.\n\x13sounds_play_m\
    essage\x18\x07\x20\x01(\x08R\x11soundsPlayMessage\x12E\n\x1fsounds_event\
    s_and_announcements\x18\x08\x20\x01(\x08R\x1csoundsEventsAndAnnouncement\
    s\x123\n\x16always_new_chat_window\x18\t\x20\x01(\x08R\x13alwaysNewChatW\
    indow\x12E\n\x1fforce_alphabetic_friend_sorting\x18\n\x20\x01(\x08R\x1cf\
    orceAlphabeticFriendSorting\x12&\n\x0fchat_flash_mode\x18\x0b\x20\x01(\
    \x05R\rchatFlashMode\x12.\n\x13remember_open_chats\x18\x0c\x20\x01(\x08R\
    \x11rememberOpenChats\x120\n\x14compact_quick_access\x18\r\x20\x01(\x08R\
    \x12compactQuickAccess\x120\n\x14compact_friends_list\x18\x0e\x20\x01(\
    \x08R\x12compactFriendsList\x12X\n)notifications_show_chat_room_notifica\
    tion\x18\x0f\x20\x01(\x08R%notificationsShowChatRoomNotification\x12J\n\
    \"sounds_play_chat_room_notification\x18\x10\x20\x01(\x08R\x1esoundsPlay\
    ChatRoomNotification\x12I\n\"hide_offline_friends_in_tag_groups\x18\x11\
    \x20\x01(\x08R\x1dhideOfflineFriendsInTagGroups\x128\n\x18hide_categoriz\
    ed_friends\x18\x12\x20\x01(\x08R\x16hideCategorizedFriends\x12I\n\"categ\
    orize_in_game_friends_by_game\x18\x13\x20\x01(\x08R\x1dcategorizeInGameF\
    riendsByGame\x12$\n\x0echat_font_size\x18\x14\x20\x01(\x05R\x0cchatFontS\
    ize\x12'\n\x0fuse24hour_clock\x18\x15\x20\x01(\x08R\x0euse24hourClock\
    \x12-\n\x13do_not_disturb_mode\x18\x16\x20\x01(\x08R\x10doNotDisturbMode\
    \x124\n\x16disable_embed_inlining\x18\x17\x20\x01(\x08R\x14disableEmbedI\
    nlining\x12*\n\x11sign_into_friends\x18\x18\x20\x01(\x08R\x0fsignIntoFri\
    ends\x12)\n\x10animated_avatars\x18\x19\x20\x01(\x08R\x0fanimatedAvatars\
    \x1a\xcf\x04\n\rVoiceSettings\x12(\n\x10voice_input_gain\x18\x01\x20\x01\
    (\x02R\x0evoiceInputGain\x12*\n\x11voice_output_gain\x18\x02\x20\x01(\
    \x02R\x0fvoiceOutputGain\x12(\n\x10noise_gate_level\x18\x03\x20\x01(\x05\
    R\x0enoiseGateLevel\x12=\n\x1bvoice_use_echo_cancellation\x18\x04\x20\
    \x01(\x08R\x18voiceUseEchoCancellation\x12?\n\x1cvoice_use_noise_cancell\
    ation\x18\x05\x20\x01(\x08R\x19voiceUseNoiseCancellation\x12<\n\x1bvoice\
    _use_auto_gain_control\x18\x06\x20\x01(\x08R\x17voiceUseAutoGainControl\
    \x127\n\x18selected_non_default_mic\x18\x07\x20\x01(\x08R\x15selectedNon\
    DefaultMic\x12=\n\x1bselected_non_default_output\x18\x08\x20\x01(\x08R\
    \x18selectedNonDefaultOutput\x12/\n\x14push_to_talk_enabled\x18\t\x20\
    \x01(\x08R\x11pushToTalkEnabled\x12/\n\x14push_to_mute_enabled\x18\n\x20\
    \x01(\x08R\x11pushToMuteEnabled\x12&\n\x0fplay_ptt_sounds\x18\x0b\x20\
    \x01(\x08R\rplayPttSounds\x1a\xaa\t\n\x07UIState\x12.\n\x13friends_list_\
    height\x18\x01\x20\x01(\x05R\x11friendsListHeight\x12,\n\x12friends_list\
    _width\x18\x02\x20\x01(\x05R\x10friendsListWidth\x12.\n\x13friends_list_\
    docked\x18\x03\x20\x01(\x08R\x11friendsListDocked\x124\n\x16friends_list\
    _collapsed\x18\x04\x20\x01(\x08R\x14friendsListCollapsed\x12D\n\x1ffrien\
    ds_list_group_chats_height\x18\x05\x20\x01(\x05R\x1bfriendsListGroupChat\
    sHeight\x120\n\x14friends_list_visible\x18\x06\x20\x01(\x08R\x12friendsL\
    istVisible\x12,\n\x12chat_popups_opened\x18\x07\x20\x01(\x05R\x10chatPop\
    upsOpened\x123\n\x16group_chat_tabs_opened\x18\x08\x20\x01(\x05R\x13grou\
    pChatTabsOpened\x125\n\x17friend_chat_tabs_opened\x18\t\x20\x01(\x05R\
    \x14friendChatTabsOpened\x12*\n\x11chat_window_width\x18\n\x20\x01(\x05R\
    \x0fchatWindowWidth\x12,\n\x12chat_window_height\x18\x0b\x20\x01(\x05R\
    \x10chatWindowHeight\x12~\n\x11category_collapse\x18\x0c\x20\x01(\x0b2Q.\
    CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryColla\
    pseStateR\x10categoryCollapse\x12@\n\x1dgroup_chat_left_col_collapsed\
    \x18\r\x20\x01(\x05R\x19groupChatLeftColCollapsed\x12B\n\x1egroup_chat_r\
    ight_col_collapsed\x18\x0e\x20\x01(\x05R\x1agroupChatRightColCollapsed\
    \x125\n\x18in_one_on_one_voice_chat\x18\x0f\x20\x01(\x08R\x13inOneOnOneV\
    oiceChat\x12-\n\x13in_group_voice_chat\x18\x10\x20\x01(\x08R\x10inGroupV\
    oiceChat\x1a\x82\x02\n\x15CategoryCollapseState\x12*\n\x11in_game_collap\
    sed\x18\x01\x20\x01(\x08R\x0finGameCollapsed\x12)\n\x10online_collapsed\
    \x18\x02\x20\x01(\x08R\x0fonlineCollapsed\x12+\n\x11offline_collapsed\
    \x18\x03\x20\x01(\x08R\x10offlineCollapsed\x122\n\x15game_groups_collaps\
    ed\x18\x04\x20\x01(\x05R\x13gameGroupsCollapsed\x121\n\x14categories_col\
    lapsed\x18\x05\x20\x01(\x05R\x13categoriesCollapsed\x1a\x90\x04\n\x07Met\
    rics\x12#\n\rfriends_count\x18\x01\x20\x01(\x05R\x0cfriendsCount\x124\n\
    \x16friends_category_count\x18\x02\x20\x01(\x05R\x14friendsCategoryCount\
    \x12:\n\x19friends_categorized_count\x18\x03\x20\x01(\x05R\x17friendsCat\
    egorizedCount\x120\n\x14friends_online_count\x18\x04\x20\x01(\x05R\x12fr\
    iendsOnlineCount\x121\n\x15friends_in_game_count\x18\x05\x20\x01(\x05R\
    \x12friendsInGameCount\x12D\n\x1ffriends_in_game_singleton_count\x18\x06\
    \x20\x01(\x05R\x1bfriendsInGameSingletonCount\x12(\n\x10game_group_count\
    \x18\x07\x20\x01(\x05R\x0egameGroupCount\x124\n\x16friends_favorite_coun\
    t\x18\x08\x20\x01(\x05R\x14friendsFavoriteCount\x12(\n\x10group_chat_cou\
    nt\x18\t\x20\x01(\x05R\x0egroupChatCount\x129\n\x19group_chat_favorite_c\
    ount\x18\n\x20\x01(\x05R\x16groupChatFavoriteCount\"a\n9CChatUsability_R\
    equestClientUsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\
    \x01\x20\x01(\rR\x0cmetricsRunId*\x9c\x01\n\x12EChatRoomJoinState\x12\
    \x20\n\x1ck_EChatRoomJoinState_Default\x10\0\x12\x1d\n\x19k_EChatRoomJoi\
    nState_None\x10\x01\x12\x1f\n\x1bk_EChatRoomJoinState_Joined\x10\x02\x12\
    $\n\x20k_EChatRoomJoinState_TestInvalid\x10c*\xa4\x02\n\x12EChatRoomGrou\
    pRank\x12\x20\n\x1ck_EChatRoomGroupRank_Default\x10\0\x12\x1f\n\x1bk_ECh\
    atRoomGroupRank_Viewer\x10\n\x12\x1e\n\x1ak_EChatRoomGroupRank_Guest\x10\
    \x0f\x12\x1f\n\x1bk_EChatRoomGroupRank_Member\x10\x14\x12\"\n\x1ek_EChat\
    RoomGroupRank_Moderator\x10\x1e\x12\x20\n\x1ck_EChatRoomGroupRank_Office\
    r\x10(\x12\x1e\n\x1ak_EChatRoomGroupRank_Owner\x102\x12$\n\x20k_EChatRoo\
    mGroupRank_TestInvalid\x10c*\xf4\x01\n\x1aEChatRoomNotificationLevel\x12\
    (\n$k_EChatroomNotificationLevel_Invalid\x10\0\x12%\n!k_EChatroomNotific\
    ationLevel_None\x10\x01\x12*\n&k_EChatroomNotificationLevel_MentionMe\
    \x10\x02\x12+\n'k_EChatroomNotificationLevel_MentionAll\x10\x03\x12,\n(k\
    _EChatroomNotificationLevel_AllMessages\x10\x04*\x97\x03\n\x16EChatRoomS\
    erverMessage\x12\x20\n\x1ck_EChatRoomServerMsg_Invalid\x10\0\x12'\n#k_EC\
    hatRoomServerMsg_RenameChatRoom\x10\x01\x12\x1f\n\x1bk_EChatRoomServerMs\
    g_Joined\x10\x02\x12\x1f\n\x1bk_EChatRoomServerMsg_Parted\x10\x03\x12\
    \x1f\n\x1bk_EChatRoomServerMsg_Kicked\x10\x04\x12\x20\n\x1ck_EChatRoomSe\
    rverMsg_Invited\x10\x05\x12(\n$k_EChatRoomServerMsg_InviteDismissed\x10\
    \x08\x12/\n+k_EChatRoomServerMsg_ChatRoomTaglineChanged\x10\t\x12.\n*k_E\
    ChatRoomServerMsg_ChatRoomAvatarChanged\x10\n\x12\"\n\x1ek_EChatRoomServ\
    erMsg_AppCustom\x10\x0b*w\n\x1cEChatRoomMessageReactionType\x12*\n&k_ECh\
    atRoomMessageReactionType_Invalid\x10\0\x12+\n'k_EChatRoomMessageReactio\
    nType_Emoticon\x10\x01*\xcb\x03\n\x1aEChatRoomMemberStateChange\x12(\n$k\
    _EChatRoomMemberStateChange_Invalid\x10\0\x12'\n#k_EChatRoomMemberStateC\
    hange_Joined\x10\x01\x12'\n#k_EChatRoomMemberStateChange_Parted\x10\x02\
    \x12'\n#k_EChatRoomMemberStateChange_Kicked\x10\x03\x12(\n$k_EChatRoomMe\
    mberStateChange_Invited\x10\x04\x12,\n(k_EChatRoomMemberStateChange_Rank\
    Changed\x10\x07\x120\n,k_EChatRoomMemberStateChange_InviteDismissed\x10\
    \x08\x12&\n\"k_EChatRoomMemberStateChange_Muted\x10\t\x12'\n#k_EChatRoom\
    MemberStateChange_Banned\x10\n\x12-\n)k_EChatRoomMemberStateChange_Roles\
    Changed\x10\x0c2\x8b\x02\n\x04Chat\x12\xe7\x01\n\x1aRequestFriendPersona\
    States\x12).CChat_RequestFriendPersonaStates_Request\x1a*.CChat_RequestF\
    riendPersonaStates_Response\"r\x82\xb5\x18nRequest\x20to\x20be\x20notifi\
    ed\x20of\x20online\x20friend\x20persona\x20state\x20information.\x20\x20\
    Responses\x20sent\x20via\x20CMsgClientPersonaState.\x1a\x19\x82\xb5\x18\
    \x15Chat-related\x20services2\xb9>\n\x08ChatRoom\x12\xa3\x01\n\x13Create\
    ChatRoomGroup\x12&.CChatRoom_CreateChatRoomGroup_Request\x1a'.CChatRoom_\
    CreateChatRoomGroup_Response\";\x82\xb5\x187Create's\x20a\x20chat\x20gro\
    up\x20that\x20can\x20contain\x20other\x20chat\x20rooms\x12z\n\x11SaveCha\
    tRoomGroup\x12$.CChatRoom_SaveChatRoomGroup_Request\x1a%.CChatRoom_SaveC\
    hatRoomGroup_Response\"\x18\x82\xb5\x18\x14Saves's\x20a\x20chat\x20group\
    \x12\x84\x01\n\x13RenameChatRoomGroup\x12&.CChatRoom_RenameChatRoomGroup\
    _Request\x1a'.CChatRoom_RenameChatRoomGroup_Response\"\x1c\x82\xb5\x18\
    \x18Rename\x20a\x20chat\x20room\x20group\x12\x99\x01\n\x17SetChatRoomGro\
    upTagline\x12*.CChatRoom_SetChatRoomGroupTagline_Request\x1a+.CChatRoom_\
    SetChatRoomGroupTagline_Response\"%\x82\xb5\x18!Set\x20tagline\x20for\
    \x20a\x20chat\x20room\x20group\x12\x99\x01\n\x16SetChatRoomGroupAvatar\
    \x12).CChatRoom_SetChatRoomGroupAvatar_Request\x1a*.CChatRoom_SetChatRoo\
    mGroupAvatar_Response\"(\x82\xb5\x18$Set\x20avatar\x20SHA\x20for\x20a\
    \x20chat\x20room\x20group\x12\xcb\x01\n!SetChatRoomGroupWatchingBroadcas\
    t\x124.CChatRoom_SetChatRoomGroupWatchingBroadcast_Request\x1a5.CChatRoo\
    m_SetChatRoomGroupWatchingBroadcast_Response\"9\x82\xb5\x185Sets\x20a\
    \x20broadcast\x20that\x20the\x20chat\x20room\x20group\x20is\x20watching\
    \x12\xe3\x01\n\x1cJoinMiniGameForChatRoomGroup\x12/.CChatRoom_JoinMiniGa\
    meForChatRoomGroup_Request\x1a0.CChatRoom_JoinMiniGameForChatRoomGroup_R\
    esponse\"`\x82\xb5\x18\\Joins\x20the\x20minigame\x20for\x20the\x20chat\
    \x20room\x20group\x20or\x20starts\x20a\x20new\x20one\x20(Winter\x202019\
    \x20sale\x20party\x20game)\x12\xac\x01\n\x1bEndMiniGameForChatRoomGroup\
    \x12..CChatRoom_EndMiniGameForChatRoomGroup_Request\x1a/.CChatRoom_EndMi\
    niGameForChatRoomGroup_Response\",\x82\xb5\x18(Ends\x20the\x20minigame\
    \x20in\x20the\x20chat\x20room\x20group\x12d\n\x0fMuteUserInGroup\x12\x1b\
    .CChatRoom_MuteUser_Request\x1a\x1c.CChatRoom_MuteUser_Response\"\x16\
    \x82\xb5\x18\x12Mute\x20user\x20in\x20group\x12h\n\x11KickUserFromGroup\
    \x12\x1b.CChatRoom_KickUser_Request\x1a\x1c.CChatRoom_KickUser_Response\
    \"\x18\x82\xb5\x18\x14Kick\x20user\x20from\x20group\x12y\n\x0fSetUserBan\
    State\x12\".CChatRoom_SetUserBanState_Request\x1a#.CChatRoom_SetUserBanS\
    tate_Response\"\x1d\x82\xb5\x18\x19Ban/unban\x20user\x20from\x20group\
    \x12\x82\x01\n\x13RevokeInviteToGroup\x12\x1f.CChatRoom_RevokeInvite_Req\
    uest\x1a\x20.CChatRoom_RevokeInvite_Response\"(\x82\xb5\x18$Revoke\x20a\
    \x20direct\x20invitation\x20of\x20a\x20user\x12e\n\nCreateRole\x12\x1d.C\
    ChatRoom_CreateRole_Request\x1a\x1e.CChatRoom_CreateRole_Response\"\x18\
    \x82\xb5\x18\x14Create\x20role\x20for\x20goup\x12a\n\x08GetRoles\x12\x1b\
    .CChatRoom_GetRoles_Request\x1a\x1c.CChatRoom_GetRoles_Response\"\x1a\
    \x82\xb5\x18\x16Get\x20all\x20roles\x20in\x20group\x12e\n\nRenameRole\
    \x12\x1d.CChatRoom_RenameRole_Request\x1a\x1e.CChatRoom_RenameRole_Respo\
    nse\"\x18\x82\xb5\x18\x14Rename\x20role\x20for\x20goup\x12l\n\x0bReorder\
    Role\x12\x1e.CChatRoom_ReorderRole_Request\x1a\x1f.CChatRoom_ReorderRole\
    _Response\"\x1c\x82\xb5\x18\x18Reorder\x20role\x20with\x20a\x20goup\x12g\
    \n\nDeleteRole\x12\x1d.CChatRoom_DeleteRole_Request\x1a\x1e.CChatRoom_De\
    leteRole_Response\"\x1a\x82\xb5\x18\x16Delete\x20role\x20from\x20group\
    \x12\x87\x01\n\x0eGetRoleActions\x12!.CChatRoom_GetRoleActions_Request\
    \x1a\".CChatRoom_GetRoleActions_Response\".\x82\xb5\x18*Get\x20all\x20de\
    fined\x20roles\x20and\x20actions\x20in\x20group\x12\x86\x01\n\x12Replace\
    RoleActions\x12%.CChatRoom_ReplaceRoleActions_Request\x1a&.CChatRoom_Rep\
    laceRoleActions_Response\"!\x82\xb5\x18\x1dReplace\x20role\x20actions\
    \x20in\x20group\x12s\n\rAddRoleToUser\x12\x20.CChatRoom_AddRoleToUser_Re\
    quest\x1a!.CChatRoom_AddRoleToUser_Response\"\x1d\x82\xb5\x18\x19Add\x20\
    role\x20to\x20user\x20in\x20group\x12\x87\x01\n\x0fGetRolesForUser\x12\"\
    .CChatRoom_GetRolesForUser_Request\x1a#.CChatRoom_GetRolesForUser_Respon\
    se\"+\x82\xb5\x18'Get\x20all\x20roles\x20assigned\x20to\x20user\x20in\
    \x20group\x12\x87\x01\n\x12DeleteRoleFromUser\x12%.CChatRoom_DeleteRoleF\
    romUser_Request\x1a&.CChatRoom_DeleteRoleFromUser_Response\"\"\x82\xb5\
    \x18\x1eDelete\x20role\x20from\x20user\x20in\x20group\x12\x81\x01\n\x11J\
    oinChatRoomGroup\x12$.CChatRoom_JoinChatRoomGroup_Request\x1a%.CChatRoom\
    _JoinChatRoomGroup_Response\"\x1f\x82\xb5\x18\x1bJoin\x20a\x20multi-user\
    \x20chat\x20room\x12\xad\x01\n\x1bInviteFriendToChatRoomGroup\x12..CChat\
    Room_InviteFriendToChatRoomGroup_Request\x1a/.CChatRoom_InviteFriendToCh\
    atRoomGroup_Response\"-\x82\xb5\x18)Invite\x20a\x20friend\x20to\x20a\x20\
    multi-user\x20chat\x20room\x12\x97\x01\n\x12LeaveChatRoomGroup\x12%.CCha\
    tRoom_LeaveChatRoomGroup_Request\x1a&.CChatRoom_LeaveChatRoomGroup_Respo\
    nse\"2\x82\xb5\x18.Leaves\x20a\x20chat\x20room\x20group\x20and\x20all\
    \x20related\x20chats\x12\x89\x01\n\x0eCreateChatRoom\x12!.CChatRoom_Crea\
    teChatRoom_Request\x1a\".CChatRoom_CreateChatRoom_Response\"0\x82\xb5\
    \x18,Creates\x20a\x20chat\x20room\x20inside\x20a\x20chat\x20room\x20grou\
    p\x12\x89\x01\n\x0eDeleteChatRoom\x12!.CChatRoom_DeleteChatRoom_Request\
    \x1a\".CChatRoom_DeleteChatRoom_Response\"0\x82\xb5\x18,Deletes\x20a\x20\
    chat\x20room\x20inside\x20a\x20chat\x20room\x20group\x12\x89\x01\n\x0eRe\
    nameChatRoom\x12!.CChatRoom_RenameChatRoom_Request\x1a\".CChatRoom_Renam\
    eChatRoom_Response\"0\x82\xb5\x18,Renames\x20a\x20chat\x20room\x20inside\
    \x20a\x20chat\x20room\x20group\x12\x8d\x01\n\x0fReorderChatRoom\x12\".CC\
    hatRoom_ReorderChatRoom_Request\x1a#.CChatRoom_ReorderChatRoom_Response\
    \"1\x82\xb5\x18-Reorders\x20a\x20chat\x20room\x20inside\x20a\x20chat\x20\
    room\x20group\x12\x8d\x01\n\x0fSendChatMessage\x12\".CChatRoom_SendChatM\
    essage_Request\x1a#.CChatRoom_SendChatMessage_Response\"1\x82\xb5\x18-Se\
    nd\x20a\x20chat\x20message\x20to\x20a\x20multi-user\x20chat\x20room\x12\
    \xa7\x01\n\rJoinVoiceChat\x12\x20.CChatRoom_JoinVoiceChat_Request\x1a!.C\
    ChatRoom_JoinVoiceChat_Response\"Q\x82\xb5\x18MJoin\x20the\x20voice\x20c\
    hat\x20in\x20a\x20multi-room\x20chat\x20(should\x20already\x20be\x20in\
    \x20the\x20chat\x20room)\x12\x86\x01\n\x0eLeaveVoiceChat\x12!.CChatRoom_\
    LeaveVoiceChat_Request\x1a\".CChatRoom_LeaveVoiceChat_Response\"-\x82\
    \xb5\x18)Leave\x20the\x20voice\x20chat\x20in\x20a\x20multi-room\x20chat\
    \x12\xc3\x01\n\x11GetMessageHistory\x12$.CChatRoom_GetMessageHistory_Req\
    uest\x1a%.CChatRoom_GetMessageHistory_Response\"a\x82\xb5\x18]Get\x20the\
    \x20history\x20of\x20messages\x20in\x20a\x20chat\x20room.\x20\x20You\x20\
    must\x20currently\x20be\x20a\x20member\x20of\x20the\x20chat\x20room.\x12\
    \x88\x01\n\x13GetMyChatRoomGroups\x12&.CChatRoom_GetMyChatRoomGroups_Req\
    uest\x1a'.CChatRoom_GetMyChatRoomGroups_Response\"\x20\x82\xb5\x18\x1cGe\
    t\x20a\x20list\x20of\x20our\x20chat\x20rooms\x12\x9a\x01\n\x15GetChatRoo\
    mGroupState\x12(.CChatRoom_GetChatRoomGroupState_Request\x1a).CChatRoom_\
    GetChatRoomGroupState_Response\",\x82\xb5\x18(Get\x20information\x20abou\
    t\x20a\x20single\x20chat\x20room\x12\xa5\x01\n\x17GetChatRoomGroupSummar\
    y\x12*.CChatRoom_GetChatRoomGroupSummary_Request\x1a+.CChatRoom_GetChatR\
    oomGroupSummary_Response\"1\x82\xb5\x18-Get\x20basic\x20information\x20a\
    bout\x20a\x20chat\x20room\x20group\x12\xd3\x01\n\x1eSetAppChatRoomGroupF\
    orceActive\x121.CChatRoom_SetAppChatRoomGroupForceActive_Request\x1a2.CC\
    hatRoom_SetAppChatRoomGroupForceActive_Response\"J\x82\xb5\x18FForce\x20\
    a\x20group\x20chat\x20to\x20be\x20considered\x20active\x20on\x20the\x20s\
    erver\x20for\x20this\x20user\x12\xd3\x01\n\"SetAppChatRoomGroupStopForce\
    Active\x12:.CChatRoom_SetAppChatRoomGroupStopForceActive_Notification\
    \x1a\x0b.NoResponse\"d\x82\xb5\x18`If\x20a\x20group\x20chat\x20is\x20for\
    ced\x20active\x20(see\x20SetAppChatRoomGroupForceActive),\x20decrement\
    \x20the\x20force\x20count\x12\x8f\x01\n\x0eAckChatMessage\x12&.CChatRoom\
    _AckChatMessage_Notification\x1a\x0b.NoResponse\"H\x82\xb5\x18DAcknowled\
    ge\x20that\x20we\x20have\x20seen\x20the\x20most\x20recent\x20chat\x20mes\
    sage\x20in\x20a\x20chat\x12\x81\x01\n\x10CreateInviteLink\x12#.CChatRoom\
    _CreateInviteLink_Request\x1a$.CChatRoom_CreateInviteLink_Response\"\"\
    \x82\xb5\x18\x1eCreates\x20a\x20chatroom\x20invite\x20link\x12\x90\x01\n\
    \x11GetInviteLinkInfo\x12$.CChatRoom_GetInviteLinkInfo_Request\x1a%.CCha\
    tRoom_GetInviteLinkInfo_Response\".\x82\xb5\x18*Returns\x20chat\x20room\
    \x20info\x20about\x20provided\x20link\x12\xaa\x01\n\rGetInviteInfo\x12\
    \x20.CChatRoom_GetInviteInfo_Request\x1a!.CChatRoom_GetInviteInfo_Respon\
    se\"T\x82\xb5\x18PReturns\x20chat\x20room\x20info\x20about\x20any\x20inv\
    ite\x20involving\x20the\x20sender\x20and\x20passed\x20group\x20id\x12\
    \xa5\x01\n\x16GetInviteLinksForGroup\x12).CChatRoom_GetInviteLinksForGro\
    up_Request\x1a*.CChatRoom_GetInviteLinksForGroup_Response\"4\x82\xb5\x18\
    0Returns\x20all\x20invite\x20links\x20for\x20the\x20specified\x20group\
    \x12\x8b\x01\n\nGetBanList\x12\x1d.CChatRoom_GetBanList_Request\x1a\x1e.\
    CChatRoom_GetBanList_Response\">\x82\xb5\x18:Gets\x20a\x20list\x20of\x20\
    users\x20who\x20have\x20been\x20banned\x20from\x20a\x20chat\x20room\x12\
    \x93\x01\n\rGetInviteList\x12\x20.CChatRoom_GetInviteList_Request\x1a!.C\
    ChatRoom_GetInviteList_Response\"=\x82\xb5\x189Gets\x20a\x20list\x20of\
    \x20users\x20who\x20have\x20been\x20invited\x20to\x20a\x20chat\x20room\
    \x12\x80\x01\n\x10DeleteInviteLink\x12#.CChatRoom_DeleteInviteLink_Reque\
    st\x1a$.CChatRoom_DeleteInviteLink_Response\"!\x82\xb5\x18\x1dDeletes\
    \x20specified\x20invite\x20link\x12\xc4\x01\n\x1eSetSessionActiveChatRoo\
    mGroups\x121.CChatRoom_SetSessionActiveChatRoomGroups_Request\x1a2.CChat\
    Room_SetSessionActiveChatRoomGroups_Response\";\x82\xb5\x187Set\x20which\
    \x20chat\x20rooms\x20we\x20are\x20using\x20in\x20the\x20active\x20sessio\
    n\x12\xb9\x01\n\x1bSetUserChatGroupPreferences\x12..CChatRoom_SetUserCha\
    tGroupPreferences_Request\x1a/.CChatRoom_SetUserChatGroupPreferences_Res\
    ponse\"9\x82\xb5\x185Set\x20preferences\x20around\x20chat\x20notificatio\
    ns\x20for\x20a\x20group\x12\x88\x01\n\x12DeleteChatMessages\x12%.CChatRo\
    om_DeleteChatMessages_Request\x1a&.CChatRoom_DeleteChatMessages_Response\
    \"#\x82\xb5\x18\x1fDeletes\x20specified\x20chat\x20messages\x12\x9a\x01\
    \n\x14UpdateMemberListView\x12,.CChatRoom_UpdateMemberListView_Notificat\
    ion\x1a\x0b.NoResponse\"G\x82\xb5\x18CA\x20client\x20is\x20indicating\
    \x20it\x20has\x20an\x20active\x20view\x20into\x20the\x20members\x20list.\
    \x12{\n\rSearchMembers\x12\x20.CChatRoom_SearchMembers_Request\x1a!.CCha\
    tRoom_SearchMembers_Response\"%\x82\xb5\x18!Search\x20chat\x20room\x20me\
    mbers\x20by\x20name.\x12\xa5\x01\n\x15UpdateMessageReaction\x12(.CChatRo\
    om_UpdateMessageReaction_Request\x1a).CChatRoom_UpdateMessageReaction_Re\
    sponse\"7\x82\xb5\x183Adds/removes\x20a\x20reaction\x20to/from\x20a\x20c\
    hat\x20room\x20message\x12\xb4\x01\n\x1aGetMessageReactionReactors\x12-.\
    CChatRoom_GetMessageReactionReactors_Request\x1a..CChatRoom_GetMessageRe\
    actionReactors_Response\"7\x82\xb5\x183Fetches\x20a\x20list\x20of\x20rea\
    ctors\x20for\x20a\x20specified\x20reaction\x1aB\x82\xb5\x18>Service\x20f\
    or\x20joining,\x20managing,\x20and\x20using\x20multi-user\x20chat\x20roo\
    ms2\xae\x03\n\rClanChatRooms\x12\xb8\x01\n\x13GetClanChatRoomInfo\x12+.C\
    ClanChatRooms_GetClanChatRoomInfo_Request\x1a,.CClanChatRooms_GetClanCha\
    tRoomInfo_Response\"F\x82\xb5\x18BGet\x20a\x20list\x20of\x20chat\x20room\
    s\x20for\x20a\x20clan,\x20optionally\x20creating\x20a\x20new\x20one\x12\
    \xb2\x01\n\x16SetClanChatRoomPrivate\x12..CClanChatRooms_SetClanChatRoom\
    Private_Request\x1a/.CClanChatRooms_SetClanChatRoomPrivate_Response\"7\
    \x82\xb5\x183Set\x20a\x20clan\x20chat\x20room\x20to\x20be\x20members\x20\
    only\x20(or\x20public)\x1a-\x82\xb5\x18)Methods\x20for\x20getting\x20cla\
    n\x20chat\x20information2\xef\x0e\n\x0eChatRoomClient\x12{\n\x19NotifyIn\
    comingChatMessage\x12+.CChatRoom_IncomingChatMessage_Notification\x1a\
    \x0b.NoResponse\"$\x82\xb5\x18\x20New\x20chat\x20message\x20for\x20a\x20\
    chat\x20room\x12\x94\x01\n\x19NotifyChatMessageModified\x12+.CChatRoom_C\
    hatMessageModified_Notification\x1a\x0b.NoResponse\"=\x82\xb5\x189An\x20\
    existing\x20chat\x20message\x20has\x20been\x20modified\x20on\x20the\x20b\
    ackend\x12\x95\x01\n\x17NotifyMemberStateChange\x12).CChatRoom_MemberSta\
    teChange_Notification\x1a\x0b.NoResponse\"B\x82\xb5\x18>A\x20chat\x20roo\
    m\x20member's\x20state\x20has\x20changed\x20(join/part/permissions)\x12\
    \x88\x01\n\x1fNotifyChatRoomHeaderStateChange\x12+.CChatRoom_ChatRoomHea\
    derState_Notification\x1a\x0b.NoResponse\"+\x82\xb5\x18'Chat\x20Room\x20\
    header\x20/\x20metadata\x20has\x20changed\x12\xa6\x01\n\x1eNotifyChatRoo\
    mGroupRoomsChange\x120.CChatRoom_ChatRoomGroupRoomsChange_Notification\
    \x1a\x0b.NoResponse\"E\x82\xb5\x18ASomething\x20about\x20a\x20chatroom\
    \x20group\x20changed\x20(created,\x20deleted,\x20etc.)\x12\xd5\x01\n#Not\
    ifyShouldRejoinChatRoomVoiceChat\x12;.CChatRoom_NotifyShouldRejoinChatRo\
    omVoiceChat_Notification\x1a\x0b.NoResponse\"d\x82\xb5\x18`Voice\x20chat\
    \x20was\x20recreated\x20or\x20dropped\x20on\x20the\x20backend\x20and\x20\
    client\x20needs\x20to\x20rejoin\x20to\x20remain\x20in\x20chat.\x12\xb3\
    \x01\n\x1fNotifyChatGroupUserStateChanged\x12<.ChatRoomClient_NotifyChat\
    GroupUserStateChanged_Notification\x1a\x0b.NoResponse\"E\x82\xb5\x18AUse\
    r\x20chat\x20group\x20state\x20(preferences,\x20ack\x20state,\x20etc)\
    \x20have\x20changed.\x12\x8f\x01\n\x18NotifyAckChatMessageEcho\x12&.CCha\
    tRoom_AckChatMessage_Notification\x1a\x0b.NoResponse\">\x82\xb5\x18:A\
    \x20session\x20acked\x20an\x20unread\x20message,\x20echo\x20to\x20other\
    \x20sessions.\x12\xed\x01\n\x18NotifyChatRoomDisconnect\x125.ChatRoomCli\
    ent_NotifyChatRoomDisconnect_Notification\x1a\x0b.NoResponse\"\x8c\x01\
    \x82\xb5\x18\x87\x01The\x20ChatRoom\x20server\x20hosting\x20the\x20chat\
    \x20rooms\x20has\x20reconnected\x20to\x20the\x20user's\x20Chat\x20server\
    \x20(may\x20have\x20restarted),\x20client\x20should\x20refresh\x20state.\
    \x12\xd5\x01\n\x1bNotifyMemberListViewUpdated\x123.CChatRoomClient_Membe\
    rListViewUpdated_Notification\x1a\x0b.NoResponse\"t\x82\xb5\x18pThe\x20l\
    ist\x20of\x20members\x20for\x20a\x20chat\x20room\x20with\x20virtualized\
    \x20member\x20list\x20has\x20changed\x20on\x20the\x20server\x20(or\x20cl\
    ient\x20requested)\x12g\n\x15NotifyMessageReaction\x12'.CChatRoom_Messag\
    eReaction_Notification\x1a\x0b.NoResponse\"\x18\x82\xb5\x18\x14New\x20me\
    ssage\x20reaction\x1a,\x82\xb5\x18$Client\x20notifications\x20for\x20cha\
    t\x20events\xc0\xb5\x18\x022\xc2\x01\n\rChatUsability\x12\x86\x01\n\x1cN\
    otifyClientUsabilityMetrics\x123.CChatUsability_ClientUsabilityMetrics_N\
    otification\x1a\x0b.NoResponse\"$\x82\xb5\x18\x20Incoming\x20metrics\x20\
    from\x20the\x20client\x1a(\x82\xb5\x18$Client\x20notifications\x20for\
    \x20chat\x20events2\xe2\x01\n\x13ChatUsabilityClient\x12\x99\x01\n#Notif\
    yRequestClientUsabilityMetrics\x12:.CChatUsability_RequestClientUsabilit\
    yMetrics_Notification\x1a\x0b.NoResponse\")\x82\xb5\x18%Request\x20clien\
    t\x20send\x20usability\x20metrics\x1a/\x82\xb5\x18'Client\x20notificatio\
    ns\x20for\x20chat\x20usability\xc0\xb5\x18\x02B\x03\x80\x01\x01J\x8d\x82\
    \x03\n\x07\x12\x05\0\0\xfc\t\x01\n\t\n\x02\x03\0\x12\x03\0\06\n\t\n\x02\
    \x03\x01\x12\x03\x01\02\n\x08\n\x01\x08\x12\x03\x03\0\"\n\t\n\x02\x08\
    \x10\x12\x03\x03\0\"\n\n\n\x02\x05\0\x12\x04\x05\0\n\x01\n\n\n\x03\x05\0\
    \x01\x12\x03\x05\x05\x17\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\x08)\n\x0c\
    \n\x05\x05\0\x02\0\x01\x12\x03\x06\x08$\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x06'(\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\x08&\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x07\x08!\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x07$\
    %\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x08(\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03\x08\x08#\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x08&'\n\x0b\
    \n\x04\x05\0\x02\x03\x12\x03\t\x08.\n\x0c\n\x05\x05\0\x02\x03\x01\x12\
    \x03\t\x08(\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\t+-\n\n\n\x02\x05\x01\
    \x12\x04\x0c\0\x15\x01\n\n\n\x03\x05\x01\x01\x12\x03\x0c\x05\x17\n\x0b\n\
    \x04\x05\x01\x02\0\x12\x03\r\x08)\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\
    \r\x08$\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\r'(\n\x0b\n\x04\x05\x01\
    \x02\x01\x12\x03\x0e\x08)\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x0e\
    \x08#\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x0e&(\n\x0b\n\x04\x05\x01\
    \x02\x02\x12\x03\x0f\x08(\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x0f\
    \x08\"\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x0f%'\n\x0b\n\x04\x05\x01\
    \x02\x03\x12\x03\x10\x08)\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x10\
    \x08#\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x10&(\n\x0b\n\x04\x05\x01\
    \x02\x04\x12\x03\x11\x08,\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x11\
    \x08&\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x11)+\n\x0b\n\x04\x05\x01\
    \x02\x05\x12\x03\x12\x08*\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\x12\
    \x08$\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03\x12')\n\x0b\n\x04\x05\x01\
    \x02\x06\x12\x03\x13\x08(\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03\x13\
    \x08\"\n\x0c\n\x05\x05\x01\x02\x06\x02\x12\x03\x13%'\n\x0b\n\x04\x05\x01\
    \x02\x07\x12\x03\x14\x08.\n\x0c\n\x05\x05\x01\x02\x07\x01\x12\x03\x14\
    \x08(\n\x0c\n\x05\x05\x01\x02\x07\x02\x12\x03\x14+-\n\n\n\x02\x05\x02\
    \x12\x04\x17\0\x1d\x01\n\n\n\x03\x05\x02\x01\x12\x03\x17\x05\x1f\n\x0b\n\
    \x04\x05\x02\x02\0\x12\x03\x18\x081\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x03\x18\x08,\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x18/0\n\x0b\n\x04\
    \x05\x02\x02\x01\x12\x03\x19\x08.\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\
    \x03\x19\x08)\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03\x19,-\n\x0b\n\x04\
    \x05\x02\x02\x02\x12\x03\x1a\x083\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\
    \x03\x1a\x08.\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03\x1a12\n\x0b\n\x04\
    \x05\x02\x02\x03\x12\x03\x1b\x084\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\
    \x03\x1b\x08/\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03\x1b23\n\x0b\n\x04\
    \x05\x02\x02\x04\x12\x03\x1c\x085\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\
    \x03\x1c\x080\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03\x1c34\n\n\n\x02\
    \x05\x03\x12\x04\x1f\0*\x01\n\n\n\x03\x05\x03\x01\x12\x03\x1f\x05\x1b\n\
    \x0b\n\x04\x05\x03\x02\0\x12\x03\x20\x08)\n\x0c\n\x05\x05\x03\x02\0\x01\
    \x12\x03\x20\x08$\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03\x20'(\n\x0b\n\
    \x04\x05\x03\x02\x01\x12\x03!\x080\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\
    \x03!\x08+\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03!./\n\x0b\n\x04\x05\
    \x03\x02\x02\x12\x03\"\x08(\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x03\"\
    \x08#\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03\"&'\n\x0b\n\x04\x05\x03\
    \x02\x03\x12\x03#\x08(\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x03#\x08#\n\
    \x0c\n\x05\x05\x03\x02\x03\x02\x12\x03#&'\n\x0b\n\x04\x05\x03\x02\x04\
    \x12\x03$\x08(\n\x0c\n\x05\x05\x03\x02\x04\x01\x12\x03$\x08#\n\x0c\n\x05\
    \x05\x03\x02\x04\x02\x12\x03$&'\n\x0b\n\x04\x05\x03\x02\x05\x12\x03%\x08\
    )\n\x0c\n\x05\x05\x03\x02\x05\x01\x12\x03%\x08$\n\x0c\n\x05\x05\x03\x02\
    \x05\x02\x12\x03%'(\n\x0b\n\x04\x05\x03\x02\x06\x12\x03&\x081\n\x0c\n\
    \x05\x05\x03\x02\x06\x01\x12\x03&\x08,\n\x0c\n\x05\x05\x03\x02\x06\x02\
    \x12\x03&/0\n\x0b\n\x04\x05\x03\x02\x07\x12\x03'\x088\n\x0c\n\x05\x05\
    \x03\x02\x07\x01\x12\x03'\x083\n\x0c\n\x05\x05\x03\x02\x07\x02\x12\x03'6\
    7\n\x0b\n\x04\x05\x03\x02\x08\x12\x03(\x088\n\x0c\n\x05\x05\x03\x02\x08\
    \x01\x12\x03(\x082\n\x0c\n\x05\x05\x03\x02\x08\x02\x12\x03(57\n\x0b\n\
    \x04\x05\x03\x02\t\x12\x03)\x08,\n\x0c\n\x05\x05\x03\x02\t\x01\x12\x03)\
    \x08&\n\x0c\n\x05\x05\x03\x02\t\x02\x12\x03))+\n\n\n\x02\x05\x04\x12\x04\
    ,\0/\x01\n\n\n\x03\x05\x04\x01\x12\x03,\x05!\n\x0b\n\x04\x05\x04\x02\0\
    \x12\x03-\x083\n\x0c\n\x05\x05\x04\x02\0\x01\x12\x03-\x08.\n\x0c\n\x05\
    \x05\x04\x02\0\x02\x12\x03-12\n\x0b\n\x04\x05\x04\x02\x01\x12\x03.\x084\
    \n\x0c\n\x05\x05\x04\x02\x01\x01\x12\x03.\x08/\n\x0c\n\x05\x05\x04\x02\
    \x01\x02\x12\x03.23\n\n\n\x02\x05\x05\x12\x041\0<\x01\n\n\n\x03\x05\x05\
    \x01\x12\x031\x05\x1f\n\x0b\n\x04\x05\x05\x02\0\x12\x032\x081\n\x0c\n\
    \x05\x05\x05\x02\0\x01\x12\x032\x08,\n\x0c\n\x05\x05\x05\x02\0\x02\x12\
    \x032/0\n\x0b\n\x04\x05\x05\x02\x01\x12\x033\x080\n\x0c\n\x05\x05\x05\
    \x02\x01\x01\x12\x033\x08+\n\x0c\n\x05\x05\x05\x02\x01\x02\x12\x033./\n\
    \x0b\n\x04\x05\x05\x02\x02\x12\x034\x080\n\x0c\n\x05\x05\x05\x02\x02\x01\
    \x12\x034\x08+\n\x0c\n\x05\x05\x05\x02\x02\x02\x12\x034./\n\x0b\n\x04\
    \x05\x05\x02\x03\x12\x035\x080\n\x0c\n\x05\x05\x05\x02\x03\x01\x12\x035\
    \x08+\n\x0c\n\x05\x05\x05\x02\x03\x02\x12\x035./\n\x0b\n\x04\x05\x05\x02\
    \x04\x12\x036\x081\n\x0c\n\x05\x05\x05\x02\x04\x01\x12\x036\x08,\n\x0c\n\
    \x05\x05\x05\x02\x04\x02\x12\x036/0\n\x0b\n\x04\x05\x05\x02\x05\x12\x037\
    \x085\n\x0c\n\x05\x05\x05\x02\x05\x01\x12\x037\x080\n\x0c\n\x05\x05\x05\
    \x02\x05\x02\x12\x03734\n\x0b\n\x04\x05\x05\x02\x06\x12\x038\x089\n\x0c\
    \n\x05\x05\x05\x02\x06\x01\x12\x038\x084\n\x0c\n\x05\x05\x05\x02\x06\x02\
    \x12\x03878\n\x0b\n\x04\x05\x05\x02\x07\x12\x039\x08/\n\x0c\n\x05\x05\
    \x05\x02\x07\x01\x12\x039\x08*\n\x0c\n\x05\x05\x05\x02\x07\x02\x12\x039-\
    .\n\x0b\n\x04\x05\x05\x02\x08\x12\x03:\x081\n\x0c\n\x05\x05\x05\x02\x08\
    \x01\x12\x03:\x08+\n\x0c\n\x05\x05\x05\x02\x08\x02\x12\x03:.0\n\x0b\n\
    \x04\x05\x05\x02\t\x12\x03;\x087\n\x0c\n\x05\x05\x05\x02\t\x01\x12\x03;\
    \x081\n\x0c\n\x05\x05\x05\x02\t\x02\x12\x03;46\n\n\n\x02\x04\0\x12\x04>\
    \0?\x01\n\n\n\x03\x04\0\x01\x12\x03>\x080\n\n\n\x02\x04\x01\x12\x04A\0B\
    \x01\n\n\n\x03\x04\x01\x01\x12\x03A\x081\n\n\n\x02\x04\x02\x12\x04D\0K\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03D\x08-\n\x0b\n\x04\x04\x02\x02\0\x12\
    \x03E\x08-\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03E\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03E\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03E\x19(\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03E+,\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03F\x08-\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03F\x08\x10\
    \n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03F\x11\x18\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03F\x19(\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03F+,\n\
    \x0b\n\x04\x04\x02\x02\x02\x12\x03G\x08!\n\x0c\n\x05\x04\x02\x02\x02\x04\
    \x12\x03G\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03G\x11\x17\n\x0c\
    \n\x05\x04\x02\x02\x02\x01\x12\x03G\x18\x1c\n\x0c\n\x05\x04\x02\x02\x02\
    \x03\x12\x03G\x1f\x20\n\x0b\n\x04\x04\x02\x02\x03\x12\x03H\x08.\n\x0c\n\
    \x05\x04\x02\x02\x03\x04\x12\x03H\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\
    \x05\x12\x03H\x11\x18\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03H\x19)\n\
    \x0c\n\x05\x04\x02\x02\x03\x03\x12\x03H,-\n\x0b\n\x04\x04\x02\x02\x04\
    \x12\x03I\x089\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03I\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x04\x05\x12\x03I\x11\x17\n\x0c\n\x05\x04\x02\x02\x04\
    \x01\x12\x03I\x184\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03I78\n\x0b\n\
    \x04\x04\x02\x02\x05\x12\x03J\x08:\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\
    \x03J\x08\x10\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03J\x11\x17\n\x0c\n\
    \x05\x04\x02\x02\x05\x01\x12\x03J\x185\n\x0c\n\x05\x04\x02\x02\x05\x03\
    \x12\x03J89\n\n\n\x02\x04\x03\x12\x04M\0Q\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03M\x08\x11\n\x0b\n\x04\x04\x03\x02\0\x12\x03N\x08$\n\x0c\n\x05\x04\
    \x03\x02\0\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03N\
    \x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03N\x18\x1f\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03N\"#\n\x0b\n\x04\x04\x03\x02\x01\x12\x03O\x08!\n\
    \x0c\n\x05\x04\x03\x02\x01\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03O\x18\
    \x1c\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03O\x1f\x20\n\x0b\n\x04\x04\
    \x03\x02\x02\x12\x03P\x08$\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03P\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03P\x11\x17\n\x0c\n\x05\x04\
    \x03\x02\x02\x01\x12\x03P\x18\x1f\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\
    \x03P\"#\n\n\n\x02\x04\x04\x12\x04S\0`\x01\n\n\n\x03\x04\x04\x01\x12\x03\
    S\x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\x03T\x08$\n\x0c\n\x05\x04\x04\
    \x02\0\x04\x12\x03T\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03T\x11\
    \x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03T\x18\x1f\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x03T\"#\n\x0b\n\x04\x04\x04\x02\x01\x12\x03U\x08;\n\x0c\n\
    \x05\x04\x04\x02\x01\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\
    \x05\x12\x03U\x11\x15\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03U\x166\n\
    \x0c\n\x05\x04\x04\x02\x01\x03\x12\x03U9:\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x03V\x08#\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03V\x08\x10\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03V\x11\x15\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03V\x16\x1e\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03V!\"\n\x0b\
    \n\x04\x04\x04\x02\x03\x12\x03W\x08\"\n\x0c\n\x05\x04\x04\x02\x03\x04\
    \x12\x03W\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03W\x11\x15\n\x0c\
    \n\x05\x04\x04\x02\x03\x01\x12\x03W\x16\x1d\n\x0c\n\x05\x04\x04\x02\x03\
    \x03\x12\x03W\x20!\n\x0b\n\x04\x04\x04\x02\x04\x12\x03X\x08%\n\x0c\n\x05\
    \x04\x04\x02\x04\x04\x12\x03X\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x05\
    \x12\x03X\x11\x15\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03X\x16\x20\n\x0c\
    \n\x05\x04\x04\x02\x04\x03\x12\x03X#$\n\x0b\n\x04\x04\x04\x02\x05\x12\
    \x03Y\x089\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03Y\x08\x10\n\x0c\n\x05\
    \x04\x04\x02\x05\x05\x12\x03Y\x11\x15\n\x0c\n\x05\x04\x04\x02\x05\x01\
    \x12\x03Y\x164\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03Y78\n\x0b\n\x04\
    \x04\x04\x02\x06\x12\x03Z\x08#\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03Z\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\x03Z\x11\x15\n\x0c\n\x05\
    \x04\x04\x02\x06\x01\x12\x03Z\x16\x1e\n\x0c\n\x05\x04\x04\x02\x06\x03\
    \x12\x03Z!\"\n\x0b\n\x04\x04\x04\x02\x07\x12\x03[\x08+\n\x0c\n\x05\x04\
    \x04\x02\x07\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x04\x02\x07\x05\x12\
    \x03[\x11\x15\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x03[\x16&\n\x0c\n\x05\
    \x04\x04\x02\x07\x03\x12\x03[)*\n\x0b\n\x04\x04\x04\x02\x08\x12\x03\\\
    \x081\n\x0c\n\x05\x04\x04\x02\x08\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x08\x05\x12\x03\\\x11\x15\n\x0c\n\x05\x04\x04\x02\x08\x01\x12\
    \x03\\\x16,\n\x0c\n\x05\x04\x04\x02\x08\x03\x12\x03\\/0\n\x0b\n\x04\x04\
    \x04\x02\t\x12\x03]\x081\n\x0c\n\x05\x04\x04\x02\t\x04\x12\x03]\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\t\x05\x12\x03]\x11\x15\n\x0c\n\x05\x04\x04\x02\
    \t\x01\x12\x03]\x16+\n\x0c\n\x05\x04\x04\x02\t\x03\x12\x03].0\n\x0b\n\
    \x04\x04\x04\x02\n\x12\x03^\x08+\n\x0c\n\x05\x04\x04\x02\n\x04\x12\x03^\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\n\x05\x12\x03^\x11\x15\n\x0c\n\x05\x04\
    \x04\x02\n\x01\x12\x03^\x16%\n\x0c\n\x05\x04\x04\x02\n\x03\x12\x03^(*\n\
    \x0b\n\x04\x04\x04\x02\x0b\x12\x03_\x086\n\x0c\n\x05\x04\x04\x02\x0b\x04\
    \x12\x03_\x08\x10\n\x0c\n\x05\x04\x04\x02\x0b\x05\x12\x03_\x11\x15\n\x0c\
    \n\x05\x04\x04\x02\x0b\x01\x12\x03_\x160\n\x0c\n\x05\x04\x04\x02\x0b\x03\
    \x12\x03_35\n\n\n\x02\x04\x05\x12\x04b\0g\x01\n\n\n\x03\x04\x05\x01\x12\
    \x03b\x08\x18\n\x0b\n\x04\x04\x05\x02\0\x12\x03c\x08#\n\x0c\n\x05\x04\
    \x05\x02\0\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03c\
    \x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03c\x18\x1e\n\x0c\n\x05\x04\
    \x05\x02\0\x03\x12\x03c!\"\n\x0b\n\x04\x04\x05\x02\x01\x12\x03d\x08+\n\
    \x0c\n\x05\x04\x05\x02\x01\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x05\x02\
    \x01\x05\x12\x03d\x11\x18\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03d\x19&\
    \n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03d)*\n\x0b\n\x04\x04\x05\x02\x02\
    \x12\x03e\x08'\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03e\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\x02\x05\x12\x03e\x11\x18\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x03e\x19\"\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03e%&\n\x0b\n\
    \x04\x04\x05\x02\x03\x12\x03f\x08*\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\
    \x03f\x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03f\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\x03\x01\x12\x03f\x18%\n\x0c\n\x05\x04\x05\x02\x03\x03\
    \x12\x03f()\n\n\n\x02\x04\x06\x12\x04i\0y\x01\n\n\n\x03\x04\x06\x01\x12\
    \x03i\x08!\n\x0b\n\x04\x04\x06\x02\0\x12\x03j\x08*\n\x0c\n\x05\x04\x06\
    \x02\0\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03j\x11\
    \x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03j\x18%\n\x0c\n\x05\x04\x06\x02\
    \0\x03\x12\x03j()\n\x0b\n\x04\x04\x06\x02\x01\x12\x03k\x08&\n\x0c\n\x05\
    \x04\x06\x02\x01\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\
    \x12\x03k\x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03k\x18!\n\x0c\n\
    \x05\x04\x06\x02\x01\x03\x12\x03k$%\n\x0b\n\x04\x04\x06\x02\x02\x12\x03l\
    \x08$\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\
    \x06\x02\x02\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\
    \x03l\x18\x1e\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03l!#\n\x0b\n\x04\x04\
    \x06\x02\x03\x12\x03m\x08-\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03m\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\
    \x06\x02\x03\x01\x12\x03m\x18'\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03m*\
    ,\n\x0b\n\x04\x04\x06\x02\x04\x12\x03n\x08#\n\x0c\n\x05\x04\x06\x02\x04\
    \x04\x12\x03n\x08\x10\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03n\x11\x17\n\
    \x0c\n\x05\x04\x06\x02\x04\x01\x12\x03n\x18\x1d\n\x0c\n\x05\x04\x06\x02\
    \x04\x03\x12\x03n\x20\"\n\x0b\n\x04\x04\x06\x02\x05\x12\x03o\x08%\n\x0c\
    \n\x05\x04\x06\x02\x05\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x06\x02\x05\
    \x05\x12\x03o\x11\x17\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03o\x18\x1f\n\
    \x0c\n\x05\x04\x06\x02\x05\x03\x12\x03o\"$\n\x0b\n\x04\x04\x06\x02\x06\
    \x12\x03p\x08'\n\x0c\n\x05\x04\x06\x02\x06\x04\x12\x03p\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x06\x05\x12\x03p\x11\x16\n\x0c\n\x05\x04\x06\x02\x06\
    \x01\x12\x03p\x17!\n\x0c\n\x05\x04\x06\x02\x06\x03\x12\x03p$&\n\x0b\n\
    \x04\x04\x06\x02\x07\x12\x03q\x08-\n\x0c\n\x05\x04\x06\x02\x07\x04\x12\
    \x03q\x08\x10\n\x0c\n\x05\x04\x06\x02\x07\x05\x12\x03q\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x07\x01\x12\x03q\x18'\n\x0c\n\x05\x04\x06\x02\x07\x03\
    \x12\x03q*,\n\x0b\n\x04\x04\x06\x02\x08\x12\x03r\x08'\n\x0c\n\x05\x04\
    \x06\x02\x08\x04\x12\x03r\x08\x10\n\x0c\n\x05\x04\x06\x02\x08\x06\x12\
    \x03r\x11\x1b\n\x0c\n\x05\x04\x06\x02\x08\x01\x12\x03r\x1c!\n\x0c\n\x05\
    \x04\x06\x02\x08\x03\x12\x03r$&\n\x0b\n\x04\x04\x06\x02\t\x12\x03s\x085\
    \n\x0c\n\x05\x04\x06\x02\t\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \t\x06\x12\x03s\x11\"\n\x0c\n\x05\x04\x06\x02\t\x01\x12\x03s#/\n\x0c\n\
    \x05\x04\x06\x02\t\x03\x12\x03s24\n\x0b\n\x04\x04\x06\x02\n\x12\x03t\x08\
    :\n\x0c\n\x05\x04\x06\x02\n\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \n\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\x06\x02\n\x01\x12\x03t\x184\n\
    \x0c\n\x05\x04\x06\x02\n\x03\x12\x03t79\n\x0b\n\x04\x04\x06\x02\x0b\x12\
    \x03u\x086\n\x0c\n\x05\x04\x06\x02\x0b\x04\x12\x03u\x08\x10\n\x0c\n\x05\
    \x04\x06\x02\x0b\x06\x12\x03u\x11\"\n\x0c\n\x05\x04\x06\x02\x0b\x01\x12\
    \x03u#0\n\x0c\n\x05\x04\x06\x02\x0b\x03\x12\x03u35\n\x0b\n\x04\x04\x06\
    \x02\x0c\x12\x03v\x08;\n\x0c\n\x05\x04\x06\x02\x0c\x04\x12\x03v\x08\x10\
    \n\x0c\n\x05\x04\x06\x02\x0c\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\x06\
    \x02\x0c\x01\x12\x03v\x185\n\x0c\n\x05\x04\x06\x02\x0c\x03\x12\x03v8:\n\
    \x0b\n\x04\x04\x06\x02\r\x12\x03w\x080\n\x0c\n\x05\x04\x06\x02\r\x04\x12\
    \x03w\x08\x10\n\x0c\n\x05\x04\x06\x02\r\x05\x12\x03w\x11\x17\n\x0c\n\x05\
    \x04\x06\x02\r\x01\x12\x03w\x18*\n\x0c\n\x05\x04\x06\x02\r\x03\x12\x03w-\
    /\n\x0b\n\x04\x04\x06\x02\x0e\x12\x03x\x08,\n\x0c\n\x05\x04\x06\x02\x0e\
    \x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\x06\x02\x0e\x05\x12\x03x\x11\x17\n\
    \x0c\n\x05\x04\x06\x02\x0e\x01\x12\x03x\x18&\n\x0c\n\x05\x04\x06\x02\x0e\
    \x03\x12\x03x)+\n\x0b\n\x02\x04\x07\x12\x05{\0\x81\x01\x01\n\n\n\x03\x04\
    \x07\x01\x12\x03{\x08\x17\n\x0b\n\x04\x04\x07\x02\0\x12\x03|\x08&\n\x0c\
    \n\x05\x04\x07\x02\0\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\
    \x12\x03|\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03|\x18!\n\x0c\n\
    \x05\x04\x07\x02\0\x03\x12\x03|$%\n\x0b\n\x04\x04\x07\x02\x01\x12\x03}\
    \x08X\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\
    \x07\x02\x01\x06\x12\x03}\x11$\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03}%\
    *\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03}-.\n\x0c\n\x05\x04\x07\x02\x01\
    \x08\x12\x03}/W\n\x0c\n\x05\x04\x07\x02\x01\x07\x12\x03}:V\n\x0b\n\x04\
    \x04\x07\x02\x02\x12\x03~\x08W\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03~\
    \x08\x10\n\x0c\n\x05\x04\x07\x02\x02\x06\x12\x03~\x11$\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03~%)\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03~,-\n\
    \x0c\n\x05\x04\x07\x02\x02\x08\x12\x03~.V\n\x0c\n\x05\x04\x07\x02\x02\
    \x07\x12\x03~9U\n\x0b\n\x04\x04\x07\x02\x03\x12\x03\x7f\x08-\n\x0c\n\x05\
    \x04\x07\x02\x03\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x07\x02\x03\x05\
    \x12\x03\x7f\x11\x17\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03\x7f\x18(\n\
    \x0c\n\x05\x04\x07\x02\x03\x03\x12\x03\x7f+,\n\x0c\n\x04\x04\x07\x02\x04\
    \x12\x04\x80\x01\x08%\n\r\n\x05\x04\x07\x02\x04\x04\x12\x04\x80\x01\x08\
    \x10\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\
    \x07\x02\x04\x01\x12\x04\x80\x01\x18\x20\n\r\n\x05\x04\x07\x02\x04\x03\
    \x12\x04\x80\x01#$\n\x0c\n\x02\x04\x08\x12\x06\x83\x01\0\x8c\x01\x01\n\
    \x0b\n\x03\x04\x08\x01\x12\x04\x83\x01\x08\x16\n\x0c\n\x04\x04\x08\x02\0\
    \x12\x04\x84\x01\x08$\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x84\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\x84\x01\x18\x1f\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\x84\x01\"#\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x85\x01\x08&\n\r\n\
    \x05\x04\x08\x02\x01\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x01\x05\x12\x04\x85\x01\x11\x17\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\
    \x85\x01\x18!\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x85\x01$%\n\x0c\n\
    \x04\x04\x08\x02\x02\x12\x04\x86\x01\x08(\n\r\n\x05\x04\x08\x02\x02\x04\
    \x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x86\x01\
    \x11\x15\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x86\x01\x16#\n\r\n\x05\
    \x04\x08\x02\x02\x03\x12\x04\x86\x01&'\n\x0c\n\x04\x04\x08\x02\x03\x12\
    \x04\x87\x01\x08-\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\x87\x01\x08\x10\
    \n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x08\
    \x02\x03\x01\x12\x04\x87\x01\x18(\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\
    \x87\x01+,\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\x88\x01\x08.\n\r\n\x05\
    \x04\x08\x02\x04\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x08\x02\x04\
    \x05\x12\x04\x88\x01\x11\x17\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\x88\
    \x01\x18)\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\x88\x01,-\n\x0c\n\x04\
    \x04\x08\x02\x05\x12\x04\x89\x01\x08'\n\r\n\x05\x04\x08\x02\x05\x04\x12\
    \x04\x89\x01\x08\x10\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\x89\x01\x11\
    \x17\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\x89\x01\x18\"\n\r\n\x05\x04\
    \x08\x02\x05\x03\x12\x04\x89\x01%&\n\x0c\n\x04\x04\x08\x02\x06\x12\x04\
    \x8a\x01\x08)\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\x8a\x01\x08\x10\n\r\
    \n\x05\x04\x08\x02\x06\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x08\x02\
    \x06\x01\x12\x04\x8a\x01\x18$\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\x8a\
    \x01'(\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\x8b\x01\x083\n\r\n\x05\x04\
    \x08\x02\x07\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x08\x02\x07\x05\
    \x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\x8b\x01\
    \x18.\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\x8b\x0112\n\x0c\n\x02\x04\t\
    \x12\x06\x8e\x01\0\x94\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x8e\x01\x08\
    \x1b\n\x0c\n\x04\x04\t\x02\0\x12\x04\x8f\x01\x08=\n\r\n\x05\x04\t\x02\0\
    \x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x8f\x01\
    \x11+\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x8f\x01,8\n\r\n\x05\x04\t\x02\0\
    \x03\x12\x04\x8f\x01;<\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x90\x01\x08.\n\
    \r\n\x05\x04\t\x02\x01\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\t\x02\
    \x01\x06\x12\x04\x90\x01\x11!\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x90\
    \x01\")\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x90\x01,-\n\x0c\n\x04\x04\t\
    \x02\x02\x12\x04\x91\x01\x08,\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\x91\
    \x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\x91\x01\x11\x17\n\r\n\
    \x05\x04\t\x02\x02\x01\x12\x04\x91\x01\x18'\n\r\n\x05\x04\t\x02\x02\x03\
    \x12\x04\x91\x01*+\n\x0c\n\x04\x04\t\x02\x03\x12\x04\x92\x01\x080\n\r\n\
    \x05\x04\t\x02\x03\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\
    \x06\x12\x04\x92\x01\x11\x20\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\x92\x01\
    !+\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\x92\x01./\n\x0c\n\x04\x04\t\x02\
    \x04\x12\x04\x93\x01\x08-\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\x93\x01\
    \x08\x10\n\r\n\x05\x04\t\x02\x04\x06\x12\x04\x93\x01\x11!\n\r\n\x05\x04\
    \t\x02\x04\x01\x12\x04\x93\x01\"(\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\
    \x93\x01+,\n\x0c\n\x02\x04\n\x12\x06\x96\x01\0\x9f\x01\x01\n\x0b\n\x03\
    \x04\n\x01\x12\x04\x96\x01\x08\x1a\n\x0c\n\x04\x04\n\x02\0\x12\x04\x97\
    \x01\x08$\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\x97\x01\x11\x17\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\x97\x01\x18\x1f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x97\x01\"#\n\x0c\
    \n\x04\x04\n\x02\x01\x12\x04\x98\x01\x08(\n\r\n\x05\x04\n\x02\x01\x04\
    \x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x98\x01\x11\
    \x17\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x98\x01\x18#\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\x98\x01&'\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x99\x01\
    \x08*\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\
    \n\x02\x02\x05\x12\x04\x99\x01\x11\x17\n\r\n\x05\x04\n\x02\x02\x01\x12\
    \x04\x99\x01\x18%\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x99\x01()\n\x0c\n\
    \x04\x04\n\x02\x03\x12\x04\x9a\x01\x08}\n\r\n\x05\x04\n\x02\x03\x04\x12\
    \x04\x9a\x01\x08\x10\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\x9a\x01\x11,\n\
    \r\n\x05\x04\n\x02\x03\x01\x12\x04\x9a\x01-G\n\r\n\x05\x04\n\x02\x03\x03\
    \x12\x04\x9a\x01JK\n\r\n\x05\x04\n\x02\x03\x08\x12\x04\x9a\x01L|\n\r\n\
    \x05\x04\n\x02\x03\x07\x12\x04\x9a\x01W{\n\x0c\n\x04\x04\n\x02\x04\x12\
    \x04\x9b\x01\x08|\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\x9b\x01\x08\x10\n\
    \r\n\x05\x04\n\x02\x04\x06\x12\x04\x9b\x01\x11,\n\r\n\x05\x04\n\x02\x04\
    \x01\x12\x04\x9b\x01-F\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\x9b\x01IJ\n\r\
    \n\x05\x04\n\x02\x04\x08\x12\x04\x9b\x01K{\n\r\n\x05\x04\n\x02\x04\x07\
    \x12\x04\x9b\x01Vz\n\x0c\n\x04\x04\n\x02\x05\x12\x04\x9c\x01\x08.\n\r\n\
    \x05\x04\n\x02\x05\x04\x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\n\x02\x05\
    \x05\x12\x04\x9c\x01\x11\x17\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\x9c\x01\
    \x18)\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x9c\x01,-\n\x0c\n\x04\x04\n\
    \x02\x06\x12\x04\x9d\x01\x08C\n\r\n\x05\x04\n\x02\x06\x04\x12\x04\x9d\
    \x01\x08\x10\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\x9d\x01\x11\x15\n\r\n\
    \x05\x04\n\x02\x06\x01\x12\x04\x9d\x01\x16,\n\r\n\x05\x04\n\x02\x06\x03\
    \x12\x04\x9d\x01/0\n\r\n\x05\x04\n\x02\x06\x08\x12\x04\x9d\x011B\n\r\n\
    \x05\x04\n\x02\x06\x07\x12\x04\x9d\x01<A\n\x0c\n\x04\x04\n\x02\x07\x12\
    \x04\x9e\x01\x08.\n\r\n\x05\x04\n\x02\x07\x04\x12\x04\x9e\x01\x08\x10\n\
    \r\n\x05\x04\n\x02\x07\x05\x12\x04\x9e\x01\x11\x17\n\r\n\x05\x04\n\x02\
    \x07\x01\x12\x04\x9e\x01\x18)\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\x9e\
    \x01,-\n\x0c\n\x02\x04\x0b\x12\x06\xa1\x01\0\xa9\x01\x01\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xa1\x01\x08\x1f\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xa2\
    \x01\x08*\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\
    \x04\x0b\x02\0\x05\x12\x04\xa2\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\xa2\x01\x18%\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xa2\x01()\n\
    \x0c\n\x04\x04\x0b\x02\x01\x12\x04\xa3\x01\x08(\n\r\n\x05\x04\x0b\x02\
    \x01\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\
    \xa3\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xa3\x01\x18#\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\xa3\x01&'\n\x0c\n\x04\x04\x0b\x02\x02\
    \x12\x04\xa4\x01\x08>\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xa4\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xa4\x01\x11$\n\r\n\x05\x04\
    \x0b\x02\x02\x01\x12\x04\xa4\x01%9\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\
    \xa4\x01<=\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\xa5\x01\x08}\n\r\n\x05\
    \x04\x0b\x02\x03\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x03\
    \x06\x12\x04\xa5\x01\x11,\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xa5\x01-\
    G\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xa5\x01JK\n\r\n\x05\x04\x0b\x02\
    \x03\x08\x12\x04\xa5\x01L|\n\r\n\x05\x04\x0b\x02\x03\x07\x12\x04\xa5\x01\
    W{\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\xa6\x01\x08|\n\r\n\x05\x04\x0b\
    \x02\x04\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x04\x06\x12\
    \x04\xa6\x01\x11,\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xa6\x01-F\n\r\n\
    \x05\x04\x0b\x02\x04\x03\x12\x04\xa6\x01IJ\n\r\n\x05\x04\x0b\x02\x04\x08\
    \x12\x04\xa6\x01K{\n\r\n\x05\x04\x0b\x02\x04\x07\x12\x04\xa6\x01Vz\n\x0c\
    \n\x04\x04\x0b\x02\x05\x12\x04\xa7\x01\x080\n\r\n\x05\x04\x0b\x02\x05\
    \x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\xa7\
    \x01\x11\x17\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xa7\x01\x18+\n\r\n\
    \x05\x04\x0b\x02\x05\x03\x12\x04\xa7\x01./\n\x0c\n\x04\x04\x0b\x02\x06\
    \x12\x04\xa8\x01\x08C\n\r\n\x05\x04\x0b\x02\x06\x04\x12\x04\xa8\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\xa8\x01\x11\x15\n\r\n\x05\x04\
    \x0b\x02\x06\x01\x12\x04\xa8\x01\x16,\n\r\n\x05\x04\x0b\x02\x06\x03\x12\
    \x04\xa8\x01/0\n\r\n\x05\x04\x0b\x02\x06\x08\x12\x04\xa8\x011B\n\r\n\x05\
    \x04\x0b\x02\x06\x07\x12\x04\xa8\x01<A\n\x0c\n\x02\x04\x0c\x12\x06\xab\
    \x01\0\xaf\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xab\x01\x08.\n\x0c\n\
    \x04\x04\x0c\x02\0\x12\x04\xac\x01\x08*\n\r\n\x05\x04\x0c\x02\0\x04\x12\
    \x04\xac\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xac\x01\x11\x17\
    \n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xac\x01\x18%\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\xac\x01()\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xad\x01\x08\
    0\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\
    \x0c\x02\x01\x06\x12\x04\xad\x01\x11%\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xad\x01&+\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xad\x01./\n\x0c\n\
    \x04\x04\x0c\x02\x02\x12\x04\xae\x01\x08>\n\r\n\x05\x04\x0c\x02\x02\x04\
    \x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\xae\x01\
    \x11)\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xae\x01*9\n\r\n\x05\x04\x0c\
    \x02\x02\x03\x12\x04\xae\x01<=\n\x0c\n\x02\x04\r\x12\x06\xb1\x01\0\xb4\
    \x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xb1\x01\x08+\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\xb2\x01\x08*\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xb2\x01\
    \x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\xb2\x01\x18%\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb2\
    \x01()\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xb3\x01\x08!\n\r\n\x05\x04\r\
    \x02\x01\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\
    \xb3\x01\x11\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xb3\x01\x18\x1c\n\r\
    \n\x05\x04\r\x02\x01\x03\x12\x04\xb3\x01\x1f\x20\n\x0c\n\x02\x04\x0e\x12\
    \x06\xb6\x01\0\xb7\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xb6\x01\x08,\
    \n\x0c\n\x02\x04\x0f\x12\x06\xb9\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\x0f\
    \x01\x12\x04\xb9\x01\x08-\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xba\x01\x08*\
    \n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\xba\x01\x11\x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \xba\x01\x18%\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xba\x01()\n\x0c\n\x04\
    \x04\x0f\x02\x01\x12\x04\xbb\x01\x08!\n\r\n\x05\x04\x0f\x02\x01\x04\x12\
    \x04\xbb\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xbb\x01\x11\
    \x17\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xbb\x01\x18\x1c\n\r\n\x05\x04\
    \x0f\x02\x01\x03\x12\x04\xbb\x01\x1f\x20\n\x0c\n\x02\x04\x10\x12\x06\xbe\
    \x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xbe\x01\x08.\n\x0c\n\
    \x04\x04\x10\x02\0\x12\x04\xbf\x01\x08!\n\r\n\x05\x04\x10\x02\0\x04\x12\
    \x04\xbf\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xbf\x01\x11\x17\
    \n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xbf\x01\x18\x1c\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xbf\x01\x1f\x20\n\x0c\n\x02\x04\x11\x12\x06\xc2\x01\0\
    \xc5\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xc2\x01\x081\n\x0c\n\x04\
    \x04\x11\x02\0\x12\x04\xc3\x01\x08*\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\
    \xc3\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xc3\x01\x11\x17\n\r\
    \n\x05\x04\x11\x02\0\x01\x12\x04\xc3\x01\x18%\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xc3\x01()\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xc4\x01\x08$\
    \n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\xc4\x01\x11\x17\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xc4\x01\x18\x1f\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xc4\x01\"#\n\
    \x0c\n\x02\x04\x12\x12\x06\xc7\x01\0\xc8\x01\x01\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xc7\x01\x082\n\x0c\n\x02\x04\x13\x12\x06\xca\x01\0\xcd\x01\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xca\x01\x080\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xcb\x01\x08*\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xcb\x01\x08\
    \x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\
    \x13\x02\0\x01\x12\x04\xcb\x01\x18%\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xcb\x01()\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xcc\x01\x08&\n\r\n\x05\
    \x04\x13\x02\x01\x04\x12\x04\xcc\x01\x08\x10\n\r\n\x05\x04\x13\x02\x01\
    \x05\x12\x04\xcc\x01\x11\x16\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xcc\
    \x01\x17!\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xcc\x01$%\n\x0c\n\x02\
    \x04\x14\x12\x06\xcf\x01\0\xd0\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xcf\x01\x081\n\x0c\n\x02\x04\x15\x12\x06\xd2\x01\0\xd6\x01\x01\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xd2\x01\x08;\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xd3\x01\x08*\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xd3\x01\x08\x10\n\r\n\
    \x05\x04\x15\x02\0\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xd3\x01\x18%\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xd3\x01()\
    \n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xd4\x01\x089\n\r\n\x05\x04\x15\x02\
    \x01\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\
    \xd4\x01\x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xd4\x01\x184\n\r\
    \n\x05\x04\x15\x02\x01\x03\x12\x04\xd4\x0178\n\x0c\n\x04\x04\x15\x02\x02\
    \x12\x04\xd5\x01\x08:\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xd5\x01\x08\
    \x10\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xd5\x01\x11\x17\n\r\n\x05\x04\
    \x15\x02\x02\x01\x12\x04\xd5\x01\x185\n\r\n\x05\x04\x15\x02\x02\x03\x12\
    \x04\xd5\x0189\n\x0c\n\x02\x04\x16\x12\x06\xd8\x01\0\xd9\x01\x01\n\x0b\n\
    \x03\x04\x16\x01\x12\x04\xd8\x01\x08<\n\x0c\n\x02\x04\x17\x12\x06\xdb\
    \x01\0\xde\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xdb\x01\x086\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xdc\x01\x08*\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xdc\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xdc\x01\x11\x17\
    \n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xdc\x01\x18%\n\r\n\x05\x04\x17\x02\
    \0\x03\x12\x04\xdc\x01()\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xdd\x01\x08\
    $\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\
    \x17\x02\x01\x05\x12\x04\xdd\x01\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\
    \x12\x04\xdd\x01\x18\x1f\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xdd\x01\"\
    #\n\x0c\n\x02\x04\x18\x12\x06\xe0\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x18\
    \x01\x12\x04\xe0\x01\x087\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xe1\x01\x08(\
    \n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x18\
    \x02\0\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xe1\x01\x18#\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xe1\x01&'\n\x0c\n\x02\
    \x04\x19\x12\x06\xe4\x01\0\xe8\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\
    \xe4\x01\x085\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xe5\x01\x08*\n\r\n\x05\
    \x04\x19\x02\0\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\
    \x12\x04\xe5\x01\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xe5\x01\x18\
    %\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xe5\x01()\n\x0c\n\x04\x04\x19\x02\
    \x01\x12\x04\xe6\x01\x08$\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xe6\x01\
    \x08\x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xe6\x01\x11\x17\n\r\n\x05\
    \x04\x19\x02\x01\x01\x12\x04\xe6\x01\x18\x1f\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\xe6\x01\"#\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xe7\x01\x08(\
    \n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x19\
    \x02\x02\x05\x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\x19\x02\x02\x01\x12\
    \x04\xe7\x01\x18#\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xe7\x01&'\n\x0c\
    \n\x02\x04\x1a\x12\x06\xea\x01\0\xeb\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xea\x01\x086\n\x0c\n\x02\x04\x1b\x12\x06\xed\x01\0\xf1\x01\x01\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\xed\x01\x08\"\n\x0c\n\x04\x04\x1b\x02\0\
    \x12\x04\xee\x01\x08*\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xee\x01\x08\
    \x10\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xee\x01\x11\x17\n\r\n\x05\x04\
    \x1b\x02\0\x01\x12\x04\xee\x01\x18%\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\
    \xee\x01()\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xef\x01\x08%\n\r\n\x05\
    \x04\x1b\x02\x01\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x01\
    \x05\x12\x04\xef\x01\x11\x18\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xef\
    \x01\x19\x20\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xef\x01#$\n\x0c\n\x04\
    \x04\x1b\x02\x02\x12\x04\xf0\x01\x08&\n\r\n\x05\x04\x1b\x02\x02\x04\x12\
    \x04\xf0\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xf0\x01\x11\
    \x16\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xf0\x01\x17!\n\r\n\x05\x04\
    \x1b\x02\x02\x03\x12\x04\xf0\x01$%\n\x0c\n\x02\x04\x1c\x12\x06\xf3\x01\0\
    \xf4\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xf3\x01\x08#\n\x0c\n\x02\
    \x04\x1d\x12\x06\xf6\x01\0\xfa\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\
    \xf6\x01\x08\"\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xf7\x01\x08*\n\r\n\x05\
    \x04\x1d\x02\0\x04\x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\
    \x12\x04\xf7\x01\x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xf7\x01\x18\
    %\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf7\x01()\n\x0c\n\x04\x04\x1d\x02\
    \x01\x12\x04\xf8\x01\x08%\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xf8\x01\
    \x08\x10\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xf8\x01\x11\x18\n\r\n\x05\
    \x04\x1d\x02\x01\x01\x12\x04\xf8\x01\x19\x20\n\r\n\x05\x04\x1d\x02\x01\
    \x03\x12\x04\xf8\x01#$\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xf9\x01\x08&\
    \n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\xf9\x01\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x02\x05\x12\x04\xf9\x01\x11\x16\n\r\n\x05\x04\x1d\x02\x02\x01\x12\
    \x04\xf9\x01\x17!\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xf9\x01$%\n\x0c\
    \n\x02\x04\x1e\x12\x06\xfc\x01\0\xfd\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\xfc\x01\x08#\n\x0c\n\x02\x04\x1f\x12\x06\xff\x01\0\x83\x02\x01\n\
    \x0b\n\x03\x04\x1f\x01\x12\x04\xff\x01\x08)\n\x0c\n\x04\x04\x1f\x02\0\
    \x12\x04\x80\x02\x08*\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\x80\x02\x08\
    \x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\x80\x02\x11\x17\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\x80\x02\x18%\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \x80\x02()\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\x81\x02\x08%\n\r\n\x05\
    \x04\x1f\x02\x01\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x01\
    \x05\x12\x04\x81\x02\x11\x18\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x81\
    \x02\x19\x20\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x81\x02#$\n\x0c\n\x04\
    \x04\x1f\x02\x02\x12\x04\x82\x02\x08$\n\r\n\x05\x04\x1f\x02\x02\x04\x12\
    \x04\x82\x02\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\x82\x02\x11\
    \x15\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\x82\x02\x16\x1f\n\r\n\x05\x04\
    \x1f\x02\x02\x03\x12\x04\x82\x02\"#\n\x0c\n\x02\x04\x20\x12\x06\x85\x02\
    \0\x86\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x85\x02\x08*\n\x0c\n\x02\
    \x04!\x12\x06\x88\x02\0\x8b\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\x88\x02\
    \x08&\n\x0c\n\x04\x04!\x02\0\x12\x04\x89\x02\x08*\n\r\n\x05\x04!\x02\0\
    \x04\x12\x04\x89\x02\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\x89\x02\
    \x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\x89\x02\x18%\n\r\n\x05\x04!\
    \x02\0\x03\x12\x04\x89\x02()\n\x0c\n\x04\x04!\x02\x01\x12\x04\x8a\x02\
    \x08%\n\r\n\x05\x04!\x02\x01\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04!\
    \x02\x01\x05\x12\x04\x8a\x02\x11\x18\n\r\n\x05\x04!\x02\x01\x01\x12\x04\
    \x8a\x02\x19\x20\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x8a\x02#$\n\x0c\n\
    \x02\x04\"\x12\x06\x8d\x02\0\x8e\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \x8d\x02\x08'\n\x0c\n\x02\x04#\x12\x06\x90\x02\0\x93\x02\x01\n\x0b\n\x03\
    \x04#\x01\x12\x04\x90\x02\x08$\n\x0c\n\x04\x04#\x02\0\x12\x04\x91\x02\
    \x08*\n\r\n\x05\x04#\x02\0\x04\x12\x04\x91\x02\x08\x10\n\r\n\x05\x04#\
    \x02\0\x05\x12\x04\x91\x02\x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\x91\
    \x02\x18%\n\r\n\x05\x04#\x02\0\x03\x12\x04\x91\x02()\n\x0c\n\x04\x04#\
    \x02\x01\x12\x04\x92\x02\x08!\n\r\n\x05\x04#\x02\x01\x04\x12\x04\x92\x02\
    \x08\x10\n\r\n\x05\x04#\x02\x01\x05\x12\x04\x92\x02\x11\x17\n\r\n\x05\
    \x04#\x02\x01\x01\x12\x04\x92\x02\x18\x1c\n\r\n\x05\x04#\x02\x01\x03\x12\
    \x04\x92\x02\x1f\x20\n\x0c\n\x02\x04$\x12\x06\x95\x02\0\x97\x02\x01\n\
    \x0b\n\x03\x04$\x01\x12\x04\x95\x02\x08%\n\x0c\n\x04\x04$\x02\0\x12\x04\
    \x96\x02\x08/\n\r\n\x05\x04$\x02\0\x04\x12\x04\x96\x02\x08\x10\n\r\n\x05\
    \x04$\x02\0\x06\x12\x04\x96\x02\x11\"\n\r\n\x05\x04$\x02\0\x01\x12\x04\
    \x96\x02#*\n\r\n\x05\x04$\x02\0\x03\x12\x04\x96\x02-.\n\x0c\n\x02\x04%\
    \x12\x06\x99\x02\0\x9b\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\x99\x02\x08\
    \"\n\x0c\n\x04\x04%\x02\0\x12\x04\x9a\x02\x08*\n\r\n\x05\x04%\x02\0\x04\
    \x12\x04\x9a\x02\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\x9a\x02\x11\
    \x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\x9a\x02\x18%\n\r\n\x05\x04%\x02\0\
    \x03\x12\x04\x9a\x02()\n\x0c\n\x02\x04&\x12\x06\x9d\x02\0\x9f\x02\x01\n\
    \x0b\n\x03\x04&\x01\x12\x04\x9d\x02\x08#\n\x0c\n\x04\x04&\x02\0\x12\x04\
    \x9e\x02\x08&\n\r\n\x05\x04&\x02\0\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\
    \x04&\x02\0\x06\x12\x04\x9e\x02\x11\x1b\n\r\n\x05\x04&\x02\0\x01\x12\x04\
    \x9e\x02\x1c!\n\r\n\x05\x04&\x02\0\x03\x12\x04\x9e\x02$%\n\x0c\n\x02\x04\
    '\x12\x06\xa1\x02\0\xa5\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xa1\x02\x08\
    $\n\x0c\n\x04\x04'\x02\0\x12\x04\xa2\x02\x08*\n\r\n\x05\x04'\x02\0\x04\
    \x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xa2\x02\x11\
    \x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xa2\x02\x18%\n\r\n\x05\x04'\x02\0\
    \x03\x12\x04\xa2\x02()\n\x0c\n\x04\x04'\x02\x01\x12\x04\xa3\x02\x08$\n\r\
    \n\x05\x04'\x02\x01\x04\x12\x04\xa3\x02\x08\x10\n\r\n\x05\x04'\x02\x01\
    \x05\x12\x04\xa3\x02\x11\x17\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xa3\x02\
    \x18\x1f\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xa3\x02\"#\n\x0c\n\x04\x04'\
    \x02\x02\x12\x04\xa4\x02\x08!\n\r\n\x05\x04'\x02\x02\x04\x12\x04\xa4\x02\
    \x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xa4\x02\x11\x17\n\r\n\x05\
    \x04'\x02\x02\x01\x12\x04\xa4\x02\x18\x1c\n\r\n\x05\x04'\x02\x02\x03\x12\
    \x04\xa4\x02\x1f\x20\n\x0c\n\x02\x04(\x12\x06\xa7\x02\0\xa8\x02\x01\n\
    \x0b\n\x03\x04(\x01\x12\x04\xa7\x02\x08%\n\x0c\n\x02\x04)\x12\x06\xaa\
    \x02\0\xae\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xaa\x02\x08%\n\x0c\n\x04\
    \x04)\x02\0\x12\x04\xab\x02\x08*\n\r\n\x05\x04)\x02\0\x04\x12\x04\xab\
    \x02\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\
    \x04)\x02\0\x01\x12\x04\xab\x02\x18%\n\r\n\x05\x04)\x02\0\x03\x12\x04\
    \xab\x02()\n\x0c\n\x04\x04)\x02\x01\x12\x04\xac\x02\x08$\n\r\n\x05\x04)\
    \x02\x01\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\
    \xac\x02\x11\x17\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xac\x02\x18\x1f\n\r\
    \n\x05\x04)\x02\x01\x03\x12\x04\xac\x02\"#\n\x0c\n\x04\x04)\x02\x02\x12\
    \x04\xad\x02\x08$\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xad\x02\x08\x10\n\r\
    \n\x05\x04)\x02\x02\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04)\x02\x02\
    \x01\x12\x04\xad\x02\x18\x1f\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xad\x02\
    \"#\n\x0c\n\x02\x04*\x12\x06\xb0\x02\0\xb1\x02\x01\n\x0b\n\x03\x04*\x01\
    \x12\x04\xb0\x02\x08&\n\x0c\n\x02\x04+\x12\x06\xb3\x02\0\xb6\x02\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xb3\x02\x08$\n\x0c\n\x04\x04+\x02\0\x12\x04\
    \xb4\x02\x08*\n\r\n\x05\x04+\x02\0\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\
    \x04+\x02\0\x05\x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04+\x02\0\x01\x12\x04\
    \xb4\x02\x18%\n\r\n\x05\x04+\x02\0\x03\x12\x04\xb4\x02()\n\x0c\n\x04\x04\
    +\x02\x01\x12\x04\xb5\x02\x08$\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xb5\
    \x02\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xb5\x02\x11\x17\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\xb5\x02\x18\x1f\n\r\n\x05\x04+\x02\x01\x03\
    \x12\x04\xb5\x02\"#\n\x0c\n\x02\x04,\x12\x06\xb8\x02\0\xb9\x02\x01\n\x0b\
    \n\x03\x04,\x01\x12\x04\xb8\x02\x08%\n\x0c\n\x02\x04-\x12\x06\xbb\x02\0\
    \xbe\x02\x01\n\x0b\n\x03\x04-\x01\x12\x04\xbb\x02\x08(\n\x0c\n\x04\x04-\
    \x02\0\x12\x04\xbc\x02\x08*\n\r\n\x05\x04-\x02\0\x04\x12\x04\xbc\x02\x08\
    \x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04-\x02\
    \0\x01\x12\x04\xbc\x02\x18%\n\r\n\x05\x04-\x02\0\x03\x12\x04\xbc\x02()\n\
    \x0c\n\x04\x04-\x02\x01\x12\x04\xbd\x02\x08$\n\r\n\x05\x04-\x02\x01\x04\
    \x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xbd\x02\x11\
    \x17\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xbd\x02\x18\x1f\n\r\n\x05\x04-\
    \x02\x01\x03\x12\x04\xbd\x02\"#\n\x0c\n\x02\x04.\x12\x06\xc0\x02\0\xc2\
    \x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\xc0\x02\x08)\n\x0c\n\x04\x04.\x02\
    \0\x12\x04\xc1\x02\x08/\n\r\n\x05\x04.\x02\0\x04\x12\x04\xc1\x02\x08\x10\
    \n\r\n\x05\x04.\x02\0\x06\x12\x04\xc1\x02\x11\"\n\r\n\x05\x04.\x02\0\x01\
    \x12\x04\xc1\x02#*\n\r\n\x05\x04.\x02\0\x03\x12\x04\xc1\x02-.\n\x0c\n\
    \x02\x04/\x12\x06\xc4\x02\0\xc8\x02\x01\n\x0b\n\x03\x04/\x01\x12\x04\xc4\
    \x02\x08,\n\x0c\n\x04\x04/\x02\0\x12\x04\xc5\x02\x08*\n\r\n\x05\x04/\x02\
    \0\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xc5\x02\
    \x11\x17\n\r\n\x05\x04/\x02\0\x01\x12\x04\xc5\x02\x18%\n\r\n\x05\x04/\
    \x02\0\x03\x12\x04\xc5\x02()\n\x0c\n\x04\x04/\x02\x01\x12\x04\xc6\x02\
    \x08$\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xc6\x02\x08\x10\n\r\n\x05\x04/\
    \x02\x01\x05\x12\x04\xc6\x02\x11\x17\n\r\n\x05\x04/\x02\x01\x01\x12\x04\
    \xc6\x02\x18\x1f\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xc6\x02\"#\n\x0c\n\
    \x04\x04/\x02\x02\x12\x04\xc7\x02\x08/\n\r\n\x05\x04/\x02\x02\x04\x12\
    \x04\xc7\x02\x08\x10\n\r\n\x05\x04/\x02\x02\x06\x12\x04\xc7\x02\x11\"\n\
    \r\n\x05\x04/\x02\x02\x01\x12\x04\xc7\x02#*\n\r\n\x05\x04/\x02\x02\x03\
    \x12\x04\xc7\x02-.\n\x0c\n\x02\x040\x12\x06\xca\x02\0\xcb\x02\x01\n\x0b\
    \n\x03\x040\x01\x12\x04\xca\x02\x08-\n\x0c\n\x02\x041\x12\x06\xcd\x02\0\
    \xd1\x02\x01\n\x0b\n\x03\x041\x01\x12\x04\xcd\x02\x08'\n\x0c\n\x04\x041\
    \x02\0\x12\x04\xce\x02\x08*\n\r\n\x05\x041\x02\0\x04\x12\x04\xce\x02\x08\
    \x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xce\x02\x11\x17\n\r\n\x05\x041\x02\
    \0\x01\x12\x04\xce\x02\x18%\n\r\n\x05\x041\x02\0\x03\x12\x04\xce\x02()\n\
    \x0c\n\x04\x041\x02\x01\x12\x04\xcf\x02\x08$\n\r\n\x05\x041\x02\x01\x04\
    \x12\x04\xcf\x02\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\xcf\x02\x11\
    \x17\n\r\n\x05\x041\x02\x01\x01\x12\x04\xcf\x02\x18\x1f\n\r\n\x05\x041\
    \x02\x01\x03\x12\x04\xcf\x02\"#\n\x0c\n\x04\x041\x02\x02\x12\x04\xd0\x02\
    \x08%\n\r\n\x05\x041\x02\x02\x04\x12\x04\xd0\x02\x08\x10\n\r\n\x05\x041\
    \x02\x02\x05\x12\x04\xd0\x02\x11\x18\n\r\n\x05\x041\x02\x02\x01\x12\x04\
    \xd0\x02\x19\x20\n\r\n\x05\x041\x02\x02\x03\x12\x04\xd0\x02#$\n\x0c\n\
    \x02\x042\x12\x06\xd3\x02\0\xd4\x02\x01\n\x0b\n\x03\x042\x01\x12\x04\xd3\
    \x02\x08(\n\x0c\n\x02\x043\x12\x06\xd6\x02\0\xd9\x02\x01\n\x0b\n\x03\x04\
    3\x01\x12\x04\xd6\x02\x08)\n\x0c\n\x04\x043\x02\0\x12\x04\xd7\x02\x08*\n\
    \r\n\x05\x043\x02\0\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x043\x02\0\x05\
    \x12\x04\xd7\x02\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xd7\x02\x18%\n\
    \r\n\x05\x043\x02\0\x03\x12\x04\xd7\x02()\n\x0c\n\x04\x043\x02\x01\x12\
    \x04\xd8\x02\x08%\n\r\n\x05\x043\x02\x01\x04\x12\x04\xd8\x02\x08\x10\n\r\
    \n\x05\x043\x02\x01\x05\x12\x04\xd8\x02\x11\x18\n\r\n\x05\x043\x02\x01\
    \x01\x12\x04\xd8\x02\x19\x20\n\r\n\x05\x043\x02\x01\x03\x12\x04\xd8\x02#\
    $\n\x0c\n\x02\x044\x12\x06\xdb\x02\0\xdd\x02\x01\n\x0b\n\x03\x044\x01\
    \x12\x04\xdb\x02\x08*\n\x0c\n\x04\x044\x02\0\x12\x04\xdc\x02\x08%\n\r\n\
    \x05\x044\x02\0\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\
    \x04\xdc\x02\x11\x17\n\r\n\x05\x044\x02\0\x01\x12\x04\xdc\x02\x18\x20\n\
    \r\n\x05\x044\x02\0\x03\x12\x04\xdc\x02#$\n\x0c\n\x02\x045\x12\x06\xdf\
    \x02\0\xe3\x02\x01\n\x0b\n\x03\x045\x01\x12\x04\xdf\x02\x08,\n\x0c\n\x04\
    \x045\x02\0\x12\x04\xe0\x02\x08*\n\r\n\x05\x045\x02\0\x04\x12\x04\xe0\
    \x02\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\xe0\x02\x11\x17\n\r\n\x05\
    \x045\x02\0\x01\x12\x04\xe0\x02\x18%\n\r\n\x05\x045\x02\0\x03\x12\x04\
    \xe0\x02()\n\x0c\n\x04\x045\x02\x01\x12\x04\xe1\x02\x08$\n\r\n\x05\x045\
    \x02\x01\x04\x12\x04\xe1\x02\x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\
    \xe1\x02\x11\x17\n\r\n\x05\x045\x02\x01\x01\x12\x04\xe1\x02\x18\x1f\n\r\
    \n\x05\x045\x02\x01\x03\x12\x04\xe1\x02\"#\n\x0c\n\x04\x045\x02\x02\x12\
    \x04\xe2\x02\x08%\n\r\n\x05\x045\x02\x02\x04\x12\x04\xe2\x02\x08\x10\n\r\
    \n\x05\x045\x02\x02\x05\x12\x04\xe2\x02\x11\x18\n\r\n\x05\x045\x02\x02\
    \x01\x12\x04\xe2\x02\x19\x20\n\r\n\x05\x045\x02\x02\x03\x12\x04\xe2\x02#\
    $\n\x0c\n\x02\x046\x12\x06\xe5\x02\0\xe6\x02\x01\n\x0b\n\x03\x046\x01\
    \x12\x04\xe5\x02\x08-\n\x0c\n\x02\x047\x12\x06\xe8\x02\0\xec\x02\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xe8\x02\x08+\n\x0c\n\x04\x047\x02\0\x12\x04\
    \xe9\x02\x08*\n\r\n\x05\x047\x02\0\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\
    \x047\x02\0\x05\x12\x04\xe9\x02\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \xe9\x02\x18%\n\r\n\x05\x047\x02\0\x03\x12\x04\xe9\x02()\n\x0c\n\x04\x04\
    7\x02\x01\x12\x04\xea\x02\x08(\n\r\n\x05\x047\x02\x01\x04\x12\x04\xea\
    \x02\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\xea\x02\x11\x17\n\r\n\
    \x05\x047\x02\x01\x01\x12\x04\xea\x02\x18#\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\xea\x02&'\n\x0c\n\x04\x047\x02\x02\x12\x04\xeb\x02\x08$\n\r\n\
    \x05\x047\x02\x02\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x047\x02\x02\x05\
    \x12\x04\xeb\x02\x11\x17\n\r\n\x05\x047\x02\x02\x01\x12\x04\xeb\x02\x18\
    \x1f\n\r\n\x05\x047\x02\x02\x03\x12\x04\xeb\x02\"#\n\x0c\n\x02\x048\x12\
    \x06\xee\x02\0\xf3\x02\x01\n\x0b\n\x03\x048\x01\x12\x04\xee\x02\x08,\n\
    \x0c\n\x04\x048\x02\0\x12\x04\xef\x02\x080\n\r\n\x05\x048\x02\0\x04\x12\
    \x04\xef\x02\x08\x10\n\r\n\x05\x048\x02\0\x06\x12\x04\xef\x02\x11%\n\r\n\
    \x05\x048\x02\0\x01\x12\x04\xef\x02&+\n\r\n\x05\x048\x02\0\x03\x12\x04\
    \xef\x02./\n\x0c\n\x04\x048\x02\x01\x12\x04\xf0\x02\x08>\n\r\n\x05\x048\
    \x02\x01\x04\x12\x04\xf0\x02\x08\x10\n\r\n\x05\x048\x02\x01\x06\x12\x04\
    \xf0\x02\x11)\n\r\n\x05\x048\x02\x01\x01\x12\x04\xf0\x02*9\n\r\n\x05\x04\
    8\x02\x01\x03\x12\x04\xf0\x02<=\n\x0c\n\x04\x048\x02\x02\x12\x04\xf1\x02\
    \x08)\n\r\n\x05\x048\x02\x02\x04\x12\x04\xf1\x02\x08\x10\n\r\n\x05\x048\
    \x02\x02\x05\x12\x04\xf1\x02\x11\x17\n\r\n\x05\x048\x02\x02\x01\x12\x04\
    \xf1\x02\x18$\n\r\n\x05\x048\x02\x02\x03\x12\x04\xf1\x02'(\n\x0c\n\x04\
    \x048\x02\x03\x12\x04\xf2\x02\x08(\n\r\n\x05\x048\x02\x03\x04\x12\x04\
    \xf2\x02\x08\x10\n\r\n\x05\x048\x02\x03\x05\x12\x04\xf2\x02\x11\x17\n\r\
    \n\x05\x048\x02\x03\x01\x12\x04\xf2\x02\x18#\n\r\n\x05\x048\x02\x03\x03\
    \x12\x04\xf2\x02&'\n\x0c\n\x02\x049\x12\x06\xf5\x02\0\xfa\x02\x01\n\x0b\
    \n\x03\x049\x01\x12\x04\xf5\x02\x085\n\x0c\n\x04\x049\x02\0\x12\x04\xf6\
    \x02\x08*\n\r\n\x05\x049\x02\0\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\
    9\x02\0\x05\x12\x04\xf6\x02\x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xf6\
    \x02\x18%\n\r\n\x05\x049\x02\0\x03\x12\x04\xf6\x02()\n\x0c\n\x04\x049\
    \x02\x01\x12\x04\xf7\x02\x08%\n\r\n\x05\x049\x02\x01\x04\x12\x04\xf7\x02\
    \x08\x10\n\r\n\x05\x049\x02\x01\x05\x12\x04\xf7\x02\x11\x18\n\r\n\x05\
    \x049\x02\x01\x01\x12\x04\xf7\x02\x19\x20\n\r\n\x05\x049\x02\x01\x03\x12\
    \x04\xf7\x02#$\n\x0c\n\x04\x049\x02\x02\x12\x04\xf8\x02\x08$\n\r\n\x05\
    \x049\x02\x02\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x049\x02\x02\x05\x12\
    \x04\xf8\x02\x11\x17\n\r\n\x05\x049\x02\x02\x01\x12\x04\xf8\x02\x18\x1f\
    \n\r\n\x05\x049\x02\x02\x03\x12\x04\xf8\x02\"#\n\x0c\n\x04\x049\x02\x03\
    \x12\x04\xf9\x02\x08/\n\r\n\x05\x049\x02\x03\x04\x12\x04\xf9\x02\x08\x10\
    \n\r\n\x05\x049\x02\x03\x05\x12\x04\xf9\x02\x11\x15\n\r\n\x05\x049\x02\
    \x03\x01\x12\x04\xf9\x02\x16*\n\r\n\x05\x049\x02\x03\x03\x12\x04\xf9\x02\
    -.\n\x0c\n\x02\x04:\x12\x06\xfc\x02\0\xfd\x02\x01\n\x0b\n\x03\x04:\x01\
    \x12\x04\xfc\x02\x086\n\x0c\n\x02\x04;\x12\x06\xff\x02\0\x81\x03\x01\n\
    \x0b\n\x03\x04;\x01\x12\x04\xff\x02\x08,\n\x0c\n\x04\x04;\x02\0\x12\x04\
    \x80\x03\x08*\n\r\n\x05\x04;\x02\0\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\
    \x04;\x02\0\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\
    \x80\x03\x18%\n\r\n\x05\x04;\x02\0\x03\x12\x04\x80\x03()\n\x0c\n\x02\x04\
    <\x12\x06\x83\x03\0\x84\x03\x01\n\x0b\n\x03\x04<\x01\x12\x04\x83\x03\x08\
    -\n\x0c\n\x02\x04=\x12\x06\x86\x03\0\x8a\x03\x01\n\x0b\n\x03\x04=\x01\
    \x12\x04\x86\x03\x08(\n\x0c\n\x04\x04=\x02\0\x12\x04\x87\x03\x08*\n\r\n\
    \x05\x04=\x02\0\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\
    \x04\x87\x03\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\x87\x03\x18%\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\x87\x03()\n\x0c\n\x04\x04=\x02\x01\x12\x04\
    \x88\x03\x08!\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x88\x03\x08\x10\n\r\n\
    \x05\x04=\x02\x01\x05\x12\x04\x88\x03\x11\x17\n\r\n\x05\x04=\x02\x01\x01\
    \x12\x04\x88\x03\x18\x1c\n\r\n\x05\x04=\x02\x01\x03\x12\x04\x88\x03\x1f\
    \x20\n\x0c\n\x04\x04=\x02\x02\x12\x04\x89\x03\x08&\n\r\n\x05\x04=\x02\
    \x02\x04\x12\x04\x89\x03\x08\x10\n\r\n\x05\x04=\x02\x02\x05\x12\x04\x89\
    \x03\x11\x15\n\r\n\x05\x04=\x02\x02\x01\x12\x04\x89\x03\x16!\n\r\n\x05\
    \x04=\x02\x02\x03\x12\x04\x89\x03$%\n\x0c\n\x02\x04>\x12\x06\x8c\x03\0\
    \x8e\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\x8c\x03\x08)\n\x0c\n\x04\x04>\
    \x02\0\x12\x04\x8d\x03\x08/\n\r\n\x05\x04>\x02\0\x04\x12\x04\x8d\x03\x08\
    \x10\n\r\n\x05\x04>\x02\0\x06\x12\x04\x8d\x03\x11\x20\n\r\n\x05\x04>\x02\
    \0\x01\x12\x04\x8d\x03!*\n\r\n\x05\x04>\x02\0\x03\x12\x04\x8d\x03-.\n\
    \x0c\n\x02\x04?\x12\x06\x90\x03\0\x93\x03\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\x90\x03\x08(\n\x0c\n\x04\x04?\x02\0\x12\x04\x91\x03\x08*\n\r\n\x05\
    \x04?\x02\0\x04\x12\x04\x91\x03\x08\x10\n\r\n\x05\x04?\x02\0\x05\x12\x04\
    \x91\x03\x11\x17\n\r\n\x05\x04?\x02\0\x01\x12\x04\x91\x03\x18%\n\r\n\x05\
    \x04?\x02\0\x03\x12\x04\x91\x03()\n\x0c\n\x04\x04?\x02\x01\x12\x04\x92\
    \x03\x08$\n\r\n\x05\x04?\x02\x01\x04\x12\x04\x92\x03\x08\x10\n\r\n\x05\
    \x04?\x02\x01\x05\x12\x04\x92\x03\x11\x17\n\r\n\x05\x04?\x02\x01\x01\x12\
    \x04\x92\x03\x18\x1f\n\r\n\x05\x04?\x02\x01\x03\x12\x04\x92\x03\"#\n\x0c\
    \n\x02\x04@\x12\x06\x95\x03\0\x96\x03\x01\n\x0b\n\x03\x04@\x01\x12\x04\
    \x95\x03\x08)\n\x0c\n\x02\x04A\x12\x06\x98\x03\0\x9c\x03\x01\n\x0b\n\x03\
    \x04A\x01\x12\x04\x98\x03\x08(\n\x0c\n\x04\x04A\x02\0\x12\x04\x99\x03\
    \x08*\n\r\n\x05\x04A\x02\0\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04A\
    \x02\0\x05\x12\x04\x99\x03\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\x04\x99\
    \x03\x18%\n\r\n\x05\x04A\x02\0\x03\x12\x04\x99\x03()\n\x0c\n\x04\x04A\
    \x02\x01\x12\x04\x9a\x03\x08$\n\r\n\x05\x04A\x02\x01\x04\x12\x04\x9a\x03\
    \x08\x10\n\r\n\x05\x04A\x02\x01\x05\x12\x04\x9a\x03\x11\x17\n\r\n\x05\
    \x04A\x02\x01\x01\x12\x04\x9a\x03\x18\x1f\n\r\n\x05\x04A\x02\x01\x03\x12\
    \x04\x9a\x03\"#\n\x0c\n\x04\x04A\x02\x02\x12\x04\x9b\x03\x08!\n\r\n\x05\
    \x04A\x02\x02\x04\x12\x04\x9b\x03\x08\x10\n\r\n\x05\x04A\x02\x02\x05\x12\
    \x04\x9b\x03\x11\x17\n\r\n\x05\x04A\x02\x02\x01\x12\x04\x9b\x03\x18\x1c\
    \n\r\n\x05\x04A\x02\x02\x03\x12\x04\x9b\x03\x1f\x20\n\x0c\n\x02\x04B\x12\
    \x06\x9e\x03\0\x9f\x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\x9e\x03\x08)\n\
    \x0c\n\x02\x04C\x12\x06\xa1\x03\0\xa5\x03\x01\n\x0b\n\x03\x04C\x01\x12\
    \x04\xa1\x03\x08)\n\x0c\n\x04\x04C\x02\0\x12\x04\xa2\x03\x08*\n\r\n\x05\
    \x04C\x02\0\x04\x12\x04\xa2\x03\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\
    \xa2\x03\x11\x17\n\r\n\x05\x04C\x02\0\x01\x12\x04\xa2\x03\x18%\n\r\n\x05\
    \x04C\x02\0\x03\x12\x04\xa2\x03()\n\x0c\n\x04\x04C\x02\x01\x12\x04\xa3\
    \x03\x08$\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xa3\x03\x08\x10\n\r\n\x05\
    \x04C\x02\x01\x05\x12\x04\xa3\x03\x11\x17\n\r\n\x05\x04C\x02\x01\x01\x12\
    \x04\xa3\x03\x18\x1f\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xa3\x03\"#\n\x0c\
    \n\x04\x04C\x02\x02\x12\x04\xa4\x03\x08/\n\r\n\x05\x04C\x02\x02\x04\x12\
    \x04\xa4\x03\x08\x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xa4\x03\x11\x17\
    \n\r\n\x05\x04C\x02\x02\x01\x12\x04\xa4\x03\x18*\n\r\n\x05\x04C\x02\x02\
    \x03\x12\x04\xa4\x03-.\n\x0c\n\x02\x04D\x12\x06\xa7\x03\0\xa8\x03\x01\n\
    \x0b\n\x03\x04D\x01\x12\x04\xa7\x03\x08*\n\x0c\n\x02\x04E\x12\x06\xaa\
    \x03\0\xaf\x03\x01\n\x0b\n\x03\x04E\x01\x12\x04\xaa\x03\x08)\n\x0c\n\x04\
    \x04E\x02\0\x12\x04\xab\x03\x08*\n\r\n\x05\x04E\x02\0\x04\x12\x04\xab\
    \x03\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\xab\x03\x11\x17\n\r\n\x05\
    \x04E\x02\0\x01\x12\x04\xab\x03\x18%\n\r\n\x05\x04E\x02\0\x03\x12\x04\
    \xab\x03()\n\x0c\n\x04\x04E\x02\x01\x12\x04\xac\x03\x08$\n\r\n\x05\x04E\
    \x02\x01\x04\x12\x04\xac\x03\x08\x10\n\r\n\x05\x04E\x02\x01\x05\x12\x04\
    \xac\x03\x11\x17\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xac\x03\x18\x1f\n\r\
    \n\x05\x04E\x02\x01\x03\x12\x04\xac\x03\"#\n\x0c\n\x04\x04E\x02\x02\x12\
    \x04\xad\x03\x08$\n\r\n\x05\x04E\x02\x02\x04\x12\x04\xad\x03\x08\x10\n\r\
    \n\x05\x04E\x02\x02\x05\x12\x04\xad\x03\x11\x17\n\r\n\x05\x04E\x02\x02\
    \x01\x12\x04\xad\x03\x18\x1f\n\r\n\x05\x04E\x02\x02\x03\x12\x04\xad\x03\
    \"#\n\x0c\n\x04\x04E\x02\x03\x12\x04\xae\x03\x08)\n\r\n\x05\x04E\x02\x03\
    \x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04E\x02\x03\x05\x12\x04\xae\x03\
    \x11\x15\n\r\n\x05\x04E\x02\x03\x01\x12\x04\xae\x03\x16$\n\r\n\x05\x04E\
    \x02\x03\x03\x12\x04\xae\x03'(\n\x0c\n\x02\x04F\x12\x06\xb1\x03\0\xb6\
    \x03\x01\n\x0b\n\x03\x04F\x01\x12\x04\xb1\x03\x08*\n\x0c\n\x04\x04F\x02\
    \0\x12\x04\xb2\x03\x08-\n\r\n\x05\x04F\x02\0\x04\x12\x04\xb2\x03\x08\x10\
    \n\r\n\x05\x04F\x02\0\x05\x12\x04\xb2\x03\x11\x17\n\r\n\x05\x04F\x02\0\
    \x01\x12\x04\xb2\x03\x18(\n\r\n\x05\x04F\x02\0\x03\x12\x04\xb2\x03+,\n\
    \x0c\n\x04\x04F\x02\x01\x12\x04\xb3\x03\x08-\n\r\n\x05\x04F\x02\x01\x04\
    \x12\x04\xb3\x03\x08\x10\n\r\n\x05\x04F\x02\x01\x05\x12\x04\xb3\x03\x11\
    \x17\n\r\n\x05\x04F\x02\x01\x01\x12\x04\xb3\x03\x18(\n\r\n\x05\x04F\x02\
    \x01\x03\x12\x04\xb3\x03+,\n\x0c\n\x04\x04F\x02\x02\x12\x04\xb4\x03\x08$\
    \n\r\n\x05\x04F\x02\x02\x04\x12\x04\xb4\x03\x08\x10\n\r\n\x05\x04F\x02\
    \x02\x05\x12\x04\xb4\x03\x11\x17\n\r\n\x05\x04F\x02\x02\x01\x12\x04\xb4\
    \x03\x18\x1f\n\r\n\x05\x04F\x02\x02\x03\x12\x04\xb4\x03\"#\n\x0c\n\x04\
    \x04F\x02\x03\x12\x04\xb5\x03\x084\n\r\n\x05\x04F\x02\x03\x04\x12\x04\
    \xb5\x03\x08\x10\n\r\n\x05\x04F\x02\x03\x05\x12\x04\xb5\x03\x11\x17\n\r\
    \n\x05\x04F\x02\x03\x01\x12\x04\xb5\x03\x18/\n\r\n\x05\x04F\x02\x03\x03\
    \x12\x04\xb5\x0323\n\x0c\n\x02\x04G\x12\x06\xb8\x03\0\xbb\x03\x01\n\x0b\
    \n\x03\x04G\x01\x12\x04\xb8\x03\x08'\n\x0c\n\x04\x04G\x02\0\x12\x04\xb9\
    \x03\x08*\n\r\n\x05\x04G\x02\0\x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04\
    G\x02\0\x05\x12\x04\xb9\x03\x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xb9\
    \x03\x18%\n\r\n\x05\x04G\x02\0\x03\x12\x04\xb9\x03()\n\x0c\n\x04\x04G\
    \x02\x01\x12\x04\xba\x03\x08$\n\r\n\x05\x04G\x02\x01\x04\x12\x04\xba\x03\
    \x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\xba\x03\x11\x17\n\r\n\x05\
    \x04G\x02\x01\x01\x12\x04\xba\x03\x18\x1f\n\r\n\x05\x04G\x02\x01\x03\x12\
    \x04\xba\x03\"#\n\x0c\n\x02\x04H\x12\x06\xbd\x03\0\xbf\x03\x01\n\x0b\n\
    \x03\x04H\x01\x12\x04\xbd\x03\x08(\n\x0c\n\x04\x04H\x02\0\x12\x04\xbe\
    \x03\x08)\n\r\n\x05\x04H\x02\0\x04\x12\x04\xbe\x03\x08\x10\n\r\n\x05\x04\
    H\x02\0\x05\x12\x04\xbe\x03\x11\x17\n\r\n\x05\x04H\x02\0\x01\x12\x04\xbe\
    \x03\x18$\n\r\n\x05\x04H\x02\0\x03\x12\x04\xbe\x03'(\n\x0c\n\x02\x04I\
    \x12\x06\xc1\x03\0\xc4\x03\x01\n\x0b\n\x03\x04I\x01\x12\x04\xc1\x03\x08(\
    \n\x0c\n\x04\x04I\x02\0\x12\x04\xc2\x03\x08*\n\r\n\x05\x04I\x02\0\x04\
    \x12\x04\xc2\x03\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xc2\x03\x11\
    \x17\n\r\n\x05\x04I\x02\0\x01\x12\x04\xc2\x03\x18%\n\r\n\x05\x04I\x02\0\
    \x03\x12\x04\xc2\x03()\n\x0c\n\x04\x04I\x02\x01\x12\x04\xc3\x03\x08$\n\r\
    \n\x05\x04I\x02\x01\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04I\x02\x01\
    \x05\x12\x04\xc3\x03\x11\x17\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xc3\x03\
    \x18\x1f\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xc3\x03\"#\n\x0c\n\x02\x04J\
    \x12\x06\xc6\x03\0\xc7\x03\x01\n\x0b\n\x03\x04J\x01\x12\x04\xc6\x03\x08)\
    \n\x0c\n\x02\x04K\x12\x06\xc9\x03\0\xd1\x03\x01\n\x0b\n\x03\x04K\x01\x12\
    \x04\xc9\x03\x08+\n\x0c\n\x04\x04K\x02\0\x12\x04\xca\x03\x08*\n\r\n\x05\
    \x04K\x02\0\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\
    \xca\x03\x11\x17\n\r\n\x05\x04K\x02\0\x01\x12\x04\xca\x03\x18%\n\r\n\x05\
    \x04K\x02\0\x03\x12\x04\xca\x03()\n\x0c\n\x04\x04K\x02\x01\x12\x04\xcb\
    \x03\x08$\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\
    \x04K\x02\x01\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04K\x02\x01\x01\x12\
    \x04\xcb\x03\x18\x1f\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xcb\x03\"#\n\x0c\
    \n\x04\x04K\x02\x02\x12\x04\xcc\x03\x08&\n\r\n\x05\x04K\x02\x02\x04\x12\
    \x04\xcc\x03\x08\x10\n\r\n\x05\x04K\x02\x02\x05\x12\x04\xcc\x03\x11\x17\
    \n\r\n\x05\x04K\x02\x02\x01\x12\x04\xcc\x03\x18!\n\r\n\x05\x04K\x02\x02\
    \x03\x12\x04\xcc\x03$%\n\x0c\n\x04\x04K\x02\x03\x12\x04\xcd\x03\x08)\n\r\
    \n\x05\x04K\x02\x03\x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x04K\x02\x03\
    \x05\x12\x04\xcd\x03\x11\x17\n\r\n\x05\x04K\x02\x03\x01\x12\x04\xcd\x03\
    \x18$\n\r\n\x05\x04K\x02\x03\x03\x12\x04\xcd\x03'(\n\x0c\n\x04\x04K\x02\
    \x04\x12\x04\xce\x03\x08'\n\r\n\x05\x04K\x02\x04\x04\x12\x04\xce\x03\x08\
    \x10\n\r\n\x05\x04K\x02\x04\x05\x12\x04\xce\x03\x11\x17\n\r\n\x05\x04K\
    \x02\x04\x01\x12\x04\xce\x03\x18\"\n\r\n\x05\x04K\x02\x04\x03\x12\x04\
    \xce\x03%&\n\x0c\n\x04\x04K\x02\x05\x12\x04\xcf\x03\x08*\n\r\n\x05\x04K\
    \x02\x05\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04K\x02\x05\x05\x12\x04\
    \xcf\x03\x11\x17\n\r\n\x05\x04K\x02\x05\x01\x12\x04\xcf\x03\x18%\n\r\n\
    \x05\x04K\x02\x05\x03\x12\x04\xcf\x03()\n\x0c\n\x04\x04K\x02\x06\x12\x04\
    \xd0\x03\x08&\n\r\n\x05\x04K\x02\x06\x04\x12\x04\xd0\x03\x08\x10\n\r\n\
    \x05\x04K\x02\x06\x05\x12\x04\xd0\x03\x11\x17\n\r\n\x05\x04K\x02\x06\x01\
    \x12\x04\xd0\x03\x18!\n\r\n\x05\x04K\x02\x06\x03\x12\x04\xd0\x03$%\n\x0c\
    \n\x02\x04L\x12\x06\xd3\x03\0\xd7\x03\x01\n\x0b\n\x03\x04L\x01\x12\x04\
    \xd3\x03\x08\x15\n\x0c\n\x04\x04L\x02\0\x12\x04\xd4\x03\x08^\n\r\n\x05\
    \x04L\x02\0\x04\x12\x04\xd4\x03\x08\x10\n\r\n\x05\x04L\x02\0\x06\x12\x04\
    \xd4\x03\x11(\n\r\n\x05\x04L\x02\0\x01\x12\x04\xd4\x03)0\n\r\n\x05\x04L\
    \x02\0\x03\x12\x04\xd4\x0334\n\r\n\x05\x04L\x02\0\x08\x12\x04\xd4\x035]\
    \n\r\n\x05\x04L\x02\0\x07\x12\x04\xd4\x03@\\\n\x0c\n\x04\x04L\x02\x01\
    \x12\x04\xd5\x03\x08)\n\r\n\x05\x04L\x02\x01\x04\x12\x04\xd5\x03\x08\x10\
    \n\r\n\x05\x04L\x02\x01\x05\x12\x04\xd5\x03\x11\x17\n\r\n\x05\x04L\x02\
    \x01\x01\x12\x04\xd5\x03\x18$\n\r\n\x05\x04L\x02\x01\x03\x12\x04\xd5\x03\
    '(\n\x0c\n\x04\x04L\x02\x02\x12\x04\xd6\x03\x08,\n\r\n\x05\x04L\x02\x02\
    \x04\x12\x04\xd6\x03\x08\x10\n\r\n\x05\x04L\x02\x02\x05\x12\x04\xd6\x03\
    \x11\x17\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xd6\x03\x18'\n\r\n\x05\x04L\
    \x02\x02\x03\x12\x04\xd6\x03*+\n\x0c\n\x02\x04M\x12\x06\xd9\x03\0\xed\
    \x03\x01\n\x0b\n\x03\x04M\x01\x12\x04\xd9\x03\x08,\n\x0e\n\x04\x04M\x03\
    \0\x12\x06\xda\x03\x08\xe9\x03\t\n\r\n\x05\x04M\x03\0\x01\x12\x04\xda\
    \x03\x10\x1b\n\x10\n\x06\x04M\x03\0\x03\0\x12\x06\xdb\x03\x10\xe0\x03\
    \x11\n\x0f\n\x07\x04M\x03\0\x03\0\x01\x12\x04\xdb\x03\x18'\n\x11\n\x08\
    \x04M\x03\0\x03\0\x02\0\x12\x05\xdc\x03\x18\x84\x01\n\x11\n\t\x04M\x03\0\
    \x03\0\x02\0\x04\x12\x04\xdc\x03\x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\
    \0\x06\x12\x04\xdc\x03!>\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x01\x12\x04\
    \xdc\x03?L\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x03\x12\x04\xdc\x03OP\n\x12\
    \n\t\x04M\x03\0\x03\0\x02\0\x08\x12\x05\xdc\x03Q\x83\x01\n\x12\n\t\x04M\
    \x03\0\x03\0\x02\0\x07\x12\x05\xdc\x03\\\x82\x01\n\x10\n\x08\x04M\x03\0\
    \x03\0\x02\x01\x12\x04\xdd\x03\x185\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\
    \x04\x12\x04\xdd\x03\x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x05\x12\
    \x04\xdd\x03!'\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x01\x12\x04\xdd\x03(0\
    \n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x03\x12\x04\xdd\x0334\n\x10\n\x08\
    \x04M\x03\0\x03\0\x02\x02\x12\x04\xde\x03\x189\n\x11\n\t\x04M\x03\0\x03\
    \0\x02\x02\x04\x12\x04\xde\x03\x18\x20\n\x11\n\t\x04M\x03\0\x03\0\x02\
    \x02\x05\x12\x04\xde\x03!'\n\x11\n\t\x04M\x03\0\x03\0\x02\x02\x01\x12\
    \x04\xde\x03(4\n\x11\n\t\x04M\x03\0\x03\0\x02\x02\x03\x12\x04\xde\x0378\
    \n\x10\n\x08\x04M\x03\0\x03\0\x02\x03\x12\x04\xdf\x03\x18;\n\x11\n\t\x04\
    M\x03\0\x03\0\x02\x03\x04\x12\x04\xdf\x03\x18\x20\n\x11\n\t\x04M\x03\0\
    \x03\0\x02\x03\x05\x12\x04\xdf\x03!%\n\x11\n\t\x04M\x03\0\x03\0\x02\x03\
    \x01\x12\x04\xdf\x03&6\n\x11\n\t\x04M\x03\0\x03\0\x02\x03\x03\x12\x04\
    \xdf\x039:\n\x0e\n\x06\x04M\x03\0\x02\0\x12\x04\xe2\x03\x10+\n\x0f\n\x07\
    \x04M\x03\0\x02\0\x04\x12\x04\xe2\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\
    \0\x05\x12\x04\xe2\x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\0\x01\x12\x04\
    \xe2\x03\x20&\n\x0f\n\x07\x04M\x03\0\x02\0\x03\x12\x04\xe2\x03)*\n\x0e\n\
    \x06\x04M\x03\0\x02\x01\x12\x04\xe3\x03\x105\n\x0f\n\x07\x04M\x03\0\x02\
    \x01\x04\x12\x04\xe3\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x01\x05\x12\
    \x04\xe3\x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\x01\x01\x12\x04\xe3\x03\
    \x200\n\x0f\n\x07\x04M\x03\0\x02\x01\x03\x12\x04\xe3\x0334\n\x0e\n\x06\
    \x04M\x03\0\x02\x02\x12\x04\xe4\x03\x10,\n\x0f\n\x07\x04M\x03\0\x02\x02\
    \x04\x12\x04\xe4\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x02\x05\x12\x04\
    \xe4\x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\x02\x01\x12\x04\xe4\x03\x20'\
    \n\x0f\n\x07\x04M\x03\0\x02\x02\x03\x12\x04\xe4\x03*+\n\x0e\n\x06\x04M\
    \x03\0\x02\x03\x12\x04\xe5\x03\x10,\n\x0f\n\x07\x04M\x03\0\x02\x03\x04\
    \x12\x04\xe5\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x03\x05\x12\x04\xe5\
    \x03\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\x03\x01\x12\x04\xe5\x03\x20'\n\
    \x0f\n\x07\x04M\x03\0\x02\x03\x03\x12\x04\xe5\x03*+\n\x0e\n\x06\x04M\x03\
    \0\x02\x04\x12\x04\xe6\x03\x10;\n\x0f\n\x07\x04M\x03\0\x02\x04\x04\x12\
    \x04\xe6\x03\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x04\x06\x12\x04\xe6\x03\
    \x19'\n\x0f\n\x07\x04M\x03\0\x02\x04\x01\x12\x04\xe6\x03(6\n\x0f\n\x07\
    \x04M\x03\0\x02\x04\x03\x12\x04\xe6\x039:\n\x0e\n\x06\x04M\x03\0\x02\x05\
    \x12\x04\xe7\x03\x10*\n\x0f\n\x07\x04M\x03\0\x02\x05\x04\x12\x04\xe7\x03\
    \x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x05\x05\x12\x04\xe7\x03\x19\x1d\n\
    \x0f\n\x07\x04M\x03\0\x02\x05\x01\x12\x04\xe7\x03\x1e%\n\x0f\n\x07\x04M\
    \x03\0\x02\x05\x03\x12\x04\xe7\x03()\n\x0e\n\x06\x04M\x03\0\x02\x06\x12\
    \x04\xe8\x03\x10i\n\x0f\n\x07\x04M\x03\0\x02\x06\x04\x12\x04\xe8\x03\x10\
    \x18\n\x0f\n\x07\x04M\x03\0\x02\x06\x06\x12\x04\xe8\x03\x19Z\n\x0f\n\x07\
    \x04M\x03\0\x02\x06\x01\x12\x04\xe8\x03[d\n\x0f\n\x07\x04M\x03\0\x02\x06\
    \x03\x12\x04\xe8\x03gh\n\x0c\n\x04\x04M\x02\0\x12\x04\xeb\x03\x08P\n\r\n\
    \x05\x04M\x02\0\x04\x12\x04\xeb\x03\x08\x10\n\r\n\x05\x04M\x02\0\x06\x12\
    \x04\xeb\x03\x11B\n\r\n\x05\x04M\x02\0\x01\x12\x04\xeb\x03CK\n\r\n\x05\
    \x04M\x02\0\x03\x12\x04\xeb\x03NO\n\x0c\n\x04\x04M\x02\x01\x12\x04\xec\
    \x03\x08)\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xec\x03\x08\x10\n\r\n\x05\
    \x04M\x02\x01\x05\x12\x04\xec\x03\x11\x15\n\r\n\x05\x04M\x02\x01\x01\x12\
    \x04\xec\x03\x16$\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xec\x03'(\n\x0c\n\
    \x02\x04N\x12\x06\xef\x03\0\xf0\x03\x01\n\x0b\n\x03\x04N\x01\x12\x04\xef\
    \x03\x08-\n\x0c\n\x02\x04O\x12\x06\xf2\x03\0\x88\x04\x01\n\x0b\n\x03\x04\
    O\x01\x12\x04\xf2\x03\x082\n\x0c\n\x04\x04O\x02\0\x12\x04\xf3\x03\x08*\n\
    \r\n\x05\x04O\x02\0\x04\x12\x04\xf3\x03\x08\x10\n\r\n\x05\x04O\x02\0\x05\
    \x12\x04\xf3\x03\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\xf3\x03\x18%\n\
    \r\n\x05\x04O\x02\0\x03\x12\x04\xf3\x03()\n\x0c\n\x04\x04O\x02\x01\x12\
    \x04\xf4\x03\x08,\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xf4\x03\x08\x10\n\r\
    \n\x05\x04O\x02\x01\x05\x12\x04\xf4\x03\x11\x17\n\r\n\x05\x04O\x02\x01\
    \x01\x12\x04\xf4\x03\x18'\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xf4\x03*+\n\
    \x0c\n\x04\x04O\x02\x02\x12\x04\xf5\x03\x080\n\r\n\x05\x04O\x02\x02\x04\
    \x12\x04\xf5\x03\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xf5\x03\x11\
    \x17\n\r\n\x05\x04O\x02\x02\x01\x12\x04\xf5\x03\x18+\n\r\n\x05\x04O\x02\
    \x02\x03\x12\x04\xf5\x03./\n\x0c\n\x04\x04O\x02\x03\x12\x04\xf6\x03\x086\
    \n\r\n\x05\x04O\x02\x03\x04\x12\x04\xf6\x03\x08\x10\n\r\n\x05\x04O\x02\
    \x03\x05\x12\x04\xf6\x03\x11\x17\n\r\n\x05\x04O\x02\x03\x01\x12\x04\xf6\
    \x03\x181\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xf6\x0345\n\x0c\n\x04\x04O\
    \x02\x04\x12\x04\xf7\x03\x08,\n\r\n\x05\x04O\x02\x04\x04\x12\x04\xf7\x03\
    \x08\x10\n\r\n\x05\x04O\x02\x04\x05\x12\x04\xf7\x03\x11\x17\n\r\n\x05\
    \x04O\x02\x04\x01\x12\x04\xf7\x03\x18'\n\r\n\x05\x04O\x02\x04\x03\x12\
    \x04\xf7\x03*+\n\x0c\n\x04\x04O\x02\x05\x12\x04\xf8\x03\x080\n\r\n\x05\
    \x04O\x02\x05\x04\x12\x04\xf8\x03\x08\x10\n\r\n\x05\x04O\x02\x05\x06\x12\
    \x04\xf8\x03\x11\x20\n\r\n\x05\x04O\x02\x05\x01\x12\x04\xf8\x03!+\n\r\n\
    \x05\x04O\x02\x05\x03\x12\x04\xf8\x03./\n\x0c\n\x04\x04O\x02\x06\x12\x04\
    \xf9\x03\x08#\n\r\n\x05\x04O\x02\x06\x04\x12\x04\xf9\x03\x08\x10\n\r\n\
    \x05\x04O\x02\x06\x05\x12\x04\xf9\x03\x11\x17\n\r\n\x05\x04O\x02\x06\x01\
    \x12\x04\xf9\x03\x18\x1e\n\r\n\x05\x04O\x02\x06\x03\x12\x04\xf9\x03!\"\n\
    \x0c\n\x04\x04O\x02\x07\x12\x04\xfa\x03\x08/\n\r\n\x05\x04O\x02\x07\x04\
    \x12\x04\xfa\x03\x08\x10\n\r\n\x05\x04O\x02\x07\x05\x12\x04\xfa\x03\x11\
    \x17\n\r\n\x05\x04O\x02\x07\x01\x12\x04\xfa\x03\x18*\n\r\n\x05\x04O\x02\
    \x07\x03\x12\x04\xfa\x03-.\n\x0c\n\x04\x04O\x02\x08\x12\x04\xfb\x03\x08,\
    \n\r\n\x05\x04O\x02\x08\x04\x12\x04\xfb\x03\x08\x10\n\r\n\x05\x04O\x02\
    \x08\x05\x12\x04\xfb\x03\x11\x17\n\r\n\x05\x04O\x02\x08\x01\x12\x04\xfb\
    \x03\x18'\n\r\n\x05\x04O\x02\x08\x03\x12\x04\xfb\x03*+\n\x0c\n\x04\x04O\
    \x02\t\x12\x04\xfc\x03\x08)\n\r\n\x05\x04O\x02\t\x04\x12\x04\xfc\x03\x08\
    \x10\n\r\n\x05\x04O\x02\t\x05\x12\x04\xfc\x03\x11\x17\n\r\n\x05\x04O\x02\
    \t\x01\x12\x04\xfc\x03\x18#\n\r\n\x05\x04O\x02\t\x03\x12\x04\xfc\x03&(\n\
    \x0c\n\x04\x04O\x02\n\x12\x04\xfd\x03\x082\n\r\n\x05\x04O\x02\n\x04\x12\
    \x04\xfd\x03\x08\x10\n\r\n\x05\x04O\x02\n\x05\x12\x04\xfd\x03\x11\x16\n\
    \r\n\x05\x04O\x02\n\x01\x12\x04\xfd\x03\x17,\n\r\n\x05\x04O\x02\n\x03\
    \x12\x04\xfd\x03/1\n\x0c\n\x04\x04O\x02\x0b\x12\x04\xfe\x03\x08X\n\r\n\
    \x05\x04O\x02\x0b\x04\x12\x04\xfe\x03\x08\x10\n\r\n\x05\x04O\x02\x0b\x06\
    \x12\x04\xfe\x03\x11$\n\r\n\x05\x04O\x02\x0b\x01\x12\x04\xfe\x03%)\n\r\n\
    \x05\x04O\x02\x0b\x03\x12\x04\xfe\x03,.\n\r\n\x05\x04O\x02\x0b\x08\x12\
    \x04\xfe\x03/W\n\r\n\x05\x04O\x02\x0b\x07\x12\x04\xfe\x03:V\n\x0c\n\x04\
    \x04O\x02\x0c\x12\x04\xff\x03\x08-\n\r\n\x05\x04O\x02\x0c\x04\x12\x04\
    \xff\x03\x08\x10\n\r\n\x05\x04O\x02\x0c\x05\x12\x04\xff\x03\x11\x17\n\r\
    \n\x05\x04O\x02\x0c\x01\x12\x04\xff\x03\x18'\n\r\n\x05\x04O\x02\x0c\x03\
    \x12\x04\xff\x03*,\n\x0c\n\x04\x04O\x02\r\x12\x04\x80\x04\x08&\n\r\n\x05\
    \x04O\x02\r\x04\x12\x04\x80\x04\x08\x10\n\r\n\x05\x04O\x02\r\x05\x12\x04\
    \x80\x04\x11\x17\n\r\n\x05\x04O\x02\r\x01\x12\x04\x80\x04\x18\x20\n\r\n\
    \x05\x04O\x02\r\x03\x12\x04\x80\x04#%\n\x0c\n\x04\x04O\x02\x0e\x12\x04\
    \x81\x04\x085\n\r\n\x05\x04O\x02\x0e\x04\x12\x04\x81\x04\x08\x10\n\r\n\
    \x05\x04O\x02\x0e\x06\x12\x04\x81\x04\x11\"\n\r\n\x05\x04O\x02\x0e\x01\
    \x12\x04\x81\x04#/\n\r\n\x05\x04O\x02\x0e\x03\x12\x04\x81\x0424\n\x0c\n\
    \x04\x04O\x02\x0f\x12\x04\x82\x04\x08:\n\r\n\x05\x04O\x02\x0f\x04\x12\
    \x04\x82\x04\x08\x10\n\r\n\x05\x04O\x02\x0f\x05\x12\x04\x82\x04\x11\x17\
    \n\r\n\x05\x04O\x02\x0f\x01\x12\x04\x82\x04\x184\n\r\n\x05\x04O\x02\x0f\
    \x03\x12\x04\x82\x0479\n\x0c\n\x04\x04O\x02\x10\x12\x04\x83\x04\x08#\n\r\
    \n\x05\x04O\x02\x10\x04\x12\x04\x83\x04\x08\x10\n\r\n\x05\x04O\x02\x10\
    \x05\x12\x04\x83\x04\x11\x17\n\r\n\x05\x04O\x02\x10\x01\x12\x04\x83\x04\
    \x18\x1d\n\r\n\x05\x04O\x02\x10\x03\x12\x04\x83\x04\x20\"\n\x0c\n\x04\
    \x04O\x02\x11\x12\x04\x84\x04\x086\n\r\n\x05\x04O\x02\x11\x04\x12\x04\
    \x84\x04\x08\x10\n\r\n\x05\x04O\x02\x11\x06\x12\x04\x84\x04\x11\"\n\r\n\
    \x05\x04O\x02\x11\x01\x12\x04\x84\x04#0\n\r\n\x05\x04O\x02\x11\x03\x12\
    \x04\x84\x0435\n\x0c\n\x04\x04O\x02\x12\x12\x04\x85\x04\x08;\n\r\n\x05\
    \x04O\x02\x12\x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04O\x02\x12\x05\x12\
    \x04\x85\x04\x11\x17\n\r\n\x05\x04O\x02\x12\x01\x12\x04\x85\x04\x185\n\r\
    \n\x05\x04O\x02\x12\x03\x12\x04\x85\x048:\n\x0c\n\x04\x04O\x02\x13\x12\
    \x04\x86\x04\x080\n\r\n\x05\x04O\x02\x13\x04\x12\x04\x86\x04\x08\x10\n\r\
    \n\x05\x04O\x02\x13\x05\x12\x04\x86\x04\x11\x17\n\r\n\x05\x04O\x02\x13\
    \x01\x12\x04\x86\x04\x18*\n\r\n\x05\x04O\x02\x13\x03\x12\x04\x86\x04-/\n\
    \x0c\n\x04\x04O\x02\x14\x12\x04\x87\x04\x08,\n\r\n\x05\x04O\x02\x14\x04\
    \x12\x04\x87\x04\x08\x10\n\r\n\x05\x04O\x02\x14\x05\x12\x04\x87\x04\x11\
    \x17\n\r\n\x05\x04O\x02\x14\x01\x12\x04\x87\x04\x18&\n\r\n\x05\x04O\x02\
    \x14\x03\x12\x04\x87\x04)+\n\x0c\n\x02\x04P\x12\x06\x8a\x04\0\x8d\x04\
    \x01\n\x0b\n\x03\x04P\x01\x12\x04\x8a\x04\x08\x1c\n\x0c\n\x04\x04P\x02\0\
    \x12\x04\x8b\x04\x08D\n\r\n\x05\x04P\x02\0\x04\x12\x04\x8b\x04\x08\x10\n\
    \r\n\x05\x04P\x02\0\x06\x12\x04\x8b\x04\x11)\n\r\n\x05\x04P\x02\0\x01\
    \x12\x04\x8b\x04*?\n\r\n\x05\x04P\x02\0\x03\x12\x04\x8b\x04BC\n\x0c\n\
    \x04\x04P\x02\x01\x12\x04\x8c\x04\x08O\n\r\n\x05\x04P\x02\x01\x04\x12\
    \x04\x8c\x04\x08\x10\n\r\n\x05\x04P\x02\x01\x06\x12\x04\x8c\x04\x11<\n\r\
    \n\x05\x04P\x02\x01\x01\x12\x04\x8c\x04=J\n\r\n\x05\x04P\x02\x01\x03\x12\
    \x04\x8c\x04MN\n\x0c\n\x02\x04Q\x12\x06\x8f\x04\0\x91\x04\x01\n\x0b\n\
    \x03\x04Q\x01\x12\x04\x8f\x04\x08.\n\x0c\n\x04\x04Q\x02\0\x12\x04\x90\
    \x04\x08<\n\r\n\x05\x04Q\x02\0\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\x04\
    Q\x02\0\x06\x12\x04\x90\x04\x11&\n\r\n\x05\x04Q\x02\0\x01\x12\x04\x90\
    \x04'7\n\r\n\x05\x04Q\x02\0\x03\x12\x04\x90\x04:;\n\x0c\n\x02\x04R\x12\
    \x06\x93\x04\0\x95\x04\x01\n\x0b\n\x03\x04R\x01\x12\x04\x93\x04\x08/\n\
    \x0c\n\x04\x04R\x02\0\x12\x04\x94\x04\x08*\n\r\n\x05\x04R\x02\0\x04\x12\
    \x04\x94\x04\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\x94\x04\x11\x17\n\
    \r\n\x05\x04R\x02\0\x01\x12\x04\x94\x04\x18%\n\r\n\x05\x04R\x02\0\x03\
    \x12\x04\x94\x04()\n\x0c\n\x02\x04S\x12\x06\x97\x04\0\x99\x04\x01\n\x0b\
    \n\x03\x04S\x01\x12\x04\x97\x04\x080\n\x0c\n\x04\x04S\x02\0\x12\x04\x98\
    \x04\x080\n\r\n\x05\x04S\x02\0\x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\x04\
    S\x02\0\x06\x12\x04\x98\x04\x11%\n\r\n\x05\x04S\x02\0\x01\x12\x04\x98\
    \x04&+\n\r\n\x05\x04S\x02\0\x03\x12\x04\x98\x04./\n\x0c\n\x02\x04T\x12\
    \x06\x9b\x04\0\x9d\x04\x01\n\x0b\n\x03\x04T\x01\x12\x04\x9b\x04\x081\n\
    \x0c\n\x04\x04T\x02\0\x12\x04\x9c\x04\x08*\n\r\n\x05\x04T\x02\0\x04\x12\
    \x04\x9c\x04\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\x9c\x04\x11\x17\n\
    \r\n\x05\x04T\x02\0\x01\x12\x04\x9c\x04\x18%\n\r\n\x05\x04T\x02\0\x03\
    \x12\x04\x9c\x04()\n\x0c\n\x02\x04U\x12\x06\x9f\x04\0\xa2\x04\x01\n\x0b\
    \n\x03\x04U\x01\x12\x04\x9f\x04\x088\n\x0c\n\x04\x04U\x02\0\x12\x04\xa0\
    \x04\x08*\n\r\n\x05\x04U\x02\0\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04\
    U\x02\0\x05\x12\x04\xa0\x04\x11\x17\n\r\n\x05\x04U\x02\0\x01\x12\x04\xa0\
    \x04\x18%\n\r\n\x05\x04U\x02\0\x03\x12\x04\xa0\x04()\n\x0c\n\x04\x04U\
    \x02\x01\x12\x04\xa1\x04\x08.\n\r\n\x05\x04U\x02\x01\x04\x12\x04\xa1\x04\
    \x08\x10\n\r\n\x05\x04U\x02\x01\x05\x12\x04\xa1\x04\x11\x17\n\r\n\x05\
    \x04U\x02\x01\x01\x12\x04\xa1\x04\x18)\n\r\n\x05\x04U\x02\x01\x03\x12\
    \x04\xa1\x04,-\n\x0c\n\x02\x04V\x12\x06\xa4\x04\0\xa7\x04\x01\n\x0b\n\
    \x03\x04V\x01\x12\x04\xa4\x04\x089\n\x0c\n\x04\x04V\x02\0\x12\x04\xa5\
    \x04\x08#\n\r\n\x05\x04V\x02\0\x04\x12\x04\xa5\x04\x08\x10\n\r\n\x05\x04\
    V\x02\0\x05\x12\x04\xa5\x04\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\x04\xa5\
    \x04\x18\x1e\n\r\n\x05\x04V\x02\0\x03\x12\x04\xa5\x04!\"\n\x0c\n\x04\x04\
    V\x02\x01\x12\x04\xa6\x04\x080\n\r\n\x05\x04V\x02\x01\x04\x12\x04\xa6\
    \x04\x08\x10\n\r\n\x05\x04V\x02\x01\x05\x12\x04\xa6\x04\x11\x17\n\r\n\
    \x05\x04V\x02\x01\x01\x12\x04\xa6\x04\x18+\n\r\n\x05\x04V\x02\x01\x03\
    \x12\x04\xa6\x04./\n\x0c\n\x02\x04W\x12\x06\xa9\x04\0\xac\x04\x01\n\x0b\
    \n\x03\x04W\x01\x12\x04\xa9\x04\x08A\n\x0c\n\x04\x04W\x02\0\x12\x04\xaa\
    \x04\x08*\n\r\n\x05\x04W\x02\0\x04\x12\x04\xaa\x04\x08\x10\n\r\n\x05\x04\
    W\x02\0\x05\x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04W\x02\0\x01\x12\x04\xaa\
    \x04\x18%\n\r\n\x05\x04W\x02\0\x03\x12\x04\xaa\x04()\n\x0c\n\x04\x04W\
    \x02\x01\x12\x04\xab\x04\x08.\n\r\n\x05\x04W\x02\x01\x04\x12\x04\xab\x04\
    \x08\x10\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xab\x04\x11\x17\n\r\n\x05\
    \x04W\x02\x01\x01\x12\x04\xab\x04\x18)\n\r\n\x05\x04W\x02\x01\x03\x12\
    \x04\xab\x04,-\n\x0c\n\x02\x04X\x12\x06\xae\x04\0\xb2\x04\x01\n\x0b\n\
    \x03\x04X\x01\x12\x04\xae\x04\x08-\n\x0c\n\x04\x04X\x02\0\x12\x04\xaf\
    \x04\x08*\n\r\n\x05\x04X\x02\0\x04\x12\x04\xaf\x04\x08\x10\n\r\n\x05\x04\
    X\x02\0\x05\x12\x04\xaf\x04\x11\x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\xaf\
    \x04\x18%\n\r\n\x05\x04X\x02\0\x03\x12\x04\xaf\x04()\n\x0c\n\x04\x04X\
    \x02\x01\x12\x04\xb0\x04\x08$\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xb0\x04\
    \x08\x10\n\r\n\x05\x04X\x02\x01\x05\x12\x04\xb0\x04\x11\x17\n\r\n\x05\
    \x04X\x02\x01\x01\x12\x04\xb0\x04\x18\x1f\n\r\n\x05\x04X\x02\x01\x03\x12\
    \x04\xb0\x04\"#\n\x0c\n\x04\x04X\x02\x02\x12\x04\xb1\x04\x08&\n\r\n\x05\
    \x04X\x02\x02\x04\x12\x04\xb1\x04\x08\x10\n\r\n\x05\x04X\x02\x02\x05\x12\
    \x04\xb1\x04\x11\x17\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xb1\x04\x18!\n\r\
    \n\x05\x04X\x02\x02\x03\x12\x04\xb1\x04$%\n\x0c\n\x02\x04Y\x12\x06\xb4\
    \x04\0\xb8\x04\x01\n\x0b\n\x03\x04Y\x01\x12\x04\xb4\x04\x08*\n\x0c\n\x04\
    \x04Y\x02\0\x12\x04\xb5\x04\x08*\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xb5\
    \x04\x08\x10\n\r\n\x05\x04Y\x02\0\x05\x12\x04\xb5\x04\x11\x17\n\r\n\x05\
    \x04Y\x02\0\x01\x12\x04\xb5\x04\x18%\n\r\n\x05\x04Y\x02\0\x03\x12\x04\
    \xb5\x04()\n\x0c\n\x04\x04Y\x02\x01\x12\x04\xb6\x04\x08*\n\r\n\x05\x04Y\
    \x02\x01\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\
    \xb6\x04\x11\x17\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\xb6\x04\x18%\n\r\n\
    \x05\x04Y\x02\x01\x03\x12\x04\xb6\x04()\n\x0c\n\x04\x04Y\x02\x02\x12\x04\
    \xb7\x04\x08$\n\r\n\x05\x04Y\x02\x02\x04\x12\x04\xb7\x04\x08\x10\n\r\n\
    \x05\x04Y\x02\x02\x05\x12\x04\xb7\x04\x11\x17\n\r\n\x05\x04Y\x02\x02\x01\
    \x12\x04\xb7\x04\x18\x1f\n\r\n\x05\x04Y\x02\x02\x03\x12\x04\xb7\x04\"#\n\
    \x0c\n\x02\x04Z\x12\x06\xba\x04\0\xbd\x04\x01\n\x0b\n\x03\x04Z\x01\x12\
    \x04\xba\x04\x08+\n\x0c\n\x04\x04Z\x02\0\x12\x04\xbb\x04\x08(\n\r\n\x05\
    \x04Z\x02\0\x04\x12\x04\xbb\x04\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\
    \xbb\x04\x11\x17\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xbb\x04\x18#\n\r\n\x05\
    \x04Z\x02\0\x03\x12\x04\xbb\x04&'\n\x0c\n\x04\x04Z\x02\x01\x12\x04\xbc\
    \x04\x08*\n\r\n\x05\x04Z\x02\x01\x04\x12\x04\xbc\x04\x08\x10\n\r\n\x05\
    \x04Z\x02\x01\x05\x12\x04\xbc\x04\x11\x17\n\r\n\x05\x04Z\x02\x01\x01\x12\
    \x04\xbc\x04\x18%\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xbc\x04()\n\x0c\n\
    \x02\x04[\x12\x06\xbf\x04\0\xc1\x04\x01\n\x0b\n\x03\x04[\x01\x12\x04\xbf\
    \x04\x08+\n\x0c\n\x04\x04[\x02\0\x12\x04\xc0\x04\x08(\n\r\n\x05\x04[\x02\
    \0\x04\x12\x04\xc0\x04\x08\x10\n\r\n\x05\x04[\x02\0\x05\x12\x04\xc0\x04\
    \x11\x17\n\r\n\x05\x04[\x02\0\x01\x12\x04\xc0\x04\x18#\n\r\n\x05\x04[\
    \x02\0\x03\x12\x04\xc0\x04&'\n\x0c\n\x02\x04\\\x12\x06\xc3\x04\0\xcb\x04\
    \x01\n\x0b\n\x03\x04\\\x01\x12\x04\xc3\x04\x08,\n\x0c\n\x04\x04\\\x02\0\
    \x12\x04\xc4\x04\x08,\n\r\n\x05\x04\\\x02\0\x04\x12\x04\xc4\x04\x08\x10\
    \n\r\n\x05\x04\\\x02\0\x05\x12\x04\xc4\x04\x11\x18\n\r\n\x05\x04\\\x02\0\
    \x01\x12\x04\xc4\x04\x19'\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xc4\x04*+\n\
    \x0c\n\x04\x04\\\x02\x01\x12\x04\xc5\x04\x08)\n\r\n\x05\x04\\\x02\x01\
    \x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\x04\\\x02\x01\x05\x12\x04\xc5\x04\
    \x11\x17\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\xc5\x04\x18$\n\r\n\x05\x04\
    \\\x02\x01\x03\x12\x04\xc5\x04'(\n\x0c\n\x04\x04\\\x02\x02\x12\x04\xc6\
    \x04\x08$\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\xc6\x04\x08\x10\n\r\n\x05\
    \x04\\\x02\x02\x05\x12\x04\xc6\x04\x11\x17\n\r\n\x05\x04\\\x02\x02\x01\
    \x12\x04\xc6\x04\x18\x1f\n\r\n\x05\x04\\\x02\x02\x03\x12\x04\xc6\x04\"#\
    \n\x0c\n\x04\x04\\\x02\x03\x12\x04\xc7\x04\x08O\n\r\n\x05\x04\\\x02\x03\
    \x04\x12\x04\xc7\x04\x08\x10\n\r\n\x05\x04\\\x02\x03\x06\x12\x04\xc7\x04\
    \x11<\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\xc7\x04=J\n\r\n\x05\x04\\\x02\
    \x03\x03\x12\x04\xc7\x04MN\n\x0c\n\x04\x04\\\x02\x04\x12\x04\xc8\x04\x08\
    D\n\r\n\x05\x04\\\x02\x04\x04\x12\x04\xc8\x04\x08\x10\n\r\n\x05\x04\\\
    \x02\x04\x06\x12\x04\xc8\x04\x11)\n\r\n\x05\x04\\\x02\x04\x01\x12\x04\
    \xc8\x04*?\n\r\n\x05\x04\\\x02\x04\x03\x12\x04\xc8\x04BC\n\x0c\n\x04\x04\
    \\\x02\x05\x12\x04\xc9\x04\x08.\n\r\n\x05\x04\\\x02\x05\x04\x12\x04\xc9\
    \x04\x08\x10\n\r\n\x05\x04\\\x02\x05\x05\x12\x04\xc9\x04\x11\x17\n\r\n\
    \x05\x04\\\x02\x05\x01\x12\x04\xc9\x04\x18(\n\r\n\x05\x04\\\x02\x05\x03\
    \x12\x04\xc9\x04+-\n\x0c\n\x04\x04\\\x02\x06\x12\x04\xca\x04\x08\"\n\r\n\
    \x05\x04\\\x02\x06\x04\x12\x04\xca\x04\x08\x10\n\r\n\x05\x04\\\x02\x06\
    \x05\x12\x04\xca\x04\x11\x15\n\r\n\x05\x04\\\x02\x06\x01\x12\x04\xca\x04\
    \x16\x1c\n\r\n\x05\x04\\\x02\x06\x03\x12\x04\xca\x04\x1f!\n\x0c\n\x02\
    \x04]\x12\x06\xcd\x04\0\xd2\x04\x01\n\x0b\n\x03\x04]\x01\x12\x04\xcd\x04\
    \x08'\n\x0c\n\x04\x04]\x02\0\x12\x04\xce\x04\x08-\n\r\n\x05\x04]\x02\0\
    \x04\x12\x04\xce\x04\x08\x10\n\r\n\x05\x04]\x02\0\x05\x12\x04\xce\x04\
    \x11\x18\n\r\n\x05\x04]\x02\0\x01\x12\x04\xce\x04\x19(\n\r\n\x05\x04]\
    \x02\0\x03\x12\x04\xce\x04+,\n\x0c\n\x04\x04]\x02\x01\x12\x04\xcf\x04\
    \x08*\n\r\n\x05\x04]\x02\x01\x04\x12\x04\xcf\x04\x08\x10\n\r\n\x05\x04]\
    \x02\x01\x05\x12\x04\xcf\x04\x11\x17\n\r\n\x05\x04]\x02\x01\x01\x12\x04\
    \xcf\x04\x18%\n\r\n\x05\x04]\x02\x01\x03\x12\x04\xcf\x04()\n\x0c\n\x04\
    \x04]\x02\x02\x12\x04\xd0\x04\x08$\n\r\n\x05\x04]\x02\x02\x04\x12\x04\
    \xd0\x04\x08\x10\n\r\n\x05\x04]\x02\x02\x05\x12\x04\xd0\x04\x11\x17\n\r\
    \n\x05\x04]\x02\x02\x01\x12\x04\xd0\x04\x18\x1f\n\r\n\x05\x04]\x02\x02\
    \x03\x12\x04\xd0\x04\"#\n\x0c\n\x04\x04]\x02\x03\x12\x04\xd1\x04\x08(\n\
    \r\n\x05\x04]\x02\x03\x04\x12\x04\xd1\x04\x08\x10\n\r\n\x05\x04]\x02\x03\
    \x05\x12\x04\xd1\x04\x11\x17\n\r\n\x05\x04]\x02\x03\x01\x12\x04\xd1\x04\
    \x18#\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xd1\x04&'\n\x0c\n\x02\x04^\x12\
    \x06\xd4\x04\0\xd8\x04\x01\n\x0b\n\x03\x04^\x01\x12\x04\xd4\x04\x08(\n\
    \x0c\n\x04\x04^\x02\0\x12\x04\xd5\x04\x08O\n\r\n\x05\x04^\x02\0\x04\x12\
    \x04\xd5\x04\x08\x10\n\r\n\x05\x04^\x02\0\x06\x12\x04\xd5\x04\x11<\n\r\n\
    \x05\x04^\x02\0\x01\x12\x04\xd5\x04=J\n\r\n\x05\x04^\x02\0\x03\x12\x04\
    \xd5\x04MN\n\x0c\n\x04\x04^\x02\x01\x12\x04\xd6\x04\x08-\n\r\n\x05\x04^\
    \x02\x01\x04\x12\x04\xd6\x04\x08\x10\n\r\n\x05\x04^\x02\x01\x05\x12\x04\
    \xd6\x04\x11\x17\n\r\n\x05\x04^\x02\x01\x01\x12\x04\xd6\x04\x18(\n\r\n\
    \x05\x04^\x02\x01\x03\x12\x04\xd6\x04+,\n\x0c\n\x04\x04^\x02\x02\x12\x04\
    \xd7\x04\x08!\n\r\n\x05\x04^\x02\x02\x04\x12\x04\xd7\x04\x08\x10\n\r\n\
    \x05\x04^\x02\x02\x05\x12\x04\xd7\x04\x11\x15\n\r\n\x05\x04^\x02\x02\x01\
    \x12\x04\xd7\x04\x16\x1c\n\r\n\x05\x04^\x02\x02\x03\x12\x04\xd7\x04\x1f\
    \x20\n\x0c\n\x02\x04_\x12\x06\xda\x04\0\xdc\x04\x01\n\x0b\n\x03\x04_\x01\
    \x12\x04\xda\x04\x080\n\x0c\n\x04\x04_\x02\0\x12\x04\xdb\x04\x08*\n\r\n\
    \x05\x04_\x02\0\x04\x12\x04\xdb\x04\x08\x10\n\r\n\x05\x04_\x02\0\x05\x12\
    \x04\xdb\x04\x11\x17\n\r\n\x05\x04_\x02\0\x01\x12\x04\xdb\x04\x18%\n\r\n\
    \x05\x04_\x02\0\x03\x12\x04\xdb\x04()\n\x0c\n\x02\x04`\x12\x06\xde\x04\0\
    \xe7\x04\x01\n\x0b\n\x03\x04`\x01\x12\x04\xde\x04\x081\n\x0e\n\x04\x04`\
    \x03\0\x12\x06\xdf\x04\x08\xe4\x04\t\n\r\n\x05\x04`\x03\0\x01\x12\x04\
    \xdf\x04\x10\x18\n\x0e\n\x06\x04`\x03\0\x02\0\x12\x04\xe0\x04\x100\n\x0f\
    \n\x07\x04`\x03\0\x02\0\x04\x12\x04\xe0\x04\x10\x18\n\x0f\n\x07\x04`\x03\
    \0\x02\0\x05\x12\x04\xe0\x04\x19\x1f\n\x0f\n\x07\x04`\x03\0\x02\0\x01\
    \x12\x04\xe0\x04\x20+\n\x0f\n\x07\x04`\x03\0\x02\0\x03\x12\x04\xe0\x04./\
    \n\x0e\n\x06\x04`\x03\0\x02\x01\x12\x04\xe1\x04\x105\n\x0f\n\x07\x04`\
    \x03\0\x02\x01\x04\x12\x04\xe1\x04\x10\x18\n\x0f\n\x07\x04`\x03\0\x02\
    \x01\x05\x12\x04\xe1\x04\x19\x20\n\x0f\n\x07\x04`\x03\0\x02\x01\x01\x12\
    \x04\xe1\x04!0\n\x0f\n\x07\x04`\x03\0\x02\x01\x03\x12\x04\xe1\x0434\n\
    \x0e\n\x06\x04`\x03\0\x02\x02\x12\x04\xe2\x04\x101\n\x0f\n\x07\x04`\x03\
    \0\x02\x02\x04\x12\x04\xe2\x04\x10\x18\n\x0f\n\x07\x04`\x03\0\x02\x02\
    \x05\x12\x04\xe2\x04\x19\x1f\n\x0f\n\x07\x04`\x03\0\x02\x02\x01\x12\x04\
    \xe2\x04\x20,\n\x0f\n\x07\x04`\x03\0\x02\x02\x03\x12\x04\xe2\x04/0\n\x0e\
    \n\x06\x04`\x03\0\x02\x03\x12\x04\xe3\x04\x10,\n\x0f\n\x07\x04`\x03\0\
    \x02\x03\x04\x12\x04\xe3\x04\x10\x18\n\x0f\n\x07\x04`\x03\0\x02\x03\x05\
    \x12\x04\xe3\x04\x19\x1f\n\x0f\n\x07\x04`\x03\0\x02\x03\x01\x12\x04\xe3\
    \x04\x20'\n\x0f\n\x07\x04`\x03\0\x02\x03\x03\x12\x04\xe3\x04*+\n\x0c\n\
    \x04\x04`\x02\0\x12\x04\xe6\x04\x08V\n\r\n\x05\x04`\x02\0\x04\x12\x04\
    \xe6\x04\x08\x10\n\r\n\x05\x04`\x02\0\x06\x12\x04\xe6\x04\x11D\n\r\n\x05\
    \x04`\x02\0\x01\x12\x04\xe6\x04EQ\n\r\n\x05\x04`\x02\0\x03\x12\x04\xe6\
    \x04TU\n\x0c\n\x02\x04a\x12\x06\xe9\x04\0\xeb\x04\x01\n\x0b\n\x03\x04a\
    \x01\x12\x04\xe9\x04\x08$\n\x0c\n\x04\x04a\x02\0\x12\x04\xea\x04\x08*\n\
    \r\n\x05\x04a\x02\0\x04\x12\x04\xea\x04\x08\x10\n\r\n\x05\x04a\x02\0\x05\
    \x12\x04\xea\x04\x11\x17\n\r\n\x05\x04a\x02\0\x01\x12\x04\xea\x04\x18%\n\
    \r\n\x05\x04a\x02\0\x03\x12\x04\xea\x04()\n\x0c\n\x02\x04b\x12\x06\xed\
    \x04\0\xf6\x04\x01\n\x0b\n\x03\x04b\x01\x12\x04\xed\x04\x08%\n\x0e\n\x04\
    \x04b\x03\0\x12\x06\xee\x04\x08\xf3\x04\t\n\r\n\x05\x04b\x03\0\x01\x12\
    \x04\xee\x04\x10\x17\n\x0e\n\x06\x04b\x03\0\x02\0\x12\x04\xef\x04\x10.\n\
    \x0f\n\x07\x04b\x03\0\x02\0\x04\x12\x04\xef\x04\x10\x18\n\x0f\n\x07\x04b\
    \x03\0\x02\0\x05\x12\x04\xef\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\0\
    \x01\x12\x04\xef\x04\x20)\n\x0f\n\x07\x04b\x03\0\x02\0\x03\x12\x04\xef\
    \x04,-\n\x0e\n\x06\x04b\x03\0\x02\x01\x12\x04\xf0\x04\x104\n\x0f\n\x07\
    \x04b\x03\0\x02\x01\x04\x12\x04\xf0\x04\x10\x18\n\x0f\n\x07\x04b\x03\0\
    \x02\x01\x05\x12\x04\xf0\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\x01\x01\
    \x12\x04\xf0\x04\x20/\n\x0f\n\x07\x04b\x03\0\x02\x01\x03\x12\x04\xf0\x04\
    23\n\x0e\n\x06\x04b\x03\0\x02\x02\x12\x04\xf1\x04\x100\n\x0f\n\x07\x04b\
    \x03\0\x02\x02\x04\x12\x04\xf1\x04\x10\x18\n\x0f\n\x07\x04b\x03\0\x02\
    \x02\x05\x12\x04\xf1\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\x02\x01\x12\
    \x04\xf1\x04\x20+\n\x0f\n\x07\x04b\x03\0\x02\x02\x03\x12\x04\xf1\x04./\n\
    \x0e\n\x06\x04b\x03\0\x02\x03\x12\x04\xf2\x04\x10/\n\x0f\n\x07\x04b\x03\
    \0\x02\x03\x04\x12\x04\xf2\x04\x10\x18\n\x0f\n\x07\x04b\x03\0\x02\x03\
    \x05\x12\x04\xf2\x04\x19\x1f\n\x0f\n\x07\x04b\x03\0\x02\x03\x01\x12\x04\
    \xf2\x04\x20*\n\x0f\n\x07\x04b\x03\0\x02\x03\x03\x12\x04\xf2\x04-.\n\x0c\
    \n\x04\x04b\x02\0\x12\x04\xf5\x04\x08A\n\r\n\x05\x04b\x02\0\x04\x12\x04\
    \xf5\x04\x08\x10\n\r\n\x05\x04b\x02\0\x06\x12\x04\xf5\x04\x117\n\r\n\x05\
    \x04b\x02\0\x01\x12\x04\xf5\x048<\n\r\n\x05\x04b\x02\0\x03\x12\x04\xf5\
    \x04?@\n\x0c\n\x02\x04c\x12\x06\xf8\x04\0\xfa\x04\x01\n\x0b\n\x03\x04c\
    \x01\x12\x04\xf8\x04\x08'\n\x0c\n\x04\x04c\x02\0\x12\x04\xf9\x04\x08*\n\
    \r\n\x05\x04c\x02\0\x04\x12\x04\xf9\x04\x08\x10\n\r\n\x05\x04c\x02\0\x05\
    \x12\x04\xf9\x04\x11\x17\n\r\n\x05\x04c\x02\0\x01\x12\x04\xf9\x04\x18%\n\
    \r\n\x05\x04c\x02\0\x03\x12\x04\xf9\x04()\n\x0c\n\x02\x04d\x12\x06\xfc\
    \x04\0\x80\x05\x01\n\x0b\n\x03\x04d\x01\x12\x04\xfc\x04\x08\x1c\n\x0c\n\
    \x04\x04d\x02\0\x12\x04\xfd\x04\x08&\n\r\n\x05\x04d\x02\0\x04\x12\x04\
    \xfd\x04\x08\x10\n\r\n\x05\x04d\x02\0\x05\x12\x04\xfd\x04\x11\x17\n\r\n\
    \x05\x04d\x02\0\x01\x12\x04\xfd\x04\x18!\n\r\n\x05\x04d\x02\0\x03\x12\
    \x04\xfd\x04$%\n\x0c\n\x04\x04d\x02\x01\x12\x04\xfe\x04\x08,\n\r\n\x05\
    \x04d\x02\x01\x04\x12\x04\xfe\x04\x08\x10\n\r\n\x05\x04d\x02\x01\x05\x12\
    \x04\xfe\x04\x11\x17\n\r\n\x05\x04d\x02\x01\x01\x12\x04\xfe\x04\x18'\n\r\
    \n\x05\x04d\x02\x01\x03\x12\x04\xfe\x04*+\n\x0c\n\x04\x04d\x02\x02\x12\
    \x04\xff\x04\x08)\n\r\n\x05\x04d\x02\x02\x04\x12\x04\xff\x04\x08\x10\n\r\
    \n\x05\x04d\x02\x02\x05\x12\x04\xff\x04\x11\x17\n\r\n\x05\x04d\x02\x02\
    \x01\x12\x04\xff\x04\x18$\n\r\n\x05\x04d\x02\x02\x03\x12\x04\xff\x04'(\n\
    \x0c\n\x02\x04e\x12\x06\x82\x05\0\x84\x05\x01\n\x0b\n\x03\x04e\x01\x12\
    \x04\x82\x05\x08(\n\x0c\n\x04\x04e\x02\0\x12\x04\x83\x05\x083\n\r\n\x05\
    \x04e\x02\0\x04\x12\x04\x83\x05\x08\x10\n\r\n\x05\x04e\x02\0\x06\x12\x04\
    \x83\x05\x11&\n\r\n\x05\x04e\x02\0\x01\x12\x04\x83\x05'.\n\r\n\x05\x04e\
    \x02\0\x03\x12\x04\x83\x0512\n\x0c\n\x02\x04f\x12\x06\x86\x05\0\x89\x05\
    \x01\n\x0b\n\x03\x04f\x01\x12\x04\x86\x05\x08*\n\x0c\n\x04\x04f\x02\0\
    \x12\x04\x87\x05\x08*\n\r\n\x05\x04f\x02\0\x04\x12\x04\x87\x05\x08\x10\n\
    \r\n\x05\x04f\x02\0\x05\x12\x04\x87\x05\x11\x17\n\r\n\x05\x04f\x02\0\x01\
    \x12\x04\x87\x05\x18%\n\r\n\x05\x04f\x02\0\x03\x12\x04\x87\x05()\n\x0c\n\
    \x04\x04f\x02\x01\x12\x04\x88\x05\x08(\n\r\n\x05\x04f\x02\x01\x04\x12\
    \x04\x88\x05\x08\x10\n\r\n\x05\x04f\x02\x01\x05\x12\x04\x88\x05\x11\x17\
    \n\r\n\x05\x04f\x02\x01\x01\x12\x04\x88\x05\x18#\n\r\n\x05\x04f\x02\x01\
    \x03\x12\x04\x88\x05&'\n\x0c\n\x02\x04g\x12\x06\x8b\x05\0\x8c\x05\x01\n\
    \x0b\n\x03\x04g\x01\x12\x04\x8b\x05\x08+\n\x0c\n\x02\x04h\x12\x06\x8e\
    \x05\0\x92\x05\x01\n\x0b\n\x03\x04h\x01\x12\x04\x8e\x05\x088\n\x0c\n\x04\
    \x04h\x02\0\x12\x04\x8f\x05\x08+\n\r\n\x05\x04h\x02\0\x04\x12\x04\x8f\
    \x05\x08\x10\n\r\n\x05\x04h\x02\0\x05\x12\x04\x8f\x05\x11\x17\n\r\n\x05\
    \x04h\x02\0\x01\x12\x04\x8f\x05\x18&\n\r\n\x05\x04h\x02\0\x03\x12\x04\
    \x8f\x05)*\n\x0c\n\x04\x04h\x02\x01\x12\x04\x90\x05\x087\n\r\n\x05\x04h\
    \x02\x01\x04\x12\x04\x90\x05\x08\x10\n\r\n\x05\x04h\x02\x01\x05\x12\x04\
    \x90\x05\x11\x17\n\r\n\x05\x04h\x02\x01\x01\x12\x04\x90\x05\x182\n\r\n\
    \x05\x04h\x02\x01\x03\x12\x04\x90\x0556\n\r\n\x04\x04h\x02\x02\x12\x05\
    \x91\x05\x08\xa6\x01\n\r\n\x05\x04h\x02\x02\x04\x12\x04\x91\x05\x08\x10\
    \n\r\n\x05\x04h\x02\x02\x05\x12\x04\x91\x05\x11\x16\n\r\n\x05\x04h\x02\
    \x02\x01\x12\x04\x91\x05\x173\n\r\n\x05\x04h\x02\x02\x03\x12\x04\x91\x05\
    67\n\x0e\n\x05\x04h\x02\x02\x08\x12\x05\x91\x058\xa5\x01\n\x11\n\x08\x04\
    h\x02\x02\x08\xd0\x86\x03\x12\x05\x91\x059\xa4\x01\n\x0c\n\x02\x04i\x12\
    \x06\x94\x05\0\x97\x05\x01\n\x0b\n\x03\x04i\x01\x12\x04\x94\x05\x089\n\
    \x0c\n\x04\x04i\x02\0\x12\x04\x95\x05\x086\n\r\n\x05\x04i\x02\0\x04\x12\
    \x04\x95\x05\x08\x10\n\r\n\x05\x04i\x02\0\x06\x12\x04\x95\x05\x11%\n\r\n\
    \x05\x04i\x02\0\x01\x12\x04\x95\x05&1\n\r\n\x05\x04i\x02\0\x03\x12\x04\
    \x95\x0545\n\x0c\n\x04\x04i\x02\x01\x12\x04\x96\x05\x08>\n\r\n\x05\x04i\
    \x02\x01\x04\x12\x04\x96\x05\x08\x10\n\r\n\x05\x04i\x02\x01\x05\x12\x04\
    \x96\x05\x11\x17\n\r\n\x05\x04i\x02\x01\x01\x12\x04\x96\x05\x189\n\r\n\
    \x05\x04i\x02\x01\x03\x12\x04\x96\x05<=\n\x0c\n\x02\x04j\x12\x06\x99\x05\
    \0\xaa\x05\x01\n\x0b\n\x03\x04j\x01\x12\x04\x99\x05\x085\n\x0e\n\x04\x04\
    j\x03\0\x12\x06\x9a\x05\x08\x9e\x05\t\n\r\n\x05\x04j\x03\0\x01\x12\x04\
    \x9a\x05\x10$\n\x0f\n\x06\x04j\x03\0\x02\0\x12\x05\x9b\x05\x10\x85\x01\n\
    \x0f\n\x07\x04j\x03\0\x02\0\x04\x12\x04\x9b\x05\x10\x18\n\x0f\n\x07\x04j\
    \x03\0\x02\0\x06\x12\x04\x9b\x05\x194\n\x0f\n\x07\x04j\x03\0\x02\0\x01\
    \x12\x04\x9b\x055O\n\x0f\n\x07\x04j\x03\0\x02\0\x03\x12\x04\x9b\x05RS\n\
    \x10\n\x07\x04j\x03\0\x02\0\x08\x12\x05\x9b\x05T\x84\x01\n\x10\n\x07\x04\
    j\x03\0\x02\0\x07\x12\x05\x9b\x05_\x83\x01\n\x0f\n\x06\x04j\x03\0\x02\
    \x01\x12\x05\x9c\x05\x10\x84\x01\n\x0f\n\x07\x04j\x03\0\x02\x01\x04\x12\
    \x04\x9c\x05\x10\x18\n\x0f\n\x07\x04j\x03\0\x02\x01\x06\x12\x04\x9c\x05\
    \x194\n\x0f\n\x07\x04j\x03\0\x02\x01\x01\x12\x04\x9c\x055N\n\x0f\n\x07\
    \x04j\x03\0\x02\x01\x03\x12\x04\x9c\x05QR\n\x10\n\x07\x04j\x03\0\x02\x01\
    \x08\x12\x05\x9c\x05S\x83\x01\n\x10\n\x07\x04j\x03\0\x02\x01\x07\x12\x05\
    \x9c\x05^\x82\x01\n\x0e\n\x06\x04j\x03\0\x02\x02\x12\x04\x9d\x05\x109\n\
    \x0f\n\x07\x04j\x03\0\x02\x02\x04\x12\x04\x9d\x05\x10\x18\n\x0f\n\x07\
    \x04j\x03\0\x02\x02\x05\x12\x04\x9d\x05\x19\x1d\n\x0f\n\x07\x04j\x03\0\
    \x02\x02\x01\x12\x04\x9d\x05\x1e4\n\x0f\n\x07\x04j\x03\0\x02\x02\x03\x12\
    \x04\x9d\x0578\n\x0e\n\x04\x04j\x03\x01\x12\x06\xa0\x05\x08\xa5\x05\t\n\
    \r\n\x05\x04j\x03\x01\x01\x12\x04\xa0\x05\x10#\n\x0e\n\x06\x04j\x03\x01\
    \x02\0\x12\x04\xa1\x05\x10,\n\x0f\n\x07\x04j\x03\x01\x02\0\x04\x12\x04\
    \xa1\x05\x10\x18\n\x0f\n\x07\x04j\x03\x01\x02\0\x05\x12\x04\xa1\x05\x19\
    \x1f\n\x0f\n\x07\x04j\x03\x01\x02\0\x01\x12\x04\xa1\x05\x20'\n\x0f\n\x07\
    \x04j\x03\x01\x02\0\x03\x12\x04\xa1\x05*+\n\x0f\n\x06\x04j\x03\x01\x02\
    \x01\x12\x05\xa2\x05\x10\x85\x01\n\x0f\n\x07\x04j\x03\x01\x02\x01\x04\
    \x12\x04\xa2\x05\x10\x18\n\x0f\n\x07\x04j\x03\x01\x02\x01\x06\x12\x04\
    \xa2\x05\x194\n\x0f\n\x07\x04j\x03\x01\x02\x01\x01\x12\x04\xa2\x055O\n\
    \x0f\n\x07\x04j\x03\x01\x02\x01\x03\x12\x04\xa2\x05RS\n\x10\n\x07\x04j\
    \x03\x01\x02\x01\x08\x12\x05\xa2\x05T\x84\x01\n\x10\n\x07\x04j\x03\x01\
    \x02\x01\x07\x12\x05\xa2\x05_\x83\x01\n\x0f\n\x06\x04j\x03\x01\x02\x02\
    \x12\x05\xa3\x05\x10\x84\x01\n\x0f\n\x07\x04j\x03\x01\x02\x02\x04\x12\
    \x04\xa3\x05\x10\x18\n\x0f\n\x07\x04j\x03\x01\x02\x02\x06\x12\x04\xa3\
    \x05\x194\n\x0f\n\x07\x04j\x03\x01\x02\x02\x01\x12\x04\xa3\x055N\n\x0f\n\
    \x07\x04j\x03\x01\x02\x02\x03\x12\x04\xa3\x05QR\n\x10\n\x07\x04j\x03\x01\
    \x02\x02\x08\x12\x05\xa3\x05S\x83\x01\n\x10\n\x07\x04j\x03\x01\x02\x02\
    \x07\x12\x05\xa3\x05^\x82\x01\n\x0e\n\x06\x04j\x03\x01\x02\x03\x12\x04\
    \xa4\x05\x109\n\x0f\n\x07\x04j\x03\x01\x02\x03\x04\x12\x04\xa4\x05\x10\
    \x18\n\x0f\n\x07\x04j\x03\x01\x02\x03\x05\x12\x04\xa4\x05\x19\x1d\n\x0f\
    \n\x07\x04j\x03\x01\x02\x03\x01\x12\x04\xa4\x05\x1e4\n\x0f\n\x07\x04j\
    \x03\x01\x02\x03\x03\x12\x04\xa4\x0578\n\x0c\n\x04\x04j\x02\0\x12\x04\
    \xa7\x05\x08*\n\r\n\x05\x04j\x02\0\x04\x12\x04\xa7\x05\x08\x10\n\r\n\x05\
    \x04j\x02\0\x05\x12\x04\xa7\x05\x11\x17\n\r\n\x05\x04j\x02\0\x01\x12\x04\
    \xa7\x05\x18%\n\r\n\x05\x04j\x02\0\x03\x12\x04\xa7\x05()\n\x0c\n\x04\x04\
    j\x02\x01\x12\x04\xa8\x05\x08p\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xa8\
    \x05\x08\x10\n\r\n\x05\x04j\x02\x01\x06\x12\x04\xa8\x05\x11T\n\r\n\x05\
    \x04j\x02\x01\x01\x12\x04\xa8\x05Uk\n\r\n\x05\x04j\x02\x01\x03\x12\x04\
    \xa8\x05no\n\x0c\n\x04\x04j\x02\x02\x12\x04\xa9\x05\x08n\n\r\n\x05\x04j\
    \x02\x02\x04\x12\x04\xa9\x05\x08\x10\n\r\n\x05\x04j\x02\x02\x06\x12\x04\
    \xa9\x05\x11S\n\r\n\x05\x04j\x02\x02\x01\x12\x04\xa9\x05Ti\n\r\n\x05\x04\
    j\x02\x02\x03\x12\x04\xa9\x05lm\n\x0c\n\x02\x04k\x12\x06\xac\x05\0\xad\
    \x05\x01\n\x0b\n\x03\x04k\x01\x12\x04\xac\x05\x086\n\x0c\n\x02\x04l\x12\
    \x06\xaf\x05\0\xb8\x05\x01\n\x0b\n\x03\x04l\x01\x12\x04\xaf\x05\x08,\n\
    \x0e\n\x04\x04l\x03\0\x12\x06\xb0\x05\x08\xb3\x05\t\n\r\n\x05\x04l\x03\0\
    \x01\x12\x04\xb0\x05\x10\x17\n\x0e\n\x06\x04l\x03\0\x02\0\x12\x04\xb1\
    \x05\x105\n\x0f\n\x07\x04l\x03\0\x02\0\x04\x12\x04\xb1\x05\x10\x18\n\x0f\
    \n\x07\x04l\x03\0\x02\0\x05\x12\x04\xb1\x05\x19\x1f\n\x0f\n\x07\x04l\x03\
    \0\x02\0\x01\x12\x04\xb1\x05\x200\n\x0f\n\x07\x04l\x03\0\x02\0\x03\x12\
    \x04\xb1\x0534\n\x0e\n\x06\x04l\x03\0\x02\x01\x12\x04\xb2\x05\x10,\n\x0f\
    \n\x07\x04l\x03\0\x02\x01\x04\x12\x04\xb2\x05\x10\x18\n\x0f\n\x07\x04l\
    \x03\0\x02\x01\x05\x12\x04\xb2\x05\x19\x1f\n\x0f\n\x07\x04l\x03\0\x02\
    \x01\x01\x12\x04\xb2\x05\x20'\n\x0f\n\x07\x04l\x03\0\x02\x01\x03\x12\x04\
    \xb2\x05*+\n\x0c\n\x04\x04l\x02\0\x12\x04\xb5\x05\x08*\n\r\n\x05\x04l\
    \x02\0\x04\x12\x04\xb5\x05\x08\x10\n\r\n\x05\x04l\x02\0\x05\x12\x04\xb5\
    \x05\x11\x17\n\r\n\x05\x04l\x02\0\x01\x12\x04\xb5\x05\x18%\n\r\n\x05\x04\
    l\x02\0\x03\x12\x04\xb5\x05()\n\x0c\n\x04\x04l\x02\x01\x12\x04\xb6\x05\
    \x08$\n\r\n\x05\x04l\x02\x01\x04\x12\x04\xb6\x05\x08\x10\n\r\n\x05\x04l\
    \x02\x01\x05\x12\x04\xb6\x05\x11\x17\n\r\n\x05\x04l\x02\x01\x01\x12\x04\
    \xb6\x05\x18\x1f\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xb6\x05\"#\n\x0c\n\
    \x04\x04l\x02\x02\x12\x04\xb7\x05\x08L\n\r\n\x05\x04l\x02\x02\x04\x12\
    \x04\xb7\x05\x08\x10\n\r\n\x05\x04l\x02\x02\x06\x12\x04\xb7\x05\x11>\n\r\
    \n\x05\x04l\x02\x02\x01\x12\x04\xb7\x05?G\n\r\n\x05\x04l\x02\x02\x03\x12\
    \x04\xb7\x05JK\n\x0c\n\x02\x04m\x12\x06\xba\x05\0\xbb\x05\x01\n\x0b\n\
    \x03\x04m\x01\x12\x04\xba\x05\x08-\n\x0c\n\x02\x04n\x12\x06\xbd\x05\0\
    \xc6\x05\x01\n\x0b\n\x03\x04n\x01\x12\x04\xbd\x05\x083\n\x0c\n\x04\x04n\
    \x02\0\x12\x04\xbe\x05\x08*\n\r\n\x05\x04n\x02\0\x04\x12\x04\xbe\x05\x08\
    \x10\n\r\n\x05\x04n\x02\0\x05\x12\x04\xbe\x05\x11\x17\n\r\n\x05\x04n\x02\
    \0\x01\x12\x04\xbe\x05\x18%\n\r\n\x05\x04n\x02\0\x03\x12\x04\xbe\x05()\n\
    \r\n\x04\x04n\x02\x01\x12\x05\xbf\x05\x08\x8b\x01\n\r\n\x05\x04n\x02\x01\
    \x04\x12\x04\xbf\x05\x08\x10\n\r\n\x05\x04n\x02\x01\x05\x12\x04\xbf\x05\
    \x11\x17\n\r\n\x05\x04n\x02\x01\x01\x12\x04\xbf\x05\x18\x1f\n\r\n\x05\
    \x04n\x02\x01\x03\x12\x04\xbf\x05\"#\n\x0e\n\x05\x04n\x02\x01\x08\x12\
    \x05\xbf\x05$\x8a\x01\n\x11\n\x08\x04n\x02\x01\x08\xd0\x86\x03\x12\x05\
    \xbf\x05%\x89\x01\n\x0c\n\x04\x04n\x02\x02\x12\x04\xc0\x05\x08!\n\r\n\
    \x05\x04n\x02\x02\x04\x12\x04\xc0\x05\x08\x10\n\r\n\x05\x04n\x02\x02\x05\
    \x12\x04\xc0\x05\x11\x16\n\r\n\x05\x04n\x02\x02\x01\x12\x04\xc0\x05\x17\
    \x1c\n\r\n\x05\x04n\x02\x02\x03\x12\x04\xc0\x05\x1f\x20\n\x0c\n\x04\x04n\
    \x02\x03\x12\x04\xc1\x05\x08\x1f\n\r\n\x05\x04n\x02\x03\x04\x12\x04\xc1\
    \x05\x08\x10\n\r\n\x05\x04n\x02\x03\x05\x12\x04\xc1\x05\x11\x16\n\r\n\
    \x05\x04n\x02\x03\x01\x12\x04\xc1\x05\x17\x1a\n\r\n\x05\x04n\x02\x03\x03\
    \x12\x04\xc1\x05\x1d\x1e\n\r\n\x04\x04n\x02\x04\x12\x05\xc2\x05\x08\xb2\
    \x01\n\r\n\x05\x04n\x02\x04\x04\x12\x04\xc2\x05\x08\x10\n\r\n\x05\x04n\
    \x02\x04\x05\x12\x04\xc2\x05\x11\x16\n\r\n\x05\x04n\x02\x04\x01\x12\x04\
    \xc2\x05\x17*\n\r\n\x05\x04n\x02\x04\x03\x12\x04\xc2\x05-.\n\x0e\n\x05\
    \x04n\x02\x04\x08\x12\x05\xc2\x05/\xb1\x01\n\x11\n\x08\x04n\x02\x04\x08\
    \xd0\x86\x03\x12\x05\xc2\x050\xb0\x01\n\x0c\n\x04\x04n\x02\x05\x12\x04\
    \xc3\x05\x08`\n\r\n\x05\x04n\x02\x05\x04\x12\x04\xc3\x05\x08\x10\n\r\n\
    \x05\x04n\x02\x05\x05\x12\x04\xc3\x05\x11\x15\n\r\n\x05\x04n\x02\x05\x01\
    \x12\x04\xc3\x05\x16!\n\r\n\x05\x04n\x02\x05\x03\x12\x04\xc3\x05$%\n\r\n\
    \x05\x04n\x02\x05\x08\x12\x04\xc3\x05&_\n\x10\n\x08\x04n\x02\x05\x08\xd0\
    \x86\x03\x12\x04\xc3\x05'^\n\x0c\n\x04\x04n\x02\x06\x12\x04\xc4\x05\x088\
    \n\r\n\x05\x04n\x02\x06\x04\x12\x04\xc4\x05\x08\x10\n\r\n\x05\x04n\x02\
    \x06\x05\x12\x04\xc4\x05\x11\x16\n\r\n\x05\x04n\x02\x06\x01\x12\x04\xc4\
    \x05\x173\n\r\n\x05\x04n\x02\x06\x03\x12\x04\xc4\x0567\n\x0c\n\x04\x04n\
    \x02\x07\x12\x04\xc5\x05\x08:\n\r\n\x05\x04n\x02\x07\x04\x12\x04\xc5\x05\
    \x08\x10\n\r\n\x05\x04n\x02\x07\x05\x12\x04\xc5\x05\x11\x16\n\r\n\x05\
    \x04n\x02\x07\x01\x12\x04\xc5\x05\x175\n\r\n\x05\x04n\x02\x07\x03\x12\
    \x04\xc5\x0589\n\x0c\n\x02\x04o\x12\x06\xc8\x05\0\xcd\x05\x01\n\x0b\n\
    \x03\x04o\x01\x12\x04\xc8\x05\x08'\n\x0c\n\x04\x04o\x02\0\x12\x04\xc9\
    \x05\x08*\n\r\n\x05\x04o\x02\0\x04\x12\x04\xc9\x05\x08\x10\n\r\n\x05\x04\
    o\x02\0\x05\x12\x04\xc9\x05\x11\x17\n\r\n\x05\x04o\x02\0\x01\x12\x04\xc9\
    \x05\x18%\n\r\n\x05\x04o\x02\0\x03\x12\x04\xc9\x05()\n\r\n\x04\x04o\x02\
    \x01\x12\x05\xca\x05\x08\xd4\x01\n\r\n\x05\x04o\x02\x01\x04\x12\x04\xca\
    \x05\x08\x10\n\r\n\x05\x04o\x02\x01\x05\x12\x04\xca\x05\x11\x17\n\r\n\
    \x05\x04o\x02\x01\x01\x12\x04\xca\x05\x18!\n\r\n\x05\x04o\x02\x01\x03\
    \x12\x04\xca\x05$%\n\x0e\n\x05\x04o\x02\x01\x08\x12\x05\xca\x05&\xd3\x01\
    \n\x11\n\x08\x04o\x02\x01\x08\xd0\x86\x03\x12\x05\xca\x05'\xd2\x01\n\x0c\
    \n\x04\x04o\x02\x02\x12\x04\xcb\x05\x08(\n\r\n\x05\x04o\x02\x02\x04\x12\
    \x04\xcb\x05\x08\x10\n\r\n\x05\x04o\x02\x02\x05\x12\x04\xcb\x05\x11\x17\
    \n\r\n\x05\x04o\x02\x02\x01\x12\x04\xcb\x05\x18#\n\r\n\x05\x04o\x02\x02\
    \x03\x12\x04\xcb\x05&'\n\x0c\n\x04\x04o\x02\x03\x12\x04\xcc\x05\x08'\n\r\
    \n\x05\x04o\x02\x03\x04\x12\x04\xcc\x05\x08\x10\n\r\n\x05\x04o\x02\x03\
    \x05\x12\x04\xcc\x05\x11\x16\n\r\n\x05\x04o\x02\x03\x01\x12\x04\xcc\x05\
    \x17\"\n\r\n\x05\x04o\x02\x03\x03\x12\x04\xcc\x05%&\n\x0c\n\x02\x04p\x12\
    \x06\xcf\x05\0\xd7\x05\x01\n\x0b\n\x03\x04p\x01\x12\x04\xcf\x05\x08(\n\
    \x0e\n\x04\x04p\x03\0\x12\x06\xd0\x05\x08\xd3\x05\t\n\r\n\x05\x04p\x03\0\
    \x01\x12\x04\xd0\x05\x10\x1b\n\x0e\n\x06\x04p\x03\0\x02\0\x12\x04\xd1\
    \x05\x10-\n\x0f\n\x07\x04p\x03\0\x02\0\x04\x12\x04\xd1\x05\x10\x18\n\x0f\
    \n\x07\x04p\x03\0\x02\0\x05\x12\x04\xd1\x05\x19\x1e\n\x0f\n\x07\x04p\x03\
    \0\x02\0\x01\x12\x04\xd1\x05\x1f(\n\x0f\n\x07\x04p\x03\0\x02\0\x03\x12\
    \x04\xd1\x05+,\n\x0e\n\x06\x04p\x03\0\x02\x01\x12\x04\xd2\x05\x10D\n\x0f\
    \n\x07\x04p\x03\0\x02\x01\x04\x12\x04\xd2\x05\x10\x18\n\x0f\n\x07\x04p\
    \x03\0\x02\x01\x06\x12\x04\xd2\x05\x197\n\x0f\n\x07\x04p\x03\0\x02\x01\
    \x01\x12\x04\xd2\x058?\n\x0f\n\x07\x04p\x03\0\x02\x01\x03\x12\x04\xd2\
    \x05BC\n\x0c\n\x04\x04p\x02\0\x12\x04\xd5\x05\x08T\n\r\n\x05\x04p\x02\0\
    \x04\x12\x04\xd5\x05\x08\x10\n\r\n\x05\x04p\x02\0\x06\x12\x04\xd5\x05\
    \x11>\n\r\n\x05\x04p\x02\0\x01\x12\x04\xd5\x05?O\n\r\n\x05\x04p\x02\0\
    \x03\x12\x04\xd5\x05RS\n\x0c\n\x04\x04p\x02\x01\x12\x04\xd6\x05\x08)\n\r\
    \n\x05\x04p\x02\x01\x04\x12\x04\xd6\x05\x08\x10\n\r\n\x05\x04p\x02\x01\
    \x05\x12\x04\xd6\x05\x11\x17\n\r\n\x05\x04p\x02\x01\x01\x12\x04\xd6\x05\
    \x18$\n\r\n\x05\x04p\x02\x01\x03\x12\x04\xd6\x05'(\n\x0c\n\x02\x04q\x12\
    \x06\xd9\x05\0\xe1\x05\x01\n\x0b\n\x03\x04q\x01\x12\x04\xd9\x05\x08/\n\
    \x0c\n\x04\x04q\x02\0\x12\x04\xda\x05\x08*\n\r\n\x05\x04q\x02\0\x04\x12\
    \x04\xda\x05\x08\x10\n\r\n\x05\x04q\x02\0\x05\x12\x04\xda\x05\x11\x17\n\
    \r\n\x05\x04q\x02\0\x01\x12\x04\xda\x05\x18%\n\r\n\x05\x04q\x02\0\x03\
    \x12\x04\xda\x05()\n\x0c\n\x04\x04q\x02\x01\x12\x04\xdb\x05\x08$\n\r\n\
    \x05\x04q\x02\x01\x04\x12\x04\xdb\x05\x08\x10\n\r\n\x05\x04q\x02\x01\x05\
    \x12\x04\xdb\x05\x11\x17\n\r\n\x05\x04q\x02\x01\x01\x12\x04\xdb\x05\x18\
    \x1f\n\r\n\x05\x04q\x02\x01\x03\x12\x04\xdb\x05\"#\n\x0c\n\x04\x04q\x02\
    \x02\x12\x04\xdc\x05\x08-\n\r\n\x05\x04q\x02\x02\x04\x12\x04\xdc\x05\x08\
    \x10\n\r\n\x05\x04q\x02\x02\x05\x12\x04\xdc\x05\x11\x17\n\r\n\x05\x04q\
    \x02\x02\x01\x12\x04\xdc\x05\x18(\n\r\n\x05\x04q\x02\x02\x03\x12\x04\xdc\
    \x05+,\n\x0c\n\x04\x04q\x02\x03\x12\x04\xdd\x05\x08$\n\r\n\x05\x04q\x02\
    \x03\x04\x12\x04\xdd\x05\x08\x10\n\r\n\x05\x04q\x02\x03\x05\x12\x04\xdd\
    \x05\x11\x17\n\r\n\x05\x04q\x02\x03\x01\x12\x04\xdd\x05\x18\x1f\n\r\n\
    \x05\x04q\x02\x03\x03\x12\x04\xdd\x05\"#\n\x0c\n\x04\x04q\x02\x04\x12\
    \x04\xde\x05\x08t\n\r\n\x05\x04q\x02\x04\x04\x12\x04\xde\x05\x08\x10\n\r\
    \n\x05\x04q\x02\x04\x06\x12\x04\xde\x05\x11.\n\r\n\x05\x04q\x02\x04\x01\
    \x12\x04\xde\x05/<\n\r\n\x05\x04q\x02\x04\x03\x12\x04\xde\x05?@\n\r\n\
    \x05\x04q\x02\x04\x08\x12\x04\xde\x05As\n\r\n\x05\x04q\x02\x04\x07\x12\
    \x04\xde\x05Lr\n\x0c\n\x04\x04q\x02\x05\x12\x04\xdf\x05\x08%\n\r\n\x05\
    \x04q\x02\x05\x04\x12\x04\xdf\x05\x08\x10\n\r\n\x05\x04q\x02\x05\x05\x12\
    \x04\xdf\x05\x11\x17\n\r\n\x05\x04q\x02\x05\x01\x12\x04\xdf\x05\x18\x20\
    \n\r\n\x05\x04q\x02\x05\x03\x12\x04\xdf\x05#$\n\x0c\n\x04\x04q\x02\x06\
    \x12\x04\xe0\x05\x08!\n\r\n\x05\x04q\x02\x06\x04\x12\x04\xe0\x05\x08\x10\
    \n\r\n\x05\x04q\x02\x06\x05\x12\x04\xe0\x05\x11\x15\n\r\n\x05\x04q\x02\
    \x06\x01\x12\x04\xe0\x05\x16\x1c\n\r\n\x05\x04q\x02\x06\x03\x12\x04\xe0\
    \x05\x1f\x20\n\x0c\n\x02\x04r\x12\x06\xe3\x05\0\xe5\x05\x01\n\x0b\n\x03\
    \x04r\x01\x12\x04\xe3\x05\x080\n\x0c\n\x04\x04r\x02\0\x12\x04\xe4\x05\
    \x08)\n\r\n\x05\x04r\x02\0\x04\x12\x04\xe4\x05\x08\x10\n\r\n\x05\x04r\
    \x02\0\x05\x12\x04\xe4\x05\x11\x17\n\r\n\x05\x04r\x02\0\x01\x12\x04\xe4\
    \x05\x18$\n\r\n\x05\x04r\x02\0\x03\x12\x04\xe4\x05'(\n\x0c\n\x02\x04s\
    \x12\x06\xe7\x05\0\xef\x05\x01\n\x0b\n\x03\x04s\x01\x12\x04\xe7\x05\x084\
    \n\x0c\n\x04\x04s\x02\0\x12\x04\xe8\x05\x08*\n\r\n\x05\x04s\x02\0\x04\
    \x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04s\x02\0\x05\x12\x04\xe8\x05\x11\
    \x17\n\r\n\x05\x04s\x02\0\x01\x12\x04\xe8\x05\x18%\n\r\n\x05\x04s\x02\0\
    \x03\x12\x04\xe8\x05()\n\x0c\n\x04\x04s\x02\x01\x12\x04\xe9\x05\x08$\n\r\
    \n\x05\x04s\x02\x01\x04\x12\x04\xe9\x05\x08\x10\n\r\n\x05\x04s\x02\x01\
    \x05\x12\x04\xe9\x05\x11\x17\n\r\n\x05\x04s\x02\x01\x01\x12\x04\xe9\x05\
    \x18\x1f\n\r\n\x05\x04s\x02\x01\x03\x12\x04\xe9\x05\"#\n\x0c\n\x04\x04s\
    \x02\x02\x12\x04\xea\x05\x08-\n\r\n\x05\x04s\x02\x02\x04\x12\x04\xea\x05\
    \x08\x10\n\r\n\x05\x04s\x02\x02\x05\x12\x04\xea\x05\x11\x17\n\r\n\x05\
    \x04s\x02\x02\x01\x12\x04\xea\x05\x18(\n\r\n\x05\x04s\x02\x02\x03\x12\
    \x04\xea\x05+,\n\x0c\n\x04\x04s\x02\x03\x12\x04\xeb\x05\x08$\n\r\n\x05\
    \x04s\x02\x03\x04\x12\x04\xeb\x05\x08\x10\n\r\n\x05\x04s\x02\x03\x05\x12\
    \x04\xeb\x05\x11\x17\n\r\n\x05\x04s\x02\x03\x01\x12\x04\xeb\x05\x18\x1f\
    \n\r\n\x05\x04s\x02\x03\x03\x12\x04\xeb\x05\"#\n\x0c\n\x04\x04s\x02\x04\
    \x12\x04\xec\x05\x08t\n\r\n\x05\x04s\x02\x04\x04\x12\x04\xec\x05\x08\x10\
    \n\r\n\x05\x04s\x02\x04\x06\x12\x04\xec\x05\x11.\n\r\n\x05\x04s\x02\x04\
    \x01\x12\x04\xec\x05/<\n\r\n\x05\x04s\x02\x04\x03\x12\x04\xec\x05?@\n\r\
    \n\x05\x04s\x02\x04\x08\x12\x04\xec\x05As\n\r\n\x05\x04s\x02\x04\x07\x12\
    \x04\xec\x05Lr\n\x0c\n\x04\x04s\x02\x05\x12\x04\xed\x05\x08%\n\r\n\x05\
    \x04s\x02\x05\x04\x12\x04\xed\x05\x08\x10\n\r\n\x05\x04s\x02\x05\x05\x12\
    \x04\xed\x05\x11\x17\n\r\n\x05\x04s\x02\x05\x01\x12\x04\xed\x05\x18\x20\
    \n\r\n\x05\x04s\x02\x05\x03\x12\x04\xed\x05#$\n\x0c\n\x04\x04s\x02\x06\
    \x12\x04\xee\x05\x08\"\n\r\n\x05\x04s\x02\x06\x04\x12\x04\xee\x05\x08\
    \x10\n\r\n\x05\x04s\x02\x06\x05\x12\x04\xee\x05\x11\x17\n\r\n\x05\x04s\
    \x02\x06\x01\x12\x04\xee\x05\x18\x1d\n\r\n\x05\x04s\x02\x06\x03\x12\x04\
    \xee\x05\x20!\n\x0c\n\x02\x04t\x12\x06\xf1\x05\0\xf3\x05\x01\n\x0b\n\x03\
    \x04t\x01\x12\x04\xf1\x05\x085\n\x0c\n\x04\x04t\x02\0\x12\x04\xf2\x05\
    \x08%\n\r\n\x05\x04t\x02\0\x04\x12\x04\xf2\x05\x08\x10\n\r\n\x05\x04t\
    \x02\0\x05\x12\x04\xf2\x05\x11\x17\n\r\n\x05\x04t\x02\0\x01\x12\x04\xf2\
    \x05\x18\x20\n\r\n\x05\x04t\x02\0\x03\x12\x04\xf2\x05#$\n\x0c\n\x02\x04u\
    \x12\x06\xf5\x05\0\xf8\x05\x01\n\x0b\n\x03\x04u\x01\x12\x04\xf5\x05\x082\
    \n\x0c\n\x04\x04u\x02\0\x12\x04\xf6\x05\x08%\n\r\n\x05\x04u\x02\0\x04\
    \x12\x04\xf6\x05\x08\x10\n\r\n\x05\x04u\x02\0\x05\x12\x04\xf6\x05\x11\
    \x18\n\r\n\x05\x04u\x02\0\x01\x12\x04\xf6\x05\x19\x20\n\r\n\x05\x04u\x02\
    \0\x03\x12\x04\xf6\x05#$\n\r\n\x04\x04u\x02\x01\x12\x05\xf7\x05\x08\x85\
    \x01\n\r\n\x05\x04u\x02\x01\x04\x12\x04\xf7\x05\x08\x10\n\r\n\x05\x04u\
    \x02\x01\x05\x12\x04\xf7\x05\x11\x15\n\r\n\x05\x04u\x02\x01\x01\x12\x04\
    \xf7\x05\x16\x20\n\r\n\x05\x04u\x02\x01\x03\x12\x04\xf7\x05#$\n\x0e\n\
    \x05\x04u\x02\x01\x08\x12\x05\xf7\x05%\x84\x01\n\r\n\x05\x04u\x02\x01\
    \x07\x12\x04\xf7\x0504\n\x11\n\x08\x04u\x02\x01\x08\xd0\x86\x03\x12\x05\
    \xf7\x056\x83\x01\n\x0c\n\x02\x04v\x12\x06\xfa\x05\0\xfc\x05\x01\n\x0b\n\
    \x03\x04v\x01\x12\x04\xfa\x05\x083\n\x0c\n\x04\x04v\x02\0\x12\x04\xfb\
    \x05\x08T\n\r\n\x05\x04v\x02\0\x04\x12\x04\xfb\x05\x08\x10\n\r\n\x05\x04\
    v\x02\0\x06\x12\x04\xfb\x05\x11<\n\r\n\x05\x04v\x02\0\x01\x12\x04\xfb\
    \x05=O\n\r\n\x05\x04v\x02\0\x03\x12\x04\xfb\x05RS\n\x0c\n\x02\x04w\x12\
    \x06\xfe\x05\0\x81\x06\x01\n\x0b\n\x03\x04w\x01\x12\x04\xfe\x05\x085\n\
    \x0c\n\x04\x04w\x02\0\x12\x04\xff\x05\x08%\n\r\n\x05\x04w\x02\0\x04\x12\
    \x04\xff\x05\x08\x10\n\r\n\x05\x04w\x02\0\x05\x12\x04\xff\x05\x11\x18\n\
    \r\n\x05\x04w\x02\0\x01\x12\x04\xff\x05\x19\x20\n\r\n\x05\x04w\x02\0\x03\
    \x12\x04\xff\x05#$\n\x0c\n\x04\x04w\x02\x01\x12\x04\x80\x06\x08,\n\r\n\
    \x05\x04w\x02\x01\x04\x12\x04\x80\x06\x08\x10\n\r\n\x05\x04w\x02\x01\x05\
    \x12\x04\x80\x06\x11\x15\n\r\n\x05\x04w\x02\x01\x01\x12\x04\x80\x06\x16'\
    \n\r\n\x05\x04w\x02\x01\x03\x12\x04\x80\x06*+\n\x0c\n\x02\x04x\x12\x06\
    \x83\x06\0\x85\x06\x01\n\x0b\n\x03\x04x\x01\x12\x04\x83\x06\x086\n\x0c\n\
    \x04\x04x\x02\0\x12\x04\x84\x06\x08,\n\r\n\x05\x04x\x02\0\x04\x12\x04\
    \x84\x06\x08\x10\n\r\n\x05\x04x\x02\0\x05\x12\x04\x84\x06\x11\x15\n\r\n\
    \x05\x04x\x02\0\x01\x12\x04\x84\x06\x16'\n\r\n\x05\x04x\x02\0\x03\x12\
    \x04\x84\x06*+\n\x0c\n\x02\x04y\x12\x06\x87\x06\0\x8b\x06\x01\n\x0b\n\
    \x03\x04y\x01\x12\x04\x87\x06\x08\x15\n\x0c\n\x04\x04y\x02\0\x12\x04\x88\
    \x06\x08&\n\r\n\x05\x04y\x02\0\x04\x12\x04\x88\x06\x08\x10\n\r\n\x05\x04\
    y\x02\0\x05\x12\x04\x88\x06\x11\x15\n\r\n\x05\x04y\x02\0\x01\x12\x04\x88\
    \x06\x16!\n\r\n\x05\x04y\x02\0\x03\x12\x04\x88\x06$%\n\x0c\n\x04\x04y\
    \x02\x01\x12\x04\x89\x06\x08'\n\r\n\x05\x04y\x02\x01\x04\x12\x04\x89\x06\
    \x08\x10\n\r\n\x05\x04y\x02\x01\x05\x12\x04\x89\x06\x11\x15\n\r\n\x05\
    \x04y\x02\x01\x01\x12\x04\x89\x06\x16\"\n\r\n\x05\x04y\x02\x01\x03\x12\
    \x04\x89\x06%&\n\x0c\n\x04\x04y\x02\x02\x12\x04\x8a\x06\x08/\n\r\n\x05\
    \x04y\x02\x02\x04\x12\x04\x8a\x06\x08\x10\n\r\n\x05\x04y\x02\x02\x05\x12\
    \x04\x8a\x06\x11\x17\n\r\n\x05\x04y\x02\x02\x01\x12\x04\x8a\x06\x18*\n\r\
    \n\x05\x04y\x02\x02\x03\x12\x04\x8a\x06-.\n\x0c\n\x02\x04z\x12\x06\x8d\
    \x06\0\x98\x06\x01\n\x0b\n\x03\x04z\x01\x12\x04\x8d\x06\x082\n\x0c\n\x04\
    \x04z\x02\0\x12\x04\x8e\x06\x08*\n\r\n\x05\x04z\x02\0\x04\x12\x04\x8e\
    \x06\x08\x10\n\r\n\x05\x04z\x02\0\x05\x12\x04\x8e\x06\x11\x17\n\r\n\x05\
    \x04z\x02\0\x01\x12\x04\x8e\x06\x18%\n\r\n\x05\x04z\x02\0\x03\x12\x04\
    \x8e\x06()\n\x0c\n\x04\x04z\x02\x01\x12\x04\x8f\x06\x08$\n\r\n\x05\x04z\
    \x02\x01\x04\x12\x04\x8f\x06\x08\x10\n\r\n\x05\x04z\x02\x01\x05\x12\x04\
    \x8f\x06\x11\x17\n\r\n\x05\x04z\x02\x01\x01\x12\x04\x8f\x06\x18\x1f\n\r\
    \n\x05\x04z\x02\x01\x03\x12\x04\x8f\x06\"#\n\x0c\n\x04\x04z\x02\x02\x12\
    \x04\x90\x06\x08,\n\r\n\x05\x04z\x02\x02\x04\x12\x04\x90\x06\x08\x10\n\r\
    \n\x05\x04z\x02\x02\x05\x12\x04\x90\x06\x11\x18\n\r\n\x05\x04z\x02\x02\
    \x01\x12\x04\x90\x06\x19'\n\r\n\x05\x04z\x02\x02\x03\x12\x04\x90\x06*+\n\
    \x0c\n\x04\x04z\x02\x03\x12\x04\x91\x06\x08$\n\r\n\x05\x04z\x02\x03\x04\
    \x12\x04\x91\x06\x08\x10\n\r\n\x05\x04z\x02\x03\x05\x12\x04\x91\x06\x11\
    \x17\n\r\n\x05\x04z\x02\x03\x01\x12\x04\x91\x06\x18\x1f\n\r\n\x05\x04z\
    \x02\x03\x03\x12\x04\x91\x06\"#\n\x0c\n\x04\x04z\x02\x04\x12\x04\x92\x06\
    \x08&\n\r\n\x05\x04z\x02\x04\x04\x12\x04\x92\x06\x08\x10\n\r\n\x05\x04z\
    \x02\x04\x05\x12\x04\x92\x06\x11\x17\n\r\n\x05\x04z\x02\x04\x01\x12\x04\
    \x92\x06\x18!\n\r\n\x05\x04z\x02\x04\x03\x12\x04\x92\x06$%\n\x0c\n\x04\
    \x04z\x02\x05\x12\x04\x93\x06\x08-\n\r\n\x05\x04z\x02\x05\x04\x12\x04\
    \x93\x06\x08\x10\n\r\n\x05\x04z\x02\x05\x06\x12\x04\x93\x06\x11\x1f\n\r\
    \n\x05\x04z\x02\x05\x01\x12\x04\x93\x06\x20(\n\r\n\x05\x04z\x02\x05\x03\
    \x12\x04\x93\x06+,\n\x0c\n\x04\x04z\x02\x06\x12\x04\x94\x06\x08$\n\r\n\
    \x05\x04z\x02\x06\x04\x12\x04\x94\x06\x08\x10\n\r\n\x05\x04z\x02\x06\x05\
    \x12\x04\x94\x06\x11\x17\n\r\n\x05\x04z\x02\x06\x01\x12\x04\x94\x06\x18\
    \x1f\n\r\n\x05\x04z\x02\x06\x03\x12\x04\x94\x06\"#\n\x0c\n\x04\x04z\x02\
    \x07\x12\x04\x95\x06\x083\n\r\n\x05\x04z\x02\x07\x04\x12\x04\x95\x06\x08\
    \x10\n\r\n\x05\x04z\x02\x07\x06\x12\x04\x95\x06\x11\x1f\n\r\n\x05\x04z\
    \x02\x07\x01\x12\x04\x95\x06\x20.\n\r\n\x05\x04z\x02\x07\x03\x12\x04\x95\
    \x0612\n\x0c\n\x04\x04z\x02\x08\x12\x04\x96\x06\x08.\n\r\n\x05\x04z\x02\
    \x08\x04\x12\x04\x96\x06\x08\x10\n\r\n\x05\x04z\x02\x08\x05\x12\x04\x96\
    \x06\x11\x17\n\r\n\x05\x04z\x02\x08\x01\x12\x04\x96\x06\x18)\n\r\n\x05\
    \x04z\x02\x08\x03\x12\x04\x96\x06,-\n\x0c\n\x04\x04z\x02\t\x12\x04\x97\
    \x06\x08r\n\r\n\x05\x04z\x02\t\x04\x12\x04\x97\x06\x08\x10\n\r\n\x05\x04\
    z\x02\t\x05\x12\x04\x97\x06\x11\x17\n\r\n\x05\x04z\x02\t\x01\x12\x04\x97\
    \x06\x18!\n\r\n\x05\x04z\x02\t\x03\x12\x04\x97\x06$&\n\r\n\x05\x04z\x02\
    \t\x08\x12\x04\x97\x06'q\n\x10\n\x08\x04z\x02\t\x08\xd0\x86\x03\x12\x04\
    \x97\x06(p\n\x0c\n\x02\x04{\x12\x06\x9a\x06\0\xa4\x06\x01\n\x0b\n\x03\
    \x04{\x01\x12\x04\x9a\x06\x082\n\x0e\n\x04\x04{\x03\0\x12\x06\x9b\x06\
    \x08\x9f\x06\t\n\r\n\x05\x04{\x03\0\x01\x12\x04\x9b\x06\x10\x1b\n\x0e\n\
    \x06\x04{\x03\0\x02\0\x12\x04\x9c\x06\x105\n\x0f\n\x07\x04{\x03\0\x02\0\
    \x04\x12\x04\x9c\x06\x10\x18\n\x0f\n\x07\x04{\x03\0\x02\0\x05\x12\x04\
    \x9c\x06\x19\x1f\n\x0f\n\x07\x04{\x03\0\x02\0\x01\x12\x04\x9c\x06\x200\n\
    \x0f\n\x07\x04{\x03\0\x02\0\x03\x12\x04\x9c\x0634\n\x0e\n\x06\x04{\x03\0\
    \x02\x01\x12\x04\x9d\x06\x10,\n\x0f\n\x07\x04{\x03\0\x02\x01\x04\x12\x04\
    \x9d\x06\x10\x18\n\x0f\n\x07\x04{\x03\0\x02\x01\x05\x12\x04\x9d\x06\x19\
    \x1f\n\x0f\n\x07\x04{\x03\0\x02\x01\x01\x12\x04\x9d\x06\x20'\n\x0f\n\x07\
    \x04{\x03\0\x02\x01\x03\x12\x04\x9d\x06*+\n\x0e\n\x06\x04{\x03\0\x02\x02\
    \x12\x04\x9e\x06\x10*\n\x0f\n\x07\x04{\x03\0\x02\x02\x04\x12\x04\x9e\x06\
    \x10\x18\n\x0f\n\x07\x04{\x03\0\x02\x02\x05\x12\x04\x9e\x06\x19\x1d\n\
    \x0f\n\x07\x04{\x03\0\x02\x02\x01\x12\x04\x9e\x06\x1e%\n\x0f\n\x07\x04{\
    \x03\0\x02\x02\x03\x12\x04\x9e\x06()\n\x0c\n\x04\x04{\x02\0\x12\x04\xa1\
    \x06\x08*\n\r\n\x05\x04{\x02\0\x04\x12\x04\xa1\x06\x08\x10\n\r\n\x05\x04\
    {\x02\0\x05\x12\x04\xa1\x06\x11\x17\n\r\n\x05\x04{\x02\0\x01\x12\x04\xa1\
    \x06\x18%\n\r\n\x05\x04{\x02\0\x03\x12\x04\xa1\x06()\n\x0c\n\x04\x04{\
    \x02\x01\x12\x04\xa2\x06\x08$\n\r\n\x05\x04{\x02\x01\x04\x12\x04\xa2\x06\
    \x08\x10\n\r\n\x05\x04{\x02\x01\x05\x12\x04\xa2\x06\x11\x17\n\r\n\x05\
    \x04{\x02\x01\x01\x12\x04\xa2\x06\x18\x1f\n\r\n\x05\x04{\x02\x01\x03\x12\
    \x04\xa2\x06\"#\n\x0c\n\x04\x04{\x02\x02\x12\x04\xa3\x06\x08V\n\r\n\x05\
    \x04{\x02\x02\x04\x12\x04\xa3\x06\x08\x10\n\r\n\x05\x04{\x02\x02\x06\x12\
    \x04\xa3\x06\x11H\n\r\n\x05\x04{\x02\x02\x01\x12\x04\xa3\x06IQ\n\r\n\x05\
    \x04{\x02\x02\x03\x12\x04\xa3\x06TU\n\x0c\n\x02\x04|\x12\x06\xa6\x06\0\
    \xaa\x06\x01\n\x0b\n\x03\x04|\x01\x12\x04\xa6\x06\x080\n\x0c\n\x04\x04|\
    \x02\0\x12\x04\xa7\x06\x08*\n\r\n\x05\x04|\x02\0\x04\x12\x04\xa7\x06\x08\
    \x10\n\r\n\x05\x04|\x02\0\x05\x12\x04\xa7\x06\x11\x17\n\r\n\x05\x04|\x02\
    \0\x01\x12\x04\xa7\x06\x18%\n\r\n\x05\x04|\x02\0\x03\x12\x04\xa7\x06()\n\
    \x0c\n\x04\x04|\x02\x01\x12\x04\xa8\x06\x08-\n\r\n\x05\x04|\x02\x01\x04\
    \x12\x04\xa8\x06\x08\x10\n\r\n\x05\x04|\x02\x01\x06\x12\x04\xa8\x06\x11!\
    \n\r\n\x05\x04|\x02\x01\x01\x12\x04\xa8\x06\"(\n\r\n\x05\x04|\x02\x01\
    \x03\x12\x04\xa8\x06+,\n\x0c\n\x04\x04|\x02\x02\x12\x04\xa9\x06\x08i\n\r\
    \n\x05\x04|\x02\x02\x04\x12\x04\xa9\x06\x08\x10\n\r\n\x05\x04|\x02\x02\
    \x06\x12\x04\xa9\x06\x11,\n\r\n\x05\x04|\x02\x02\x01\x12\x04\xa9\x06-3\n\
    \r\n\x05\x04|\x02\x02\x03\x12\x04\xa9\x0667\n\r\n\x05\x04|\x02\x02\x08\
    \x12\x04\xa9\x068h\n\r\n\x05\x04|\x02\x02\x07\x12\x04\xa9\x06Cg\n\x0c\n\
    \x02\x04}\x12\x06\xac\x06\0\xae\x06\x01\n\x0b\n\x03\x04}\x01\x12\x04\xac\
    \x06\x082\n\x0c\n\x04\x04}\x02\0\x12\x04\xad\x06\x08=\n\r\n\x05\x04}\x02\
    \0\x04\x12\x04\xad\x06\x08\x10\n\r\n\x05\x04}\x02\0\x06\x12\x04\xad\x06\
    \x11+\n\r\n\x05\x04}\x02\0\x01\x12\x04\xad\x06,8\n\r\n\x05\x04}\x02\0\
    \x03\x12\x04\xad\x06;<\n\x0c\n\x02\x04~\x12\x06\xb0\x06\0\xb4\x06\x01\n\
    \x0b\n\x03\x04~\x01\x12\x04\xb0\x06\x087\n\x0c\n\x04\x04~\x02\0\x12\x04\
    \xb1\x06\x08*\n\r\n\x05\x04~\x02\0\x04\x12\x04\xb1\x06\x08\x10\n\r\n\x05\
    \x04~\x02\0\x05\x12\x04\xb1\x06\x11\x17\n\r\n\x05\x04~\x02\0\x01\x12\x04\
    \xb1\x06\x18%\n\r\n\x05\x04~\x02\0\x03\x12\x04\xb1\x06()\n\x0c\n\x04\x04\
    ~\x02\x01\x12\x04\xb2\x06\x08,\n\r\n\x05\x04~\x02\x01\x04\x12\x04\xb2\
    \x06\x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\x04\xb2\x06\x11\x17\n\r\n\
    \x05\x04~\x02\x01\x01\x12\x04\xb2\x06\x18'\n\r\n\x05\x04~\x02\x01\x03\
    \x12\x04\xb2\x06*+\n\x0c\n\x04\x04~\x02\x02\x12\x04\xb3\x06\x080\n\r\n\
    \x05\x04~\x02\x02\x04\x12\x04\xb3\x06\x08\x10\n\r\n\x05\x04~\x02\x02\x06\
    \x12\x04\xb3\x06\x11\x20\n\r\n\x05\x04~\x02\x02\x01\x12\x04\xb3\x06!+\n\
    \r\n\x05\x04~\x02\x02\x03\x12\x04\xb3\x06./\n\x0c\n\x02\x04\x7f\x12\x06\
    \xb6\x06\0\xb9\x06\x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\xb6\x06\x08B\n\
    \x0c\n\x04\x04\x7f\x02\0\x12\x04\xb7\x06\x08$\n\r\n\x05\x04\x7f\x02\0\
    \x04\x12\x04\xb7\x06\x08\x10\n\r\n\x05\x04\x7f\x02\0\x05\x12\x04\xb7\x06\
    \x11\x17\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xb7\x06\x18\x1f\n\r\n\x05\
    \x04\x7f\x02\0\x03\x12\x04\xb7\x06\"#\n\x0c\n\x04\x04\x7f\x02\x01\x12\
    \x04\xb8\x06\x08*\n\r\n\x05\x04\x7f\x02\x01\x04\x12\x04\xb8\x06\x08\x10\
    \n\r\n\x05\x04\x7f\x02\x01\x05\x12\x04\xb8\x06\x11\x17\n\r\n\x05\x04\x7f\
    \x02\x01\x01\x12\x04\xb8\x06\x18%\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\
    \xb8\x06()\n\r\n\x03\x04\x80\x01\x12\x06\xbb\x06\0\xc0\x06\x01\n\x0c\n\
    \x04\x04\x80\x01\x01\x12\x04\xbb\x06\x08C\n\r\n\x05\x04\x80\x01\x02\0\
    \x12\x04\xbc\x06\x08*\n\x0e\n\x06\x04\x80\x01\x02\0\x04\x12\x04\xbc\x06\
    \x08\x10\n\x0e\n\x06\x04\x80\x01\x02\0\x05\x12\x04\xbc\x06\x11\x17\n\x0e\
    \n\x06\x04\x80\x01\x02\0\x01\x12\x04\xbc\x06\x18%\n\x0e\n\x06\x04\x80\
    \x01\x02\0\x03\x12\x04\xbc\x06()\n\r\n\x05\x04\x80\x01\x02\x01\x12\x04\
    \xbd\x06\x08D\n\x0e\n\x06\x04\x80\x01\x02\x01\x04\x12\x04\xbd\x06\x08\
    \x10\n\x0e\n\x06\x04\x80\x01\x02\x01\x06\x12\x04\xbd\x06\x11)\n\x0e\n\
    \x06\x04\x80\x01\x02\x01\x01\x12\x04\xbd\x06*?\n\x0e\n\x06\x04\x80\x01\
    \x02\x01\x03\x12\x04\xbd\x06BC\n\r\n\x05\x04\x80\x01\x02\x02\x12\x04\xbe\
    \x06\x08O\n\x0e\n\x06\x04\x80\x01\x02\x02\x04\x12\x04\xbe\x06\x08\x10\n\
    \x0e\n\x06\x04\x80\x01\x02\x02\x06\x12\x04\xbe\x06\x11<\n\x0e\n\x06\x04\
    \x80\x01\x02\x02\x01\x12\x04\xbe\x06=J\n\x0e\n\x06\x04\x80\x01\x02\x02\
    \x03\x12\x04\xbe\x06MN\n\r\n\x05\x04\x80\x01\x02\x03\x12\x04\xbf\x06\x08\
    n\n\x0e\n\x06\x04\x80\x01\x02\x03\x04\x12\x04\xbf\x06\x08\x10\n\x0e\n\
    \x06\x04\x80\x01\x02\x03\x06\x12\x04\xbf\x06\x11,\n\x0e\n\x06\x04\x80\
    \x01\x02\x03\x01\x12\x04\xbf\x06-8\n\x0e\n\x06\x04\x80\x01\x02\x03\x03\
    \x12\x04\xbf\x06;<\n\x0e\n\x06\x04\x80\x01\x02\x03\x08\x12\x04\xbf\x06=m\
    \n\x0e\n\x06\x04\x80\x01\x02\x03\x07\x12\x04\xbf\x06Hl\n\r\n\x03\x04\x81\
    \x01\x12\x06\xc2\x06\0\xc4\x06\x01\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\
    \xc2\x06\x08<\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\xc3\x06\x08+\n\x0e\n\
    \x06\x04\x81\x01\x02\0\x04\x12\x04\xc3\x06\x08\x10\n\x0e\n\x06\x04\x81\
    \x01\x02\0\x05\x12\x04\xc3\x06\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\0\x01\
    \x12\x04\xc3\x06\x18&\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xc3\x06)\
    *\n\r\n\x03\x04\x82\x01\x12\x06\xc6\x06\0\xcc\x06\x01\n\x0c\n\x04\x04\
    \x82\x01\x01\x12\x04\xc6\x06\x08\x1f\n\r\n\x05\x04\x82\x01\x02\0\x12\x04\
    \xc7\x06\x08!\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\xc7\x06\x08\x10\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x05\x12\x04\xc7\x06\x11\x16\n\x0e\n\x06\
    \x04\x82\x01\x02\0\x01\x12\x04\xc7\x06\x17\x1c\n\x0e\n\x06\x04\x82\x01\
    \x02\0\x03\x12\x04\xc7\x06\x1f\x20\n\r\n\x05\x04\x82\x01\x02\x01\x12\x04\
    \xc8\x06\x08\x1f\n\x0e\n\x06\x04\x82\x01\x02\x01\x04\x12\x04\xc8\x06\x08\
    \x10\n\x0e\n\x06\x04\x82\x01\x02\x01\x05\x12\x04\xc8\x06\x11\x16\n\x0e\n\
    \x06\x04\x82\x01\x02\x01\x01\x12\x04\xc8\x06\x17\x1a\n\x0e\n\x06\x04\x82\
    \x01\x02\x01\x03\x12\x04\xc8\x06\x1d\x1e\n\r\n\x05\x04\x82\x01\x02\x02\
    \x12\x04\xc9\x06\x08'\n\x0e\n\x06\x04\x82\x01\x02\x02\x04\x12\x04\xc9\
    \x06\x08\x10\n\x0e\n\x06\x04\x82\x01\x02\x02\x05\x12\x04\xc9\x06\x11\x16\
    \n\x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\xc9\x06\x17\"\n\x0e\n\x06\
    \x04\x82\x01\x02\x02\x03\x12\x04\xc9\x06%&\n\x0e\n\x05\x04\x82\x01\x02\
    \x03\x12\x05\xca\x06\x08\x84\x01\n\x0e\n\x06\x04\x82\x01\x02\x03\x04\x12\
    \x04\xca\x06\x08\x10\n\x0e\n\x06\x04\x82\x01\x02\x03\x05\x12\x04\xca\x06\
    \x11\x16\n\x0e\n\x06\x04\x82\x01\x02\x03\x01\x12\x04\xca\x06\x17*\n\x0e\
    \n\x06\x04\x82\x01\x02\x03\x03\x12\x04\xca\x06-.\n\x0f\n\x06\x04\x82\x01\
    \x02\x03\x08\x12\x05\xca\x06/\x83\x01\n\x12\n\t\x04\x82\x01\x02\x03\x08\
    \xd0\x86\x03\x12\x05\xca\x060\x82\x01\n\x0e\n\x05\x04\x82\x01\x02\x04\
    \x12\x05\xcb\x06\x08\x88\x01\n\x0e\n\x06\x04\x82\x01\x02\x04\x04\x12\x04\
    \xcb\x06\x08\x10\n\x0e\n\x06\x04\x82\x01\x02\x04\x05\x12\x04\xcb\x06\x11\
    \x16\n\x0e\n\x06\x04\x82\x01\x02\x04\x01\x12\x04\xcb\x06\x17*\n\x0e\n\
    \x06\x04\x82\x01\x02\x04\x03\x12\x04\xcb\x06-.\n\x0f\n\x06\x04\x82\x01\
    \x02\x04\x08\x12\x05\xcb\x06/\x87\x01\n\x12\n\t\x04\x82\x01\x02\x04\x08\
    \xd0\x86\x03\x12\x05\xcb\x060\x86\x01\n\r\n\x03\x04\x83\x01\x12\x06\xce\
    \x06\0\xd2\x06\x01\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\xce\x06\x08$\n\r\
    \n\x05\x04\x83\x01\x02\0\x12\x04\xcf\x06\x08\"\n\x0e\n\x06\x04\x83\x01\
    \x02\0\x04\x12\x04\xcf\x06\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\0\x05\x12\
    \x04\xcf\x06\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\xcf\x06\
    \x17\x1d\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xcf\x06\x20!\n\r\n\
    \x05\x04\x83\x01\x02\x01\x12\x04\xd0\x06\x08\"\n\x0e\n\x06\x04\x83\x01\
    \x02\x01\x04\x12\x04\xd0\x06\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\x01\x05\
    \x12\x04\xd0\x06\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\x01\x01\x12\x04\xd0\
    \x06\x17\x1d\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xd0\x06\x20!\n\
    \r\n\x05\x04\x83\x01\x02\x02\x12\x04\xd1\x06\x08#\n\x0e\n\x06\x04\x83\
    \x01\x02\x02\x04\x12\x04\xd1\x06\x08\x10\n\x0e\n\x06\x04\x83\x01\x02\x02\
    \x05\x12\x04\xd1\x06\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\x02\x01\x12\x04\
    \xd1\x06\x17\x1e\n\x0e\n\x06\x04\x83\x01\x02\x02\x03\x12\x04\xd1\x06!\"\
    \n\r\n\x03\x04\x84\x01\x12\x06\xd4\x06\0\xe2\x06\x01\n\x0c\n\x04\x04\x84\
    \x01\x01\x12\x04\xd4\x06\x08:\n\x0f\n\x05\x04\x84\x01\x03\0\x12\x06\xd5\
    \x06\x08\xd9\x06\t\n\x0e\n\x06\x04\x84\x01\x03\0\x01\x12\x04\xd5\x06\x10\
    #\n\x0f\n\x07\x04\x84\x01\x03\0\x02\0\x12\x04\xd6\x06\x10(\n\x10\n\x08\
    \x04\x84\x01\x03\0\x02\0\x04\x12\x04\xd6\x06\x10\x18\n\x10\n\x08\x04\x84\
    \x01\x03\0\x02\0\x05\x12\x04\xd6\x06\x19\x1e\n\x10\n\x08\x04\x84\x01\x03\
    \0\x02\0\x01\x12\x04\xd6\x06\x1f#\n\x10\n\x08\x04\x84\x01\x03\0\x02\0\
    \x03\x12\x04\xd6\x06&'\n\x0f\n\x07\x04\x84\x01\x03\0\x02\x01\x12\x04\xd7\
    \x06\x10.\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\x04\x12\x04\xd7\x06\x10\
    \x18\n\x10\n\x08\x04\x84\x01\x03\0\x02\x01\x05\x12\x04\xd7\x06\x19\x1f\n\
    \x10\n\x08\x04\x84\x01\x03\0\x02\x01\x01\x12\x04\xd7\x06\x20)\n\x10\n\
    \x08\x04\x84\x01\x03\0\x02\x01\x03\x12\x04\xd7\x06,-\n\x0f\n\x07\x04\x84\
    \x01\x03\0\x02\x02\x12\x04\xd8\x06\x10D\n\x10\n\x08\x04\x84\x01\x03\0\
    \x02\x02\x04\x12\x04\xd8\x06\x10\x18\n\x10\n\x08\x04\x84\x01\x03\0\x02\
    \x02\x06\x12\x04\xd8\x06\x197\n\x10\n\x08\x04\x84\x01\x03\0\x02\x02\x01\
    \x12\x04\xd8\x068?\n\x10\n\x08\x04\x84\x01\x03\0\x02\x02\x03\x12\x04\xd8\
    \x06BC\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\xdb\x06\x08*\n\x0e\n\x06\x04\
    \x84\x01\x02\0\x04\x12\x04\xdb\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\0\
    \x05\x12\x04\xdb\x06\x11\x17\n\x0e\n\x06\x04\x84\x01\x02\0\x01\x12\x04\
    \xdb\x06\x18%\n\x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\xdb\x06()\n\r\n\
    \x05\x04\x84\x01\x02\x01\x12\x04\xdc\x06\x08q\n\x0e\n\x06\x04\x84\x01\
    \x02\x01\x04\x12\x04\xdc\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x01\x05\
    \x12\x04\xdc\x06\x11\x17\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\x04\xdc\
    \x06\x18\x1f\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\xdc\x06\"#\n\
    \x0e\n\x06\x04\x84\x01\x02\x01\x08\x12\x04\xdc\x06$p\n\x11\n\t\x04\x84\
    \x01\x02\x01\x08\xd0\x86\x03\x12\x04\xdc\x06%o\n\r\n\x05\x04\x84\x01\x02\
    \x02\x12\x04\xdd\x06\x083\n\x0e\n\x06\x04\x84\x01\x02\x02\x04\x12\x04\
    \xdd\x06\x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x02\x06\x12\x04\xdd\x06\x11\
    )\n\x0e\n\x06\x04\x84\x01\x02\x02\x01\x12\x04\xdd\x06*.\n\x0e\n\x06\x04\
    \x84\x01\x02\x02\x03\x12\x04\xdd\x0612\n\r\n\x05\x04\x84\x01\x02\x03\x12\
    \x04\xde\x06\x08e\n\x0e\n\x06\x04\x84\x01\x02\x03\x04\x12\x04\xde\x06\
    \x08\x10\n\x0e\n\x06\x04\x84\x01\x02\x03\x06\x12\x04\xde\x06\x11X\n\x0e\
    \n\x06\x04\x84\x01\x02\x03\x01\x12\x04\xde\x06Y`\n\x0e\n\x06\x04\x84\x01\
    \x02\x03\x03\x12\x04\xde\x06cd\n\r\n\x05\x04\x84\x01\x02\x04\x12\x04\xdf\
    \x06\x08)\n\x0e\n\x06\x04\x84\x01\x02\x04\x04\x12\x04\xdf\x06\x08\x10\n\
    \x0e\n\x06\x04\x84\x01\x02\x04\x05\x12\x04\xdf\x06\x11\x17\n\x0e\n\x06\
    \x04\x84\x01\x02\x04\x01\x12\x04\xdf\x06\x18$\n\x0e\n\x06\x04\x84\x01\
    \x02\x04\x03\x12\x04\xdf\x06'(\n\r\n\x05\x04\x84\x01\x02\x05\x12\x04\xe0\
    \x06\x08B\n\x0e\n\x06\x04\x84\x01\x02\x05\x04\x12\x04\xe0\x06\x08\x10\n\
    \x0e\n\x06\x04\x84\x01\x02\x05\x06\x12\x04\xe0\x06\x11.\n\x0e\n\x06\x04\
    \x84\x01\x02\x05\x01\x12\x04\xe0\x06/=\n\x0e\n\x06\x04\x84\x01\x02\x05\
    \x03\x12\x04\xe0\x06@A\n\r\n\x05\x04\x84\x01\x02\x06\x12\x04\xe1\x06\x08\
    H\n\x0e\n\x06\x04\x84\x01\x02\x06\x04\x12\x04\xe1\x06\x08\x10\n\x0e\n\
    \x06\x04\x84\x01\x02\x06\x06\x12\x04\xe1\x06\x11/\n\x0e\n\x06\x04\x84\
    \x01\x02\x06\x01\x12\x04\xe1\x060C\n\x0e\n\x06\x04\x84\x01\x02\x06\x03\
    \x12\x04\xe1\x06FG\n\r\n\x03\x04\x85\x01\x12\x06\xe4\x06\0\xed\x06\x01\n\
    \x0c\n\x04\x04\x85\x01\x01\x12\x04\xe4\x06\x08.\n\r\n\x05\x04\x85\x01\
    \x02\0\x12\x04\xe5\x06\x08*\n\x0e\n\x06\x04\x85\x01\x02\0\x04\x12\x04\
    \xe5\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\0\x05\x12\x04\xe5\x06\x11\
    \x17\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\xe5\x06\x18%\n\x0e\n\x06\
    \x04\x85\x01\x02\0\x03\x12\x04\xe5\x06()\n\r\n\x05\x04\x85\x01\x02\x01\
    \x12\x04\xe6\x06\x08$\n\x0e\n\x06\x04\x85\x01\x02\x01\x04\x12\x04\xe6\
    \x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x01\x05\x12\x04\xe6\x06\x11\x17\
    \n\x0e\n\x06\x04\x85\x01\x02\x01\x01\x12\x04\xe6\x06\x18\x1f\n\x0e\n\x06\
    \x04\x85\x01\x02\x01\x03\x12\x04\xe6\x06\"#\n\r\n\x05\x04\x85\x01\x02\
    \x02\x12\x04\xe7\x06\x08-\n\x0e\n\x06\x04\x85\x01\x02\x02\x04\x12\x04\
    \xe7\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x02\x05\x12\x04\xe7\x06\x11\
    \x17\n\x0e\n\x06\x04\x85\x01\x02\x02\x01\x12\x04\xe7\x06\x18(\n\x0e\n\
    \x06\x04\x85\x01\x02\x02\x03\x12\x04\xe7\x06+,\n\r\n\x05\x04\x85\x01\x02\
    \x03\x12\x04\xe8\x06\x08$\n\x0e\n\x06\x04\x85\x01\x02\x03\x04\x12\x04\
    \xe8\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x03\x05\x12\x04\xe8\x06\x11\
    \x17\n\x0e\n\x06\x04\x85\x01\x02\x03\x01\x12\x04\xe8\x06\x18\x1f\n\x0e\n\
    \x06\x04\x85\x01\x02\x03\x03\x12\x04\xe8\x06\"#\n\r\n\x05\x04\x85\x01\
    \x02\x04\x12\x04\xe9\x06\x08%\n\x0e\n\x06\x04\x85\x01\x02\x04\x04\x12\
    \x04\xe9\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x04\x05\x12\x04\xe9\x06\
    \x11\x18\n\x0e\n\x06\x04\x85\x01\x02\x04\x01\x12\x04\xe9\x06\x19\x20\n\
    \x0e\n\x06\x04\x85\x01\x02\x04\x03\x12\x04\xe9\x06#$\n\r\n\x05\x04\x85\
    \x01\x02\x05\x12\x04\xea\x06\x08t\n\x0e\n\x06\x04\x85\x01\x02\x05\x04\
    \x12\x04\xea\x06\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x05\x06\x12\x04\xea\
    \x06\x11.\n\x0e\n\x06\x04\x85\x01\x02\x05\x01\x12\x04\xea\x06/<\n\x0e\n\
    \x06\x04\x85\x01\x02\x05\x03\x12\x04\xea\x06?@\n\x0e\n\x06\x04\x85\x01\
    \x02\x05\x08\x12\x04\xea\x06As\n\x0e\n\x06\x04\x85\x01\x02\x05\x07\x12\
    \x04\xea\x06Lr\n\r\n\x05\x04\x85\x01\x02\x06\x12\x04\xeb\x06\x08%\n\x0e\
    \n\x06\x04\x85\x01\x02\x06\x04\x12\x04\xeb\x06\x08\x10\n\x0e\n\x06\x04\
    \x85\x01\x02\x06\x05\x12\x04\xeb\x06\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\
    \x06\x01\x12\x04\xeb\x06\x18\x20\n\x0e\n\x06\x04\x85\x01\x02\x06\x03\x12\
    \x04\xeb\x06#$\n\r\n\x05\x04\x85\x01\x02\x07\x12\x04\xec\x06\x08!\n\x0e\
    \n\x06\x04\x85\x01\x02\x07\x04\x12\x04\xec\x06\x08\x10\n\x0e\n\x06\x04\
    \x85\x01\x02\x07\x05\x12\x04\xec\x06\x11\x15\n\x0e\n\x06\x04\x85\x01\x02\
    \x07\x01\x12\x04\xec\x06\x16\x1c\n\x0e\n\x06\x04\x85\x01\x02\x07\x03\x12\
    \x04\xec\x06\x1f\x20\n\r\n\x03\x04\x86\x01\x12\x06\xef\x06\0\xca\x07\x01\
    \n\x0c\n\x04\x04\x86\x01\x01\x12\x04\xef\x06\x08:\n\x0f\n\x05\x04\x86\
    \x01\x03\0\x12\x06\xf0\x06\x08\x8a\x07\t\n\x0e\n\x06\x04\x86\x01\x03\0\
    \x01\x12\x04\xf0\x06\x10\x18\n\x0f\n\x07\x04\x86\x01\x03\0\x02\0\x12\x04\
    \xf1\x06\x10<\n\x10\n\x08\x04\x86\x01\x03\0\x02\0\x04\x12\x04\xf1\x06\
    \x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\0\x05\x12\x04\xf1\x06\x19\x1d\
    \n\x10\n\x08\x04\x86\x01\x03\0\x02\0\x01\x12\x04\xf1\x06\x1e7\n\x10\n\
    \x08\x04\x86\x01\x03\0\x02\0\x03\x12\x04\xf1\x06:;\n\x0f\n\x07\x04\x86\
    \x01\x03\0\x02\x01\x12\x04\xf2\x06\x10<\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x01\x04\x12\x04\xf2\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \x01\x05\x12\x04\xf2\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x01\
    \x01\x12\x04\xf2\x06\x1e7\n\x10\n\x08\x04\x86\x01\x03\0\x02\x01\x03\x12\
    \x04\xf2\x06:;\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x02\x12\x04\xf3\x06\x10\
    =\n\x10\n\x08\x04\x86\x01\x03\0\x02\x02\x04\x12\x04\xf3\x06\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\0\x02\x02\x05\x12\x04\xf3\x06\x19\x1d\n\x10\n\
    \x08\x04\x86\x01\x03\0\x02\x02\x01\x12\x04\xf3\x06\x1e8\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x02\x03\x12\x04\xf3\x06;<\n\x0f\n\x07\x04\x86\x01\x03\
    \0\x02\x03\x12\x04\xf4\x06\x10I\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\
    \x04\x12\x04\xf4\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\x05\
    \x12\x04\xf4\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\x01\x12\
    \x04\xf4\x06\x1eD\n\x10\n\x08\x04\x86\x01\x03\0\x02\x03\x03\x12\x04\xf4\
    \x06GH\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x04\x12\x04\xf5\x06\x105\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\x04\x04\x12\x04\xf5\x06\x10\x18\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x04\x05\x12\x04\xf5\x06\x19\x1d\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x04\x01\x12\x04\xf5\x06\x1e0\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x04\x03\x12\x04\xf5\x0634\n\x0f\n\x07\x04\x86\x01\x03\0\x02\
    \x05\x12\x04\xf6\x06\x105\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x04\x12\
    \x04\xf6\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x05\x12\x04\
    \xf6\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x01\x12\x04\xf6\
    \x06\x1e0\n\x10\n\x08\x04\x86\x01\x03\0\x02\x05\x03\x12\x04\xf6\x0634\n\
    \x0f\n\x07\x04\x86\x01\x03\0\x02\x06\x12\x04\xf7\x06\x106\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x06\x04\x12\x04\xf7\x06\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x06\x05\x12\x04\xf7\x06\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x06\x01\x12\x04\xf7\x06\x1e1\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\x06\x03\x12\x04\xf7\x0645\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x07\
    \x12\x04\xf8\x06\x10B\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x04\x12\x04\
    \xf8\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x05\x12\x04\xf8\
    \x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x01\x12\x04\xf8\x06\
    \x1e=\n\x10\n\x08\x04\x86\x01\x03\0\x02\x07\x03\x12\x04\xf8\x06@A\n\x0f\
    \n\x07\x04\x86\x01\x03\0\x02\x08\x12\x04\xf9\x06\x109\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x08\x04\x12\x04\xf9\x06\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x08\x05\x12\x04\xf9\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x08\x01\x12\x04\xf9\x06\x1e4\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x08\x03\x12\x04\xf9\x0678\n\x0f\n\x07\x04\x86\x01\x03\0\x02\t\x12\
    \x04\xfa\x06\x10C\n\x10\n\x08\x04\x86\x01\x03\0\x02\t\x04\x12\x04\xfa\
    \x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\t\x05\x12\x04\xfa\x06\x19\
    \x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\t\x01\x12\x04\xfa\x06\x1e=\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\t\x03\x12\x04\xfa\x06@B\n\x0f\n\x07\x04\x86\
    \x01\x03\0\x02\n\x12\x04\xfb\x06\x104\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \n\x04\x12\x04\xfb\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\n\x05\
    \x12\x04\xfb\x06\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\0\x02\n\x01\x12\x04\
    \xfb\x06\x1f.\n\x10\n\x08\x04\x86\x01\x03\0\x02\n\x03\x12\x04\xfb\x0613\
    \n\x0f\n\x07\x04\x86\x01\x03\0\x02\x0b\x12\x04\xfc\x06\x107\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x0b\x04\x12\x04\xfc\x06\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x0b\x05\x12\x04\xfc\x06\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x0b\x01\x12\x04\xfc\x06\x1e1\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\x0b\x03\x12\x04\xfc\x0646\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x0c\
    \x12\x04\xfd\x06\x108\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x04\x12\x04\
    \xfd\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x05\x12\x04\xfd\
    \x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x01\x12\x04\xfd\x06\
    \x1e2\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0c\x03\x12\x04\xfd\x0657\n\x0f\
    \n\x07\x04\x86\x01\x03\0\x02\r\x12\x04\xfe\x06\x108\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\r\x04\x12\x04\xfe\x06\x10\x18\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\r\x05\x12\x04\xfe\x06\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\r\
    \x01\x12\x04\xfe\x06\x1e2\n\x10\n\x08\x04\x86\x01\x03\0\x02\r\x03\x12\
    \x04\xfe\x0657\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x0e\x12\x04\xff\x06\x10\
    M\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0e\x04\x12\x04\xff\x06\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\0\x02\x0e\x05\x12\x04\xff\x06\x19\x1d\n\x10\n\
    \x08\x04\x86\x01\x03\0\x02\x0e\x01\x12\x04\xff\x06\x1eG\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x0e\x03\x12\x04\xff\x06JL\n\x0f\n\x07\x04\x86\x01\x03\
    \0\x02\x0f\x12\x04\x80\x07\x10F\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\
    \x04\x12\x04\x80\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\x05\
    \x12\x04\x80\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\x01\x12\
    \x04\x80\x07\x1e@\n\x10\n\x08\x04\x86\x01\x03\0\x02\x0f\x03\x12\x04\x80\
    \x07CE\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x10\x12\x04\x81\x07\x10F\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\x10\x04\x12\x04\x81\x07\x10\x18\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x10\x05\x12\x04\x81\x07\x19\x1d\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x10\x01\x12\x04\x81\x07\x1e@\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x10\x03\x12\x04\x81\x07CE\n\x0f\n\x07\x04\x86\x01\x03\0\x02\
    \x11\x12\x04\x82\x07\x10<\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x04\x12\
    \x04\x82\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x05\x12\x04\
    \x82\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x01\x12\x04\x82\
    \x07\x1e6\n\x10\n\x08\x04\x86\x01\x03\0\x02\x11\x03\x12\x04\x82\x079;\n\
    \x0f\n\x07\x04\x86\x01\x03\0\x02\x12\x12\x04\x83\x07\x10F\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x12\x04\x12\x04\x83\x07\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x12\x05\x12\x04\x83\x07\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x12\x01\x12\x04\x83\x07\x1e@\n\x10\n\x08\x04\x86\x01\x03\
    \0\x02\x12\x03\x12\x04\x83\x07CE\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x13\
    \x12\x04\x84\x07\x103\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x04\x12\x04\
    \x84\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x05\x12\x04\x84\
    \x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x01\x12\x04\x84\x07\
    \x1f-\n\x10\n\x08\x04\x86\x01\x03\0\x02\x13\x03\x12\x04\x84\x0702\n\x0f\
    \n\x07\x04\x86\x01\x03\0\x02\x14\x12\x04\x85\x07\x103\n\x10\n\x08\x04\
    \x86\x01\x03\0\x02\x14\x04\x12\x04\x85\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\0\x02\x14\x05\x12\x04\x85\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x14\x01\x12\x04\x85\x07\x1e-\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x14\x03\x12\x04\x85\x0702\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x15\x12\
    \x04\x86\x07\x107\n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x04\x12\x04\x86\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x05\x12\x04\x86\x07\
    \x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x01\x12\x04\x86\x07\x1e1\
    \n\x10\n\x08\x04\x86\x01\x03\0\x02\x15\x03\x12\x04\x86\x0746\n\x0f\n\x07\
    \x04\x86\x01\x03\0\x02\x16\x12\x04\x87\x07\x10:\n\x10\n\x08\x04\x86\x01\
    \x03\0\x02\x16\x04\x12\x04\x87\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\
    \x02\x16\x05\x12\x04\x87\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \x16\x01\x12\x04\x87\x07\x1e4\n\x10\n\x08\x04\x86\x01\x03\0\x02\x16\x03\
    \x12\x04\x87\x0779\n\x0f\n\x07\x04\x86\x01\x03\0\x02\x17\x12\x04\x88\x07\
    \x105\n\x10\n\x08\x04\x86\x01\x03\0\x02\x17\x04\x12\x04\x88\x07\x10\x18\
    \n\x10\n\x08\x04\x86\x01\x03\0\x02\x17\x05\x12\x04\x88\x07\x19\x1d\n\x10\
    \n\x08\x04\x86\x01\x03\0\x02\x17\x01\x12\x04\x88\x07\x1e/\n\x10\n\x08\
    \x04\x86\x01\x03\0\x02\x17\x03\x12\x04\x88\x0724\n\x0f\n\x07\x04\x86\x01\
    \x03\0\x02\x18\x12\x04\x89\x07\x104\n\x10\n\x08\x04\x86\x01\x03\0\x02\
    \x18\x04\x12\x04\x89\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\0\x02\x18\
    \x05\x12\x04\x89\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\0\x02\x18\x01\
    \x12\x04\x89\x07\x1e.\n\x10\n\x08\x04\x86\x01\x03\0\x02\x18\x03\x12\x04\
    \x89\x0713\n\x0f\n\x05\x04\x86\x01\x03\x01\x12\x06\x8c\x07\x08\x98\x07\t\
    \n\x0e\n\x06\x04\x86\x01\x03\x01\x01\x12\x04\x8c\x07\x10\x1d\n\x0f\n\x07\
    \x04\x86\x01\x03\x01\x02\0\x12\x04\x8d\x07\x104\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\0\x04\x12\x04\x8d\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\0\x05\x12\x04\x8d\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x01\
    \x02\0\x01\x12\x04\x8d\x07\x1f/\n\x10\n\x08\x04\x86\x01\x03\x01\x02\0\
    \x03\x12\x04\x8d\x0723\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\x01\x12\x04\
    \x8e\x07\x105\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x04\x12\x04\x8e\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x05\x12\x04\x8e\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x01\x12\x04\x8e\x07\x1f\
    0\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x01\x03\x12\x04\x8e\x0734\n\x0f\n\
    \x07\x04\x86\x01\x03\x01\x02\x02\x12\x04\x8f\x07\x104\n\x10\n\x08\x04\
    \x86\x01\x03\x01\x02\x02\x04\x12\x04\x8f\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\x01\x02\x02\x05\x12\x04\x8f\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\x02\x01\x12\x04\x8f\x07\x1f/\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\x02\x03\x12\x04\x8f\x0723\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\
    \x03\x12\x04\x90\x07\x10>\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x04\
    \x12\x04\x90\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x05\x12\
    \x04\x90\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x01\x12\x04\
    \x90\x07\x1e9\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x03\x03\x12\x04\x90\
    \x07<=\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\x04\x12\x04\x91\x07\x10?\n\
    \x10\n\x08\x04\x86\x01\x03\x01\x02\x04\x04\x12\x04\x91\x07\x10\x18\n\x10\
    \n\x08\x04\x86\x01\x03\x01\x02\x04\x05\x12\x04\x91\x07\x19\x1d\n\x10\n\
    \x08\x04\x86\x01\x03\x01\x02\x04\x01\x12\x04\x91\x07\x1e:\n\x10\n\x08\
    \x04\x86\x01\x03\x01\x02\x04\x03\x12\x04\x91\x07=>\n\x0f\n\x07\x04\x86\
    \x01\x03\x01\x02\x05\x12\x04\x92\x07\x10>\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\x05\x04\x12\x04\x92\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\
    \x02\x05\x05\x12\x04\x92\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\
    \x05\x01\x12\x04\x92\x07\x1e9\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x05\
    \x03\x12\x04\x92\x07<=\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\x06\x12\x04\
    \x93\x07\x10;\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x04\x12\x04\x93\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x05\x12\x04\x93\x07\
    \x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x01\x12\x04\x93\x07\x1e\
    6\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x06\x03\x12\x04\x93\x079:\n\x0f\n\
    \x07\x04\x86\x01\x03\x01\x02\x07\x12\x04\x94\x07\x10>\n\x10\n\x08\x04\
    \x86\x01\x03\x01\x02\x07\x04\x12\x04\x94\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\x01\x02\x07\x05\x12\x04\x94\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\x07\x01\x12\x04\x94\x07\x1e9\n\x10\n\x08\x04\x86\x01\x03\
    \x01\x02\x07\x03\x12\x04\x94\x07<=\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\
    \x08\x12\x04\x95\x07\x107\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x04\
    \x12\x04\x95\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x05\x12\
    \x04\x95\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x01\x12\x04\
    \x95\x07\x1e2\n\x10\n\x08\x04\x86\x01\x03\x01\x02\x08\x03\x12\x04\x95\
    \x0756\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\t\x12\x04\x96\x07\x108\n\x10\
    \n\x08\x04\x86\x01\x03\x01\x02\t\x04\x12\x04\x96\x07\x10\x18\n\x10\n\x08\
    \x04\x86\x01\x03\x01\x02\t\x05\x12\x04\x96\x07\x19\x1d\n\x10\n\x08\x04\
    \x86\x01\x03\x01\x02\t\x01\x12\x04\x96\x07\x1e2\n\x10\n\x08\x04\x86\x01\
    \x03\x01\x02\t\x03\x12\x04\x96\x0757\n\x0f\n\x07\x04\x86\x01\x03\x01\x02\
    \n\x12\x04\x97\x07\x103\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x04\x12\
    \x04\x97\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x05\x12\x04\
    \x97\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x01\x12\x04\x97\
    \x07\x1e-\n\x10\n\x08\x04\x86\x01\x03\x01\x02\n\x03\x12\x04\x97\x0702\n\
    \x0f\n\x05\x04\x86\x01\x03\x02\x12\x06\x9a\x07\x08\xb3\x07\t\n\x0e\n\x06\
    \x04\x86\x01\x03\x02\x01\x12\x04\x9a\x07\x10\x17\n\x11\n\x07\x04\x86\x01\
    \x03\x02\x03\0\x12\x06\x9b\x07\x10\xa1\x07\x11\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x03\0\x01\x12\x04\x9b\x07\x18-\n\x11\n\t\x04\x86\x01\x03\x02\
    \x03\0\x02\0\x12\x04\x9c\x07\x18<\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\
    \x02\0\x04\x12\x04\x9c\x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\
    \x02\0\x05\x12\x04\x9c\x07!%\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\0\
    \x01\x12\x04\x9c\x07&7\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\0\x03\x12\
    \x04\x9c\x07:;\n\x11\n\t\x04\x86\x01\x03\x02\x03\0\x02\x01\x12\x04\x9d\
    \x07\x18;\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x04\x12\x04\x9d\
    \x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x05\x12\x04\x9d\
    \x07!%\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x01\x12\x04\x9d\x07&6\
    \n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x01\x03\x12\x04\x9d\x079:\n\x11\
    \n\t\x04\x86\x01\x03\x02\x03\0\x02\x02\x12\x04\x9e\x07\x18<\n\x12\n\n\
    \x04\x86\x01\x03\x02\x03\0\x02\x02\x04\x12\x04\x9e\x07\x18\x20\n\x12\n\n\
    \x04\x86\x01\x03\x02\x03\0\x02\x02\x05\x12\x04\x9e\x07!%\n\x12\n\n\x04\
    \x86\x01\x03\x02\x03\0\x02\x02\x01\x12\x04\x9e\x07&7\n\x12\n\n\x04\x86\
    \x01\x03\x02\x03\0\x02\x02\x03\x12\x04\x9e\x07:;\n\x11\n\t\x04\x86\x01\
    \x03\x02\x03\0\x02\x03\x12\x04\x9f\x07\x18A\n\x12\n\n\x04\x86\x01\x03\
    \x02\x03\0\x02\x03\x04\x12\x04\x9f\x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\
    \x02\x03\0\x02\x03\x05\x12\x04\x9f\x07!&\n\x12\n\n\x04\x86\x01\x03\x02\
    \x03\0\x02\x03\x01\x12\x04\x9f\x07'<\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\
    \x02\x03\x03\x12\x04\x9f\x07?@\n\x11\n\t\x04\x86\x01\x03\x02\x03\0\x02\
    \x04\x12\x04\xa0\x07\x18@\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\
    \x04\x12\x04\xa0\x07\x18\x20\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\
    \x05\x12\x04\xa0\x07!&\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\x01\
    \x12\x04\xa0\x07';\n\x12\n\n\x04\x86\x01\x03\x02\x03\0\x02\x04\x03\x12\
    \x04\xa0\x07>?\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\0\x12\x04\xa3\x07\x10\
    7\n\x10\n\x08\x04\x86\x01\x03\x02\x02\0\x04\x12\x04\xa3\x07\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\0\x05\x12\x04\xa3\x07\x19\x1e\n\x10\n\
    \x08\x04\x86\x01\x03\x02\x02\0\x01\x12\x04\xa3\x07\x1f2\n\x10\n\x08\x04\
    \x86\x01\x03\x02\x02\0\x03\x12\x04\xa3\x0756\n\x0f\n\x07\x04\x86\x01\x03\
    \x02\x02\x01\x12\x04\xa4\x07\x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\
    \x01\x04\x12\x04\xa4\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x01\
    \x05\x12\x04\xa4\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x01\x01\
    \x12\x04\xa4\x07\x1f1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x01\x03\x12\
    \x04\xa4\x0745\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x02\x12\x04\xa5\x07\
    \x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x02\x04\x12\x04\xa5\x07\x10\
    \x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x02\x05\x12\x04\xa5\x07\x19\x1d\
    \n\x10\n\x08\x04\x86\x01\x03\x02\x02\x02\x01\x12\x04\xa5\x07\x1e1\n\x10\
    \n\x08\x04\x86\x01\x03\x02\x02\x02\x03\x12\x04\xa5\x0745\n\x0f\n\x07\x04\
    \x86\x01\x03\x02\x02\x03\x12\x04\xa6\x07\x109\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x03\x04\x12\x04\xa6\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x03\x05\x12\x04\xa6\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x03\x01\x12\x04\xa6\x07\x1e4\n\x10\n\x08\x04\x86\x01\x03\x02\x02\
    \x03\x03\x12\x04\xa6\x0778\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x04\x12\
    \x04\xa7\x07\x10C\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x04\x12\x04\
    \xa7\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x05\x12\x04\xa7\
    \x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x01\x12\x04\xa7\x07\
    \x1f>\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x04\x03\x12\x04\xa7\x07AB\n\
    \x0f\n\x07\x04\x86\x01\x03\x02\x02\x05\x12\x04\xa8\x07\x107\n\x10\n\x08\
    \x04\x86\x01\x03\x02\x02\x05\x04\x12\x04\xa8\x07\x10\x18\n\x10\n\x08\x04\
    \x86\x01\x03\x02\x02\x05\x05\x12\x04\xa8\x07\x19\x1d\n\x10\n\x08\x04\x86\
    \x01\x03\x02\x02\x05\x01\x12\x04\xa8\x07\x1e2\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x05\x03\x12\x04\xa8\x0756\n\x0f\n\x07\x04\x86\x01\x03\x02\
    \x02\x06\x12\x04\xa9\x07\x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\
    \x04\x12\x04\xa9\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\x05\
    \x12\x04\xa9\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\x01\x12\
    \x04\xa9\x07\x1f1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x06\x03\x12\x04\
    \xa9\x0745\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x07\x12\x04\xaa\x07\x10:\
    \n\x10\n\x08\x04\x86\x01\x03\x02\x02\x07\x04\x12\x04\xaa\x07\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\x07\x05\x12\x04\xaa\x07\x19\x1e\n\x10\
    \n\x08\x04\x86\x01\x03\x02\x02\x07\x01\x12\x04\xaa\x07\x1f5\n\x10\n\x08\
    \x04\x86\x01\x03\x02\x02\x07\x03\x12\x04\xaa\x0789\n\x0f\n\x07\x04\x86\
    \x01\x03\x02\x02\x08\x12\x04\xab\x07\x10;\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x08\x04\x12\x04\xab\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x08\x05\x12\x04\xab\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\
    \x08\x01\x12\x04\xab\x07\x1f6\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x08\
    \x03\x12\x04\xab\x079:\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\t\x12\x04\xac\
    \x07\x106\n\x10\n\x08\x04\x86\x01\x03\x02\x02\t\x04\x12\x04\xac\x07\x10\
    \x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\t\x05\x12\x04\xac\x07\x19\x1e\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\t\x01\x12\x04\xac\x07\x1f0\n\x10\n\
    \x08\x04\x86\x01\x03\x02\x02\t\x03\x12\x04\xac\x0735\n\x0f\n\x07\x04\x86\
    \x01\x03\x02\x02\n\x12\x04\xad\x07\x107\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\n\x04\x12\x04\xad\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\n\
    \x05\x12\x04\xad\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\n\x01\
    \x12\x04\xad\x07\x1f1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\n\x03\x12\x04\
    \xad\x0746\n\x10\n\x07\x04\x86\x01\x03\x02\x02\x0b\x12\x05\xae\x07\x10\
    \x82\x01\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0b\x04\x12\x04\xae\x07\x10\
    \x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0b\x06\x12\x04\xae\x07\x19j\n\
    \x10\n\x08\x04\x86\x01\x03\x02\x02\x0b\x01\x12\x04\xae\x07k|\n\x11\n\x08\
    \x04\x86\x01\x03\x02\x02\x0b\x03\x12\x05\xae\x07\x7f\x81\x01\n\x0f\n\x07\
    \x04\x86\x01\x03\x02\x02\x0c\x12\x04\xaf\x07\x10B\n\x10\n\x08\x04\x86\
    \x01\x03\x02\x02\x0c\x04\x12\x04\xaf\x07\x10\x18\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x0c\x05\x12\x04\xaf\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x0c\x01\x12\x04\xaf\x07\x1f<\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x0c\x03\x12\x04\xaf\x07?A\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\r\x12\
    \x04\xb0\x07\x10C\n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x04\x12\x04\xb0\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x05\x12\x04\xb0\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x01\x12\x04\xb0\x07\x1f=\
    \n\x10\n\x08\x04\x86\x01\x03\x02\x02\r\x03\x12\x04\xb0\x07@B\n\x0f\n\x07\
    \x04\x86\x01\x03\x02\x02\x0e\x12\x04\xb1\x07\x10<\n\x10\n\x08\x04\x86\
    \x01\x03\x02\x02\x0e\x04\x12\x04\xb1\x07\x10\x18\n\x10\n\x08\x04\x86\x01\
    \x03\x02\x02\x0e\x05\x12\x04\xb1\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\
    \x02\x02\x0e\x01\x12\x04\xb1\x07\x1e6\n\x10\n\x08\x04\x86\x01\x03\x02\
    \x02\x0e\x03\x12\x04\xb1\x079;\n\x0f\n\x07\x04\x86\x01\x03\x02\x02\x0f\
    \x12\x04\xb2\x07\x107\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x04\x12\
    \x04\xb2\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x05\x12\x04\
    \xb2\x07\x19\x1d\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x01\x12\x04\xb2\
    \x07\x1e1\n\x10\n\x08\x04\x86\x01\x03\x02\x02\x0f\x03\x12\x04\xb2\x0746\
    \n\x0f\n\x05\x04\x86\x01\x03\x03\x12\x06\xb5\x07\x08\xc0\x07\t\n\x0e\n\
    \x06\x04\x86\x01\x03\x03\x01\x12\x04\xb5\x07\x10\x17\n\x0f\n\x07\x04\x86\
    \x01\x03\x03\x02\0\x12\x04\xb6\x07\x101\n\x10\n\x08\x04\x86\x01\x03\x03\
    \x02\0\x04\x12\x04\xb6\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\0\
    \x05\x12\x04\xb6\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\0\x01\
    \x12\x04\xb6\x07\x1f,\n\x10\n\x08\x04\x86\x01\x03\x03\x02\0\x03\x12\x04\
    \xb6\x07/0\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x01\x12\x04\xb7\x07\x10:\
    \n\x10\n\x08\x04\x86\x01\x03\x03\x02\x01\x04\x12\x04\xb7\x07\x10\x18\n\
    \x10\n\x08\x04\x86\x01\x03\x03\x02\x01\x05\x12\x04\xb7\x07\x19\x1e\n\x10\
    \n\x08\x04\x86\x01\x03\x03\x02\x01\x01\x12\x04\xb7\x07\x1f5\n\x10\n\x08\
    \x04\x86\x01\x03\x03\x02\x01\x03\x12\x04\xb7\x0789\n\x0f\n\x07\x04\x86\
    \x01\x03\x03\x02\x02\x12\x04\xb8\x07\x10=\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\x02\x04\x12\x04\xb8\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\
    \x02\x02\x05\x12\x04\xb8\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\
    \x02\x01\x12\x04\xb8\x07\x1f8\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x02\
    \x03\x12\x04\xb8\x07;<\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x03\x12\x04\
    \xb9\x07\x108\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x04\x12\x04\xb9\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x05\x12\x04\xb9\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x01\x12\x04\xb9\x07\x1f\
    3\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x03\x03\x12\x04\xb9\x0767\n\x0f\n\
    \x07\x04\x86\x01\x03\x03\x02\x04\x12\x04\xba\x07\x109\n\x10\n\x08\x04\
    \x86\x01\x03\x03\x02\x04\x04\x12\x04\xba\x07\x10\x18\n\x10\n\x08\x04\x86\
    \x01\x03\x03\x02\x04\x05\x12\x04\xba\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\
    \x03\x03\x02\x04\x01\x12\x04\xba\x07\x1f4\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\x04\x03\x12\x04\xba\x0778\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\
    \x05\x12\x04\xbb\x07\x10C\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x04\
    \x12\x04\xbb\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x05\x12\
    \x04\xbb\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x01\x12\x04\
    \xbb\x07\x1f>\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x05\x03\x12\x04\xbb\
    \x07AB\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x06\x12\x04\xbc\x07\x104\n\
    \x10\n\x08\x04\x86\x01\x03\x03\x02\x06\x04\x12\x04\xbc\x07\x10\x18\n\x10\
    \n\x08\x04\x86\x01\x03\x03\x02\x06\x05\x12\x04\xbc\x07\x19\x1e\n\x10\n\
    \x08\x04\x86\x01\x03\x03\x02\x06\x01\x12\x04\xbc\x07\x1f/\n\x10\n\x08\
    \x04\x86\x01\x03\x03\x02\x06\x03\x12\x04\xbc\x0723\n\x0f\n\x07\x04\x86\
    \x01\x03\x03\x02\x07\x12\x04\xbd\x07\x10:\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\x07\x04\x12\x04\xbd\x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\
    \x02\x07\x05\x12\x04\xbd\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\
    \x07\x01\x12\x04\xbd\x07\x1f5\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x07\
    \x03\x12\x04\xbd\x0789\n\x0f\n\x07\x04\x86\x01\x03\x03\x02\x08\x12\x04\
    \xbe\x07\x104\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x04\x12\x04\xbe\
    \x07\x10\x18\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x05\x12\x04\xbe\x07\
    \x19\x1e\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x01\x12\x04\xbe\x07\x1f\
    /\n\x10\n\x08\x04\x86\x01\x03\x03\x02\x08\x03\x12\x04\xbe\x0723\n\x0f\n\
    \x07\x04\x86\x01\x03\x03\x02\t\x12\x04\xbf\x07\x10>\n\x10\n\x08\x04\x86\
    \x01\x03\x03\x02\t\x04\x12\x04\xbf\x07\x10\x18\n\x10\n\x08\x04\x86\x01\
    \x03\x03\x02\t\x05\x12\x04\xbf\x07\x19\x1e\n\x10\n\x08\x04\x86\x01\x03\
    \x03\x02\t\x01\x12\x04\xbf\x07\x1f8\n\x10\n\x08\x04\x86\x01\x03\x03\x02\
    \t\x03\x12\x04\xbf\x07;=\n\r\n\x05\x04\x86\x01\x02\0\x12\x04\xc2\x07\x08\
    +\n\x0e\n\x06\x04\x86\x01\x02\0\x04\x12\x04\xc2\x07\x08\x10\n\x0e\n\x06\
    \x04\x86\x01\x02\0\x05\x12\x04\xc2\x07\x11\x17\n\x0e\n\x06\x04\x86\x01\
    \x02\0\x01\x12\x04\xc2\x07\x18&\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\
    \x04\xc2\x07)*\n\r\n\x05\x04\x86\x01\x02\x01\x12\x04\xc3\x07\x08)\n\x0e\
    \n\x06\x04\x86\x01\x02\x01\x04\x12\x04\xc3\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x01\x05\x12\x04\xc3\x07\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\
    \x01\x01\x12\x04\xc3\x07\x18$\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\
    \x04\xc3\x07'(\n\r\n\x05\x04\x86\x01\x02\x02\x12\x04\xc4\x07\x08,\n\x0e\
    \n\x06\x04\x86\x01\x02\x02\x04\x12\x04\xc4\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x02\x05\x12\x04\xc4\x07\x11\x17\n\x0e\n\x06\x04\x86\x01\x02\
    \x02\x01\x12\x04\xc4\x07\x18'\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\x12\
    \x04\xc4\x07*+\n\r\n\x05\x04\x86\x01\x02\x03\x12\x04\xc5\x07\x08!\n\x0e\
    \n\x06\x04\x86\x01\x02\x03\x04\x12\x04\xc5\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x03\x05\x12\x04\xc5\x07\x11\x15\n\x0e\n\x06\x04\x86\x01\x02\
    \x03\x01\x12\x04\xc5\x07\x16\x1c\n\x0e\n\x06\x04\x86\x01\x02\x03\x03\x12\
    \x04\xc5\x07\x1f\x20\n\r\n\x05\x04\x86\x01\x02\x04\x12\x04\xc6\x07\x08\\\
    \n\x0e\n\x06\x04\x86\x01\x02\x04\x04\x12\x04\xc6\x07\x08\x10\n\x0e\n\x06\
    \x04\x86\x01\x02\x04\x06\x12\x04\xc6\x07\x11M\n\x0e\n\x06\x04\x86\x01\
    \x02\x04\x01\x12\x04\xc6\x07NV\n\x0e\n\x06\x04\x86\x01\x02\x04\x03\x12\
    \x04\xc6\x07Y[\n\r\n\x05\x04\x86\x01\x02\x05\x12\x04\xc7\x07\x08g\n\x0e\
    \n\x06\x04\x86\x01\x02\x05\x04\x12\x04\xc7\x07\x08\x10\n\x0e\n\x06\x04\
    \x86\x01\x02\x05\x06\x12\x04\xc7\x07\x11R\n\x0e\n\x06\x04\x86\x01\x02\
    \x05\x01\x12\x04\xc7\x07Sa\n\x0e\n\x06\x04\x86\x01\x02\x05\x03\x12\x04\
    \xc7\x07df\n\r\n\x05\x04\x86\x01\x02\x06\x12\x04\xc8\x07\x08[\n\x0e\n\
    \x06\x04\x86\x01\x02\x06\x04\x12\x04\xc8\x07\x08\x10\n\x0e\n\x06\x04\x86\
    \x01\x02\x06\x06\x12\x04\xc8\x07\x11L\n\x0e\n\x06\x04\x86\x01\x02\x06\
    \x01\x12\x04\xc8\x07MU\n\x0e\n\x06\x04\x86\x01\x02\x06\x03\x12\x04\xc8\
    \x07XZ\n\r\n\x05\x04\x86\x01\x02\x07\x12\x04\xc9\x07\x08Z\n\x0e\n\x06\
    \x04\x86\x01\x02\x07\x04\x12\x04\xc9\x07\x08\x10\n\x0e\n\x06\x04\x86\x01\
    \x02\x07\x06\x12\x04\xc9\x07\x11L\n\x0e\n\x06\x04\x86\x01\x02\x07\x01\
    \x12\x04\xc9\x07MT\n\x0e\n\x06\x04\x86\x01\x02\x07\x03\x12\x04\xc9\x07WY\
    \n\r\n\x03\x04\x87\x01\x12\x06\xcc\x07\0\xce\x07\x01\n\x0c\n\x04\x04\x87\
    \x01\x01\x12\x04\xcc\x07\x08A\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\xcd\
    \x07\x08+\n\x0e\n\x06\x04\x87\x01\x02\0\x04\x12\x04\xcd\x07\x08\x10\n\
    \x0e\n\x06\x04\x87\x01\x02\0\x05\x12\x04\xcd\x07\x11\x17\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x01\x12\x04\xcd\x07\x18&\n\x0e\n\x06\x04\x87\x01\x02\0\
    \x03\x12\x04\xcd\x07)*\n\x0c\n\x02\x06\0\x12\x06\xd0\x07\0\xd6\x07\x01\n\
    \x0b\n\x03\x06\0\x01\x12\x04\xd0\x07\x08\x0c\n\x0b\n\x03\x06\0\x03\x12\
    \x04\xd1\x07\x08?\n\x0e\n\x06\x06\0\x03\xd0\x86\x03\x12\x04\xd1\x07\x08?\
    \n\x0e\n\x04\x06\0\x02\0\x12\x06\xd3\x07\x08\xd5\x07\t\n\r\n\x05\x06\0\
    \x02\0\x01\x12\x04\xd3\x07\x0c&\n\r\n\x05\x06\0\x02\0\x02\x12\x04\xd3\
    \x07(Q\n\x0e\n\x05\x06\0\x02\0\x03\x12\x05\xd3\x07\\\x86\x01\n\x0e\n\x05\
    \x06\0\x02\0\x04\x12\x05\xd4\x07\x10\x9f\x01\n\x11\n\x08\x06\0\x02\0\x04\
    \xd0\x86\x03\x12\x05\xd4\x07\x10\x9f\x01\n\x0c\n\x02\x06\x01\x12\x06\xd8\
    \x07\0\xae\t\x01\n\x0b\n\x03\x06\x01\x01\x12\x04\xd8\x07\x08\x10\n\x0b\n\
    \x03\x06\x01\x03\x12\x04\xd9\x07\x08h\n\x0e\n\x06\x06\x01\x03\xd0\x86\
    \x03\x12\x04\xd9\x07\x08h\n\x0e\n\x04\x06\x01\x02\0\x12\x06\xdb\x07\x08\
    \xdd\x07\t\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\xdb\x07\x0c\x1f\n\r\n\x05\
    \x06\x01\x02\0\x02\x12\x04\xdb\x07!G\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\
    \xdb\x07Ry\n\r\n\x05\x06\x01\x02\0\x04\x12\x04\xdc\x07\x10h\n\x10\n\x08\
    \x06\x01\x02\0\x04\xd0\x86\x03\x12\x04\xdc\x07\x10h\n\x0e\n\x04\x06\x01\
    \x02\x01\x12\x06\xdf\x07\x08\xe1\x07\t\n\r\n\x05\x06\x01\x02\x01\x01\x12\
    \x04\xdf\x07\x0c\x1d\n\r\n\x05\x06\x01\x02\x01\x02\x12\x04\xdf\x07\x1fC\
    \n\r\n\x05\x06\x01\x02\x01\x03\x12\x04\xdf\x07Ns\n\r\n\x05\x06\x01\x02\
    \x01\x04\x12\x04\xe0\x07\x10E\n\x10\n\x08\x06\x01\x02\x01\x04\xd0\x86\
    \x03\x12\x04\xe0\x07\x10E\n\x0e\n\x04\x06\x01\x02\x02\x12\x06\xe3\x07\
    \x08\xe5\x07\t\n\r\n\x05\x06\x01\x02\x02\x01\x12\x04\xe3\x07\x0c\x1f\n\r\
    \n\x05\x06\x01\x02\x02\x02\x12\x04\xe3\x07!G\n\r\n\x05\x06\x01\x02\x02\
    \x03\x12\x04\xe3\x07Ry\n\r\n\x05\x06\x01\x02\x02\x04\x12\x04\xe4\x07\x10\
    I\n\x10\n\x08\x06\x01\x02\x02\x04\xd0\x86\x03\x12\x04\xe4\x07\x10I\n\x0e\
    \n\x04\x06\x01\x02\x03\x12\x06\xe7\x07\x08\xe9\x07\t\n\r\n\x05\x06\x01\
    \x02\x03\x01\x12\x04\xe7\x07\x0c#\n\r\n\x05\x06\x01\x02\x03\x02\x12\x04\
    \xe7\x07%O\n\x0e\n\x05\x06\x01\x02\x03\x03\x12\x05\xe7\x07Z\x85\x01\n\r\
    \n\x05\x06\x01\x02\x03\x04\x12\x04\xe8\x07\x10R\n\x10\n\x08\x06\x01\x02\
    \x03\x04\xd0\x86\x03\x12\x04\xe8\x07\x10R\n\x0e\n\x04\x06\x01\x02\x04\
    \x12\x06\xeb\x07\x08\xed\x07\t\n\r\n\x05\x06\x01\x02\x04\x01\x12\x04\xeb\
    \x07\x0c\"\n\r\n\x05\x06\x01\x02\x04\x02\x12\x04\xeb\x07$M\n\x0e\n\x05\
    \x06\x01\x02\x04\x03\x12\x05\xeb\x07X\x82\x01\n\r\n\x05\x06\x01\x02\x04\
    \x04\x12\x04\xec\x07\x10U\n\x10\n\x08\x06\x01\x02\x04\x04\xd0\x86\x03\
    \x12\x04\xec\x07\x10U\n\x0e\n\x04\x06\x01\x02\x05\x12\x06\xef\x07\x08\
    \xf1\x07\t\n\r\n\x05\x06\x01\x02\x05\x01\x12\x04\xef\x07\x0c-\n\r\n\x05\
    \x06\x01\x02\x05\x02\x12\x04\xef\x07/c\n\x0e\n\x05\x06\x01\x02\x05\x03\
    \x12\x05\xef\x07n\xa3\x01\n\r\n\x05\x06\x01\x02\x05\x04\x12\x04\xf0\x07\
    \x10f\n\x10\n\x08\x06\x01\x02\x05\x04\xd0\x86\x03\x12\x04\xf0\x07\x10f\n\
    \x0e\n\x04\x06\x01\x02\x06\x12\x06\xf3\x07\x08\xf5\x07\t\n\r\n\x05\x06\
    \x01\x02\x06\x01\x12\x04\xf3\x07\x0c(\n\r\n\x05\x06\x01\x02\x06\x02\x12\
    \x04\xf3\x07*Y\n\x0e\n\x05\x06\x01\x02\x06\x03\x12\x05\xf3\x07d\x94\x01\
    \n\x0e\n\x05\x06\x01\x02\x06\x04\x12\x05\xf4\x07\x10\x8d\x01\n\x11\n\x08\
    \x06\x01\x02\x06\x04\xd0\x86\x03\x12\x05\xf4\x07\x10\x8d\x01\n\x0e\n\x04\
    \x06\x01\x02\x07\x12\x06\xf7\x07\x08\xf9\x07\t\n\r\n\x05\x06\x01\x02\x07\
    \x01\x12\x04\xf7\x07\x0c'\n\r\n\x05\x06\x01\x02\x07\x02\x12\x04\xf7\x07)\
    W\n\x0e\n\x05\x06\x01\x02\x07\x03\x12\x05\xf7\x07b\x91\x01\n\r\n\x05\x06\
    \x01\x02\x07\x04\x12\x04\xf8\x07\x10Y\n\x10\n\x08\x06\x01\x02\x07\x04\
    \xd0\x86\x03\x12\x04\xf8\x07\x10Y\n\x0e\n\x04\x06\x01\x02\x08\x12\x06\
    \xfb\x07\x08\xfd\x07\t\n\r\n\x05\x06\x01\x02\x08\x01\x12\x04\xfb\x07\x0c\
    \x1b\n\r\n\x05\x06\x01\x02\x08\x02\x12\x04\xfb\x07\x1d8\n\r\n\x05\x06\
    \x01\x02\x08\x03\x12\x04\xfb\x07C_\n\r\n\x05\x06\x01\x02\x08\x04\x12\x04\
    \xfc\x07\x10C\n\x10\n\x08\x06\x01\x02\x08\x04\xd0\x86\x03\x12\x04\xfc\
    \x07\x10C\n\x0e\n\x04\x06\x01\x02\t\x12\x06\xff\x07\x08\x81\x08\t\n\r\n\
    \x05\x06\x01\x02\t\x01\x12\x04\xff\x07\x0c\x1d\n\r\n\x05\x06\x01\x02\t\
    \x02\x12\x04\xff\x07\x1f:\n\r\n\x05\x06\x01\x02\t\x03\x12\x04\xff\x07Ea\
    \n\r\n\x05\x06\x01\x02\t\x04\x12\x04\x80\x08\x10E\n\x10\n\x08\x06\x01\
    \x02\t\x04\xd0\x86\x03\x12\x04\x80\x08\x10E\n\x0e\n\x04\x06\x01\x02\n\
    \x12\x06\x83\x08\x08\x85\x08\t\n\r\n\x05\x06\x01\x02\n\x01\x12\x04\x83\
    \x08\x0c\x1b\n\r\n\x05\x06\x01\x02\n\x02\x12\x04\x83\x08\x1d?\n\r\n\x05\
    \x06\x01\x02\n\x03\x12\x04\x83\x08Jm\n\r\n\x05\x06\x01\x02\n\x04\x12\x04\
    \x84\x08\x10J\n\x10\n\x08\x06\x01\x02\n\x04\xd0\x86\x03\x12\x04\x84\x08\
    \x10J\n\x0e\n\x04\x06\x01\x02\x0b\x12\x06\x87\x08\x08\x89\x08\t\n\r\n\
    \x05\x06\x01\x02\x0b\x01\x12\x04\x87\x08\x0c\x1f\n\r\n\x05\x06\x01\x02\
    \x0b\x02\x12\x04\x87\x08!@\n\r\n\x05\x06\x01\x02\x0b\x03\x12\x04\x87\x08\
    Kk\n\r\n\x05\x06\x01\x02\x0b\x04\x12\x04\x88\x08\x10U\n\x10\n\x08\x06\
    \x01\x02\x0b\x04\xd0\x86\x03\x12\x04\x88\x08\x10U\n\x0e\n\x04\x06\x01\
    \x02\x0c\x12\x06\x8b\x08\x08\x8d\x08\t\n\r\n\x05\x06\x01\x02\x0c\x01\x12\
    \x04\x8b\x08\x0c\x16\n\r\n\x05\x06\x01\x02\x0c\x02\x12\x04\x8b\x08\x185\
    \n\r\n\x05\x06\x01\x02\x0c\x03\x12\x04\x8b\x08@^\n\r\n\x05\x06\x01\x02\
    \x0c\x04\x12\x04\x8c\x08\x10E\n\x10\n\x08\x06\x01\x02\x0c\x04\xd0\x86\
    \x03\x12\x04\x8c\x08\x10E\n\x0e\n\x04\x06\x01\x02\r\x12\x06\x8f\x08\x08\
    \x91\x08\t\n\r\n\x05\x06\x01\x02\r\x01\x12\x04\x8f\x08\x0c\x14\n\r\n\x05\
    \x06\x01\x02\r\x02\x12\x04\x8f\x08\x161\n\r\n\x05\x06\x01\x02\r\x03\x12\
    \x04\x8f\x08<X\n\r\n\x05\x06\x01\x02\r\x04\x12\x04\x90\x08\x10G\n\x10\n\
    \x08\x06\x01\x02\r\x04\xd0\x86\x03\x12\x04\x90\x08\x10G\n\x0e\n\x04\x06\
    \x01\x02\x0e\x12\x06\x93\x08\x08\x95\x08\t\n\r\n\x05\x06\x01\x02\x0e\x01\
    \x12\x04\x93\x08\x0c\x16\n\r\n\x05\x06\x01\x02\x0e\x02\x12\x04\x93\x08\
    \x185\n\r\n\x05\x06\x01\x02\x0e\x03\x12\x04\x93\x08@^\n\r\n\x05\x06\x01\
    \x02\x0e\x04\x12\x04\x94\x08\x10E\n\x10\n\x08\x06\x01\x02\x0e\x04\xd0\
    \x86\x03\x12\x04\x94\x08\x10E\n\x0e\n\x04\x06\x01\x02\x0f\x12\x06\x97\
    \x08\x08\x99\x08\t\n\r\n\x05\x06\x01\x02\x0f\x01\x12\x04\x97\x08\x0c\x17\
    \n\r\n\x05\x06\x01\x02\x0f\x02\x12\x04\x97\x08\x197\n\r\n\x05\x06\x01\
    \x02\x0f\x03\x12\x04\x97\x08Ba\n\r\n\x05\x06\x01\x02\x0f\x04\x12\x04\x98\
    \x08\x10I\n\x10\n\x08\x06\x01\x02\x0f\x04\xd0\x86\x03\x12\x04\x98\x08\
    \x10I\n\x0e\n\x04\x06\x01\x02\x10\x12\x06\x9b\x08\x08\x9d\x08\t\n\r\n\
    \x05\x06\x01\x02\x10\x01\x12\x04\x9b\x08\x0c\x16\n\r\n\x05\x06\x01\x02\
    \x10\x02\x12\x04\x9b\x08\x185\n\r\n\x05\x06\x01\x02\x10\x03\x12\x04\x9b\
    \x08@^\n\r\n\x05\x06\x01\x02\x10\x04\x12\x04\x9c\x08\x10G\n\x10\n\x08\
    \x06\x01\x02\x10\x04\xd0\x86\x03\x12\x04\x9c\x08\x10G\n\x0e\n\x04\x06\
    \x01\x02\x11\x12\x06\x9f\x08\x08\xa1\x08\t\n\r\n\x05\x06\x01\x02\x11\x01\
    \x12\x04\x9f\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\x11\x02\x12\x04\x9f\x08\
    \x1c=\n\r\n\x05\x06\x01\x02\x11\x03\x12\x04\x9f\x08Hj\n\r\n\x05\x06\x01\
    \x02\x11\x04\x12\x04\xa0\x08\x10[\n\x10\n\x08\x06\x01\x02\x11\x04\xd0\
    \x86\x03\x12\x04\xa0\x08\x10[\n\x0e\n\x04\x06\x01\x02\x12\x12\x06\xa3\
    \x08\x08\xa5\x08\t\n\r\n\x05\x06\x01\x02\x12\x01\x12\x04\xa3\x08\x0c\x1e\
    \n\r\n\x05\x06\x01\x02\x12\x02\x12\x04\xa3\x08\x20E\n\r\n\x05\x06\x01\
    \x02\x12\x03\x12\x04\xa3\x08Pv\n\r\n\x05\x06\x01\x02\x12\x04\x12\x04\xa4\
    \x08\x10N\n\x10\n\x08\x06\x01\x02\x12\x04\xd0\x86\x03\x12\x04\xa4\x08\
    \x10N\n\x0e\n\x04\x06\x01\x02\x13\x12\x06\xa7\x08\x08\xa9\x08\t\n\r\n\
    \x05\x06\x01\x02\x13\x01\x12\x04\xa7\x08\x0c\x19\n\r\n\x05\x06\x01\x02\
    \x13\x02\x12\x04\xa7\x08\x1b;\n\r\n\x05\x06\x01\x02\x13\x03\x12\x04\xa7\
    \x08Fg\n\r\n\x05\x06\x01\x02\x13\x04\x12\x04\xa8\x08\x10J\n\x10\n\x08\
    \x06\x01\x02\x13\x04\xd0\x86\x03\x12\x04\xa8\x08\x10J\n\x0e\n\x04\x06\
    \x01\x02\x14\x12\x06\xab\x08\x08\xad\x08\t\n\r\n\x05\x06\x01\x02\x14\x01\
    \x12\x04\xab\x08\x0c\x1b\n\r\n\x05\x06\x01\x02\x14\x02\x12\x04\xab\x08\
    \x1d?\n\r\n\x05\x06\x01\x02\x14\x03\x12\x04\xab\x08Jm\n\r\n\x05\x06\x01\
    \x02\x14\x04\x12\x04\xac\x08\x10X\n\x10\n\x08\x06\x01\x02\x14\x04\xd0\
    \x86\x03\x12\x04\xac\x08\x10X\n\x0e\n\x04\x06\x01\x02\x15\x12\x06\xaf\
    \x08\x08\xb1\x08\t\n\r\n\x05\x06\x01\x02\x15\x01\x12\x04\xaf\x08\x0c\x1e\
    \n\r\n\x05\x06\x01\x02\x15\x02\x12\x04\xaf\x08\x20E\n\r\n\x05\x06\x01\
    \x02\x15\x03\x12\x04\xaf\x08Pv\n\r\n\x05\x06\x01\x02\x15\x04\x12\x04\xb0\
    \x08\x10O\n\x10\n\x08\x06\x01\x02\x15\x04\xd0\x86\x03\x12\x04\xb0\x08\
    \x10O\n\x0e\n\x04\x06\x01\x02\x16\x12\x06\xb3\x08\x08\xb5\x08\t\n\r\n\
    \x05\x06\x01\x02\x16\x01\x12\x04\xb3\x08\x0c\x1d\n\r\n\x05\x06\x01\x02\
    \x16\x02\x12\x04\xb3\x08\x1fC\n\r\n\x05\x06\x01\x02\x16\x03\x12\x04\xb3\
    \x08Ns\n\r\n\x05\x06\x01\x02\x16\x04\x12\x04\xb4\x08\x10L\n\x10\n\x08\
    \x06\x01\x02\x16\x04\xd0\x86\x03\x12\x04\xb4\x08\x10L\n\x0e\n\x04\x06\
    \x01\x02\x17\x12\x06\xb7\x08\x08\xb9\x08\t\n\r\n\x05\x06\x01\x02\x17\x01\
    \x12\x04\xb7\x08\x0c'\n\r\n\x05\x06\x01\x02\x17\x02\x12\x04\xb7\x08)W\n\
    \x0e\n\x05\x06\x01\x02\x17\x03\x12\x05\xb7\x08b\x91\x01\n\r\n\x05\x06\
    \x01\x02\x17\x04\x12\x04\xb8\x08\x10Z\n\x10\n\x08\x06\x01\x02\x17\x04\
    \xd0\x86\x03\x12\x04\xb8\x08\x10Z\n\x0e\n\x04\x06\x01\x02\x18\x12\x06\
    \xbb\x08\x08\xbd\x08\t\n\r\n\x05\x06\x01\x02\x18\x01\x12\x04\xbb\x08\x0c\
    \x1e\n\r\n\x05\x06\x01\x02\x18\x02\x12\x04\xbb\x08\x20E\n\r\n\x05\x06\
    \x01\x02\x18\x03\x12\x04\xbb\x08Pv\n\r\n\x05\x06\x01\x02\x18\x04\x12\x04\
    \xbc\x08\x10_\n\x10\n\x08\x06\x01\x02\x18\x04\xd0\x86\x03\x12\x04\xbc\
    \x08\x10_\n\x0e\n\x04\x06\x01\x02\x19\x12\x06\xbf\x08\x08\xc1\x08\t\n\r\
    \n\x05\x06\x01\x02\x19\x01\x12\x04\xbf\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\
    \x19\x02\x12\x04\xbf\x08\x1c=\n\r\n\x05\x06\x01\x02\x19\x03\x12\x04\xbf\
    \x08Hj\n\r\n\x05\x06\x01\x02\x19\x04\x12\x04\xc0\x08\x10]\n\x10\n\x08\
    \x06\x01\x02\x19\x04\xd0\x86\x03\x12\x04\xc0\x08\x10]\n\x0e\n\x04\x06\
    \x01\x02\x1a\x12\x06\xc3\x08\x08\xc5\x08\t\n\r\n\x05\x06\x01\x02\x1a\x01\
    \x12\x04\xc3\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\x1a\x02\x12\x04\xc3\x08\
    \x1c=\n\r\n\x05\x06\x01\x02\x1a\x03\x12\x04\xc3\x08Hj\n\r\n\x05\x06\x01\
    \x02\x1a\x04\x12\x04\xc4\x08\x10]\n\x10\n\x08\x06\x01\x02\x1a\x04\xd0\
    \x86\x03\x12\x04\xc4\x08\x10]\n\x0e\n\x04\x06\x01\x02\x1b\x12\x06\xc7\
    \x08\x08\xc9\x08\t\n\r\n\x05\x06\x01\x02\x1b\x01\x12\x04\xc7\x08\x0c\x1a\
    \n\r\n\x05\x06\x01\x02\x1b\x02\x12\x04\xc7\x08\x1c=\n\r\n\x05\x06\x01\
    \x02\x1b\x03\x12\x04\xc7\x08Hj\n\r\n\x05\x06\x01\x02\x1b\x04\x12\x04\xc8\
    \x08\x10]\n\x10\n\x08\x06\x01\x02\x1b\x04\xd0\x86\x03\x12\x04\xc8\x08\
    \x10]\n\x0e\n\x04\x06\x01\x02\x1c\x12\x06\xcb\x08\x08\xcd\x08\t\n\r\n\
    \x05\x06\x01\x02\x1c\x01\x12\x04\xcb\x08\x0c\x1b\n\r\n\x05\x06\x01\x02\
    \x1c\x02\x12\x04\xcb\x08\x1d?\n\r\n\x05\x06\x01\x02\x1c\x03\x12\x04\xcb\
    \x08Jm\n\r\n\x05\x06\x01\x02\x1c\x04\x12\x04\xcc\x08\x10^\n\x10\n\x08\
    \x06\x01\x02\x1c\x04\xd0\x86\x03\x12\x04\xcc\x08\x10^\n\x0e\n\x04\x06\
    \x01\x02\x1d\x12\x06\xcf\x08\x08\xd1\x08\t\n\r\n\x05\x06\x01\x02\x1d\x01\
    \x12\x04\xcf\x08\x0c\x1b\n\r\n\x05\x06\x01\x02\x1d\x02\x12\x04\xcf\x08\
    \x1d?\n\r\n\x05\x06\x01\x02\x1d\x03\x12\x04\xcf\x08Jm\n\r\n\x05\x06\x01\
    \x02\x1d\x04\x12\x04\xd0\x08\x10^\n\x10\n\x08\x06\x01\x02\x1d\x04\xd0\
    \x86\x03\x12\x04\xd0\x08\x10^\n\x0e\n\x04\x06\x01\x02\x1e\x12\x06\xd3\
    \x08\x08\xd5\x08\t\n\r\n\x05\x06\x01\x02\x1e\x01\x12\x04\xd3\x08\x0c\x19\
    \n\r\n\x05\x06\x01\x02\x1e\x02\x12\x04\xd3\x08\x1b;\n\r\n\x05\x06\x01\
    \x02\x1e\x03\x12\x04\xd3\x08Fg\n\r\n\x05\x06\x01\x02\x1e\x04\x12\x04\xd4\
    \x08\x10~\n\x10\n\x08\x06\x01\x02\x1e\x04\xd0\x86\x03\x12\x04\xd4\x08\
    \x10~\n\x0e\n\x04\x06\x01\x02\x1f\x12\x06\xd7\x08\x08\xd9\x08\t\n\r\n\
    \x05\x06\x01\x02\x1f\x01\x12\x04\xd7\x08\x0c\x1a\n\r\n\x05\x06\x01\x02\
    \x1f\x02\x12\x04\xd7\x08\x1c=\n\r\n\x05\x06\x01\x02\x1f\x03\x12\x04\xd7\
    \x08Hj\n\r\n\x05\x06\x01\x02\x1f\x04\x12\x04\xd8\x08\x10Z\n\x10\n\x08\
    \x06\x01\x02\x1f\x04\xd0\x86\x03\x12\x04\xd8\x08\x10Z\n\x0e\n\x04\x06\
    \x01\x02\x20\x12\x06\xdb\x08\x08\xdd\x08\t\n\r\n\x05\x06\x01\x02\x20\x01\
    \x12\x04\xdb\x08\x0c\x1d\n\r\n\x05\x06\x01\x02\x20\x02\x12\x04\xdb\x08\
    \x1fC\n\r\n\x05\x06\x01\x02\x20\x03\x12\x04\xdb\x08Ns\n\x0e\n\x05\x06\
    \x01\x02\x20\x04\x12\x05\xdc\x08\x10\x8e\x01\n\x11\n\x08\x06\x01\x02\x20\
    \x04\xd0\x86\x03\x12\x05\xdc\x08\x10\x8e\x01\n\x0e\n\x04\x06\x01\x02!\
    \x12\x06\xdf\x08\x08\xe1\x08\t\n\r\n\x05\x06\x01\x02!\x01\x12\x04\xdf\
    \x08\x0c\x1f\n\r\n\x05\x06\x01\x02!\x02\x12\x04\xdf\x08!G\n\r\n\x05\x06\
    \x01\x02!\x03\x12\x04\xdf\x08Ry\n\r\n\x05\x06\x01\x02!\x04\x12\x04\xe0\
    \x08\x10M\n\x10\n\x08\x06\x01\x02!\x04\xd0\x86\x03\x12\x04\xe0\x08\x10M\
    \n\x0e\n\x04\x06\x01\x02\"\x12\x06\xe3\x08\x08\xe5\x08\t\n\r\n\x05\x06\
    \x01\x02\"\x01\x12\x04\xe3\x08\x0c!\n\r\n\x05\x06\x01\x02\"\x02\x12\x04\
    \xe3\x08#K\n\r\n\x05\x06\x01\x02\"\x03\x12\x04\xe3\x08V\x7f\n\r\n\x05\
    \x06\x01\x02\"\x04\x12\x04\xe4\x08\x10Y\n\x10\n\x08\x06\x01\x02\"\x04\
    \xd0\x86\x03\x12\x04\xe4\x08\x10Y\n\x0e\n\x04\x06\x01\x02#\x12\x06\xe7\
    \x08\x08\xe9\x08\t\n\r\n\x05\x06\x01\x02#\x01\x12\x04\xe7\x08\x0c#\n\r\n\
    \x05\x06\x01\x02#\x02\x12\x04\xe7\x08%O\n\x0e\n\x05\x06\x01\x02#\x03\x12\
    \x05\xe7\x08Z\x85\x01\n\r\n\x05\x06\x01\x02#\x04\x12\x04\xe8\x08\x10^\n\
    \x10\n\x08\x06\x01\x02#\x04\xd0\x86\x03\x12\x04\xe8\x08\x10^\n\x0e\n\x04\
    \x06\x01\x02$\x12\x06\xeb\x08\x08\xed\x08\t\n\r\n\x05\x06\x01\x02$\x01\
    \x12\x04\xeb\x08\x0c*\n\r\n\x05\x06\x01\x02$\x02\x12\x04\xeb\x08,]\n\x0e\
    \n\x05\x06\x01\x02$\x03\x12\x05\xeb\x08h\x9a\x01\n\r\n\x05\x06\x01\x02$\
    \x04\x12\x04\xec\x08\x10w\n\x10\n\x08\x06\x01\x02$\x04\xd0\x86\x03\x12\
    \x04\xec\x08\x10w\n\x0e\n\x04\x06\x01\x02%\x12\x06\xef\x08\x08\xf1\x08\t\
    \n\r\n\x05\x06\x01\x02%\x01\x12\x04\xef\x08\x0c.\n\r\n\x05\x06\x01\x02%\
    \x02\x12\x04\xef\x080j\n\x0e\n\x05\x06\x01\x02%\x03\x12\x05\xef\x08u\x80\
    \x01\n\x0e\n\x05\x06\x01\x02%\x04\x12\x05\xf0\x08\x10\x91\x01\n\x11\n\
    \x08\x06\x01\x02%\x04\xd0\x86\x03\x12\x05\xf0\x08\x10\x91\x01\n\x0e\n\
    \x04\x06\x01\x02&\x12\x06\xf3\x08\x08\xf5\x08\t\n\r\n\x05\x06\x01\x02&\
    \x01\x12\x04\xf3\x08\x0c\x1a\n\r\n\x05\x06\x01\x02&\x02\x12\x04\xf3\x08\
    \x1cB\n\r\n\x05\x06\x01\x02&\x03\x12\x04\xf3\x08MX\n\r\n\x05\x06\x01\x02\
    &\x04\x12\x04\xf4\x08\x10u\n\x10\n\x08\x06\x01\x02&\x04\xd0\x86\x03\x12\
    \x04\xf4\x08\x10u\n\x0e\n\x04\x06\x01\x02'\x12\x06\xf7\x08\x08\xf9\x08\t\
    \n\r\n\x05\x06\x01\x02'\x01\x12\x04\xf7\x08\x0c\x1c\n\r\n\x05\x06\x01\
    \x02'\x02\x12\x04\xf7\x08\x1eA\n\r\n\x05\x06\x01\x02'\x03\x12\x04\xf7\
    \x08Lp\n\r\n\x05\x06\x01\x02'\x04\x12\x04\xf8\x08\x10O\n\x10\n\x08\x06\
    \x01\x02'\x04\xd0\x86\x03\x12\x04\xf8\x08\x10O\n\x0e\n\x04\x06\x01\x02(\
    \x12\x06\xfb\x08\x08\xfd\x08\t\n\r\n\x05\x06\x01\x02(\x01\x12\x04\xfb\
    \x08\x0c\x1d\n\r\n\x05\x06\x01\x02(\x02\x12\x04\xfb\x08\x1fC\n\r\n\x05\
    \x06\x01\x02(\x03\x12\x04\xfb\x08Ns\n\r\n\x05\x06\x01\x02(\x04\x12\x04\
    \xfc\x08\x10[\n\x10\n\x08\x06\x01\x02(\x04\xd0\x86\x03\x12\x04\xfc\x08\
    \x10[\n\x0e\n\x04\x06\x01\x02)\x12\x06\xff\x08\x08\x81\t\t\n\r\n\x05\x06\
    \x01\x02)\x01\x12\x04\xff\x08\x0c\x19\n\r\n\x05\x06\x01\x02)\x02\x12\x04\
    \xff\x08\x1b;\n\r\n\x05\x06\x01\x02)\x03\x12\x04\xff\x08Fg\n\x0e\n\x05\
    \x06\x01\x02)\x04\x12\x05\x80\t\x10\x81\x01\n\x11\n\x08\x06\x01\x02)\x04\
    \xd0\x86\x03\x12\x05\x80\t\x10\x81\x01\n\x0e\n\x04\x06\x01\x02*\x12\x06\
    \x83\t\x08\x85\t\t\n\r\n\x05\x06\x01\x02*\x01\x12\x04\x83\t\x0c\"\n\r\n\
    \x05\x06\x01\x02*\x02\x12\x04\x83\t$M\n\x0e\n\x05\x06\x01\x02*\x03\x12\
    \x05\x83\tX\x82\x01\n\r\n\x05\x06\x01\x02*\x04\x12\x04\x84\t\x10a\n\x10\
    \n\x08\x06\x01\x02*\x04\xd0\x86\x03\x12\x04\x84\t\x10a\n\x0e\n\x04\x06\
    \x01\x02+\x12\x06\x87\t\x08\x89\t\t\n\r\n\x05\x06\x01\x02+\x01\x12\x04\
    \x87\t\x0c\x16\n\r\n\x05\x06\x01\x02+\x02\x12\x04\x87\t\x185\n\r\n\x05\
    \x06\x01\x02+\x03\x12\x04\x87\t@^\n\r\n\x05\x06\x01\x02+\x04\x12\x04\x88\
    \t\x10k\n\x10\n\x08\x06\x01\x02+\x04\xd0\x86\x03\x12\x04\x88\t\x10k\n\
    \x0e\n\x04\x06\x01\x02,\x12\x06\x8b\t\x08\x8d\t\t\n\r\n\x05\x06\x01\x02,\
    \x01\x12\x04\x8b\t\x0c\x19\n\r\n\x05\x06\x01\x02,\x02\x12\x04\x8b\t\x1b;\
    \n\r\n\x05\x06\x01\x02,\x03\x12\x04\x8b\tFg\n\r\n\x05\x06\x01\x02,\x04\
    \x12\x04\x8c\t\x10j\n\x10\n\x08\x06\x01\x02,\x04\xd0\x86\x03\x12\x04\x8c\
    \t\x10j\n\x0e\n\x04\x06\x01\x02-\x12\x06\x8f\t\x08\x91\t\t\n\r\n\x05\x06\
    \x01\x02-\x01\x12\x04\x8f\t\x0c\x1c\n\r\n\x05\x06\x01\x02-\x02\x12\x04\
    \x8f\t\x1eA\n\r\n\x05\x06\x01\x02-\x03\x12\x04\x8f\tLp\n\r\n\x05\x06\x01\
    \x02-\x04\x12\x04\x90\t\x10N\n\x10\n\x08\x06\x01\x02-\x04\xd0\x86\x03\
    \x12\x04\x90\t\x10N\n\x0e\n\x04\x06\x01\x02.\x12\x06\x93\t\x08\x95\t\t\n\
    \r\n\x05\x06\x01\x02.\x01\x12\x04\x93\t\x0c*\n\r\n\x05\x06\x01\x02.\x02\
    \x12\x04\x93\t,]\n\x0e\n\x05\x06\x01\x02.\x03\x12\x05\x93\th\x9a\x01\n\r\
    \n\x05\x06\x01\x02.\x04\x12\x04\x94\t\x10h\n\x10\n\x08\x06\x01\x02.\x04\
    \xd0\x86\x03\x12\x04\x94\t\x10h\n\x0e\n\x04\x06\x01\x02/\x12\x06\x97\t\
    \x08\x99\t\t\n\r\n\x05\x06\x01\x02/\x01\x12\x04\x97\t\x0c'\n\r\n\x05\x06\
    \x01\x02/\x02\x12\x04\x97\t)W\n\x0e\n\x05\x06\x01\x02/\x03\x12\x05\x97\t\
    b\x91\x01\n\r\n\x05\x06\x01\x02/\x04\x12\x04\x98\t\x10f\n\x10\n\x08\x06\
    \x01\x02/\x04\xd0\x86\x03\x12\x04\x98\t\x10f\n\x0e\n\x04\x06\x01\x020\
    \x12\x06\x9b\t\x08\x9d\t\t\n\r\n\x05\x06\x01\x020\x01\x12\x04\x9b\t\x0c\
    \x1e\n\r\n\x05\x06\x01\x020\x02\x12\x04\x9b\t\x20E\n\r\n\x05\x06\x01\x02\
    0\x03\x12\x04\x9b\tPv\n\r\n\x05\x06\x01\x020\x04\x12\x04\x9c\t\x10P\n\
    \x10\n\x08\x06\x01\x020\x04\xd0\x86\x03\x12\x04\x9c\t\x10P\n\x0e\n\x04\
    \x06\x01\x021\x12\x06\x9f\t\x08\xa1\t\t\n\r\n\x05\x06\x01\x021\x01\x12\
    \x04\x9f\t\x0c\x20\n\r\n\x05\x06\x01\x021\x02\x12\x04\x9f\t\"N\n\r\n\x05\
    \x06\x01\x021\x03\x12\x04\x9f\tYd\n\r\n\x05\x06\x01\x021\x04\x12\x04\xa0\
    \t\x10t\n\x10\n\x08\x06\x01\x021\x04\xd0\x86\x03\x12\x04\xa0\t\x10t\n\
    \x0e\n\x04\x06\x01\x022\x12\x06\xa3\t\x08\xa5\t\t\n\r\n\x05\x06\x01\x022\
    \x01\x12\x04\xa3\t\x0c\x19\n\r\n\x05\x06\x01\x022\x02\x12\x04\xa3\t\x1b;\
    \n\r\n\x05\x06\x01\x022\x03\x12\x04\xa3\tFg\n\r\n\x05\x06\x01\x022\x04\
    \x12\x04\xa4\t\x10R\n\x10\n\x08\x06\x01\x022\x04\xd0\x86\x03\x12\x04\xa4\
    \t\x10R\n\x0e\n\x04\x06\x01\x023\x12\x06\xa7\t\x08\xa9\t\t\n\r\n\x05\x06\
    \x01\x023\x01\x12\x04\xa7\t\x0c!\n\r\n\x05\x06\x01\x023\x02\x12\x04\xa7\
    \t#K\n\r\n\x05\x06\x01\x023\x03\x12\x04\xa7\tV\x7f\n\r\n\x05\x06\x01\x02\
    3\x04\x12\x04\xa8\t\x10d\n\x10\n\x08\x06\x01\x023\x04\xd0\x86\x03\x12\
    \x04\xa8\t\x10d\n\x0e\n\x04\x06\x01\x024\x12\x06\xab\t\x08\xad\t\t\n\r\n\
    \x05\x06\x01\x024\x01\x12\x04\xab\t\x0c&\n\r\n\x05\x06\x01\x024\x02\x12\
    \x04\xab\t(U\n\x0e\n\x05\x06\x01\x024\x03\x12\x05\xab\t`\x8e\x01\n\r\n\
    \x05\x06\x01\x024\x04\x12\x04\xac\t\x10d\n\x10\n\x08\x06\x01\x024\x04\
    \xd0\x86\x03\x12\x04\xac\t\x10d\n\x0c\n\x02\x06\x02\x12\x06\xb0\t\0\xba\
    \t\x01\n\x0b\n\x03\x06\x02\x01\x12\x04\xb0\t\x08\x15\n\x0b\n\x03\x06\x02\
    \x03\x12\x04\xb1\t\x08S\n\x0e\n\x06\x06\x02\x03\xd0\x86\x03\x12\x04\xb1\
    \t\x08S\n\x0e\n\x04\x06\x02\x02\0\x12\x06\xb3\t\x08\xb5\t\t\n\r\n\x05\
    \x06\x02\x02\0\x01\x12\x04\xb3\t\x0c\x1f\n\r\n\x05\x06\x02\x02\0\x02\x12\
    \x04\xb3\t!L\n\x0e\n\x05\x06\x02\x02\0\x03\x12\x05\xb3\tW\x83\x01\n\r\n\
    \x05\x06\x02\x02\0\x04\x12\x04\xb4\t\x10s\n\x10\n\x08\x06\x02\x02\0\x04\
    \xd0\x86\x03\x12\x04\xb4\t\x10s\n\x0e\n\x04\x06\x02\x02\x01\x12\x06\xb7\
    \t\x08\xb9\t\t\n\r\n\x05\x06\x02\x02\x01\x01\x12\x04\xb7\t\x0c\"\n\r\n\
    \x05\x06\x02\x02\x01\x02\x12\x04\xb7\t$R\n\x0e\n\x05\x06\x02\x02\x01\x03\
    \x12\x05\xb7\t]\x8c\x01\n\r\n\x05\x06\x02\x02\x01\x04\x12\x04\xb8\t\x10d\
    \n\x10\n\x08\x06\x02\x02\x01\x04\xd0\x86\x03\x12\x04\xb8\t\x10d\n\x0c\n\
    \x02\x06\x03\x12\x06\xbc\t\0\xeb\t\x01\n\x0b\n\x03\x06\x03\x01\x12\x04\
    \xbc\t\x08\x16\n\x0b\n\x03\x06\x03\x03\x12\x04\xbd\t\x08N\n\x0e\n\x06\
    \x06\x03\x03\xd0\x86\x03\x12\x04\xbd\t\x08N\n\x0b\n\x03\x06\x03\x03\x12\
    \x04\xbe\t\x08K\n\x0e\n\x06\x06\x03\x03\xd8\x86\x03\x12\x04\xbe\t\x08K\n\
    \x0e\n\x04\x06\x03\x02\0\x12\x06\xc0\t\x08\xc2\t\t\n\r\n\x05\x06\x03\x02\
    \0\x01\x12\x04\xc0\t\x0c%\n\r\n\x05\x06\x03\x02\0\x02\x12\x04\xc0\t'R\n\
    \r\n\x05\x06\x03\x02\0\x03\x12\x04\xc0\t]h\n\r\n\x05\x06\x03\x02\0\x04\
    \x12\x04\xc1\t\x10Q\n\x10\n\x08\x06\x03\x02\0\x04\xd0\x86\x03\x12\x04\
    \xc1\t\x10Q\n\x0e\n\x04\x06\x03\x02\x01\x12\x06\xc4\t\x08\xc6\t\t\n\r\n\
    \x05\x06\x03\x02\x01\x01\x12\x04\xc4\t\x0c%\n\r\n\x05\x06\x03\x02\x01\
    \x02\x12\x04\xc4\t'R\n\r\n\x05\x06\x03\x02\x01\x03\x12\x04\xc4\t]h\n\r\n\
    \x05\x06\x03\x02\x01\x04\x12\x04\xc5\t\x10j\n\x10\n\x08\x06\x03\x02\x01\
    \x04\xd0\x86\x03\x12\x04\xc5\t\x10j\n\x0e\n\x04\x06\x03\x02\x02\x12\x06\
    \xc8\t\x08\xca\t\t\n\r\n\x05\x06\x03\x02\x02\x01\x12\x04\xc8\t\x0c#\n\r\
    \n\x05\x06\x03\x02\x02\x02\x12\x04\xc8\t%N\n\r\n\x05\x06\x03\x02\x02\x03\
    \x12\x04\xc8\tYd\n\r\n\x05\x06\x03\x02\x02\x04\x12\x04\xc9\t\x10o\n\x10\
    \n\x08\x06\x03\x02\x02\x04\xd0\x86\x03\x12\x04\xc9\t\x10o\n\x0e\n\x04\
    \x06\x03\x02\x03\x12\x06\xcc\t\x08\xce\t\t\n\r\n\x05\x06\x03\x02\x03\x01\
    \x12\x04\xcc\t\x0c+\n\r\n\x05\x06\x03\x02\x03\x02\x12\x04\xcc\t-X\n\r\n\
    \x05\x06\x03\x02\x03\x03\x12\x04\xcc\tcn\n\r\n\x05\x06\x03\x02\x03\x04\
    \x12\x04\xcd\t\x10X\n\x10\n\x08\x06\x03\x02\x03\x04\xd0\x86\x03\x12\x04\
    \xcd\t\x10X\n\x0e\n\x04\x06\x03\x02\x04\x12\x06\xd0\t\x08\xd2\t\t\n\r\n\
    \x05\x06\x03\x02\x04\x01\x12\x04\xd0\t\x0c*\n\r\n\x05\x06\x03\x02\x04\
    \x02\x12\x04\xd0\t,\\\n\r\n\x05\x06\x03\x02\x04\x03\x12\x04\xd0\tgr\n\r\
    \n\x05\x06\x03\x02\x04\x04\x12\x04\xd1\t\x10r\n\x10\n\x08\x06\x03\x02\
    \x04\x04\xd0\x86\x03\x12\x04\xd1\t\x10r\n\x0e\n\x04\x06\x03\x02\x05\x12\
    \x06\xd4\t\x08\xd6\t\t\n\r\n\x05\x06\x03\x02\x05\x01\x12\x04\xd4\t\x0c/\
    \n\r\n\x05\x06\x03\x02\x05\x02\x12\x04\xd4\t1l\n\x0e\n\x05\x06\x03\x02\
    \x05\x03\x12\x05\xd4\tw\x82\x01\n\x0e\n\x05\x06\x03\x02\x05\x04\x12\x05\
    \xd5\t\x10\x91\x01\n\x11\n\x08\x06\x03\x02\x05\x04\xd0\x86\x03\x12\x05\
    \xd5\t\x10\x91\x01\n\x0e\n\x04\x06\x03\x02\x06\x12\x06\xd8\t\x08\xda\t\t\
    \n\r\n\x05\x06\x03\x02\x06\x01\x12\x04\xd8\t\x0c+\n\r\n\x05\x06\x03\x02\
    \x06\x02\x12\x04\xd8\t-i\n\r\n\x05\x06\x03\x02\x06\x03\x12\x04\xd8\tt\
    \x7f\n\r\n\x05\x06\x03\x02\x06\x04\x12\x04\xd9\t\x10r\n\x10\n\x08\x06\
    \x03\x02\x06\x04\xd0\x86\x03\x12\x04\xd9\t\x10r\n\x0e\n\x04\x06\x03\x02\
    \x07\x12\x06\xdc\t\x08\xde\t\t\n\r\n\x05\x06\x03\x02\x07\x01\x12\x04\xdc\
    \t\x0c$\n\r\n\x05\x06\x03\x02\x07\x02\x12\x04\xdc\t&L\n\r\n\x05\x06\x03\
    \x02\x07\x03\x12\x04\xdc\tWb\n\r\n\x05\x06\x03\x02\x07\x04\x12\x04\xdd\t\
    \x10k\n\x10\n\x08\x06\x03\x02\x07\x04\xd0\x86\x03\x12\x04\xdd\t\x10k\n\
    \x0e\n\x04\x06\x03\x02\x08\x12\x06\xe0\t\x08\xe2\t\t\n\r\n\x05\x06\x03\
    \x02\x08\x01\x12\x04\xe0\t\x0c$\n\r\n\x05\x06\x03\x02\x08\x02\x12\x04\
    \xe0\t&[\n\r\n\x05\x06\x03\x02\x08\x03\x12\x04\xe0\tfq\n\x0e\n\x05\x06\
    \x03\x02\x08\x04\x12\x05\xe1\t\x10\xb8\x01\n\x11\n\x08\x06\x03\x02\x08\
    \x04\xd0\x86\x03\x12\x05\xe1\t\x10\xb8\x01\n\x0e\n\x04\x06\x03\x02\t\x12\
    \x06\xe4\t\x08\xe6\t\t\n\r\n\x05\x06\x03\x02\t\x01\x12\x04\xe4\t\x0c'\n\
    \r\n\x05\x06\x03\x02\t\x02\x12\x04\xe4\t)\\\n\r\n\x05\x06\x03\x02\t\x03\
    \x12\x04\xe4\tgr\n\x0e\n\x05\x06\x03\x02\t\x04\x12\x05\xe5\t\x10\xa1\x01\
    \n\x11\n\x08\x06\x03\x02\t\x04\xd0\x86\x03\x12\x05\xe5\t\x10\xa1\x01\n\
    \x0e\n\x04\x06\x03\x02\n\x12\x06\xe8\t\x08\xea\t\t\n\r\n\x05\x06\x03\x02\
    \n\x01\x12\x04\xe8\t\x0c!\n\r\n\x05\x06\x03\x02\n\x02\x12\x04\xe8\t#J\n\
    \r\n\x05\x06\x03\x02\n\x03\x12\x04\xe8\tU`\n\r\n\x05\x06\x03\x02\n\x04\
    \x12\x04\xe9\t\x10E\n\x10\n\x08\x06\x03\x02\n\x04\xd0\x86\x03\x12\x04\
    \xe9\t\x10E\n\x0c\n\x02\x06\x04\x12\x06\xed\t\0\xf3\t\x01\n\x0b\n\x03\
    \x06\x04\x01\x12\x04\xed\t\x08\x15\n\x0b\n\x03\x06\x04\x03\x12\x04\xee\t\
    \x08N\n\x0e\n\x06\x06\x04\x03\xd0\x86\x03\x12\x04\xee\t\x08N\n\x0e\n\x04\
    \x06\x04\x02\0\x12\x06\xf0\t\x08\xf2\t\t\n\r\n\x05\x06\x04\x02\0\x01\x12\
    \x04\xf0\t\x0c(\n\r\n\x05\x06\x04\x02\0\x02\x12\x04\xf0\t*]\n\r\n\x05\
    \x06\x04\x02\0\x03\x12\x04\xf0\ths\n\r\n\x05\x06\x04\x02\0\x04\x12\x04\
    \xf1\t\x10Q\n\x10\n\x08\x06\x04\x02\0\x04\xd0\x86\x03\x12\x04\xf1\t\x10Q\
    \n\x0c\n\x02\x06\x05\x12\x06\xf5\t\0\xfc\t\x01\n\x0b\n\x03\x06\x05\x01\
    \x12\x04\xf5\t\x08\x1b\n\x0b\n\x03\x06\x05\x03\x12\x04\xf6\t\x08Q\n\x0e\
    \n\x06\x06\x05\x03\xd0\x86\x03\x12\x04\xf6\t\x08Q\n\x0b\n\x03\x06\x05\
    \x03\x12\x04\xf7\t\x08K\n\x0e\n\x06\x06\x05\x03\xd8\x86\x03\x12\x04\xf7\
    \t\x08K\n\x0e\n\x04\x06\x05\x02\0\x12\x06\xf9\t\x08\xfb\t\t\n\r\n\x05\
    \x06\x05\x02\0\x01\x12\x04\xf9\t\x0c/\n\r\n\x05\x06\x05\x02\0\x02\x12\
    \x04\xf9\t1k\n\x0e\n\x05\x06\x05\x02\0\x03\x12\x05\xf9\tv\x81\x01\n\r\n\
    \x05\x06\x05\x02\0\x04\x12\x04\xfa\t\x10V\n\x10\n\x08\x06\x05\x02\0\x04\
    \xd0\x86\x03\x12\x04\xfa\t\x10V\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
