// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_broadcast.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_BeginBroadcastSession_Request {
    // message fields
    permission: ::std::option::Option<i32>,
    gameid: ::std::option::Option<u64>,
    client_instance_id: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    cellid: ::std::option::Option<u32>,
    rtmp_token: ::std::option::Option<u64>,
    thumbnail_upload: ::std::option::Option<bool>,
    client_beta: ::protobuf::SingularField<::std::string::String>,
    sysid: ::std::option::Option<u32>,
    allow_webrtc: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BeginBroadcastSession_Request {
    fn default() -> &'a CBroadcast_BeginBroadcastSession_Request {
        <CBroadcast_BeginBroadcastSession_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BeginBroadcastSession_Request {
    pub fn new() -> CBroadcast_BeginBroadcastSession_Request {
        ::std::default::Default::default()
    }

    // optional int32 permission = 1;


    pub fn get_permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 2;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint64 client_instance_id = 3;


    pub fn get_client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }
    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    // optional string title = 4;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 cellid = 5;


    pub fn get_cellid(&self) -> u32 {
        self.cellid.unwrap_or(0)
    }
    pub fn clear_cellid(&mut self) {
        self.cellid = ::std::option::Option::None;
    }

    pub fn has_cellid(&self) -> bool {
        self.cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cellid(&mut self, v: u32) {
        self.cellid = ::std::option::Option::Some(v);
    }

    // optional uint64 rtmp_token = 6;


    pub fn get_rtmp_token(&self) -> u64 {
        self.rtmp_token.unwrap_or(0)
    }
    pub fn clear_rtmp_token(&mut self) {
        self.rtmp_token = ::std::option::Option::None;
    }

    pub fn has_rtmp_token(&self) -> bool {
        self.rtmp_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_token(&mut self, v: u64) {
        self.rtmp_token = ::std::option::Option::Some(v);
    }

    // optional bool thumbnail_upload = 7;


    pub fn get_thumbnail_upload(&self) -> bool {
        self.thumbnail_upload.unwrap_or(false)
    }
    pub fn clear_thumbnail_upload(&mut self) {
        self.thumbnail_upload = ::std::option::Option::None;
    }

    pub fn has_thumbnail_upload(&self) -> bool {
        self.thumbnail_upload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload(&mut self, v: bool) {
        self.thumbnail_upload = ::std::option::Option::Some(v);
    }

    // optional string client_beta = 8;


    pub fn get_client_beta(&self) -> &str {
        match self.client_beta.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_beta(&mut self) {
        self.client_beta.clear();
    }

    pub fn has_client_beta(&self) -> bool {
        self.client_beta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_beta(&mut self, v: ::std::string::String) {
        self.client_beta = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_beta(&mut self) -> &mut ::std::string::String {
        if self.client_beta.is_none() {
            self.client_beta.set_default();
        }
        self.client_beta.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_beta(&mut self) -> ::std::string::String {
        self.client_beta.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 sysid = 9;


    pub fn get_sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }
    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }

    // optional bool allow_webrtc = 10;


    pub fn get_allow_webrtc(&self) -> bool {
        self.allow_webrtc.unwrap_or(false)
    }
    pub fn clear_allow_webrtc(&mut self) {
        self.allow_webrtc = ::std::option::Option::None;
    }

    pub fn has_allow_webrtc(&self) -> bool {
        self.allow_webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_webrtc(&mut self, v: bool) {
        self.allow_webrtc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BeginBroadcastSession_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.client_instance_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cellid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rtmp_token = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.thumbnail_upload = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_beta)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sysid = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_webrtc = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_instance_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.cellid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtmp_token {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbnail_upload {
            my_size += 2;
        }
        if let Some(ref v) = self.client_beta.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.sysid {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.allow_webrtc {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permission {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.cellid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rtmp_token {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.thumbnail_upload {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.client_beta.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.allow_webrtc {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_BeginBroadcastSession_Request {
        CBroadcast_BeginBroadcastSession_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "permission",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.permission },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gameid",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.gameid },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "client_instance_id",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.client_instance_id },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.client_instance_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.title },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cellid",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.cellid },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.cellid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rtmp_token",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.rtmp_token },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.rtmp_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "thumbnail_upload",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.thumbnail_upload },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.thumbnail_upload },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_beta",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.client_beta },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.client_beta },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sysid",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.sysid },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.sysid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_webrtc",
                |m: &CBroadcast_BeginBroadcastSession_Request| { &m.allow_webrtc },
                |m: &mut CBroadcast_BeginBroadcastSession_Request| { &mut m.allow_webrtc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_BeginBroadcastSession_Request>(
                "CBroadcast_BeginBroadcastSession_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_BeginBroadcastSession_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_BeginBroadcastSession_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_BeginBroadcastSession_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_BeginBroadcastSession_Request {
    fn clear(&mut self) {
        self.permission = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.client_instance_id = ::std::option::Option::None;
        self.title.clear();
        self.cellid = ::std::option::Option::None;
        self.rtmp_token = ::std::option::Option::None;
        self.thumbnail_upload = ::std::option::Option::None;
        self.client_beta.clear();
        self.sysid = ::std::option::Option::None;
        self.allow_webrtc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_BeginBroadcastSession_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_BeginBroadcastSession_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_BeginBroadcastSession_Response {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    thumbnail_upload_address: ::protobuf::SingularField<::std::string::String>,
    thumbnail_upload_token: ::protobuf::SingularField<::std::string::String>,
    thumbnail_interval_seconds: ::std::option::Option<u32>,
    heartbeat_interval_seconds: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BeginBroadcastSession_Response {
    fn default() -> &'a CBroadcast_BeginBroadcastSession_Response {
        <CBroadcast_BeginBroadcastSession_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BeginBroadcastSession_Response {
    pub fn new() -> CBroadcast_BeginBroadcastSession_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_upload_address = 2;


    pub fn get_thumbnail_upload_address(&self) -> &str {
        match self.thumbnail_upload_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbnail_upload_address(&mut self) {
        self.thumbnail_upload_address.clear();
    }

    pub fn has_thumbnail_upload_address(&self) -> bool {
        self.thumbnail_upload_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload_address(&mut self, v: ::std::string::String) {
        self.thumbnail_upload_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_upload_address(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_upload_address.is_none() {
            self.thumbnail_upload_address.set_default();
        }
        self.thumbnail_upload_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_upload_address(&mut self) -> ::std::string::String {
        self.thumbnail_upload_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbnail_upload_token = 3;


    pub fn get_thumbnail_upload_token(&self) -> &str {
        match self.thumbnail_upload_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbnail_upload_token(&mut self) {
        self.thumbnail_upload_token.clear();
    }

    pub fn has_thumbnail_upload_token(&self) -> bool {
        self.thumbnail_upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload_token(&mut self, v: ::std::string::String) {
        self.thumbnail_upload_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_upload_token(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_upload_token.is_none() {
            self.thumbnail_upload_token.set_default();
        }
        self.thumbnail_upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_upload_token(&mut self) -> ::std::string::String {
        self.thumbnail_upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 thumbnail_interval_seconds = 4;


    pub fn get_thumbnail_interval_seconds(&self) -> u32 {
        self.thumbnail_interval_seconds.unwrap_or(0)
    }
    pub fn clear_thumbnail_interval_seconds(&mut self) {
        self.thumbnail_interval_seconds = ::std::option::Option::None;
    }

    pub fn has_thumbnail_interval_seconds(&self) -> bool {
        self.thumbnail_interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_interval_seconds(&mut self, v: u32) {
        self.thumbnail_interval_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 heartbeat_interval_seconds = 5;


    pub fn get_heartbeat_interval_seconds(&self) -> u32 {
        self.heartbeat_interval_seconds.unwrap_or(0)
    }
    pub fn clear_heartbeat_interval_seconds(&mut self) {
        self.heartbeat_interval_seconds = ::std::option::Option::None;
    }

    pub fn has_heartbeat_interval_seconds(&self) -> bool {
        self.heartbeat_interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_interval_seconds(&mut self, v: u32) {
        self.heartbeat_interval_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BeginBroadcastSession_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnail_upload_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnail_upload_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.thumbnail_interval_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.heartbeat_interval_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(ref v) = self.thumbnail_upload_address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.thumbnail_upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.thumbnail_interval_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.thumbnail_upload_address.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.thumbnail_upload_token.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.thumbnail_interval_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_BeginBroadcastSession_Response {
        CBroadcast_BeginBroadcastSession_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_BeginBroadcastSession_Response| { &m.broadcast_id },
                |m: &mut CBroadcast_BeginBroadcastSession_Response| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_upload_address",
                |m: &CBroadcast_BeginBroadcastSession_Response| { &m.thumbnail_upload_address },
                |m: &mut CBroadcast_BeginBroadcastSession_Response| { &mut m.thumbnail_upload_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_upload_token",
                |m: &CBroadcast_BeginBroadcastSession_Response| { &m.thumbnail_upload_token },
                |m: &mut CBroadcast_BeginBroadcastSession_Response| { &mut m.thumbnail_upload_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "thumbnail_interval_seconds",
                |m: &CBroadcast_BeginBroadcastSession_Response| { &m.thumbnail_interval_seconds },
                |m: &mut CBroadcast_BeginBroadcastSession_Response| { &mut m.thumbnail_interval_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "heartbeat_interval_seconds",
                |m: &CBroadcast_BeginBroadcastSession_Response| { &m.heartbeat_interval_seconds },
                |m: &mut CBroadcast_BeginBroadcastSession_Response| { &mut m.heartbeat_interval_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_BeginBroadcastSession_Response>(
                "CBroadcast_BeginBroadcastSession_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_BeginBroadcastSession_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_BeginBroadcastSession_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_BeginBroadcastSession_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_BeginBroadcastSession_Response {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.thumbnail_upload_address.clear();
        self.thumbnail_upload_token.clear();
        self.thumbnail_interval_seconds = ::std::option::Option::None;
        self.heartbeat_interval_seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_BeginBroadcastSession_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_BeginBroadcastSession_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_EndBroadcastSession_Request {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_EndBroadcastSession_Request {
    fn default() -> &'a CBroadcast_EndBroadcastSession_Request {
        <CBroadcast_EndBroadcastSession_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_EndBroadcastSession_Request {
    pub fn new() -> CBroadcast_EndBroadcastSession_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_EndBroadcastSession_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_EndBroadcastSession_Request {
        CBroadcast_EndBroadcastSession_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_EndBroadcastSession_Request| { &m.broadcast_id },
                |m: &mut CBroadcast_EndBroadcastSession_Request| { &mut m.broadcast_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_EndBroadcastSession_Request>(
                "CBroadcast_EndBroadcastSession_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_EndBroadcastSession_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_EndBroadcastSession_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_EndBroadcastSession_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_EndBroadcastSession_Request {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_EndBroadcastSession_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_EndBroadcastSession_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_EndBroadcastSession_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_EndBroadcastSession_Response {
    fn default() -> &'a CBroadcast_EndBroadcastSession_Response {
        <CBroadcast_EndBroadcastSession_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_EndBroadcastSession_Response {
    pub fn new() -> CBroadcast_EndBroadcastSession_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_EndBroadcastSession_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_EndBroadcastSession_Response {
        CBroadcast_EndBroadcastSession_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_EndBroadcastSession_Response>(
                "CBroadcast_EndBroadcastSession_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_EndBroadcastSession_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_EndBroadcastSession_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_EndBroadcastSession_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_EndBroadcastSession_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_EndBroadcastSession_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_EndBroadcastSession_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_StartBroadcastUpload_Request {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    cellid: ::std::option::Option<u32>,
    as_rtmp: ::std::option::Option<bool>,
    delay_seconds: ::std::option::Option<u32>,
    rtmp_token: ::std::option::Option<u64>,
    upload_ip_address: ::std::option::Option<u32>,
    is_replay: ::std::option::Option<bool>,
    sysid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBroadcastUpload_Request {
    fn default() -> &'a CBroadcast_StartBroadcastUpload_Request {
        <CBroadcast_StartBroadcastUpload_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBroadcastUpload_Request {
    pub fn new() -> CBroadcast_StartBroadcastUpload_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cellid = 2;


    pub fn get_cellid(&self) -> u32 {
        self.cellid.unwrap_or(0)
    }
    pub fn clear_cellid(&mut self) {
        self.cellid = ::std::option::Option::None;
    }

    pub fn has_cellid(&self) -> bool {
        self.cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cellid(&mut self, v: u32) {
        self.cellid = ::std::option::Option::Some(v);
    }

    // optional bool as_rtmp = 3;


    pub fn get_as_rtmp(&self) -> bool {
        self.as_rtmp.unwrap_or(false)
    }
    pub fn clear_as_rtmp(&mut self) {
        self.as_rtmp = ::std::option::Option::None;
    }

    pub fn has_as_rtmp(&self) -> bool {
        self.as_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_rtmp(&mut self, v: bool) {
        self.as_rtmp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_seconds = 4;


    pub fn get_delay_seconds(&self) -> u32 {
        self.delay_seconds.unwrap_or(0)
    }
    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: u32) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    // optional uint64 rtmp_token = 5;


    pub fn get_rtmp_token(&self) -> u64 {
        self.rtmp_token.unwrap_or(0u64)
    }
    pub fn clear_rtmp_token(&mut self) {
        self.rtmp_token = ::std::option::Option::None;
    }

    pub fn has_rtmp_token(&self) -> bool {
        self.rtmp_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_token(&mut self, v: u64) {
        self.rtmp_token = ::std::option::Option::Some(v);
    }

    // optional uint32 upload_ip_address = 6;


    pub fn get_upload_ip_address(&self) -> u32 {
        self.upload_ip_address.unwrap_or(0)
    }
    pub fn clear_upload_ip_address(&mut self) {
        self.upload_ip_address = ::std::option::Option::None;
    }

    pub fn has_upload_ip_address(&self) -> bool {
        self.upload_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_ip_address(&mut self, v: u32) {
        self.upload_ip_address = ::std::option::Option::Some(v);
    }

    // optional bool is_replay = 7;


    pub fn get_is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }
    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional uint32 sysid = 8;


    pub fn get_sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }
    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StartBroadcastUpload_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cellid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.as_rtmp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rtmp_token = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.upload_ip_address = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_replay = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sysid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.cellid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.as_rtmp {
            my_size += 2;
        }
        if let Some(v) = self.delay_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtmp_token {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.upload_ip_address {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_replay {
            my_size += 2;
        }
        if let Some(v) = self.sysid {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.cellid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.as_rtmp {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.delay_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtmp_token {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.upload_ip_address {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_StartBroadcastUpload_Request {
        CBroadcast_StartBroadcastUpload_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.broadcast_id },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cellid",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.cellid },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.cellid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "as_rtmp",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.as_rtmp },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.as_rtmp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delay_seconds",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.delay_seconds },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.delay_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rtmp_token",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.rtmp_token },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.rtmp_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "upload_ip_address",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.upload_ip_address },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.upload_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_replay",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.is_replay },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.is_replay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sysid",
                |m: &CBroadcast_StartBroadcastUpload_Request| { &m.sysid },
                |m: &mut CBroadcast_StartBroadcastUpload_Request| { &mut m.sysid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_StartBroadcastUpload_Request>(
                "CBroadcast_StartBroadcastUpload_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_StartBroadcastUpload_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_StartBroadcastUpload_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_StartBroadcastUpload_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_StartBroadcastUpload_Request {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.cellid = ::std::option::Option::None;
        self.as_rtmp = ::std::option::Option::None;
        self.delay_seconds = ::std::option::Option::None;
        self.rtmp_token = ::std::option::Option::None;
        self.upload_ip_address = ::std::option::Option::None;
        self.is_replay = ::std::option::Option::None;
        self.sysid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_StartBroadcastUpload_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_StartBroadcastUpload_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_StartBroadcastUpload_Response {
    // message fields
    upload_token: ::protobuf::SingularField<::std::string::String>,
    upload_address: ::protobuf::SingularField<::std::string::String>,
    broadcast_upload_id: ::std::option::Option<u64>,
    enable_replay: ::std::option::Option<bool>,
    http_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBroadcastUpload_Response {
    fn default() -> &'a CBroadcast_StartBroadcastUpload_Response {
        <CBroadcast_StartBroadcastUpload_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBroadcastUpload_Response {
    pub fn new() -> CBroadcast_StartBroadcastUpload_Response {
        ::std::default::Default::default()
    }

    // optional string upload_token = 1;


    pub fn get_upload_token(&self) -> &str {
        match self.upload_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_upload_token(&mut self) {
        self.upload_token.clear();
    }

    pub fn has_upload_token(&self) -> bool {
        self.upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_token(&mut self, v: ::std::string::String) {
        self.upload_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_token(&mut self) -> &mut ::std::string::String {
        if self.upload_token.is_none() {
            self.upload_token.set_default();
        }
        self.upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_token(&mut self) -> ::std::string::String {
        self.upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string upload_address = 2;


    pub fn get_upload_address(&self) -> &str {
        match self.upload_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_upload_address(&mut self) {
        self.upload_address.clear();
    }

    pub fn has_upload_address(&self) -> bool {
        self.upload_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_address(&mut self, v: ::std::string::String) {
        self.upload_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_address(&mut self) -> &mut ::std::string::String {
        if self.upload_address.is_none() {
            self.upload_address.set_default();
        }
        self.upload_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_address(&mut self) -> ::std::string::String {
        self.upload_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcast_upload_id = 3;


    pub fn get_broadcast_upload_id(&self) -> u64 {
        self.broadcast_upload_id.unwrap_or(0)
    }
    pub fn clear_broadcast_upload_id(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_upload_id(&self) -> bool {
        self.broadcast_upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_upload_id(&mut self, v: u64) {
        self.broadcast_upload_id = ::std::option::Option::Some(v);
    }

    // optional bool enable_replay = 6;


    pub fn get_enable_replay(&self) -> bool {
        self.enable_replay.unwrap_or(false)
    }
    pub fn clear_enable_replay(&mut self) {
        self.enable_replay = ::std::option::Option::None;
    }

    pub fn has_enable_replay(&self) -> bool {
        self.enable_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_replay(&mut self, v: bool) {
        self.enable_replay = ::std::option::Option::Some(v);
    }

    // optional string http_address = 7;


    pub fn get_http_address(&self) -> &str {
        match self.http_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_http_address(&mut self) {
        self.http_address.clear();
    }

    pub fn has_http_address(&self) -> bool {
        self.http_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_address(&mut self, v: ::std::string::String) {
        self.http_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_address(&mut self) -> &mut ::std::string::String {
        if self.http_address.is_none() {
            self.http_address.set_default();
        }
        self.http_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_address(&mut self) -> ::std::string::String {
        self.http_address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_StartBroadcastUpload_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.upload_token)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.upload_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_upload_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_replay = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.upload_address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.broadcast_upload_id {
            my_size += 9;
        }
        if let Some(v) = self.enable_replay {
            my_size += 2;
        }
        if let Some(ref v) = self.http_address.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.upload_token.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.upload_address.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.broadcast_upload_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.enable_replay {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.http_address.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_StartBroadcastUpload_Response {
        CBroadcast_StartBroadcastUpload_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upload_token",
                |m: &CBroadcast_StartBroadcastUpload_Response| { &m.upload_token },
                |m: &mut CBroadcast_StartBroadcastUpload_Response| { &mut m.upload_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upload_address",
                |m: &CBroadcast_StartBroadcastUpload_Response| { &m.upload_address },
                |m: &mut CBroadcast_StartBroadcastUpload_Response| { &mut m.upload_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_upload_id",
                |m: &CBroadcast_StartBroadcastUpload_Response| { &m.broadcast_upload_id },
                |m: &mut CBroadcast_StartBroadcastUpload_Response| { &mut m.broadcast_upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_replay",
                |m: &CBroadcast_StartBroadcastUpload_Response| { &m.enable_replay },
                |m: &mut CBroadcast_StartBroadcastUpload_Response| { &mut m.enable_replay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "http_address",
                |m: &CBroadcast_StartBroadcastUpload_Response| { &m.http_address },
                |m: &mut CBroadcast_StartBroadcastUpload_Response| { &mut m.http_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_StartBroadcastUpload_Response>(
                "CBroadcast_StartBroadcastUpload_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_StartBroadcastUpload_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_StartBroadcastUpload_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_StartBroadcastUpload_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_StartBroadcastUpload_Response {
    fn clear(&mut self) {
        self.upload_token.clear();
        self.upload_address.clear();
        self.broadcast_upload_id = ::std::option::Option::None;
        self.enable_replay = ::std::option::Option::None;
        self.http_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_StartBroadcastUpload_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_StartBroadcastUpload_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_NotifyBroadcastUploadStop_Notification {
    // message fields
    broadcast_upload_id: ::std::option::Option<u64>,
    upload_result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_NotifyBroadcastUploadStop_Notification {
    fn default() -> &'a CBroadcast_NotifyBroadcastUploadStop_Notification {
        <CBroadcast_NotifyBroadcastUploadStop_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_NotifyBroadcastUploadStop_Notification {
    pub fn new() -> CBroadcast_NotifyBroadcastUploadStop_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_upload_id = 1;


    pub fn get_broadcast_upload_id(&self) -> u64 {
        self.broadcast_upload_id.unwrap_or(0)
    }
    pub fn clear_broadcast_upload_id(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_upload_id(&self) -> bool {
        self.broadcast_upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_upload_id(&mut self, v: u64) {
        self.broadcast_upload_id = ::std::option::Option::Some(v);
    }

    // optional uint32 upload_result = 2;


    pub fn get_upload_result(&self) -> u32 {
        self.upload_result.unwrap_or(0)
    }
    pub fn clear_upload_result(&mut self) {
        self.upload_result = ::std::option::Option::None;
    }

    pub fn has_upload_result(&self) -> bool {
        self.upload_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_result(&mut self, v: u32) {
        self.upload_result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_NotifyBroadcastUploadStop_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_upload_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.upload_result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_upload_id {
            my_size += 9;
        }
        if let Some(v) = self.upload_result {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_upload_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.upload_result {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_NotifyBroadcastUploadStop_Notification {
        CBroadcast_NotifyBroadcastUploadStop_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_upload_id",
                |m: &CBroadcast_NotifyBroadcastUploadStop_Notification| { &m.broadcast_upload_id },
                |m: &mut CBroadcast_NotifyBroadcastUploadStop_Notification| { &mut m.broadcast_upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "upload_result",
                |m: &CBroadcast_NotifyBroadcastUploadStop_Notification| { &m.upload_result },
                |m: &mut CBroadcast_NotifyBroadcastUploadStop_Notification| { &mut m.upload_result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_NotifyBroadcastUploadStop_Notification>(
                "CBroadcast_NotifyBroadcastUploadStop_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_NotifyBroadcastUploadStop_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_NotifyBroadcastUploadStop_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_NotifyBroadcastUploadStop_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_NotifyBroadcastUploadStop_Notification {
    fn clear(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
        self.upload_result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_NotifyBroadcastUploadStop_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_NotifyBroadcastUploadStop_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WatchBroadcast_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    existing_broadcast_id: ::std::option::Option<u64>,
    viewer_token: ::std::option::Option<u64>,
    client_cell: ::std::option::Option<u32>,
    watch_location: ::std::option::Option<EBroadcastWatchLocation>,
    is_webrtc: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WatchBroadcast_Request {
    fn default() -> &'a CBroadcast_WatchBroadcast_Request {
        <CBroadcast_WatchBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WatchBroadcast_Request {
    pub fn new() -> CBroadcast_WatchBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 existing_broadcast_id = 2;


    pub fn get_existing_broadcast_id(&self) -> u64 {
        self.existing_broadcast_id.unwrap_or(0)
    }
    pub fn clear_existing_broadcast_id(&mut self) {
        self.existing_broadcast_id = ::std::option::Option::None;
    }

    pub fn has_existing_broadcast_id(&self) -> bool {
        self.existing_broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_existing_broadcast_id(&mut self, v: u64) {
        self.existing_broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 3;


    pub fn get_viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }
    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }

    // optional uint32 client_cell = 5;


    pub fn get_client_cell(&self) -> u32 {
        self.client_cell.unwrap_or(0)
    }
    pub fn clear_client_cell(&mut self) {
        self.client_cell = ::std::option::Option::None;
    }

    pub fn has_client_cell(&self) -> bool {
        self.client_cell.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cell(&mut self, v: u32) {
        self.client_cell = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastWatchLocation watch_location = 6;


    pub fn get_watch_location(&self) -> EBroadcastWatchLocation {
        self.watch_location.unwrap_or(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid)
    }
    pub fn clear_watch_location(&mut self) {
        self.watch_location = ::std::option::Option::None;
    }

    pub fn has_watch_location(&self) -> bool {
        self.watch_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_location(&mut self, v: EBroadcastWatchLocation) {
        self.watch_location = ::std::option::Option::Some(v);
    }

    // optional bool is_webrtc = 7;


    pub fn get_is_webrtc(&self) -> bool {
        self.is_webrtc.unwrap_or(false)
    }
    pub fn clear_is_webrtc(&mut self) {
        self.is_webrtc = ::std::option::Option::None;
    }

    pub fn has_is_webrtc(&self) -> bool {
        self.is_webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_webrtc(&mut self, v: bool) {
        self.is_webrtc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WatchBroadcast_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.existing_broadcast_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.viewer_token = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_cell = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.watch_location, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_webrtc = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.existing_broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.viewer_token {
            my_size += 9;
        }
        if let Some(v) = self.client_cell {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watch_location {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.is_webrtc {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.existing_broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.client_cell {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.watch_location {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.is_webrtc {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WatchBroadcast_Request {
        CBroadcast_WatchBroadcast_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_WatchBroadcast_Request| { &m.steamid },
                |m: &mut CBroadcast_WatchBroadcast_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "existing_broadcast_id",
                |m: &CBroadcast_WatchBroadcast_Request| { &m.existing_broadcast_id },
                |m: &mut CBroadcast_WatchBroadcast_Request| { &mut m.existing_broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "viewer_token",
                |m: &CBroadcast_WatchBroadcast_Request| { &m.viewer_token },
                |m: &mut CBroadcast_WatchBroadcast_Request| { &mut m.viewer_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_cell",
                |m: &CBroadcast_WatchBroadcast_Request| { &m.client_cell },
                |m: &mut CBroadcast_WatchBroadcast_Request| { &mut m.client_cell },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EBroadcastWatchLocation>>(
                "watch_location",
                |m: &CBroadcast_WatchBroadcast_Request| { &m.watch_location },
                |m: &mut CBroadcast_WatchBroadcast_Request| { &mut m.watch_location },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_webrtc",
                |m: &CBroadcast_WatchBroadcast_Request| { &m.is_webrtc },
                |m: &mut CBroadcast_WatchBroadcast_Request| { &mut m.is_webrtc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WatchBroadcast_Request>(
                "CBroadcast_WatchBroadcast_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WatchBroadcast_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WatchBroadcast_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WatchBroadcast_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WatchBroadcast_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.existing_broadcast_id = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.client_cell = ::std::option::Option::None;
        self.watch_location = ::std::option::Option::None;
        self.is_webrtc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WatchBroadcast_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WatchBroadcast_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WatchBroadcast_Response {
    // message fields
    response: ::std::option::Option<CBroadcast_WatchBroadcast_Response_EWatchResponse>,
    mpd_url: ::protobuf::SingularField<::std::string::String>,
    broadcast_id: ::std::option::Option<u64>,
    gameid: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    num_viewers: ::std::option::Option<u32>,
    permission: ::std::option::Option<i32>,
    is_rtmp: ::std::option::Option<bool>,
    seconds_delay: ::std::option::Option<i32>,
    viewer_token: ::std::option::Option<u64>,
    hls_m3u8_master_url: ::protobuf::SingularField<::std::string::String>,
    heartbeat_interval: ::std::option::Option<i32>,
    thumbnail_url: ::protobuf::SingularField<::std::string::String>,
    is_webrtc: ::std::option::Option<bool>,
    webrtc_session_id: ::std::option::Option<u64>,
    webrtc_offer_sdp: ::protobuf::SingularField<::std::string::String>,
    webrtc_turn_server: ::protobuf::SingularField<::std::string::String>,
    is_replay: ::std::option::Option<bool>,
    duration: ::std::option::Option<i32>,
    cdn_auth_url_parameters: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WatchBroadcast_Response {
    fn default() -> &'a CBroadcast_WatchBroadcast_Response {
        <CBroadcast_WatchBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WatchBroadcast_Response {
    pub fn new() -> CBroadcast_WatchBroadcast_Response {
        ::std::default::Default::default()
    }

    // optional .CBroadcast_WatchBroadcast_Response.EWatchResponse response = 1;


    pub fn get_response(&self) -> CBroadcast_WatchBroadcast_Response_EWatchResponse {
        self.response.unwrap_or(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseReady)
    }
    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CBroadcast_WatchBroadcast_Response_EWatchResponse) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional string mpd_url = 2;


    pub fn get_mpd_url(&self) -> &str {
        match self.mpd_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mpd_url(&mut self) {
        self.mpd_url.clear();
    }

    pub fn has_mpd_url(&self) -> bool {
        self.mpd_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mpd_url(&mut self, v: ::std::string::String) {
        self.mpd_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mpd_url(&mut self) -> &mut ::std::string::String {
        if self.mpd_url.is_none() {
            self.mpd_url.set_default();
        }
        self.mpd_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_mpd_url(&mut self) -> ::std::string::String {
        self.mpd_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcast_id = 3;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 4;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_viewers = 6;


    pub fn get_num_viewers(&self) -> u32 {
        self.num_viewers.unwrap_or(0)
    }
    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: u32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }

    // optional int32 permission = 7;


    pub fn get_permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional bool is_rtmp = 8;


    pub fn get_is_rtmp(&self) -> bool {
        self.is_rtmp.unwrap_or(false)
    }
    pub fn clear_is_rtmp(&mut self) {
        self.is_rtmp = ::std::option::Option::None;
    }

    pub fn has_is_rtmp(&self) -> bool {
        self.is_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_rtmp(&mut self, v: bool) {
        self.is_rtmp = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_delay = 9;


    pub fn get_seconds_delay(&self) -> i32 {
        self.seconds_delay.unwrap_or(0)
    }
    pub fn clear_seconds_delay(&mut self) {
        self.seconds_delay = ::std::option::Option::None;
    }

    pub fn has_seconds_delay(&self) -> bool {
        self.seconds_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_delay(&mut self, v: i32) {
        self.seconds_delay = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 10;


    pub fn get_viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }
    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }

    // optional string hls_m3u8_master_url = 11;


    pub fn get_hls_m3u8_master_url(&self) -> &str {
        match self.hls_m3u8_master_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hls_m3u8_master_url(&mut self) {
        self.hls_m3u8_master_url.clear();
    }

    pub fn has_hls_m3u8_master_url(&self) -> bool {
        self.hls_m3u8_master_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hls_m3u8_master_url(&mut self, v: ::std::string::String) {
        self.hls_m3u8_master_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hls_m3u8_master_url(&mut self) -> &mut ::std::string::String {
        if self.hls_m3u8_master_url.is_none() {
            self.hls_m3u8_master_url.set_default();
        }
        self.hls_m3u8_master_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_hls_m3u8_master_url(&mut self) -> ::std::string::String {
        self.hls_m3u8_master_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 heartbeat_interval = 12;


    pub fn get_heartbeat_interval(&self) -> i32 {
        self.heartbeat_interval.unwrap_or(0)
    }
    pub fn clear_heartbeat_interval(&mut self) {
        self.heartbeat_interval = ::std::option::Option::None;
    }

    pub fn has_heartbeat_interval(&self) -> bool {
        self.heartbeat_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_interval(&mut self, v: i32) {
        self.heartbeat_interval = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 13;


    pub fn get_thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url.clear();
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url.set_default();
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_webrtc = 14;


    pub fn get_is_webrtc(&self) -> bool {
        self.is_webrtc.unwrap_or(false)
    }
    pub fn clear_is_webrtc(&mut self) {
        self.is_webrtc = ::std::option::Option::None;
    }

    pub fn has_is_webrtc(&self) -> bool {
        self.is_webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_webrtc(&mut self, v: bool) {
        self.is_webrtc = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 15;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional string webrtc_offer_sdp = 16;


    pub fn get_webrtc_offer_sdp(&self) -> &str {
        match self.webrtc_offer_sdp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_webrtc_offer_sdp(&mut self) {
        self.webrtc_offer_sdp.clear();
    }

    pub fn has_webrtc_offer_sdp(&self) -> bool {
        self.webrtc_offer_sdp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_offer_sdp(&mut self, v: ::std::string::String) {
        self.webrtc_offer_sdp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webrtc_offer_sdp(&mut self) -> &mut ::std::string::String {
        if self.webrtc_offer_sdp.is_none() {
            self.webrtc_offer_sdp.set_default();
        }
        self.webrtc_offer_sdp.as_mut().unwrap()
    }

    // Take field
    pub fn take_webrtc_offer_sdp(&mut self) -> ::std::string::String {
        self.webrtc_offer_sdp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string webrtc_turn_server = 17;


    pub fn get_webrtc_turn_server(&self) -> &str {
        match self.webrtc_turn_server.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_webrtc_turn_server(&mut self) {
        self.webrtc_turn_server.clear();
    }

    pub fn has_webrtc_turn_server(&self) -> bool {
        self.webrtc_turn_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_turn_server(&mut self, v: ::std::string::String) {
        self.webrtc_turn_server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webrtc_turn_server(&mut self) -> &mut ::std::string::String {
        if self.webrtc_turn_server.is_none() {
            self.webrtc_turn_server.set_default();
        }
        self.webrtc_turn_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_webrtc_turn_server(&mut self) -> ::std::string::String {
        self.webrtc_turn_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_replay = 18;


    pub fn get_is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }
    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 19;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string cdn_auth_url_parameters = 20;


    pub fn get_cdn_auth_url_parameters(&self) -> &str {
        match self.cdn_auth_url_parameters.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cdn_auth_url_parameters(&mut self) {
        self.cdn_auth_url_parameters.clear();
    }

    pub fn has_cdn_auth_url_parameters(&self) -> bool {
        self.cdn_auth_url_parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cdn_auth_url_parameters(&mut self, v: ::std::string::String) {
        self.cdn_auth_url_parameters = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cdn_auth_url_parameters(&mut self) -> &mut ::std::string::String {
        if self.cdn_auth_url_parameters.is_none() {
            self.cdn_auth_url_parameters.set_default();
        }
        self.cdn_auth_url_parameters.as_mut().unwrap()
    }

    // Take field
    pub fn take_cdn_auth_url_parameters(&mut self) -> ::std::string::String {
        self.cdn_auth_url_parameters.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WatchBroadcast_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.response, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mpd_url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_viewers = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_rtmp = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_delay = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.viewer_token = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hls_m3u8_master_url)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.heartbeat_interval = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnail_url)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_webrtc = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.webrtc_offer_sdp)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.webrtc_turn_server)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_replay = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cdn_auth_url_parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.mpd_url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_rtmp {
            my_size += 2;
        }
        if let Some(v) = self.seconds_delay {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.viewer_token {
            my_size += 9;
        }
        if let Some(ref v) = self.hls_m3u8_master_url.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.heartbeat_interval {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.is_webrtc {
            my_size += 2;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.webrtc_offer_sdp.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.webrtc_turn_server.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.is_replay {
            my_size += 3;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cdn_auth_url_parameters.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.mpd_url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.permission {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.is_rtmp {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.seconds_delay {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(10, v)?;
        }
        if let Some(ref v) = self.hls_m3u8_master_url.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.heartbeat_interval {
            os.write_int32(12, v)?;
        }
        if let Some(ref v) = self.thumbnail_url.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.is_webrtc {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(15, v)?;
        }
        if let Some(ref v) = self.webrtc_offer_sdp.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.webrtc_turn_server.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(19, v)?;
        }
        if let Some(ref v) = self.cdn_auth_url_parameters.as_ref() {
            os.write_string(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WatchBroadcast_Response {
        CBroadcast_WatchBroadcast_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CBroadcast_WatchBroadcast_Response_EWatchResponse>>(
                "response",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.response },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.response },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mpd_url",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.mpd_url },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.mpd_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.broadcast_id },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gameid",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.gameid },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.title },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_viewers",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.num_viewers },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.num_viewers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "permission",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.permission },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_rtmp",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.is_rtmp },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.is_rtmp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seconds_delay",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.seconds_delay },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.seconds_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "viewer_token",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.viewer_token },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.viewer_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hls_m3u8_master_url",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.hls_m3u8_master_url },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.hls_m3u8_master_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "heartbeat_interval",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.heartbeat_interval },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.heartbeat_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_url",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.thumbnail_url },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.thumbnail_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_webrtc",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.is_webrtc },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.is_webrtc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "webrtc_offer_sdp",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.webrtc_offer_sdp },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.webrtc_offer_sdp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "webrtc_turn_server",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.webrtc_turn_server },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.webrtc_turn_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_replay",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.is_replay },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.is_replay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.duration },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cdn_auth_url_parameters",
                |m: &CBroadcast_WatchBroadcast_Response| { &m.cdn_auth_url_parameters },
                |m: &mut CBroadcast_WatchBroadcast_Response| { &mut m.cdn_auth_url_parameters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WatchBroadcast_Response>(
                "CBroadcast_WatchBroadcast_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WatchBroadcast_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WatchBroadcast_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WatchBroadcast_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WatchBroadcast_Response {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.mpd_url.clear();
        self.broadcast_id = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.title.clear();
        self.num_viewers = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.is_rtmp = ::std::option::Option::None;
        self.seconds_delay = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.hls_m3u8_master_url.clear();
        self.heartbeat_interval = ::std::option::Option::None;
        self.thumbnail_url.clear();
        self.is_webrtc = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.webrtc_offer_sdp.clear();
        self.webrtc_turn_server.clear();
        self.is_replay = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.cdn_auth_url_parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WatchBroadcast_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WatchBroadcast_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CBroadcast_WatchBroadcast_Response_EWatchResponse {
    k_EWatchResponseReady = 1,
    k_EWatchResponseNotAvailable = 2,
    k_EWatchResponseWaitingForApproval = 3,
    k_EWatchResponseWaitingForStart = 4,
    k_EWatchResponseInvalidSession = 5,
    k_EWatchResponseTooManyBroadcasts = 6,
    k_EWatchResponseWaitingForReconnect = 7,
    k_EWatchResponseSystemNotSupported = 8,
    k_EWatchResponseUserRestricted = 9,
    k_EWatchResponseClientOutOfDate = 10,
    k_EWatchResponsePoorUploadQuality = 11,
    k_EWatchResponseMissingSubscription = 12,
}

impl ::protobuf::ProtobufEnum for CBroadcast_WatchBroadcast_Response_EWatchResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CBroadcast_WatchBroadcast_Response_EWatchResponse> {
        match value {
            1 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseReady),
            2 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseNotAvailable),
            3 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseWaitingForApproval),
            4 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseWaitingForStart),
            5 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseInvalidSession),
            6 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseTooManyBroadcasts),
            7 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseWaitingForReconnect),
            8 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseSystemNotSupported),
            9 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseUserRestricted),
            10 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseClientOutOfDate),
            11 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponsePoorUploadQuality),
            12 => ::std::option::Option::Some(CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseMissingSubscription),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CBroadcast_WatchBroadcast_Response_EWatchResponse] = &[
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseReady,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseNotAvailable,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseWaitingForApproval,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseWaitingForStart,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseInvalidSession,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseTooManyBroadcasts,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseWaitingForReconnect,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseSystemNotSupported,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseUserRestricted,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseClientOutOfDate,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponsePoorUploadQuality,
            CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseMissingSubscription,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CBroadcast_WatchBroadcast_Response_EWatchResponse>("CBroadcast_WatchBroadcast_Response.EWatchResponse", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CBroadcast_WatchBroadcast_Response_EWatchResponse {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CBroadcast_WatchBroadcast_Response_EWatchResponse {
    fn default() -> Self {
        CBroadcast_WatchBroadcast_Response_EWatchResponse::k_EWatchResponseReady
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WatchBroadcast_Response_EWatchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_HeartbeatBroadcast_Notification {
    // message fields
    steamid: ::std::option::Option<u64>,
    broadcast_id: ::std::option::Option<u64>,
    viewer_token: ::std::option::Option<u64>,
    representation: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_HeartbeatBroadcast_Notification {
    fn default() -> &'a CBroadcast_HeartbeatBroadcast_Notification {
        <CBroadcast_HeartbeatBroadcast_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_HeartbeatBroadcast_Notification {
    pub fn new() -> CBroadcast_HeartbeatBroadcast_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 3;


    pub fn get_viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }
    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }

    // optional uint32 representation = 4;


    pub fn get_representation(&self) -> u32 {
        self.representation.unwrap_or(0)
    }
    pub fn clear_representation(&mut self) {
        self.representation = ::std::option::Option::None;
    }

    pub fn has_representation(&self) -> bool {
        self.representation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_representation(&mut self, v: u32) {
        self.representation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_HeartbeatBroadcast_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.viewer_token = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.representation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.viewer_token {
            my_size += 9;
        }
        if let Some(v) = self.representation {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.representation {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_HeartbeatBroadcast_Notification {
        CBroadcast_HeartbeatBroadcast_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_HeartbeatBroadcast_Notification| { &m.steamid },
                |m: &mut CBroadcast_HeartbeatBroadcast_Notification| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_HeartbeatBroadcast_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_HeartbeatBroadcast_Notification| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "viewer_token",
                |m: &CBroadcast_HeartbeatBroadcast_Notification| { &m.viewer_token },
                |m: &mut CBroadcast_HeartbeatBroadcast_Notification| { &mut m.viewer_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "representation",
                |m: &CBroadcast_HeartbeatBroadcast_Notification| { &m.representation },
                |m: &mut CBroadcast_HeartbeatBroadcast_Notification| { &mut m.representation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_HeartbeatBroadcast_Notification>(
                "CBroadcast_HeartbeatBroadcast_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_HeartbeatBroadcast_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_HeartbeatBroadcast_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_HeartbeatBroadcast_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_HeartbeatBroadcast_Notification {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.representation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_HeartbeatBroadcast_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_HeartbeatBroadcast_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_StopWatchingBroadcast_Notification {
    // message fields
    steamid: ::std::option::Option<u64>,
    broadcast_id: ::std::option::Option<u64>,
    viewer_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StopWatchingBroadcast_Notification {
    fn default() -> &'a CBroadcast_StopWatchingBroadcast_Notification {
        <CBroadcast_StopWatchingBroadcast_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StopWatchingBroadcast_Notification {
    pub fn new() -> CBroadcast_StopWatchingBroadcast_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 3;


    pub fn get_viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }
    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StopWatchingBroadcast_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.viewer_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.viewer_token {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_StopWatchingBroadcast_Notification {
        CBroadcast_StopWatchingBroadcast_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_StopWatchingBroadcast_Notification| { &m.steamid },
                |m: &mut CBroadcast_StopWatchingBroadcast_Notification| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_StopWatchingBroadcast_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_StopWatchingBroadcast_Notification| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "viewer_token",
                |m: &CBroadcast_StopWatchingBroadcast_Notification| { &m.viewer_token },
                |m: &mut CBroadcast_StopWatchingBroadcast_Notification| { &mut m.viewer_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_StopWatchingBroadcast_Notification>(
                "CBroadcast_StopWatchingBroadcast_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_StopWatchingBroadcast_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_StopWatchingBroadcast_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_StopWatchingBroadcast_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_StopWatchingBroadcast_Notification {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_StopWatchingBroadcast_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_StopWatchingBroadcast_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastStatus_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    broadcast_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastStatus_Request {
    fn default() -> &'a CBroadcast_GetBroadcastStatus_Request {
        <CBroadcast_GetBroadcastStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastStatus_Request {
    pub fn new() -> CBroadcast_GetBroadcastStatus_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastStatus_Request {
        CBroadcast_GetBroadcastStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_GetBroadcastStatus_Request| { &m.steamid },
                |m: &mut CBroadcast_GetBroadcastStatus_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_GetBroadcastStatus_Request| { &m.broadcast_id },
                |m: &mut CBroadcast_GetBroadcastStatus_Request| { &mut m.broadcast_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastStatus_Request>(
                "CBroadcast_GetBroadcastStatus_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastStatus_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastStatus_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastStatus_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastStatus_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastStatus_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastStatus_Response {
    // message fields
    gameid: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    num_viewers: ::std::option::Option<u32>,
    permission: ::std::option::Option<i32>,
    is_rtmp: ::std::option::Option<bool>,
    seconds_delay: ::std::option::Option<i32>,
    is_publisher: ::std::option::Option<bool>,
    thumbnail_url: ::protobuf::SingularField<::std::string::String>,
    update_interval: ::std::option::Option<i32>,
    is_uploading: ::std::option::Option<bool>,
    duration: ::std::option::Option<u32>,
    is_replay: ::std::option::Option<bool>,
    is_capturing_vod: ::std::option::Option<bool>,
    is_store_whitelisted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastStatus_Response {
    fn default() -> &'a CBroadcast_GetBroadcastStatus_Response {
        <CBroadcast_GetBroadcastStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastStatus_Response {
    pub fn new() -> CBroadcast_GetBroadcastStatus_Response {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_viewers = 3;


    pub fn get_num_viewers(&self) -> u32 {
        self.num_viewers.unwrap_or(0)
    }
    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: u32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }

    // optional int32 permission = 4;


    pub fn get_permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional bool is_rtmp = 5;


    pub fn get_is_rtmp(&self) -> bool {
        self.is_rtmp.unwrap_or(false)
    }
    pub fn clear_is_rtmp(&mut self) {
        self.is_rtmp = ::std::option::Option::None;
    }

    pub fn has_is_rtmp(&self) -> bool {
        self.is_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_rtmp(&mut self, v: bool) {
        self.is_rtmp = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_delay = 6;


    pub fn get_seconds_delay(&self) -> i32 {
        self.seconds_delay.unwrap_or(0)
    }
    pub fn clear_seconds_delay(&mut self) {
        self.seconds_delay = ::std::option::Option::None;
    }

    pub fn has_seconds_delay(&self) -> bool {
        self.seconds_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_delay(&mut self, v: i32) {
        self.seconds_delay = ::std::option::Option::Some(v);
    }

    // optional bool is_publisher = 7;


    pub fn get_is_publisher(&self) -> bool {
        self.is_publisher.unwrap_or(false)
    }
    pub fn clear_is_publisher(&mut self) {
        self.is_publisher = ::std::option::Option::None;
    }

    pub fn has_is_publisher(&self) -> bool {
        self.is_publisher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_publisher(&mut self, v: bool) {
        self.is_publisher = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 8;


    pub fn get_thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url.clear();
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url.set_default();
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 update_interval = 9;


    pub fn get_update_interval(&self) -> i32 {
        self.update_interval.unwrap_or(0)
    }
    pub fn clear_update_interval(&mut self) {
        self.update_interval = ::std::option::Option::None;
    }

    pub fn has_update_interval(&self) -> bool {
        self.update_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_interval(&mut self, v: i32) {
        self.update_interval = ::std::option::Option::Some(v);
    }

    // optional bool is_uploading = 10;


    pub fn get_is_uploading(&self) -> bool {
        self.is_uploading.unwrap_or(false)
    }
    pub fn clear_is_uploading(&mut self) {
        self.is_uploading = ::std::option::Option::None;
    }

    pub fn has_is_uploading(&self) -> bool {
        self.is_uploading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_uploading(&mut self, v: bool) {
        self.is_uploading = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 11;


    pub fn get_duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool is_replay = 12;


    pub fn get_is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }
    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional bool is_capturing_vod = 13;


    pub fn get_is_capturing_vod(&self) -> bool {
        self.is_capturing_vod.unwrap_or(false)
    }
    pub fn clear_is_capturing_vod(&mut self) {
        self.is_capturing_vod = ::std::option::Option::None;
    }

    pub fn has_is_capturing_vod(&self) -> bool {
        self.is_capturing_vod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_capturing_vod(&mut self, v: bool) {
        self.is_capturing_vod = ::std::option::Option::Some(v);
    }

    // optional bool is_store_whitelisted = 14;


    pub fn get_is_store_whitelisted(&self) -> bool {
        self.is_store_whitelisted.unwrap_or(false)
    }
    pub fn clear_is_store_whitelisted(&mut self) {
        self.is_store_whitelisted = ::std::option::Option::None;
    }

    pub fn has_is_store_whitelisted(&self) -> bool {
        self.is_store_whitelisted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_store_whitelisted(&mut self, v: bool) {
        self.is_store_whitelisted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_viewers = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_rtmp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_delay = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_publisher = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnail_url)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.update_interval = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_uploading = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_replay = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_capturing_vod = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_store_whitelisted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_rtmp {
            my_size += 2;
        }
        if let Some(v) = self.seconds_delay {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_publisher {
            my_size += 2;
        }
        if let Some(ref v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.update_interval {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_uploading {
            my_size += 2;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_replay {
            my_size += 2;
        }
        if let Some(v) = self.is_capturing_vod {
            my_size += 2;
        }
        if let Some(v) = self.is_store_whitelisted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.permission {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.is_rtmp {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.seconds_delay {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.is_publisher {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.thumbnail_url.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.update_interval {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.is_uploading {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_capturing_vod {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_store_whitelisted {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastStatus_Response {
        CBroadcast_GetBroadcastStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gameid",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.gameid },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.title },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_viewers",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.num_viewers },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.num_viewers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "permission",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.permission },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_rtmp",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.is_rtmp },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.is_rtmp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seconds_delay",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.seconds_delay },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.seconds_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_publisher",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.is_publisher },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.is_publisher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_url",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.thumbnail_url },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.thumbnail_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "update_interval",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.update_interval },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.update_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_uploading",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.is_uploading },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.is_uploading },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duration",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.duration },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_replay",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.is_replay },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.is_replay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_capturing_vod",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.is_capturing_vod },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.is_capturing_vod },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_store_whitelisted",
                |m: &CBroadcast_GetBroadcastStatus_Response| { &m.is_store_whitelisted },
                |m: &mut CBroadcast_GetBroadcastStatus_Response| { &mut m.is_store_whitelisted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastStatus_Response>(
                "CBroadcast_GetBroadcastStatus_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastStatus_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastStatus_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastStatus_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastStatus_Response {
    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.title.clear();
        self.num_viewers = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.is_rtmp = ::std::option::Option::None;
        self.seconds_delay = ::std::option::Option::None;
        self.is_publisher = ::std::option::Option::None;
        self.thumbnail_url.clear();
        self.update_interval = ::std::option::Option::None;
        self.is_uploading = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.is_replay = ::std::option::Option::None;
        self.is_capturing_vod = ::std::option::Option::None;
        self.is_store_whitelisted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastStatus_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastThumbnail_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    broadcast_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastThumbnail_Request {
    fn default() -> &'a CBroadcast_GetBroadcastThumbnail_Request {
        <CBroadcast_GetBroadcastThumbnail_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastThumbnail_Request {
    pub fn new() -> CBroadcast_GetBroadcastThumbnail_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastThumbnail_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastThumbnail_Request {
        CBroadcast_GetBroadcastThumbnail_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_GetBroadcastThumbnail_Request| { &m.steamid },
                |m: &mut CBroadcast_GetBroadcastThumbnail_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_GetBroadcastThumbnail_Request| { &m.broadcast_id },
                |m: &mut CBroadcast_GetBroadcastThumbnail_Request| { &mut m.broadcast_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastThumbnail_Request>(
                "CBroadcast_GetBroadcastThumbnail_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastThumbnail_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastThumbnail_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastThumbnail_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastThumbnail_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastThumbnail_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastThumbnail_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastThumbnail_Response {
    // message fields
    thumbnail_url: ::protobuf::SingularField<::std::string::String>,
    update_interval: ::std::option::Option<i32>,
    num_viewers: ::std::option::Option<i32>,
    duration: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastThumbnail_Response {
    fn default() -> &'a CBroadcast_GetBroadcastThumbnail_Response {
        <CBroadcast_GetBroadcastThumbnail_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastThumbnail_Response {
    pub fn new() -> CBroadcast_GetBroadcastThumbnail_Response {
        ::std::default::Default::default()
    }

    // optional string thumbnail_url = 1;


    pub fn get_thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url.clear();
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url.set_default();
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 update_interval = 2;


    pub fn get_update_interval(&self) -> i32 {
        self.update_interval.unwrap_or(0)
    }
    pub fn clear_update_interval(&mut self) {
        self.update_interval = ::std::option::Option::None;
    }

    pub fn has_update_interval(&self) -> bool {
        self.update_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_interval(&mut self, v: i32) {
        self.update_interval = ::std::option::Option::Some(v);
    }

    // optional int32 num_viewers = 3;


    pub fn get_num_viewers(&self) -> i32 {
        self.num_viewers.unwrap_or(0)
    }
    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: i32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 4;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastThumbnail_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnail_url)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.update_interval = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_viewers = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.thumbnail_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.update_interval {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.thumbnail_url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.update_interval {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastThumbnail_Response {
        CBroadcast_GetBroadcastThumbnail_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_url",
                |m: &CBroadcast_GetBroadcastThumbnail_Response| { &m.thumbnail_url },
                |m: &mut CBroadcast_GetBroadcastThumbnail_Response| { &mut m.thumbnail_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "update_interval",
                |m: &CBroadcast_GetBroadcastThumbnail_Response| { &m.update_interval },
                |m: &mut CBroadcast_GetBroadcastThumbnail_Response| { &mut m.update_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_viewers",
                |m: &CBroadcast_GetBroadcastThumbnail_Response| { &m.num_viewers },
                |m: &mut CBroadcast_GetBroadcastThumbnail_Response| { &mut m.num_viewers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &CBroadcast_GetBroadcastThumbnail_Response| { &m.duration },
                |m: &mut CBroadcast_GetBroadcastThumbnail_Response| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastThumbnail_Response>(
                "CBroadcast_GetBroadcastThumbnail_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastThumbnail_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastThumbnail_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastThumbnail_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastThumbnail_Response {
    fn clear(&mut self) {
        self.thumbnail_url.clear();
        self.update_interval = ::std::option::Option::None;
        self.num_viewers = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastThumbnail_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastThumbnail_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_InviteToBroadcast_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    approval_response: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_InviteToBroadcast_Request {
    fn default() -> &'a CBroadcast_InviteToBroadcast_Request {
        <CBroadcast_InviteToBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_InviteToBroadcast_Request {
    pub fn new() -> CBroadcast_InviteToBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool approval_response = 2;


    pub fn get_approval_response(&self) -> bool {
        self.approval_response.unwrap_or(false)
    }
    pub fn clear_approval_response(&mut self) {
        self.approval_response = ::std::option::Option::None;
    }

    pub fn has_approval_response(&self) -> bool {
        self.approval_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_approval_response(&mut self, v: bool) {
        self.approval_response = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_InviteToBroadcast_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.approval_response = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.approval_response {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.approval_response {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_InviteToBroadcast_Request {
        CBroadcast_InviteToBroadcast_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_InviteToBroadcast_Request| { &m.steamid },
                |m: &mut CBroadcast_InviteToBroadcast_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "approval_response",
                |m: &CBroadcast_InviteToBroadcast_Request| { &m.approval_response },
                |m: &mut CBroadcast_InviteToBroadcast_Request| { &mut m.approval_response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_InviteToBroadcast_Request>(
                "CBroadcast_InviteToBroadcast_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_InviteToBroadcast_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_InviteToBroadcast_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_InviteToBroadcast_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_InviteToBroadcast_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.approval_response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_InviteToBroadcast_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_InviteToBroadcast_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_InviteToBroadcast_Response {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_InviteToBroadcast_Response {
    fn default() -> &'a CBroadcast_InviteToBroadcast_Response {
        <CBroadcast_InviteToBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_InviteToBroadcast_Response {
    pub fn new() -> CBroadcast_InviteToBroadcast_Response {
        ::std::default::Default::default()
    }

    // optional bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_InviteToBroadcast_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_InviteToBroadcast_Response {
        CBroadcast_InviteToBroadcast_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &CBroadcast_InviteToBroadcast_Response| { &m.success },
                |m: &mut CBroadcast_InviteToBroadcast_Response| { &mut m.success },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_InviteToBroadcast_Response>(
                "CBroadcast_InviteToBroadcast_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_InviteToBroadcast_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_InviteToBroadcast_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_InviteToBroadcast_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_InviteToBroadcast_Response {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_InviteToBroadcast_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_InviteToBroadcast_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SendBroadcastStateToServer_Request {
    // message fields
    permission: ::std::option::Option<i32>,
    gameid: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    game_data_config: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SendBroadcastStateToServer_Request {
    fn default() -> &'a CBroadcast_SendBroadcastStateToServer_Request {
        <CBroadcast_SendBroadcastStateToServer_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SendBroadcastStateToServer_Request {
    pub fn new() -> CBroadcast_SendBroadcastStateToServer_Request {
        ::std::default::Default::default()
    }

    // optional int32 permission = 1;


    pub fn get_permission(&self) -> i32 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: i32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 2;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_data_config = 4;


    pub fn get_game_data_config(&self) -> &str {
        match self.game_data_config.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_data_config(&mut self) {
        self.game_data_config.clear();
    }

    pub fn has_game_data_config(&self) -> bool {
        self.game_data_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_config(&mut self, v: ::std::string::String) {
        self.game_data_config = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data_config(&mut self) -> &mut ::std::string::String {
        if self.game_data_config.is_none() {
            self.game_data_config.set_default();
        }
        self.game_data_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data_config(&mut self) -> ::std::string::String {
        self.game_data_config.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_SendBroadcastStateToServer_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_data_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.game_data_config.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permission {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.game_data_config.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SendBroadcastStateToServer_Request {
        CBroadcast_SendBroadcastStateToServer_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "permission",
                |m: &CBroadcast_SendBroadcastStateToServer_Request| { &m.permission },
                |m: &mut CBroadcast_SendBroadcastStateToServer_Request| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gameid",
                |m: &CBroadcast_SendBroadcastStateToServer_Request| { &m.gameid },
                |m: &mut CBroadcast_SendBroadcastStateToServer_Request| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CBroadcast_SendBroadcastStateToServer_Request| { &m.title },
                |m: &mut CBroadcast_SendBroadcastStateToServer_Request| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_data_config",
                |m: &CBroadcast_SendBroadcastStateToServer_Request| { &m.game_data_config },
                |m: &mut CBroadcast_SendBroadcastStateToServer_Request| { &mut m.game_data_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SendBroadcastStateToServer_Request>(
                "CBroadcast_SendBroadcastStateToServer_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SendBroadcastStateToServer_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SendBroadcastStateToServer_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SendBroadcastStateToServer_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SendBroadcastStateToServer_Request {
    fn clear(&mut self) {
        self.permission = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.title.clear();
        self.game_data_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SendBroadcastStateToServer_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SendBroadcastStateToServer_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SendBroadcastStateToServer_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SendBroadcastStateToServer_Response {
    fn default() -> &'a CBroadcast_SendBroadcastStateToServer_Response {
        <CBroadcast_SendBroadcastStateToServer_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SendBroadcastStateToServer_Response {
    pub fn new() -> CBroadcast_SendBroadcastStateToServer_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_SendBroadcastStateToServer_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SendBroadcastStateToServer_Response {
        CBroadcast_SendBroadcastStateToServer_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SendBroadcastStateToServer_Response>(
                "CBroadcast_SendBroadcastStateToServer_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SendBroadcastStateToServer_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SendBroadcastStateToServer_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SendBroadcastStateToServer_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SendBroadcastStateToServer_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SendBroadcastStateToServer_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SendBroadcastStateToServer_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    fn default() -> &'a CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        <CBroadcast_NotifyBroadcastSessionHeartbeat_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    pub fn new() -> CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        CBroadcast_NotifyBroadcastSessionHeartbeat_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_NotifyBroadcastSessionHeartbeat_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_NotifyBroadcastSessionHeartbeat_Notification| { &mut m.broadcast_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_NotifyBroadcastSessionHeartbeat_Notification>(
                "CBroadcast_NotifyBroadcastSessionHeartbeat_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_NotifyBroadcastSessionHeartbeat_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_NotifyBroadcastSessionHeartbeat_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastChatInfo_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    broadcast_id: ::std::option::Option<u64>,
    client_ip: ::std::option::Option<u32>,
    client_cell: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatInfo_Request {
    fn default() -> &'a CBroadcast_GetBroadcastChatInfo_Request {
        <CBroadcast_GetBroadcastChatInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatInfo_Request {
    pub fn new() -> CBroadcast_GetBroadcastChatInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_id = 2;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_ip = 3;


    pub fn get_client_ip(&self) -> u32 {
        self.client_ip.unwrap_or(0)
    }
    pub fn clear_client_ip(&mut self) {
        self.client_ip = ::std::option::Option::None;
    }

    pub fn has_client_ip(&self) -> bool {
        self.client_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_ip(&mut self, v: u32) {
        self.client_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 client_cell = 4;


    pub fn get_client_cell(&self) -> u32 {
        self.client_cell.unwrap_or(0)
    }
    pub fn clear_client_cell(&mut self) {
        self.client_cell = ::std::option::Option::None;
    }

    pub fn has_client_cell(&self) -> bool {
        self.client_cell.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cell(&mut self, v: u32) {
        self.client_cell = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_cell = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.client_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_cell {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_cell {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastChatInfo_Request {
        CBroadcast_GetBroadcastChatInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_GetBroadcastChatInfo_Request| { &m.steamid },
                |m: &mut CBroadcast_GetBroadcastChatInfo_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_GetBroadcastChatInfo_Request| { &m.broadcast_id },
                |m: &mut CBroadcast_GetBroadcastChatInfo_Request| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_ip",
                |m: &CBroadcast_GetBroadcastChatInfo_Request| { &m.client_ip },
                |m: &mut CBroadcast_GetBroadcastChatInfo_Request| { &mut m.client_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_cell",
                |m: &CBroadcast_GetBroadcastChatInfo_Request| { &m.client_cell },
                |m: &mut CBroadcast_GetBroadcastChatInfo_Request| { &mut m.client_cell },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastChatInfo_Request>(
                "CBroadcast_GetBroadcastChatInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatInfo_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastChatInfo_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastChatInfo_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastChatInfo_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_id = ::std::option::Option::None;
        self.client_ip = ::std::option::Option::None;
        self.client_cell = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastChatInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastChatInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastChatInfo_Response {
    // message fields
    chat_id: ::std::option::Option<u64>,
    view_url_template: ::protobuf::SingularField<::std::string::String>,
    pub flair_group_ids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatInfo_Response {
    fn default() -> &'a CBroadcast_GetBroadcastChatInfo_Response {
        <CBroadcast_GetBroadcastChatInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatInfo_Response {
    pub fn new() -> CBroadcast_GetBroadcastChatInfo_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string view_url_template = 3;


    pub fn get_view_url_template(&self) -> &str {
        match self.view_url_template.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_view_url_template(&mut self) {
        self.view_url_template.clear();
    }

    pub fn has_view_url_template(&self) -> bool {
        self.view_url_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_url_template(&mut self, v: ::std::string::String) {
        self.view_url_template = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_url_template(&mut self) -> &mut ::std::string::String {
        if self.view_url_template.is_none() {
            self.view_url_template.set_default();
        }
        self.view_url_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_url_template(&mut self) -> ::std::string::String {
        self.view_url_template.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 flair_group_ids = 4;


    pub fn get_flair_group_ids(&self) -> &[u32] {
        &self.flair_group_ids
    }
    pub fn clear_flair_group_ids(&mut self) {
        self.flair_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_flair_group_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.flair_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flair_group_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.flair_group_ids
    }

    // Take field
    pub fn take_flair_group_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.flair_group_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatInfo_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.view_url_template)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.flair_group_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 9;
        }
        if let Some(ref v) = self.view_url_template.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.flair_group_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.view_url_template.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.flair_group_ids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastChatInfo_Response {
        CBroadcast_GetBroadcastChatInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "chat_id",
                |m: &CBroadcast_GetBroadcastChatInfo_Response| { &m.chat_id },
                |m: &mut CBroadcast_GetBroadcastChatInfo_Response| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "view_url_template",
                |m: &CBroadcast_GetBroadcastChatInfo_Response| { &m.view_url_template },
                |m: &mut CBroadcast_GetBroadcastChatInfo_Response| { &mut m.view_url_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flair_group_ids",
                |m: &CBroadcast_GetBroadcastChatInfo_Response| { &m.flair_group_ids },
                |m: &mut CBroadcast_GetBroadcastChatInfo_Response| { &mut m.flair_group_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastChatInfo_Response>(
                "CBroadcast_GetBroadcastChatInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatInfo_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastChatInfo_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastChatInfo_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastChatInfo_Response {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.view_url_template.clear();
        self.flair_group_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastChatInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastChatInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_PostChatMessage_Request {
    // message fields
    chat_id: ::std::option::Option<u64>,
    message: ::protobuf::SingularField<::std::string::String>,
    instance_id: ::std::option::Option<u32>,
    language: ::std::option::Option<u32>,
    country_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_PostChatMessage_Request {
    fn default() -> &'a CBroadcast_PostChatMessage_Request {
        <CBroadcast_PostChatMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_PostChatMessage_Request {
    pub fn new() -> CBroadcast_PostChatMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 instance_id = 3;


    pub fn get_instance_id(&self) -> u32 {
        self.instance_id.unwrap_or(0)
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 language = 4;


    pub fn get_language(&self) -> u32 {
        self.language.unwrap_or(0u32)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional string country_code = 5;


    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_PostChatMessage_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instance_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 9;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.language {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_PostChatMessage_Request {
        CBroadcast_PostChatMessage_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "chat_id",
                |m: &CBroadcast_PostChatMessage_Request| { &m.chat_id },
                |m: &mut CBroadcast_PostChatMessage_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CBroadcast_PostChatMessage_Request| { &m.message },
                |m: &mut CBroadcast_PostChatMessage_Request| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "instance_id",
                |m: &CBroadcast_PostChatMessage_Request| { &m.instance_id },
                |m: &mut CBroadcast_PostChatMessage_Request| { &mut m.instance_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "language",
                |m: &CBroadcast_PostChatMessage_Request| { &m.language },
                |m: &mut CBroadcast_PostChatMessage_Request| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country_code",
                |m: &CBroadcast_PostChatMessage_Request| { &m.country_code },
                |m: &mut CBroadcast_PostChatMessage_Request| { &mut m.country_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_PostChatMessage_Request>(
                "CBroadcast_PostChatMessage_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_PostChatMessage_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_PostChatMessage_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_PostChatMessage_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_PostChatMessage_Request {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.message.clear();
        self.instance_id = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.country_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_PostChatMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_PostChatMessage_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_PostChatMessage_Response {
    // message fields
    persona_name: ::protobuf::SingularField<::std::string::String>,
    in_game: ::std::option::Option<bool>,
    result: ::std::option::Option<i32>,
    cooldown_time_seconds: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_PostChatMessage_Response {
    fn default() -> &'a CBroadcast_PostChatMessage_Response {
        <CBroadcast_PostChatMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_PostChatMessage_Response {
    pub fn new() -> CBroadcast_PostChatMessage_Response {
        ::std::default::Default::default()
    }

    // optional string persona_name = 1;


    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_game = 2;


    pub fn get_in_game(&self) -> bool {
        self.in_game.unwrap_or(false)
    }
    pub fn clear_in_game(&mut self) {
        self.in_game = ::std::option::Option::None;
    }

    pub fn has_in_game(&self) -> bool {
        self.in_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game(&mut self, v: bool) {
        self.in_game = ::std::option::Option::Some(v);
    }

    // optional int32 result = 3;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional int32 cooldown_time_seconds = 4;


    pub fn get_cooldown_time_seconds(&self) -> i32 {
        self.cooldown_time_seconds.unwrap_or(0)
    }
    pub fn clear_cooldown_time_seconds(&mut self) {
        self.cooldown_time_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_time_seconds(&self) -> bool {
        self.cooldown_time_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_time_seconds(&mut self, v: i32) {
        self.cooldown_time_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_PostChatMessage_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_game = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cooldown_time_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.in_game {
            my_size += 2;
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cooldown_time_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.persona_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.in_game {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cooldown_time_seconds {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_PostChatMessage_Response {
        CBroadcast_PostChatMessage_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name",
                |m: &CBroadcast_PostChatMessage_Response| { &m.persona_name },
                |m: &mut CBroadcast_PostChatMessage_Response| { &mut m.persona_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_game",
                |m: &CBroadcast_PostChatMessage_Response| { &m.in_game },
                |m: &mut CBroadcast_PostChatMessage_Response| { &mut m.in_game },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &CBroadcast_PostChatMessage_Response| { &m.result },
                |m: &mut CBroadcast_PostChatMessage_Response| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cooldown_time_seconds",
                |m: &CBroadcast_PostChatMessage_Response| { &m.cooldown_time_seconds },
                |m: &mut CBroadcast_PostChatMessage_Response| { &mut m.cooldown_time_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_PostChatMessage_Response>(
                "CBroadcast_PostChatMessage_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_PostChatMessage_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_PostChatMessage_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_PostChatMessage_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_PostChatMessage_Response {
    fn clear(&mut self) {
        self.persona_name.clear();
        self.in_game = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.cooldown_time_seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_PostChatMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_PostChatMessage_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_UpdateChatMessageFlair_Request {
    // message fields
    chat_id: ::std::option::Option<u64>,
    flair: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_UpdateChatMessageFlair_Request {
    fn default() -> &'a CBroadcast_UpdateChatMessageFlair_Request {
        <CBroadcast_UpdateChatMessageFlair_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_UpdateChatMessageFlair_Request {
    pub fn new() -> CBroadcast_UpdateChatMessageFlair_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string flair = 2;


    pub fn get_flair(&self) -> &str {
        match self.flair.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_flair(&mut self) {
        self.flair.clear();
    }

    pub fn has_flair(&self) -> bool {
        self.flair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flair(&mut self, v: ::std::string::String) {
        self.flair = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flair(&mut self) -> &mut ::std::string::String {
        if self.flair.is_none() {
            self.flair.set_default();
        }
        self.flair.as_mut().unwrap()
    }

    // Take field
    pub fn take_flair(&mut self) -> ::std::string::String {
        self.flair.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_UpdateChatMessageFlair_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.flair)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 9;
        }
        if let Some(ref v) = self.flair.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.flair.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_UpdateChatMessageFlair_Request {
        CBroadcast_UpdateChatMessageFlair_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "chat_id",
                |m: &CBroadcast_UpdateChatMessageFlair_Request| { &m.chat_id },
                |m: &mut CBroadcast_UpdateChatMessageFlair_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "flair",
                |m: &CBroadcast_UpdateChatMessageFlair_Request| { &m.flair },
                |m: &mut CBroadcast_UpdateChatMessageFlair_Request| { &mut m.flair },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_UpdateChatMessageFlair_Request>(
                "CBroadcast_UpdateChatMessageFlair_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_UpdateChatMessageFlair_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_UpdateChatMessageFlair_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_UpdateChatMessageFlair_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_UpdateChatMessageFlair_Request {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.flair.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_UpdateChatMessageFlair_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_UpdateChatMessageFlair_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_UpdateChatMessageFlair_Response {
    // message fields
    result: ::std::option::Option<i32>,
    chat_id: ::std::option::Option<u64>,
    flair: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_UpdateChatMessageFlair_Response {
    fn default() -> &'a CBroadcast_UpdateChatMessageFlair_Response {
        <CBroadcast_UpdateChatMessageFlair_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_UpdateChatMessageFlair_Response {
    pub fn new() -> CBroadcast_UpdateChatMessageFlair_Response {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional fixed64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string flair = 3;


    pub fn get_flair(&self) -> &str {
        match self.flair.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_flair(&mut self) {
        self.flair.clear();
    }

    pub fn has_flair(&self) -> bool {
        self.flair.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flair(&mut self, v: ::std::string::String) {
        self.flair = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flair(&mut self) -> &mut ::std::string::String {
        if self.flair.is_none() {
            self.flair.set_default();
        }
        self.flair.as_mut().unwrap()
    }

    // Take field
    pub fn take_flair(&mut self) -> ::std::string::String {
        self.flair.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_UpdateChatMessageFlair_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.flair)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += 9;
        }
        if let Some(ref v) = self.flair.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.flair.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_UpdateChatMessageFlair_Response {
        CBroadcast_UpdateChatMessageFlair_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &CBroadcast_UpdateChatMessageFlair_Response| { &m.result },
                |m: &mut CBroadcast_UpdateChatMessageFlair_Response| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "chat_id",
                |m: &CBroadcast_UpdateChatMessageFlair_Response| { &m.chat_id },
                |m: &mut CBroadcast_UpdateChatMessageFlair_Response| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "flair",
                |m: &CBroadcast_UpdateChatMessageFlair_Response| { &m.flair },
                |m: &mut CBroadcast_UpdateChatMessageFlair_Response| { &mut m.flair },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_UpdateChatMessageFlair_Response>(
                "CBroadcast_UpdateChatMessageFlair_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_UpdateChatMessageFlair_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_UpdateChatMessageFlair_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_UpdateChatMessageFlair_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_UpdateChatMessageFlair_Response {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.flair.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_UpdateChatMessageFlair_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_UpdateChatMessageFlair_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_MuteBroadcastChatUser_Request {
    // message fields
    chat_id: ::std::option::Option<u64>,
    user_steamid: ::std::option::Option<u64>,
    muted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_MuteBroadcastChatUser_Request {
    fn default() -> &'a CBroadcast_MuteBroadcastChatUser_Request {
        <CBroadcast_MuteBroadcastChatUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_MuteBroadcastChatUser_Request {
    pub fn new() -> CBroadcast_MuteBroadcastChatUser_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 user_steamid = 2;


    pub fn get_user_steamid(&self) -> u64 {
        self.user_steamid.unwrap_or(0)
    }
    pub fn clear_user_steamid(&mut self) {
        self.user_steamid = ::std::option::Option::None;
    }

    pub fn has_user_steamid(&self) -> bool {
        self.user_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_steamid(&mut self, v: u64) {
        self.user_steamid = ::std::option::Option::Some(v);
    }

    // optional bool muted = 3;


    pub fn get_muted(&self) -> bool {
        self.muted.unwrap_or(false)
    }
    pub fn clear_muted(&mut self) {
        self.muted = ::std::option::Option::None;
    }

    pub fn has_muted(&self) -> bool {
        self.muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muted(&mut self, v: bool) {
        self.muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_MuteBroadcastChatUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.user_steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.muted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 9;
        }
        if let Some(v) = self.user_steamid {
            my_size += 9;
        }
        if let Some(v) = self.muted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.user_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.muted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_MuteBroadcastChatUser_Request {
        CBroadcast_MuteBroadcastChatUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "chat_id",
                |m: &CBroadcast_MuteBroadcastChatUser_Request| { &m.chat_id },
                |m: &mut CBroadcast_MuteBroadcastChatUser_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "user_steamid",
                |m: &CBroadcast_MuteBroadcastChatUser_Request| { &m.user_steamid },
                |m: &mut CBroadcast_MuteBroadcastChatUser_Request| { &mut m.user_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "muted",
                |m: &CBroadcast_MuteBroadcastChatUser_Request| { &m.muted },
                |m: &mut CBroadcast_MuteBroadcastChatUser_Request| { &mut m.muted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_MuteBroadcastChatUser_Request>(
                "CBroadcast_MuteBroadcastChatUser_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_MuteBroadcastChatUser_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_MuteBroadcastChatUser_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_MuteBroadcastChatUser_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_MuteBroadcastChatUser_Request {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.user_steamid = ::std::option::Option::None;
        self.muted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_MuteBroadcastChatUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_MuteBroadcastChatUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_MuteBroadcastChatUser_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_MuteBroadcastChatUser_Response {
    fn default() -> &'a CBroadcast_MuteBroadcastChatUser_Response {
        <CBroadcast_MuteBroadcastChatUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_MuteBroadcastChatUser_Response {
    pub fn new() -> CBroadcast_MuteBroadcastChatUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_MuteBroadcastChatUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_MuteBroadcastChatUser_Response {
        CBroadcast_MuteBroadcastChatUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_MuteBroadcastChatUser_Response>(
                "CBroadcast_MuteBroadcastChatUser_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_MuteBroadcastChatUser_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_MuteBroadcastChatUser_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_MuteBroadcastChatUser_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_MuteBroadcastChatUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_MuteBroadcastChatUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_MuteBroadcastChatUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_RemoveUserChatText_Request {
    // message fields
    chat_id: ::std::option::Option<u64>,
    user_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_RemoveUserChatText_Request {
    fn default() -> &'a CBroadcast_RemoveUserChatText_Request {
        <CBroadcast_RemoveUserChatText_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_RemoveUserChatText_Request {
    pub fn new() -> CBroadcast_RemoveUserChatText_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 user_steamid = 2;


    pub fn get_user_steamid(&self) -> u64 {
        self.user_steamid.unwrap_or(0)
    }
    pub fn clear_user_steamid(&mut self) {
        self.user_steamid = ::std::option::Option::None;
    }

    pub fn has_user_steamid(&self) -> bool {
        self.user_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_steamid(&mut self, v: u64) {
        self.user_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_RemoveUserChatText_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.user_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 9;
        }
        if let Some(v) = self.user_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.user_steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_RemoveUserChatText_Request {
        CBroadcast_RemoveUserChatText_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "chat_id",
                |m: &CBroadcast_RemoveUserChatText_Request| { &m.chat_id },
                |m: &mut CBroadcast_RemoveUserChatText_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "user_steamid",
                |m: &CBroadcast_RemoveUserChatText_Request| { &m.user_steamid },
                |m: &mut CBroadcast_RemoveUserChatText_Request| { &mut m.user_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_RemoveUserChatText_Request>(
                "CBroadcast_RemoveUserChatText_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_RemoveUserChatText_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_RemoveUserChatText_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_RemoveUserChatText_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_RemoveUserChatText_Request {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.user_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_RemoveUserChatText_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_RemoveUserChatText_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_RemoveUserChatText_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_RemoveUserChatText_Response {
    fn default() -> &'a CBroadcast_RemoveUserChatText_Response {
        <CBroadcast_RemoveUserChatText_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_RemoveUserChatText_Response {
    pub fn new() -> CBroadcast_RemoveUserChatText_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_RemoveUserChatText_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_RemoveUserChatText_Response {
        CBroadcast_RemoveUserChatText_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_RemoveUserChatText_Response>(
                "CBroadcast_RemoveUserChatText_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_RemoveUserChatText_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_RemoveUserChatText_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_RemoveUserChatText_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_RemoveUserChatText_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_RemoveUserChatText_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_RemoveUserChatText_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastChatUserNames_Request {
    // message fields
    chat_id: ::std::option::Option<u64>,
    pub user_steamid: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatUserNames_Request {
    fn default() -> &'a CBroadcast_GetBroadcastChatUserNames_Request {
        <CBroadcast_GetBroadcastChatUserNames_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatUserNames_Request {
    pub fn new() -> CBroadcast_GetBroadcastChatUserNames_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // repeated fixed64 user_steamid = 2;


    pub fn get_user_steamid(&self) -> &[u64] {
        &self.user_steamid
    }
    pub fn clear_user_steamid(&mut self) {
        self.user_steamid.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_steamid(&mut self, v: ::std::vec::Vec<u64>) {
        self.user_steamid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_steamid(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.user_steamid
    }

    // Take field
    pub fn take_user_steamid(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.user_steamid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatUserNames_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.user_steamid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 9;
        }
        my_size += 9 * self.user_steamid.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.user_steamid {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastChatUserNames_Request {
        CBroadcast_GetBroadcastChatUserNames_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "chat_id",
                |m: &CBroadcast_GetBroadcastChatUserNames_Request| { &m.chat_id },
                |m: &mut CBroadcast_GetBroadcastChatUserNames_Request| { &mut m.chat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "user_steamid",
                |m: &CBroadcast_GetBroadcastChatUserNames_Request| { &m.user_steamid },
                |m: &mut CBroadcast_GetBroadcastChatUserNames_Request| { &mut m.user_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastChatUserNames_Request>(
                "CBroadcast_GetBroadcastChatUserNames_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatUserNames_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastChatUserNames_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastChatUserNames_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastChatUserNames_Request {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.user_steamid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastChatUserNames_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastChatUserNames_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastChatUserNames_Response {
    // message fields
    pub persona_names: ::protobuf::RepeatedField<CBroadcast_GetBroadcastChatUserNames_Response_PersonaName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatUserNames_Response {
    fn default() -> &'a CBroadcast_GetBroadcastChatUserNames_Response {
        <CBroadcast_GetBroadcastChatUserNames_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatUserNames_Response {
    pub fn new() -> CBroadcast_GetBroadcastChatUserNames_Response {
        ::std::default::Default::default()
    }

    // repeated .CBroadcast_GetBroadcastChatUserNames_Response.PersonaName persona_names = 1;


    pub fn get_persona_names(&self) -> &[CBroadcast_GetBroadcastChatUserNames_Response_PersonaName] {
        &self.persona_names
    }
    pub fn clear_persona_names(&mut self) {
        self.persona_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_persona_names(&mut self, v: ::protobuf::RepeatedField<CBroadcast_GetBroadcastChatUserNames_Response_PersonaName>) {
        self.persona_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_persona_names(&mut self) -> &mut ::protobuf::RepeatedField<CBroadcast_GetBroadcastChatUserNames_Response_PersonaName> {
        &mut self.persona_names
    }

    // Take field
    pub fn take_persona_names(&mut self) -> ::protobuf::RepeatedField<CBroadcast_GetBroadcastChatUserNames_Response_PersonaName> {
        ::std::mem::replace(&mut self.persona_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatUserNames_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.persona_names {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.persona_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.persona_names {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.persona_names {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastChatUserNames_Response {
        CBroadcast_GetBroadcastChatUserNames_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_GetBroadcastChatUserNames_Response_PersonaName>>(
                "persona_names",
                |m: &CBroadcast_GetBroadcastChatUserNames_Response| { &m.persona_names },
                |m: &mut CBroadcast_GetBroadcastChatUserNames_Response| { &mut m.persona_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastChatUserNames_Response>(
                "CBroadcast_GetBroadcastChatUserNames_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatUserNames_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastChatUserNames_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastChatUserNames_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastChatUserNames_Response {
    fn clear(&mut self) {
        self.persona_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastChatUserNames_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastChatUserNames_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
    // message fields
    steam_id: ::std::option::Option<u64>,
    persona: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
    fn default() -> &'a CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
        <CBroadcast_GetBroadcastChatUserNames_Response_PersonaName as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
    pub fn new() -> CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional string persona = 2;


    pub fn get_persona(&self) -> &str {
        match self.persona.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona(&mut self) {
        self.persona.clear();
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: ::std::string::String) {
        self.persona = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut ::std::string::String {
        if self.persona.is_none() {
            self.persona.set_default();
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> ::std::string::String {
        self.persona.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.persona.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.persona.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
        CBroadcast_GetBroadcastChatUserNames_Response_PersonaName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CBroadcast_GetBroadcastChatUserNames_Response_PersonaName| { &m.steam_id },
                |m: &mut CBroadcast_GetBroadcastChatUserNames_Response_PersonaName| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona",
                |m: &CBroadcast_GetBroadcastChatUserNames_Response_PersonaName| { &m.persona },
                |m: &mut CBroadcast_GetBroadcastChatUserNames_Response_PersonaName| { &mut m.persona },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastChatUserNames_Response_PersonaName>(
                "CBroadcast_GetBroadcastChatUserNames_Response.PersonaName",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastChatUserNames_Response_PersonaName> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastChatUserNames_Response_PersonaName::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.persona.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_StartBuildClip_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    broadcast_session_id: ::std::option::Option<u64>,
    first_segment: ::std::option::Option<i32>,
    num_segments: ::std::option::Option<i32>,
    clip_description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBuildClip_Request {
    fn default() -> &'a CBroadcast_StartBuildClip_Request {
        <CBroadcast_StartBuildClip_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBuildClip_Request {
    pub fn new() -> CBroadcast_StartBuildClip_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_session_id = 2;


    pub fn get_broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }
    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional int32 first_segment = 3;


    pub fn get_first_segment(&self) -> i32 {
        self.first_segment.unwrap_or(0)
    }
    pub fn clear_first_segment(&mut self) {
        self.first_segment = ::std::option::Option::None;
    }

    pub fn has_first_segment(&self) -> bool {
        self.first_segment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_segment(&mut self, v: i32) {
        self.first_segment = ::std::option::Option::Some(v);
    }

    // optional int32 num_segments = 4;


    pub fn get_num_segments(&self) -> i32 {
        self.num_segments.unwrap_or(0)
    }
    pub fn clear_num_segments(&mut self) {
        self.num_segments = ::std::option::Option::None;
    }

    pub fn has_num_segments(&self) -> bool {
        self.num_segments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_segments(&mut self, v: i32) {
        self.num_segments = ::std::option::Option::Some(v);
    }

    // optional string clip_description = 5;


    pub fn get_clip_description(&self) -> &str {
        match self.clip_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clip_description(&mut self) {
        self.clip_description.clear();
    }

    pub fn has_clip_description(&self) -> bool {
        self.clip_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_description(&mut self, v: ::std::string::String) {
        self.clip_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_description(&mut self) -> &mut ::std::string::String {
        if self.clip_description.is_none() {
            self.clip_description.set_default();
        }
        self.clip_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_description(&mut self) -> ::std::string::String {
        self.clip_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_StartBuildClip_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.first_segment = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_segments = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clip_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.broadcast_session_id {
            my_size += 9;
        }
        if let Some(v) = self.first_segment {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_segments {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clip_description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.first_segment {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.num_segments {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.clip_description.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_StartBuildClip_Request {
        CBroadcast_StartBuildClip_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_StartBuildClip_Request| { &m.steamid },
                |m: &mut CBroadcast_StartBuildClip_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_session_id",
                |m: &CBroadcast_StartBuildClip_Request| { &m.broadcast_session_id },
                |m: &mut CBroadcast_StartBuildClip_Request| { &mut m.broadcast_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "first_segment",
                |m: &CBroadcast_StartBuildClip_Request| { &m.first_segment },
                |m: &mut CBroadcast_StartBuildClip_Request| { &mut m.first_segment },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_segments",
                |m: &CBroadcast_StartBuildClip_Request| { &m.num_segments },
                |m: &mut CBroadcast_StartBuildClip_Request| { &mut m.num_segments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clip_description",
                |m: &CBroadcast_StartBuildClip_Request| { &m.clip_description },
                |m: &mut CBroadcast_StartBuildClip_Request| { &mut m.clip_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_StartBuildClip_Request>(
                "CBroadcast_StartBuildClip_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_StartBuildClip_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_StartBuildClip_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_StartBuildClip_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_StartBuildClip_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.broadcast_session_id = ::std::option::Option::None;
        self.first_segment = ::std::option::Option::None;
        self.num_segments = ::std::option::Option::None;
        self.clip_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_StartBuildClip_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_StartBuildClip_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_StartBuildClip_Response {
    // message fields
    broadcast_clip_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StartBuildClip_Response {
    fn default() -> &'a CBroadcast_StartBuildClip_Response {
        <CBroadcast_StartBuildClip_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StartBuildClip_Response {
    pub fn new() -> CBroadcast_StartBuildClip_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_clip_id = 1;


    pub fn get_broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }
    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StartBuildClip_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_clip_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_StartBuildClip_Response {
        CBroadcast_StartBuildClip_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_clip_id",
                |m: &CBroadcast_StartBuildClip_Response| { &m.broadcast_clip_id },
                |m: &mut CBroadcast_StartBuildClip_Response| { &mut m.broadcast_clip_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_StartBuildClip_Response>(
                "CBroadcast_StartBuildClip_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_StartBuildClip_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_StartBuildClip_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_StartBuildClip_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_StartBuildClip_Response {
    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_StartBuildClip_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_StartBuildClip_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBuildClipStatus_Request {
    // message fields
    broadcast_clip_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBuildClipStatus_Request {
    fn default() -> &'a CBroadcast_GetBuildClipStatus_Request {
        <CBroadcast_GetBuildClipStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBuildClipStatus_Request {
    pub fn new() -> CBroadcast_GetBuildClipStatus_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_clip_id = 1;


    pub fn get_broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }
    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBuildClipStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_clip_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBuildClipStatus_Request {
        CBroadcast_GetBuildClipStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_clip_id",
                |m: &CBroadcast_GetBuildClipStatus_Request| { &m.broadcast_clip_id },
                |m: &mut CBroadcast_GetBuildClipStatus_Request| { &mut m.broadcast_clip_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBuildClipStatus_Request>(
                "CBroadcast_GetBuildClipStatus_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBuildClipStatus_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBuildClipStatus_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBuildClipStatus_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBuildClipStatus_Request {
    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBuildClipStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBuildClipStatus_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBuildClipStatus_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBuildClipStatus_Response {
    fn default() -> &'a CBroadcast_GetBuildClipStatus_Response {
        <CBroadcast_GetBuildClipStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBuildClipStatus_Response {
    pub fn new() -> CBroadcast_GetBuildClipStatus_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_GetBuildClipStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBuildClipStatus_Response {
        CBroadcast_GetBuildClipStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBuildClipStatus_Response>(
                "CBroadcast_GetBuildClipStatus_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBuildClipStatus_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBuildClipStatus_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBuildClipStatus_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBuildClipStatus_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBuildClipStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBuildClipStatus_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SetClipDetails_Request {
    // message fields
    broadcast_clip_id: ::std::option::Option<u64>,
    start_time: ::std::option::Option<u32>,
    end_time: ::std::option::Option<u32>,
    video_description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetClipDetails_Request {
    fn default() -> &'a CBroadcast_SetClipDetails_Request {
        <CBroadcast_SetClipDetails_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetClipDetails_Request {
    pub fn new() -> CBroadcast_SetClipDetails_Request {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;


    pub fn get_broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }
    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 2;


    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time = 3;


    pub fn get_end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional string video_description = 4;


    pub fn get_video_description(&self) -> &str {
        match self.video_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_video_description(&mut self) {
        self.video_description.clear();
    }

    pub fn has_video_description(&self) -> bool {
        self.video_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_description(&mut self, v: ::std::string::String) {
        self.video_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_description(&mut self) -> &mut ::std::string::String {
        if self.video_description.is_none() {
            self.video_description.set_default();
        }
        self.video_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_description(&mut self) -> ::std::string::String {
        self.video_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_SetClipDetails_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.broadcast_clip_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.video_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.video_description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.video_description.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SetClipDetails_Request {
        CBroadcast_SetClipDetails_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "broadcast_clip_id",
                |m: &CBroadcast_SetClipDetails_Request| { &m.broadcast_clip_id },
                |m: &mut CBroadcast_SetClipDetails_Request| { &mut m.broadcast_clip_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_time",
                |m: &CBroadcast_SetClipDetails_Request| { &m.start_time },
                |m: &mut CBroadcast_SetClipDetails_Request| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "end_time",
                |m: &CBroadcast_SetClipDetails_Request| { &m.end_time },
                |m: &mut CBroadcast_SetClipDetails_Request| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "video_description",
                |m: &CBroadcast_SetClipDetails_Request| { &m.video_description },
                |m: &mut CBroadcast_SetClipDetails_Request| { &mut m.video_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SetClipDetails_Request>(
                "CBroadcast_SetClipDetails_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SetClipDetails_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SetClipDetails_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SetClipDetails_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SetClipDetails_Request {
    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.video_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SetClipDetails_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SetClipDetails_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SetClipDetails_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetClipDetails_Response {
    fn default() -> &'a CBroadcast_SetClipDetails_Response {
        <CBroadcast_SetClipDetails_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetClipDetails_Response {
    pub fn new() -> CBroadcast_SetClipDetails_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_SetClipDetails_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SetClipDetails_Response {
        CBroadcast_SetClipDetails_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SetClipDetails_Response>(
                "CBroadcast_SetClipDetails_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SetClipDetails_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SetClipDetails_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SetClipDetails_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SetClipDetails_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SetClipDetails_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SetClipDetails_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetClipDetails_Request {
    // message fields
    broadcast_clip_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetClipDetails_Request {
    fn default() -> &'a CBroadcast_GetClipDetails_Request {
        <CBroadcast_GetClipDetails_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetClipDetails_Request {
    pub fn new() -> CBroadcast_GetClipDetails_Request {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;


    pub fn get_broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }
    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetClipDetails_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.broadcast_clip_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetClipDetails_Request {
        CBroadcast_GetClipDetails_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "broadcast_clip_id",
                |m: &CBroadcast_GetClipDetails_Request| { &m.broadcast_clip_id },
                |m: &mut CBroadcast_GetClipDetails_Request| { &mut m.broadcast_clip_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetClipDetails_Request>(
                "CBroadcast_GetClipDetails_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetClipDetails_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetClipDetails_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetClipDetails_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetClipDetails_Request {
    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetClipDetails_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetClipDetails_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetClipDetails_Response {
    // message fields
    broadcast_clip_id: ::std::option::Option<u64>,
    video_id: ::std::option::Option<u64>,
    channel_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    accountid_broadcaster: ::std::option::Option<u32>,
    accountid_clipmaker: ::std::option::Option<u32>,
    video_description: ::protobuf::SingularField<::std::string::String>,
    start_time: ::std::option::Option<u32>,
    length_milliseconds: ::std::option::Option<u32>,
    thumbnail_path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetClipDetails_Response {
    fn default() -> &'a CBroadcast_GetClipDetails_Response {
        <CBroadcast_GetClipDetails_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetClipDetails_Response {
    pub fn new() -> CBroadcast_GetClipDetails_Response {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;


    pub fn get_broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }
    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }

    // optional uint64 video_id = 2;


    pub fn get_video_id(&self) -> u64 {
        self.video_id.unwrap_or(0)
    }
    pub fn clear_video_id(&mut self) {
        self.video_id = ::std::option::Option::None;
    }

    pub fn has_video_id(&self) -> bool {
        self.video_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_id(&mut self, v: u64) {
        self.video_id = ::std::option::Option::Some(v);
    }

    // optional uint64 channel_id = 3;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id.unwrap_or(0)
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 4;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_broadcaster = 5;


    pub fn get_accountid_broadcaster(&self) -> u32 {
        self.accountid_broadcaster.unwrap_or(0)
    }
    pub fn clear_accountid_broadcaster(&mut self) {
        self.accountid_broadcaster = ::std::option::Option::None;
    }

    pub fn has_accountid_broadcaster(&self) -> bool {
        self.accountid_broadcaster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_broadcaster(&mut self, v: u32) {
        self.accountid_broadcaster = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_clipmaker = 6;


    pub fn get_accountid_clipmaker(&self) -> u32 {
        self.accountid_clipmaker.unwrap_or(0)
    }
    pub fn clear_accountid_clipmaker(&mut self) {
        self.accountid_clipmaker = ::std::option::Option::None;
    }

    pub fn has_accountid_clipmaker(&self) -> bool {
        self.accountid_clipmaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_clipmaker(&mut self, v: u32) {
        self.accountid_clipmaker = ::std::option::Option::Some(v);
    }

    // optional string video_description = 7;


    pub fn get_video_description(&self) -> &str {
        match self.video_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_video_description(&mut self) {
        self.video_description.clear();
    }

    pub fn has_video_description(&self) -> bool {
        self.video_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_description(&mut self, v: ::std::string::String) {
        self.video_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_description(&mut self) -> &mut ::std::string::String {
        if self.video_description.is_none() {
            self.video_description.set_default();
        }
        self.video_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_description(&mut self) -> ::std::string::String {
        self.video_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 start_time = 8;


    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 length_milliseconds = 9;


    pub fn get_length_milliseconds(&self) -> u32 {
        self.length_milliseconds.unwrap_or(0)
    }
    pub fn clear_length_milliseconds(&mut self) {
        self.length_milliseconds = ::std::option::Option::None;
    }

    pub fn has_length_milliseconds(&self) -> bool {
        self.length_milliseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_milliseconds(&mut self, v: u32) {
        self.length_milliseconds = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_path = 10;


    pub fn get_thumbnail_path(&self) -> &str {
        match self.thumbnail_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbnail_path(&mut self) {
        self.thumbnail_path.clear();
    }

    pub fn has_thumbnail_path(&self) -> bool {
        self.thumbnail_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_path(&mut self, v: ::std::string::String) {
        self.thumbnail_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_path(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_path.is_none() {
            self.thumbnail_path.set_default();
        }
        self.thumbnail_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_path(&mut self) -> ::std::string::String {
        self.thumbnail_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetClipDetails_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.broadcast_clip_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.video_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_broadcaster = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_clipmaker = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.video_description)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length_milliseconds = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnail_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.video_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_broadcaster {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_clipmaker {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.video_description.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length_milliseconds {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.thumbnail_path.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.video_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.accountid_broadcaster {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.accountid_clipmaker {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.video_description.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.length_milliseconds {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.thumbnail_path.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetClipDetails_Response {
        CBroadcast_GetClipDetails_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "broadcast_clip_id",
                |m: &CBroadcast_GetClipDetails_Response| { &m.broadcast_clip_id },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.broadcast_clip_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "video_id",
                |m: &CBroadcast_GetClipDetails_Response| { &m.video_id },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.video_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "channel_id",
                |m: &CBroadcast_GetClipDetails_Response| { &m.channel_id },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CBroadcast_GetClipDetails_Response| { &m.app_id },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_broadcaster",
                |m: &CBroadcast_GetClipDetails_Response| { &m.accountid_broadcaster },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.accountid_broadcaster },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_clipmaker",
                |m: &CBroadcast_GetClipDetails_Response| { &m.accountid_clipmaker },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.accountid_clipmaker },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "video_description",
                |m: &CBroadcast_GetClipDetails_Response| { &m.video_description },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.video_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_time",
                |m: &CBroadcast_GetClipDetails_Response| { &m.start_time },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "length_milliseconds",
                |m: &CBroadcast_GetClipDetails_Response| { &m.length_milliseconds },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.length_milliseconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_path",
                |m: &CBroadcast_GetClipDetails_Response| { &m.thumbnail_path },
                |m: &mut CBroadcast_GetClipDetails_Response| { &mut m.thumbnail_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetClipDetails_Response>(
                "CBroadcast_GetClipDetails_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetClipDetails_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetClipDetails_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetClipDetails_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetClipDetails_Response {
    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.video_id = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.accountid_broadcaster = ::std::option::Option::None;
        self.accountid_clipmaker = ::std::option::Option::None;
        self.video_description.clear();
        self.start_time = ::std::option::Option::None;
        self.length_milliseconds = ::std::option::Option::None;
        self.thumbnail_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetClipDetails_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetClipDetails_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SetRTMPInfo_Request {
    // message fields
    broadcast_permission: ::std::option::Option<i32>,
    update_token: ::std::option::Option<bool>,
    broadcast_delay: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    required_app_id: ::std::option::Option<u32>,
    broadcast_chat_permission: ::std::option::Option<EBroadcastChatPermission>,
    broadcast_buffer: ::std::option::Option<i32>,
    steamid: ::std::option::Option<u64>,
    chat_rate_limit: ::std::option::Option<u32>,
    enable_replay: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetRTMPInfo_Request {
    fn default() -> &'a CBroadcast_SetRTMPInfo_Request {
        <CBroadcast_SetRTMPInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetRTMPInfo_Request {
    pub fn new() -> CBroadcast_SetRTMPInfo_Request {
        ::std::default::Default::default()
    }

    // optional int32 broadcast_permission = 1;


    pub fn get_broadcast_permission(&self) -> i32 {
        self.broadcast_permission.unwrap_or(0)
    }
    pub fn clear_broadcast_permission(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_permission(&self) -> bool {
        self.broadcast_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permission(&mut self, v: i32) {
        self.broadcast_permission = ::std::option::Option::Some(v);
    }

    // optional bool update_token = 2;


    pub fn get_update_token(&self) -> bool {
        self.update_token.unwrap_or(false)
    }
    pub fn clear_update_token(&mut self) {
        self.update_token = ::std::option::Option::None;
    }

    pub fn has_update_token(&self) -> bool {
        self.update_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_token(&mut self, v: bool) {
        self.update_token = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_delay = 3;


    pub fn get_broadcast_delay(&self) -> i32 {
        self.broadcast_delay.unwrap_or(0)
    }
    pub fn clear_broadcast_delay(&mut self) {
        self.broadcast_delay = ::std::option::Option::None;
    }

    pub fn has_broadcast_delay(&self) -> bool {
        self.broadcast_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_delay(&mut self, v: i32) {
        self.broadcast_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 4;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 required_app_id = 5;


    pub fn get_required_app_id(&self) -> u32 {
        self.required_app_id.unwrap_or(0)
    }
    pub fn clear_required_app_id(&mut self) {
        self.required_app_id = ::std::option::Option::None;
    }

    pub fn has_required_app_id(&self) -> bool {
        self.required_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_app_id(&mut self, v: u32) {
        self.required_app_id = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastChatPermission broadcast_chat_permission = 6;


    pub fn get_broadcast_chat_permission(&self) -> EBroadcastChatPermission {
        self.broadcast_chat_permission.unwrap_or(EBroadcastChatPermission::k_EBroadcastChatPermissionPublic)
    }
    pub fn clear_broadcast_chat_permission(&mut self) {
        self.broadcast_chat_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_chat_permission(&self) -> bool {
        self.broadcast_chat_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_chat_permission(&mut self, v: EBroadcastChatPermission) {
        self.broadcast_chat_permission = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_buffer = 7;


    pub fn get_broadcast_buffer(&self) -> i32 {
        self.broadcast_buffer.unwrap_or(0)
    }
    pub fn clear_broadcast_buffer(&mut self) {
        self.broadcast_buffer = ::std::option::Option::None;
    }

    pub fn has_broadcast_buffer(&self) -> bool {
        self.broadcast_buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_buffer(&mut self, v: i32) {
        self.broadcast_buffer = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 8;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_rate_limit = 9;


    pub fn get_chat_rate_limit(&self) -> u32 {
        self.chat_rate_limit.unwrap_or(0)
    }
    pub fn clear_chat_rate_limit(&mut self) {
        self.chat_rate_limit = ::std::option::Option::None;
    }

    pub fn has_chat_rate_limit(&self) -> bool {
        self.chat_rate_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_rate_limit(&mut self, v: u32) {
        self.chat_rate_limit = ::std::option::Option::Some(v);
    }

    // optional bool enable_replay = 10;


    pub fn get_enable_replay(&self) -> bool {
        self.enable_replay.unwrap_or(false)
    }
    pub fn clear_enable_replay(&mut self) {
        self.enable_replay = ::std::option::Option::None;
    }

    pub fn has_enable_replay(&self) -> bool {
        self.enable_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_replay(&mut self, v: bool) {
        self.enable_replay = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_SetRTMPInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.broadcast_permission = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_token = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.broadcast_delay = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.required_app_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.broadcast_chat_permission, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.broadcast_buffer = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chat_rate_limit = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_replay = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_permission {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_token {
            my_size += 2;
        }
        if let Some(v) = self.broadcast_delay {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.required_app_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.broadcast_chat_permission {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.broadcast_buffer {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_rate_limit {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_replay {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_permission {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_token {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.broadcast_delay {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.required_app_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.broadcast_chat_permission {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.broadcast_buffer {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(8, v)?;
        }
        if let Some(v) = self.chat_rate_limit {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.enable_replay {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SetRTMPInfo_Request {
        CBroadcast_SetRTMPInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "broadcast_permission",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.broadcast_permission },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.broadcast_permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_token",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.update_token },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.update_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "broadcast_delay",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.broadcast_delay },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.broadcast_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.app_id },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "required_app_id",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.required_app_id },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.required_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EBroadcastChatPermission>>(
                "broadcast_chat_permission",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.broadcast_chat_permission },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.broadcast_chat_permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "broadcast_buffer",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.broadcast_buffer },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.broadcast_buffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.steamid },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chat_rate_limit",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.chat_rate_limit },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.chat_rate_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_replay",
                |m: &CBroadcast_SetRTMPInfo_Request| { &m.enable_replay },
                |m: &mut CBroadcast_SetRTMPInfo_Request| { &mut m.enable_replay },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SetRTMPInfo_Request>(
                "CBroadcast_SetRTMPInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SetRTMPInfo_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SetRTMPInfo_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SetRTMPInfo_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SetRTMPInfo_Request {
    fn clear(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
        self.update_token = ::std::option::Option::None;
        self.broadcast_delay = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.required_app_id = ::std::option::Option::None;
        self.broadcast_chat_permission = ::std::option::Option::None;
        self.broadcast_buffer = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_rate_limit = ::std::option::Option::None;
        self.enable_replay = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SetRTMPInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SetRTMPInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SetRTMPInfo_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SetRTMPInfo_Response {
    fn default() -> &'a CBroadcast_SetRTMPInfo_Response {
        <CBroadcast_SetRTMPInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SetRTMPInfo_Response {
    pub fn new() -> CBroadcast_SetRTMPInfo_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_SetRTMPInfo_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SetRTMPInfo_Response {
        CBroadcast_SetRTMPInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SetRTMPInfo_Response>(
                "CBroadcast_SetRTMPInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SetRTMPInfo_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SetRTMPInfo_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SetRTMPInfo_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SetRTMPInfo_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SetRTMPInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SetRTMPInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetRTMPInfo_Request {
    // message fields
    ip: ::std::option::Option<u32>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetRTMPInfo_Request {
    fn default() -> &'a CBroadcast_GetRTMPInfo_Request {
        <CBroadcast_GetRTMPInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetRTMPInfo_Request {
    pub fn new() -> CBroadcast_GetRTMPInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 ip = 1;


    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }
    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetRTMPInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ip {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetRTMPInfo_Request {
        CBroadcast_GetRTMPInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ip",
                |m: &CBroadcast_GetRTMPInfo_Request| { &m.ip },
                |m: &mut CBroadcast_GetRTMPInfo_Request| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_GetRTMPInfo_Request| { &m.steamid },
                |m: &mut CBroadcast_GetRTMPInfo_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetRTMPInfo_Request>(
                "CBroadcast_GetRTMPInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetRTMPInfo_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetRTMPInfo_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetRTMPInfo_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetRTMPInfo_Request {
    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetRTMPInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetRTMPInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetRTMPInfo_Response {
    // message fields
    broadcast_permission: ::std::option::Option<i32>,
    rtmp_host: ::protobuf::SingularField<::std::string::String>,
    rtmp_token: ::protobuf::SingularField<::std::string::String>,
    broadcast_delay: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    required_app_id: ::std::option::Option<u32>,
    broadcast_chat_permission: ::std::option::Option<EBroadcastChatPermission>,
    broadcast_buffer: ::std::option::Option<i32>,
    steamid: ::std::option::Option<u64>,
    chat_rate_limit: ::std::option::Option<u32>,
    enable_replay: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetRTMPInfo_Response {
    fn default() -> &'a CBroadcast_GetRTMPInfo_Response {
        <CBroadcast_GetRTMPInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetRTMPInfo_Response {
    pub fn new() -> CBroadcast_GetRTMPInfo_Response {
        ::std::default::Default::default()
    }

    // optional int32 broadcast_permission = 1;


    pub fn get_broadcast_permission(&self) -> i32 {
        self.broadcast_permission.unwrap_or(0)
    }
    pub fn clear_broadcast_permission(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_permission(&self) -> bool {
        self.broadcast_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permission(&mut self, v: i32) {
        self.broadcast_permission = ::std::option::Option::Some(v);
    }

    // optional string rtmp_host = 2;


    pub fn get_rtmp_host(&self) -> &str {
        match self.rtmp_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_rtmp_host(&mut self) {
        self.rtmp_host.clear();
    }

    pub fn has_rtmp_host(&self) -> bool {
        self.rtmp_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_host(&mut self, v: ::std::string::String) {
        self.rtmp_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtmp_host(&mut self) -> &mut ::std::string::String {
        if self.rtmp_host.is_none() {
            self.rtmp_host.set_default();
        }
        self.rtmp_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_rtmp_host(&mut self) -> ::std::string::String {
        self.rtmp_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rtmp_token = 3;


    pub fn get_rtmp_token(&self) -> &str {
        match self.rtmp_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_rtmp_token(&mut self) {
        self.rtmp_token.clear();
    }

    pub fn has_rtmp_token(&self) -> bool {
        self.rtmp_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtmp_token(&mut self, v: ::std::string::String) {
        self.rtmp_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtmp_token(&mut self) -> &mut ::std::string::String {
        if self.rtmp_token.is_none() {
            self.rtmp_token.set_default();
        }
        self.rtmp_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_rtmp_token(&mut self) -> ::std::string::String {
        self.rtmp_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 broadcast_delay = 4;


    pub fn get_broadcast_delay(&self) -> i32 {
        self.broadcast_delay.unwrap_or(0)
    }
    pub fn clear_broadcast_delay(&mut self) {
        self.broadcast_delay = ::std::option::Option::None;
    }

    pub fn has_broadcast_delay(&self) -> bool {
        self.broadcast_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_delay(&mut self, v: i32) {
        self.broadcast_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 5;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 required_app_id = 6;


    pub fn get_required_app_id(&self) -> u32 {
        self.required_app_id.unwrap_or(0)
    }
    pub fn clear_required_app_id(&mut self) {
        self.required_app_id = ::std::option::Option::None;
    }

    pub fn has_required_app_id(&self) -> bool {
        self.required_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_app_id(&mut self, v: u32) {
        self.required_app_id = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastChatPermission broadcast_chat_permission = 7;


    pub fn get_broadcast_chat_permission(&self) -> EBroadcastChatPermission {
        self.broadcast_chat_permission.unwrap_or(EBroadcastChatPermission::k_EBroadcastChatPermissionPublic)
    }
    pub fn clear_broadcast_chat_permission(&mut self) {
        self.broadcast_chat_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_chat_permission(&self) -> bool {
        self.broadcast_chat_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_chat_permission(&mut self, v: EBroadcastChatPermission) {
        self.broadcast_chat_permission = ::std::option::Option::Some(v);
    }

    // optional int32 broadcast_buffer = 8;


    pub fn get_broadcast_buffer(&self) -> i32 {
        self.broadcast_buffer.unwrap_or(0)
    }
    pub fn clear_broadcast_buffer(&mut self) {
        self.broadcast_buffer = ::std::option::Option::None;
    }

    pub fn has_broadcast_buffer(&self) -> bool {
        self.broadcast_buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_buffer(&mut self, v: i32) {
        self.broadcast_buffer = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 9;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_rate_limit = 10;


    pub fn get_chat_rate_limit(&self) -> u32 {
        self.chat_rate_limit.unwrap_or(0)
    }
    pub fn clear_chat_rate_limit(&mut self) {
        self.chat_rate_limit = ::std::option::Option::None;
    }

    pub fn has_chat_rate_limit(&self) -> bool {
        self.chat_rate_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_rate_limit(&mut self, v: u32) {
        self.chat_rate_limit = ::std::option::Option::Some(v);
    }

    // optional bool enable_replay = 11;


    pub fn get_enable_replay(&self) -> bool {
        self.enable_replay.unwrap_or(false)
    }
    pub fn clear_enable_replay(&mut self) {
        self.enable_replay = ::std::option::Option::None;
    }

    pub fn has_enable_replay(&self) -> bool {
        self.enable_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_replay(&mut self, v: bool) {
        self.enable_replay = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetRTMPInfo_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.broadcast_permission = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rtmp_host)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rtmp_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.broadcast_delay = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.required_app_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.broadcast_chat_permission, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.broadcast_buffer = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chat_rate_limit = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_replay = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_permission {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rtmp_host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.rtmp_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.broadcast_delay {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.required_app_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.broadcast_chat_permission {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(v) = self.broadcast_buffer {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_rate_limit {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_replay {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_permission {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.rtmp_host.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.rtmp_token.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.broadcast_delay {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.required_app_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.broadcast_chat_permission {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.broadcast_buffer {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(9, v)?;
        }
        if let Some(v) = self.chat_rate_limit {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.enable_replay {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetRTMPInfo_Response {
        CBroadcast_GetRTMPInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "broadcast_permission",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.broadcast_permission },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.broadcast_permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtmp_host",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.rtmp_host },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.rtmp_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtmp_token",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.rtmp_token },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.rtmp_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "broadcast_delay",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.broadcast_delay },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.broadcast_delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.app_id },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "required_app_id",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.required_app_id },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.required_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EBroadcastChatPermission>>(
                "broadcast_chat_permission",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.broadcast_chat_permission },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.broadcast_chat_permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "broadcast_buffer",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.broadcast_buffer },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.broadcast_buffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.steamid },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chat_rate_limit",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.chat_rate_limit },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.chat_rate_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_replay",
                |m: &CBroadcast_GetRTMPInfo_Response| { &m.enable_replay },
                |m: &mut CBroadcast_GetRTMPInfo_Response| { &mut m.enable_replay },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetRTMPInfo_Response>(
                "CBroadcast_GetRTMPInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetRTMPInfo_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetRTMPInfo_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetRTMPInfo_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetRTMPInfo_Response {
    fn clear(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
        self.rtmp_host.clear();
        self.rtmp_token.clear();
        self.broadcast_delay = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.required_app_id = ::std::option::Option::None;
        self.broadcast_chat_permission = ::std::option::Option::None;
        self.broadcast_buffer = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_rate_limit = ::std::option::Option::None;
        self.enable_replay = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetRTMPInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetRTMPInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCHaveTURNServer_Notification {
    // message fields
    broadcast_session_id: ::std::option::Option<u64>,
    turn_server: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCHaveTURNServer_Notification {
    fn default() -> &'a CBroadcast_WebRTCHaveTURNServer_Notification {
        <CBroadcast_WebRTCHaveTURNServer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCHaveTURNServer_Notification {
    pub fn new() -> CBroadcast_WebRTCHaveTURNServer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;


    pub fn get_broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }
    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional string turn_server = 2;


    pub fn get_turn_server(&self) -> &str {
        match self.turn_server.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_turn_server(&mut self) {
        self.turn_server.clear();
    }

    pub fn has_turn_server(&self) -> bool {
        self.turn_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_server(&mut self, v: ::std::string::String) {
        self.turn_server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_turn_server(&mut self) -> &mut ::std::string::String {
        if self.turn_server.is_none() {
            self.turn_server.set_default();
        }
        self.turn_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_turn_server(&mut self) -> ::std::string::String {
        self.turn_server.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCHaveTURNServer_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.turn_server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.turn_server.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.turn_server.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCHaveTURNServer_Notification {
        CBroadcast_WebRTCHaveTURNServer_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_session_id",
                |m: &CBroadcast_WebRTCHaveTURNServer_Notification| { &m.broadcast_session_id },
                |m: &mut CBroadcast_WebRTCHaveTURNServer_Notification| { &mut m.broadcast_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "turn_server",
                |m: &CBroadcast_WebRTCHaveTURNServer_Notification| { &m.turn_server },
                |m: &mut CBroadcast_WebRTCHaveTURNServer_Notification| { &mut m.turn_server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCHaveTURNServer_Notification>(
                "CBroadcast_WebRTCHaveTURNServer_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCHaveTURNServer_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCHaveTURNServer_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCHaveTURNServer_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCHaveTURNServer_Notification {
    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.turn_server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCHaveTURNServer_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCHaveTURNServer_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCStartResult_Request {
    // message fields
    webrtc_session_id: ::std::option::Option<u64>,
    started: ::std::option::Option<bool>,
    offer: ::protobuf::SingularField<::std::string::String>,
    resolution_x: ::std::option::Option<u32>,
    resolution_y: ::std::option::Option<u32>,
    fps: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStartResult_Request {
    fn default() -> &'a CBroadcast_WebRTCStartResult_Request {
        <CBroadcast_WebRTCStartResult_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStartResult_Request {
    pub fn new() -> CBroadcast_WebRTCStartResult_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 webrtc_session_id = 1;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional bool started = 2;


    pub fn get_started(&self) -> bool {
        self.started.unwrap_or(false)
    }
    pub fn clear_started(&mut self) {
        self.started = ::std::option::Option::None;
    }

    pub fn has_started(&self) -> bool {
        self.started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_started(&mut self, v: bool) {
        self.started = ::std::option::Option::Some(v);
    }

    // optional string offer = 3;


    pub fn get_offer(&self) -> &str {
        match self.offer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_offer(&mut self) {
        self.offer.clear();
    }

    pub fn has_offer(&self) -> bool {
        self.offer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer(&mut self, v: ::std::string::String) {
        self.offer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer(&mut self) -> &mut ::std::string::String {
        if self.offer.is_none() {
            self.offer.set_default();
        }
        self.offer.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer(&mut self) -> ::std::string::String {
        self.offer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 resolution_x = 4;


    pub fn get_resolution_x(&self) -> u32 {
        self.resolution_x.unwrap_or(0)
    }
    pub fn clear_resolution_x(&mut self) {
        self.resolution_x = ::std::option::Option::None;
    }

    pub fn has_resolution_x(&self) -> bool {
        self.resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolution_x(&mut self, v: u32) {
        self.resolution_x = ::std::option::Option::Some(v);
    }

    // optional uint32 resolution_y = 5;


    pub fn get_resolution_y(&self) -> u32 {
        self.resolution_y.unwrap_or(0)
    }
    pub fn clear_resolution_y(&mut self) {
        self.resolution_y = ::std::option::Option::None;
    }

    pub fn has_resolution_y(&self) -> bool {
        self.resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolution_y(&mut self, v: u32) {
        self.resolution_y = ::std::option::Option::Some(v);
    }

    // optional uint32 fps = 6;


    pub fn get_fps(&self) -> u32 {
        self.fps.unwrap_or(0)
    }
    pub fn clear_fps(&mut self) {
        self.fps = ::std::option::Option::None;
    }

    pub fn has_fps(&self) -> bool {
        self.fps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: u32) {
        self.fps = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStartResult_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.started = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offer)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.resolution_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.resolution_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fps = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(v) = self.started {
            my_size += 2;
        }
        if let Some(ref v) = self.offer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.resolution_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resolution_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fps {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.started {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.offer.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.resolution_x {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.resolution_y {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.fps {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCStartResult_Request {
        CBroadcast_WebRTCStartResult_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCStartResult_Request| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCStartResult_Request| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "started",
                |m: &CBroadcast_WebRTCStartResult_Request| { &m.started },
                |m: &mut CBroadcast_WebRTCStartResult_Request| { &mut m.started },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "offer",
                |m: &CBroadcast_WebRTCStartResult_Request| { &m.offer },
                |m: &mut CBroadcast_WebRTCStartResult_Request| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "resolution_x",
                |m: &CBroadcast_WebRTCStartResult_Request| { &m.resolution_x },
                |m: &mut CBroadcast_WebRTCStartResult_Request| { &mut m.resolution_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "resolution_y",
                |m: &CBroadcast_WebRTCStartResult_Request| { &m.resolution_y },
                |m: &mut CBroadcast_WebRTCStartResult_Request| { &mut m.resolution_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fps",
                |m: &CBroadcast_WebRTCStartResult_Request| { &m.fps },
                |m: &mut CBroadcast_WebRTCStartResult_Request| { &mut m.fps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCStartResult_Request>(
                "CBroadcast_WebRTCStartResult_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStartResult_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCStartResult_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCStartResult_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCStartResult_Request {
    fn clear(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
        self.started = ::std::option::Option::None;
        self.offer.clear();
        self.resolution_x = ::std::option::Option::None;
        self.resolution_y = ::std::option::Option::None;
        self.fps = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCStartResult_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCStartResult_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCStartResult_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStartResult_Response {
    fn default() -> &'a CBroadcast_WebRTCStartResult_Response {
        <CBroadcast_WebRTCStartResult_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStartResult_Response {
    pub fn new() -> CBroadcast_WebRTCStartResult_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStartResult_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCStartResult_Response {
        CBroadcast_WebRTCStartResult_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCStartResult_Response>(
                "CBroadcast_WebRTCStartResult_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStartResult_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCStartResult_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCStartResult_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCStartResult_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCStartResult_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCStartResult_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCStopped_Request {
    // message fields
    webrtc_session_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStopped_Request {
    fn default() -> &'a CBroadcast_WebRTCStopped_Request {
        <CBroadcast_WebRTCStopped_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStopped_Request {
    pub fn new() -> CBroadcast_WebRTCStopped_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 webrtc_session_id = 1;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStopped_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCStopped_Request {
        CBroadcast_WebRTCStopped_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCStopped_Request| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCStopped_Request| { &mut m.webrtc_session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCStopped_Request>(
                "CBroadcast_WebRTCStopped_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStopped_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCStopped_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCStopped_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCStopped_Request {
    fn clear(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCStopped_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCStopped_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCStopped_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStopped_Response {
    fn default() -> &'a CBroadcast_WebRTCStopped_Response {
        <CBroadcast_WebRTCStopped_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStopped_Response {
    pub fn new() -> CBroadcast_WebRTCStopped_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStopped_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCStopped_Response {
        CBroadcast_WebRTCStopped_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCStopped_Response>(
                "CBroadcast_WebRTCStopped_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStopped_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCStopped_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCStopped_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCStopped_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCStopped_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCStopped_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCSetAnswer_Request {
    // message fields
    broadcaster_steamid: ::std::option::Option<u64>,
    webrtc_session_id: ::std::option::Option<u64>,
    answer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCSetAnswer_Request {
    fn default() -> &'a CBroadcast_WebRTCSetAnswer_Request {
        <CBroadcast_WebRTCSetAnswer_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCSetAnswer_Request {
    pub fn new() -> CBroadcast_WebRTCSetAnswer_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;


    pub fn get_broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }
    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional string answer = 3;


    pub fn get_answer(&self) -> &str {
        match self.answer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    pub fn has_answer(&self) -> bool {
        self.answer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.answer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        if self.answer.is_none() {
            self.answer.set_default();
        }
        self.answer.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        self.answer.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCSetAnswer_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcaster_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.answer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 9;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.answer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.answer.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCSetAnswer_Request {
        CBroadcast_WebRTCSetAnswer_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcaster_steamid",
                |m: &CBroadcast_WebRTCSetAnswer_Request| { &m.broadcaster_steamid },
                |m: &mut CBroadcast_WebRTCSetAnswer_Request| { &mut m.broadcaster_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCSetAnswer_Request| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCSetAnswer_Request| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "answer",
                |m: &CBroadcast_WebRTCSetAnswer_Request| { &m.answer },
                |m: &mut CBroadcast_WebRTCSetAnswer_Request| { &mut m.answer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCSetAnswer_Request>(
                "CBroadcast_WebRTCSetAnswer_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCSetAnswer_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCSetAnswer_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCSetAnswer_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCSetAnswer_Request {
    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.answer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCSetAnswer_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCSetAnswer_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCSetAnswer_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCSetAnswer_Response {
    fn default() -> &'a CBroadcast_WebRTCSetAnswer_Response {
        <CBroadcast_WebRTCSetAnswer_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCSetAnswer_Response {
    pub fn new() -> CBroadcast_WebRTCSetAnswer_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCSetAnswer_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCSetAnswer_Response {
        CBroadcast_WebRTCSetAnswer_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCSetAnswer_Response>(
                "CBroadcast_WebRTCSetAnswer_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCSetAnswer_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCSetAnswer_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCSetAnswer_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCSetAnswer_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCSetAnswer_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCSetAnswer_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCLookupTURNServer_Request {
    // message fields
    cellid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCLookupTURNServer_Request {
    fn default() -> &'a CBroadcast_WebRTCLookupTURNServer_Request {
        <CBroadcast_WebRTCLookupTURNServer_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCLookupTURNServer_Request {
    pub fn new() -> CBroadcast_WebRTCLookupTURNServer_Request {
        ::std::default::Default::default()
    }

    // optional uint32 cellid = 1;


    pub fn get_cellid(&self) -> u32 {
        self.cellid.unwrap_or(0)
    }
    pub fn clear_cellid(&mut self) {
        self.cellid = ::std::option::Option::None;
    }

    pub fn has_cellid(&self) -> bool {
        self.cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cellid(&mut self, v: u32) {
        self.cellid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCLookupTURNServer_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cellid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cellid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cellid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCLookupTURNServer_Request {
        CBroadcast_WebRTCLookupTURNServer_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cellid",
                |m: &CBroadcast_WebRTCLookupTURNServer_Request| { &m.cellid },
                |m: &mut CBroadcast_WebRTCLookupTURNServer_Request| { &mut m.cellid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCLookupTURNServer_Request>(
                "CBroadcast_WebRTCLookupTURNServer_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCLookupTURNServer_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCLookupTURNServer_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCLookupTURNServer_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCLookupTURNServer_Request {
    fn clear(&mut self) {
        self.cellid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCLookupTURNServer_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCLookupTURNServer_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCLookupTURNServer_Response {
    // message fields
    turn_server: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCLookupTURNServer_Response {
    fn default() -> &'a CBroadcast_WebRTCLookupTURNServer_Response {
        <CBroadcast_WebRTCLookupTURNServer_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCLookupTURNServer_Response {
    pub fn new() -> CBroadcast_WebRTCLookupTURNServer_Response {
        ::std::default::Default::default()
    }

    // optional string turn_server = 1;


    pub fn get_turn_server(&self) -> &str {
        match self.turn_server.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_turn_server(&mut self) {
        self.turn_server.clear();
    }

    pub fn has_turn_server(&self) -> bool {
        self.turn_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_server(&mut self, v: ::std::string::String) {
        self.turn_server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_turn_server(&mut self) -> &mut ::std::string::String {
        if self.turn_server.is_none() {
            self.turn_server.set_default();
        }
        self.turn_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_turn_server(&mut self) -> ::std::string::String {
        self.turn_server.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCLookupTURNServer_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.turn_server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.turn_server.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.turn_server.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCLookupTURNServer_Response {
        CBroadcast_WebRTCLookupTURNServer_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "turn_server",
                |m: &CBroadcast_WebRTCLookupTURNServer_Response| { &m.turn_server },
                |m: &mut CBroadcast_WebRTCLookupTURNServer_Response| { &mut m.turn_server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCLookupTURNServer_Response>(
                "CBroadcast_WebRTCLookupTURNServer_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCLookupTURNServer_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCLookupTURNServer_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCLookupTURNServer_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCLookupTURNServer_Response {
    fn clear(&mut self) {
        self.turn_server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCLookupTURNServer_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCLookupTURNServer_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTC_Candidate {
    // message fields
    sdp_mid: ::protobuf::SingularField<::std::string::String>,
    sdp_mline_index: ::std::option::Option<i32>,
    candidate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTC_Candidate {
    fn default() -> &'a CBroadcast_WebRTC_Candidate {
        <CBroadcast_WebRTC_Candidate as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTC_Candidate {
    pub fn new() -> CBroadcast_WebRTC_Candidate {
        ::std::default::Default::default()
    }

    // optional string sdp_mid = 1;


    pub fn get_sdp_mid(&self) -> &str {
        match self.sdp_mid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sdp_mid(&mut self) {
        self.sdp_mid.clear();
    }

    pub fn has_sdp_mid(&self) -> bool {
        self.sdp_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp_mid(&mut self, v: ::std::string::String) {
        self.sdp_mid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp_mid(&mut self) -> &mut ::std::string::String {
        if self.sdp_mid.is_none() {
            self.sdp_mid.set_default();
        }
        self.sdp_mid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp_mid(&mut self) -> ::std::string::String {
        self.sdp_mid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 sdp_mline_index = 2;


    pub fn get_sdp_mline_index(&self) -> i32 {
        self.sdp_mline_index.unwrap_or(0)
    }
    pub fn clear_sdp_mline_index(&mut self) {
        self.sdp_mline_index = ::std::option::Option::None;
    }

    pub fn has_sdp_mline_index(&self) -> bool {
        self.sdp_mline_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp_mline_index(&mut self, v: i32) {
        self.sdp_mline_index = ::std::option::Option::Some(v);
    }

    // optional string candidate = 3;


    pub fn get_candidate(&self) -> &str {
        match self.candidate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTC_Candidate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdp_mid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sdp_mline_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sdp_mid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sdp_mline_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sdp_mid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.sdp_mline_index {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTC_Candidate {
        CBroadcast_WebRTC_Candidate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp_mid",
                |m: &CBroadcast_WebRTC_Candidate| { &m.sdp_mid },
                |m: &mut CBroadcast_WebRTC_Candidate| { &mut m.sdp_mid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sdp_mline_index",
                |m: &CBroadcast_WebRTC_Candidate| { &m.sdp_mline_index },
                |m: &mut CBroadcast_WebRTC_Candidate| { &mut m.sdp_mline_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &CBroadcast_WebRTC_Candidate| { &m.candidate },
                |m: &mut CBroadcast_WebRTC_Candidate| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTC_Candidate>(
                "CBroadcast_WebRTC_Candidate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTC_Candidate {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTC_Candidate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTC_Candidate::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTC_Candidate {
    fn clear(&mut self) {
        self.sdp_mid.clear();
        self.sdp_mline_index = ::std::option::Option::None;
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTC_Candidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTC_Candidate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCAddHostCandidate_Request {
    // message fields
    webrtc_session_id: ::std::option::Option<u64>,
    pub candidate: ::protobuf::SingularPtrField<CBroadcast_WebRTC_Candidate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddHostCandidate_Request {
    fn default() -> &'a CBroadcast_WebRTCAddHostCandidate_Request {
        <CBroadcast_WebRTCAddHostCandidate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddHostCandidate_Request {
    pub fn new() -> CBroadcast_WebRTCAddHostCandidate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 webrtc_session_id = 1;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional .CBroadcast_WebRTC_Candidate candidate = 2;


    pub fn get_candidate(&self) -> &CBroadcast_WebRTC_Candidate {
        self.candidate.as_ref().unwrap_or_else(|| <CBroadcast_WebRTC_Candidate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: CBroadcast_WebRTC_Candidate) {
        self.candidate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut CBroadcast_WebRTC_Candidate {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> CBroadcast_WebRTC_Candidate {
        self.candidate.take().unwrap_or_else(|| CBroadcast_WebRTC_Candidate::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddHostCandidate_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.candidate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCAddHostCandidate_Request {
        CBroadcast_WebRTCAddHostCandidate_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCAddHostCandidate_Request| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCAddHostCandidate_Request| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_WebRTC_Candidate>>(
                "candidate",
                |m: &CBroadcast_WebRTCAddHostCandidate_Request| { &m.candidate },
                |m: &mut CBroadcast_WebRTCAddHostCandidate_Request| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCAddHostCandidate_Request>(
                "CBroadcast_WebRTCAddHostCandidate_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddHostCandidate_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCAddHostCandidate_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCAddHostCandidate_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCAddHostCandidate_Request {
    fn clear(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCAddHostCandidate_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCAddHostCandidate_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCAddHostCandidate_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddHostCandidate_Response {
    fn default() -> &'a CBroadcast_WebRTCAddHostCandidate_Response {
        <CBroadcast_WebRTCAddHostCandidate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddHostCandidate_Response {
    pub fn new() -> CBroadcast_WebRTCAddHostCandidate_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddHostCandidate_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCAddHostCandidate_Response {
        CBroadcast_WebRTCAddHostCandidate_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCAddHostCandidate_Response>(
                "CBroadcast_WebRTCAddHostCandidate_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddHostCandidate_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCAddHostCandidate_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCAddHostCandidate_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCAddHostCandidate_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCAddHostCandidate_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCAddHostCandidate_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCAddViewerCandidate_Request {
    // message fields
    broadcaster_steamid: ::std::option::Option<u64>,
    webrtc_session_id: ::std::option::Option<u64>,
    pub candidate: ::protobuf::SingularPtrField<CBroadcast_WebRTC_Candidate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddViewerCandidate_Request {
    fn default() -> &'a CBroadcast_WebRTCAddViewerCandidate_Request {
        <CBroadcast_WebRTCAddViewerCandidate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddViewerCandidate_Request {
    pub fn new() -> CBroadcast_WebRTCAddViewerCandidate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;


    pub fn get_broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }
    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional .CBroadcast_WebRTC_Candidate candidate = 3;


    pub fn get_candidate(&self) -> &CBroadcast_WebRTC_Candidate {
        self.candidate.as_ref().unwrap_or_else(|| <CBroadcast_WebRTC_Candidate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: CBroadcast_WebRTC_Candidate) {
        self.candidate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut CBroadcast_WebRTC_Candidate {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> CBroadcast_WebRTC_Candidate {
        self.candidate.take().unwrap_or_else(|| CBroadcast_WebRTC_Candidate::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddViewerCandidate_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.candidate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcaster_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 9;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCAddViewerCandidate_Request {
        CBroadcast_WebRTCAddViewerCandidate_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcaster_steamid",
                |m: &CBroadcast_WebRTCAddViewerCandidate_Request| { &m.broadcaster_steamid },
                |m: &mut CBroadcast_WebRTCAddViewerCandidate_Request| { &mut m.broadcaster_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCAddViewerCandidate_Request| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCAddViewerCandidate_Request| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_WebRTC_Candidate>>(
                "candidate",
                |m: &CBroadcast_WebRTCAddViewerCandidate_Request| { &m.candidate },
                |m: &mut CBroadcast_WebRTCAddViewerCandidate_Request| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCAddViewerCandidate_Request>(
                "CBroadcast_WebRTCAddViewerCandidate_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddViewerCandidate_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCAddViewerCandidate_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCAddViewerCandidate_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCAddViewerCandidate_Request {
    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCAddViewerCandidate_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCAddViewerCandidate_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCAddViewerCandidate_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddViewerCandidate_Response {
    fn default() -> &'a CBroadcast_WebRTCAddViewerCandidate_Response {
        <CBroadcast_WebRTCAddViewerCandidate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddViewerCandidate_Response {
    pub fn new() -> CBroadcast_WebRTCAddViewerCandidate_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddViewerCandidate_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCAddViewerCandidate_Response {
        CBroadcast_WebRTCAddViewerCandidate_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCAddViewerCandidate_Response>(
                "CBroadcast_WebRTCAddViewerCandidate_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddViewerCandidate_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCAddViewerCandidate_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCAddViewerCandidate_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCAddViewerCandidate_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCAddViewerCandidate_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCAddViewerCandidate_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCGetHostCandidates_Request {
    // message fields
    broadcaster_steamid: ::std::option::Option<u64>,
    webrtc_session_id: ::std::option::Option<u64>,
    candidate_generation: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCGetHostCandidates_Request {
    fn default() -> &'a CBroadcast_WebRTCGetHostCandidates_Request {
        <CBroadcast_WebRTCGetHostCandidates_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCGetHostCandidates_Request {
    pub fn new() -> CBroadcast_WebRTCGetHostCandidates_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;


    pub fn get_broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }
    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 candidate_generation = 3;


    pub fn get_candidate_generation(&self) -> u32 {
        self.candidate_generation.unwrap_or(0)
    }
    pub fn clear_candidate_generation(&mut self) {
        self.candidate_generation = ::std::option::Option::None;
    }

    pub fn has_candidate_generation(&self) -> bool {
        self.candidate_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate_generation(&mut self, v: u32) {
        self.candidate_generation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCGetHostCandidates_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcaster_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.candidate_generation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 9;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(v) = self.candidate_generation {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.candidate_generation {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCGetHostCandidates_Request {
        CBroadcast_WebRTCGetHostCandidates_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcaster_steamid",
                |m: &CBroadcast_WebRTCGetHostCandidates_Request| { &m.broadcaster_steamid },
                |m: &mut CBroadcast_WebRTCGetHostCandidates_Request| { &mut m.broadcaster_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCGetHostCandidates_Request| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCGetHostCandidates_Request| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "candidate_generation",
                |m: &CBroadcast_WebRTCGetHostCandidates_Request| { &m.candidate_generation },
                |m: &mut CBroadcast_WebRTCGetHostCandidates_Request| { &mut m.candidate_generation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCGetHostCandidates_Request>(
                "CBroadcast_WebRTCGetHostCandidates_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCGetHostCandidates_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCGetHostCandidates_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCGetHostCandidates_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCGetHostCandidates_Request {
    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate_generation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCGetHostCandidates_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCGetHostCandidates_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCGetHostCandidates_Response {
    // message fields
    candidate_generation: ::std::option::Option<u32>,
    pub candidates: ::protobuf::RepeatedField<CBroadcast_WebRTC_Candidate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCGetHostCandidates_Response {
    fn default() -> &'a CBroadcast_WebRTCGetHostCandidates_Response {
        <CBroadcast_WebRTCGetHostCandidates_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCGetHostCandidates_Response {
    pub fn new() -> CBroadcast_WebRTCGetHostCandidates_Response {
        ::std::default::Default::default()
    }

    // optional uint32 candidate_generation = 1;


    pub fn get_candidate_generation(&self) -> u32 {
        self.candidate_generation.unwrap_or(0)
    }
    pub fn clear_candidate_generation(&mut self) {
        self.candidate_generation = ::std::option::Option::None;
    }

    pub fn has_candidate_generation(&self) -> bool {
        self.candidate_generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate_generation(&mut self, v: u32) {
        self.candidate_generation = ::std::option::Option::Some(v);
    }

    // repeated .CBroadcast_WebRTC_Candidate candidates = 2;


    pub fn get_candidates(&self) -> &[CBroadcast_WebRTC_Candidate] {
        &self.candidates
    }
    pub fn clear_candidates(&mut self) {
        self.candidates.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidates(&mut self, v: ::protobuf::RepeatedField<CBroadcast_WebRTC_Candidate>) {
        self.candidates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_candidates(&mut self) -> &mut ::protobuf::RepeatedField<CBroadcast_WebRTC_Candidate> {
        &mut self.candidates
    }

    // Take field
    pub fn take_candidates(&mut self) -> ::protobuf::RepeatedField<CBroadcast_WebRTC_Candidate> {
        ::std::mem::replace(&mut self.candidates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCGetHostCandidates_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.candidates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.candidate_generation = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.candidates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.candidate_generation {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.candidates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.candidate_generation {
            os.write_uint32(1, v)?;
        }
        for v in &self.candidates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCGetHostCandidates_Response {
        CBroadcast_WebRTCGetHostCandidates_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "candidate_generation",
                |m: &CBroadcast_WebRTCGetHostCandidates_Response| { &m.candidate_generation },
                |m: &mut CBroadcast_WebRTCGetHostCandidates_Response| { &mut m.candidate_generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_WebRTC_Candidate>>(
                "candidates",
                |m: &CBroadcast_WebRTCGetHostCandidates_Response| { &m.candidates },
                |m: &mut CBroadcast_WebRTCGetHostCandidates_Response| { &mut m.candidates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCGetHostCandidates_Response>(
                "CBroadcast_WebRTCGetHostCandidates_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCGetHostCandidates_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCGetHostCandidates_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCGetHostCandidates_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCGetHostCandidates_Response {
    fn clear(&mut self) {
        self.candidate_generation = ::std::option::Option::None;
        self.candidates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCGetHostCandidates_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCGetHostCandidates_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastUploadStats_Request {
    // message fields
    row_limit: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    upload_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    session_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastUploadStats_Request {
    fn default() -> &'a CBroadcast_GetBroadcastUploadStats_Request {
        <CBroadcast_GetBroadcastUploadStats_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastUploadStats_Request {
    pub fn new() -> CBroadcast_GetBroadcastUploadStats_Request {
        ::std::default::Default::default()
    }

    // optional uint32 row_limit = 1;


    pub fn get_row_limit(&self) -> u32 {
        self.row_limit.unwrap_or(100u32)
    }
    pub fn clear_row_limit(&mut self) {
        self.row_limit = ::std::option::Option::None;
    }

    pub fn has_row_limit(&self) -> bool {
        self.row_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row_limit(&mut self, v: u32) {
        self.row_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 2;


    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0u32)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint64 upload_id = 3;


    pub fn get_upload_id(&self) -> u64 {
        self.upload_id.unwrap_or(0)
    }
    pub fn clear_upload_id(&mut self) {
        self.upload_id = ::std::option::Option::None;
    }

    pub fn has_upload_id(&self) -> bool {
        self.upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: u64) {
        self.upload_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 session_id = 5;


    pub fn get_session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastUploadStats_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.row_limit = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upload_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.row_limit {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.upload_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.row_limit {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.upload_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastUploadStats_Request {
        CBroadcast_GetBroadcastUploadStats_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "row_limit",
                |m: &CBroadcast_GetBroadcastUploadStats_Request| { &m.row_limit },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Request| { &mut m.row_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_time",
                |m: &CBroadcast_GetBroadcastUploadStats_Request| { &m.start_time },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Request| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upload_id",
                |m: &CBroadcast_GetBroadcastUploadStats_Request| { &m.upload_id },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Request| { &mut m.upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_GetBroadcastUploadStats_Request| { &m.steamid },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "session_id",
                |m: &CBroadcast_GetBroadcastUploadStats_Request| { &m.session_id },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Request| { &mut m.session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastUploadStats_Request>(
                "CBroadcast_GetBroadcastUploadStats_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastUploadStats_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastUploadStats_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastUploadStats_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastUploadStats_Request {
    fn clear(&mut self) {
        self.row_limit = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.upload_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastUploadStats_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastUploadStats_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastUploadStats_Response {
    // message fields
    pub upload_stats: ::protobuf::RepeatedField<CBroadcast_GetBroadcastUploadStats_Response_UploadStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastUploadStats_Response {
    fn default() -> &'a CBroadcast_GetBroadcastUploadStats_Response {
        <CBroadcast_GetBroadcastUploadStats_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastUploadStats_Response {
    pub fn new() -> CBroadcast_GetBroadcastUploadStats_Response {
        ::std::default::Default::default()
    }

    // repeated .CBroadcast_GetBroadcastUploadStats_Response.UploadStats upload_stats = 1;


    pub fn get_upload_stats(&self) -> &[CBroadcast_GetBroadcastUploadStats_Response_UploadStats] {
        &self.upload_stats
    }
    pub fn clear_upload_stats(&mut self) {
        self.upload_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_upload_stats(&mut self, v: ::protobuf::RepeatedField<CBroadcast_GetBroadcastUploadStats_Response_UploadStats>) {
        self.upload_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_upload_stats(&mut self) -> &mut ::protobuf::RepeatedField<CBroadcast_GetBroadcastUploadStats_Response_UploadStats> {
        &mut self.upload_stats
    }

    // Take field
    pub fn take_upload_stats(&mut self) -> ::protobuf::RepeatedField<CBroadcast_GetBroadcastUploadStats_Response_UploadStats> {
        ::std::mem::replace(&mut self.upload_stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastUploadStats_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.upload_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.upload_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.upload_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.upload_stats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastUploadStats_Response {
        CBroadcast_GetBroadcastUploadStats_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_GetBroadcastUploadStats_Response_UploadStats>>(
                "upload_stats",
                |m: &CBroadcast_GetBroadcastUploadStats_Response| { &m.upload_stats },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response| { &mut m.upload_stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastUploadStats_Response>(
                "CBroadcast_GetBroadcastUploadStats_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastUploadStats_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastUploadStats_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastUploadStats_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastUploadStats_Response {
    fn clear(&mut self) {
        self.upload_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastUploadStats_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastUploadStats_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
    // message fields
    upload_result: ::std::option::Option<u32>,
    time_stopped: ::std::option::Option<u32>,
    seconds_uploaded: ::std::option::Option<u32>,
    max_viewers: ::std::option::Option<u32>,
    resolution_x: ::std::option::Option<u32>,
    resolution_y: ::std::option::Option<u32>,
    avg_bandwidth: ::std::option::Option<u32>,
    total_bytes: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    total_unique_viewers: ::std::option::Option<u32>,
    total_seconds_watched: ::std::option::Option<u64>,
    time_started: ::std::option::Option<u32>,
    upload_id: ::std::option::Option<u64>,
    local_address: ::protobuf::SingularField<::std::string::String>,
    remote_address: ::protobuf::SingularField<::std::string::String>,
    frames_per_second: ::std::option::Option<u32>,
    num_representations: ::std::option::Option<u32>,
    app_name: ::protobuf::SingularField<::std::string::String>,
    is_replay: ::std::option::Option<bool>,
    session_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
    fn default() -> &'a CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
        <CBroadcast_GetBroadcastUploadStats_Response_UploadStats as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
    pub fn new() -> CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
        ::std::default::Default::default()
    }

    // optional uint32 upload_result = 1;


    pub fn get_upload_result(&self) -> u32 {
        self.upload_result.unwrap_or(0)
    }
    pub fn clear_upload_result(&mut self) {
        self.upload_result = ::std::option::Option::None;
    }

    pub fn has_upload_result(&self) -> bool {
        self.upload_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_result(&mut self, v: u32) {
        self.upload_result = ::std::option::Option::Some(v);
    }

    // optional uint32 time_stopped = 2;


    pub fn get_time_stopped(&self) -> u32 {
        self.time_stopped.unwrap_or(0)
    }
    pub fn clear_time_stopped(&mut self) {
        self.time_stopped = ::std::option::Option::None;
    }

    pub fn has_time_stopped(&self) -> bool {
        self.time_stopped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stopped(&mut self, v: u32) {
        self.time_stopped = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_uploaded = 3;


    pub fn get_seconds_uploaded(&self) -> u32 {
        self.seconds_uploaded.unwrap_or(0)
    }
    pub fn clear_seconds_uploaded(&mut self) {
        self.seconds_uploaded = ::std::option::Option::None;
    }

    pub fn has_seconds_uploaded(&self) -> bool {
        self.seconds_uploaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_uploaded(&mut self, v: u32) {
        self.seconds_uploaded = ::std::option::Option::Some(v);
    }

    // optional uint32 max_viewers = 4;


    pub fn get_max_viewers(&self) -> u32 {
        self.max_viewers.unwrap_or(0)
    }
    pub fn clear_max_viewers(&mut self) {
        self.max_viewers = ::std::option::Option::None;
    }

    pub fn has_max_viewers(&self) -> bool {
        self.max_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_viewers(&mut self, v: u32) {
        self.max_viewers = ::std::option::Option::Some(v);
    }

    // optional uint32 resolution_x = 5;


    pub fn get_resolution_x(&self) -> u32 {
        self.resolution_x.unwrap_or(0)
    }
    pub fn clear_resolution_x(&mut self) {
        self.resolution_x = ::std::option::Option::None;
    }

    pub fn has_resolution_x(&self) -> bool {
        self.resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolution_x(&mut self, v: u32) {
        self.resolution_x = ::std::option::Option::Some(v);
    }

    // optional uint32 resolution_y = 6;


    pub fn get_resolution_y(&self) -> u32 {
        self.resolution_y.unwrap_or(0)
    }
    pub fn clear_resolution_y(&mut self) {
        self.resolution_y = ::std::option::Option::None;
    }

    pub fn has_resolution_y(&self) -> bool {
        self.resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolution_y(&mut self, v: u32) {
        self.resolution_y = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_bandwidth = 7;


    pub fn get_avg_bandwidth(&self) -> u32 {
        self.avg_bandwidth.unwrap_or(0)
    }
    pub fn clear_avg_bandwidth(&mut self) {
        self.avg_bandwidth = ::std::option::Option::None;
    }

    pub fn has_avg_bandwidth(&self) -> bool {
        self.avg_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_bandwidth(&mut self, v: u32) {
        self.avg_bandwidth = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes = 8;


    pub fn get_total_bytes(&self) -> u64 {
        self.total_bytes.unwrap_or(0)
    }
    pub fn clear_total_bytes(&mut self) {
        self.total_bytes = ::std::option::Option::None;
    }

    pub fn has_total_bytes(&self) -> bool {
        self.total_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes(&mut self, v: u64) {
        self.total_bytes = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 9;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 total_unique_viewers = 10;


    pub fn get_total_unique_viewers(&self) -> u32 {
        self.total_unique_viewers.unwrap_or(0)
    }
    pub fn clear_total_unique_viewers(&mut self) {
        self.total_unique_viewers = ::std::option::Option::None;
    }

    pub fn has_total_unique_viewers(&self) -> bool {
        self.total_unique_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_unique_viewers(&mut self, v: u32) {
        self.total_unique_viewers = ::std::option::Option::Some(v);
    }

    // optional uint64 total_seconds_watched = 11;


    pub fn get_total_seconds_watched(&self) -> u64 {
        self.total_seconds_watched.unwrap_or(0)
    }
    pub fn clear_total_seconds_watched(&mut self) {
        self.total_seconds_watched = ::std::option::Option::None;
    }

    pub fn has_total_seconds_watched(&self) -> bool {
        self.total_seconds_watched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_seconds_watched(&mut self, v: u64) {
        self.total_seconds_watched = ::std::option::Option::Some(v);
    }

    // optional uint32 time_started = 12;


    pub fn get_time_started(&self) -> u32 {
        self.time_started.unwrap_or(0)
    }
    pub fn clear_time_started(&mut self) {
        self.time_started = ::std::option::Option::None;
    }

    pub fn has_time_started(&self) -> bool {
        self.time_started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_started(&mut self, v: u32) {
        self.time_started = ::std::option::Option::Some(v);
    }

    // optional uint64 upload_id = 13;


    pub fn get_upload_id(&self) -> u64 {
        self.upload_id.unwrap_or(0)
    }
    pub fn clear_upload_id(&mut self) {
        self.upload_id = ::std::option::Option::None;
    }

    pub fn has_upload_id(&self) -> bool {
        self.upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: u64) {
        self.upload_id = ::std::option::Option::Some(v);
    }

    // optional string local_address = 14;


    pub fn get_local_address(&self) -> &str {
        match self.local_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_local_address(&mut self) {
        self.local_address.clear();
    }

    pub fn has_local_address(&self) -> bool {
        self.local_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_address(&mut self, v: ::std::string::String) {
        self.local_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_address(&mut self) -> &mut ::std::string::String {
        if self.local_address.is_none() {
            self.local_address.set_default();
        }
        self.local_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_address(&mut self) -> ::std::string::String {
        self.local_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_address = 15;


    pub fn get_remote_address(&self) -> &str {
        match self.remote_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_remote_address(&mut self) {
        self.remote_address.clear();
    }

    pub fn has_remote_address(&self) -> bool {
        self.remote_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_address(&mut self, v: ::std::string::String) {
        self.remote_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_address(&mut self) -> &mut ::std::string::String {
        if self.remote_address.is_none() {
            self.remote_address.set_default();
        }
        self.remote_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_address(&mut self) -> ::std::string::String {
        self.remote_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 frames_per_second = 16;


    pub fn get_frames_per_second(&self) -> u32 {
        self.frames_per_second.unwrap_or(0)
    }
    pub fn clear_frames_per_second(&mut self) {
        self.frames_per_second = ::std::option::Option::None;
    }

    pub fn has_frames_per_second(&self) -> bool {
        self.frames_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frames_per_second(&mut self, v: u32) {
        self.frames_per_second = ::std::option::Option::Some(v);
    }

    // optional uint32 num_representations = 17;


    pub fn get_num_representations(&self) -> u32 {
        self.num_representations.unwrap_or(0)
    }
    pub fn clear_num_representations(&mut self) {
        self.num_representations = ::std::option::Option::None;
    }

    pub fn has_num_representations(&self) -> bool {
        self.num_representations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_representations(&mut self, v: u32) {
        self.num_representations = ::std::option::Option::Some(v);
    }

    // optional string app_name = 18;


    pub fn get_app_name(&self) -> &str {
        match self.app_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_app_name(&mut self) {
        self.app_name.clear();
    }

    pub fn has_app_name(&self) -> bool {
        self.app_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_name(&mut self, v: ::std::string::String) {
        self.app_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_name(&mut self) -> &mut ::std::string::String {
        if self.app_name.is_none() {
            self.app_name.set_default();
        }
        self.app_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_name(&mut self) -> ::std::string::String {
        self.app_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_replay = 19;


    pub fn get_is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }
    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional uint64 session_id = 20;


    pub fn get_session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.upload_result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_stopped = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_uploaded = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_viewers = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.resolution_x = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.resolution_y = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_bandwidth = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_unique_viewers = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_seconds_watched = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_started = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upload_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.local_address)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.remote_address)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frames_per_second = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_representations = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.app_name)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_replay = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.upload_result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_stopped {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_uploaded {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_viewers {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resolution_x {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.resolution_y {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_bandwidth {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_unique_viewers {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_seconds_watched {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_started {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.upload_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.local_address.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.remote_address.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.frames_per_second {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_representations {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.app_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.is_replay {
            my_size += 3;
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.upload_result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_stopped {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.seconds_uploaded {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_viewers {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.resolution_x {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.resolution_y {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.avg_bandwidth {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.total_bytes {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.total_unique_viewers {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.total_seconds_watched {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.time_started {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.upload_id {
            os.write_uint64(13, v)?;
        }
        if let Some(ref v) = self.local_address.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.remote_address.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.frames_per_second {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.num_representations {
            os.write_uint32(17, v)?;
        }
        if let Some(ref v) = self.app_name.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(20, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
        CBroadcast_GetBroadcastUploadStats_Response_UploadStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "upload_result",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.upload_result },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.upload_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_stopped",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.time_stopped },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.time_stopped },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_uploaded",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.seconds_uploaded },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.seconds_uploaded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_viewers",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.max_viewers },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.max_viewers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "resolution_x",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.resolution_x },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.resolution_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "resolution_y",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.resolution_y },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.resolution_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_bandwidth",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.avg_bandwidth },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.avg_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_bytes",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.total_bytes },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.total_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.app_id },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_unique_viewers",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.total_unique_viewers },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.total_unique_viewers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_seconds_watched",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.total_seconds_watched },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.total_seconds_watched },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_started",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.time_started },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.time_started },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upload_id",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.upload_id },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_address",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.local_address },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.local_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_address",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.remote_address },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.remote_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frames_per_second",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.frames_per_second },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.frames_per_second },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_representations",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.num_representations },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.num_representations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_name",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.app_name },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.app_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_replay",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.is_replay },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.is_replay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "session_id",
                |m: &CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &m.session_id },
                |m: &mut CBroadcast_GetBroadcastUploadStats_Response_UploadStats| { &mut m.session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastUploadStats_Response_UploadStats>(
                "CBroadcast_GetBroadcastUploadStats_Response.UploadStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastUploadStats_Response_UploadStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastUploadStats_Response_UploadStats::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
    fn clear(&mut self) {
        self.upload_result = ::std::option::Option::None;
        self.time_stopped = ::std::option::Option::None;
        self.seconds_uploaded = ::std::option::Option::None;
        self.max_viewers = ::std::option::Option::None;
        self.resolution_x = ::std::option::Option::None;
        self.resolution_y = ::std::option::Option::None;
        self.avg_bandwidth = ::std::option::Option::None;
        self.total_bytes = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.total_unique_viewers = ::std::option::Option::None;
        self.total_seconds_watched = ::std::option::Option::None;
        self.time_started = ::std::option::Option::None;
        self.upload_id = ::std::option::Option::None;
        self.local_address.clear();
        self.remote_address.clear();
        self.frames_per_second = ::std::option::Option::None;
        self.num_representations = ::std::option::Option::None;
        self.app_name.clear();
        self.is_replay = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastViewerStats_Request {
    // message fields
    upload_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastViewerStats_Request {
    fn default() -> &'a CBroadcast_GetBroadcastViewerStats_Request {
        <CBroadcast_GetBroadcastViewerStats_Request as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastViewerStats_Request {
    pub fn new() -> CBroadcast_GetBroadcastViewerStats_Request {
        ::std::default::Default::default()
    }

    // optional uint64 upload_id = 1;


    pub fn get_upload_id(&self) -> u64 {
        self.upload_id.unwrap_or(0)
    }
    pub fn clear_upload_id(&mut self) {
        self.upload_id = ::std::option::Option::None;
    }

    pub fn has_upload_id(&self) -> bool {
        self.upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: u64) {
        self.upload_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastViewerStats_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upload_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.upload_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.upload_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastViewerStats_Request {
        CBroadcast_GetBroadcastViewerStats_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upload_id",
                |m: &CBroadcast_GetBroadcastViewerStats_Request| { &m.upload_id },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Request| { &mut m.upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_GetBroadcastViewerStats_Request| { &m.steamid },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastViewerStats_Request>(
                "CBroadcast_GetBroadcastViewerStats_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastViewerStats_Request {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastViewerStats_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastViewerStats_Request::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastViewerStats_Request {
    fn clear(&mut self) {
        self.upload_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastViewerStats_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastViewerStats_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastViewerStats_Response {
    // message fields
    pub viewer_stats: ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_ViewerStats>,
    pub country_stats: ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_CountryStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastViewerStats_Response {
    fn default() -> &'a CBroadcast_GetBroadcastViewerStats_Response {
        <CBroadcast_GetBroadcastViewerStats_Response as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastViewerStats_Response {
    pub fn new() -> CBroadcast_GetBroadcastViewerStats_Response {
        ::std::default::Default::default()
    }

    // repeated .CBroadcast_GetBroadcastViewerStats_Response.ViewerStats viewer_stats = 1;


    pub fn get_viewer_stats(&self) -> &[CBroadcast_GetBroadcastViewerStats_Response_ViewerStats] {
        &self.viewer_stats
    }
    pub fn clear_viewer_stats(&mut self) {
        self.viewer_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewer_stats(&mut self, v: ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_ViewerStats>) {
        self.viewer_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewer_stats(&mut self) -> &mut ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_ViewerStats> {
        &mut self.viewer_stats
    }

    // Take field
    pub fn take_viewer_stats(&mut self) -> ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_ViewerStats> {
        ::std::mem::replace(&mut self.viewer_stats, ::protobuf::RepeatedField::new())
    }

    // repeated .CBroadcast_GetBroadcastViewerStats_Response.CountryStats country_stats = 2;


    pub fn get_country_stats(&self) -> &[CBroadcast_GetBroadcastViewerStats_Response_CountryStats] {
        &self.country_stats
    }
    pub fn clear_country_stats(&mut self) {
        self.country_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_country_stats(&mut self, v: ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_CountryStats>) {
        self.country_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_country_stats(&mut self) -> &mut ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_CountryStats> {
        &mut self.country_stats
    }

    // Take field
    pub fn take_country_stats(&mut self) -> ::protobuf::RepeatedField<CBroadcast_GetBroadcastViewerStats_Response_CountryStats> {
        ::std::mem::replace(&mut self.country_stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastViewerStats_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.viewer_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.country_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.viewer_stats)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.country_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.viewer_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.country_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.viewer_stats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.country_stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastViewerStats_Response {
        CBroadcast_GetBroadcastViewerStats_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_GetBroadcastViewerStats_Response_ViewerStats>>(
                "viewer_stats",
                |m: &CBroadcast_GetBroadcastViewerStats_Response| { &m.viewer_stats },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Response| { &mut m.viewer_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_GetBroadcastViewerStats_Response_CountryStats>>(
                "country_stats",
                |m: &CBroadcast_GetBroadcastViewerStats_Response| { &m.country_stats },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Response| { &mut m.country_stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastViewerStats_Response>(
                "CBroadcast_GetBroadcastViewerStats_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastViewerStats_Response {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastViewerStats_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastViewerStats_Response::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastViewerStats_Response {
    fn clear(&mut self) {
        self.viewer_stats.clear();
        self.country_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastViewerStats_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastViewerStats_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
    // message fields
    time: ::std::option::Option<u32>,
    num_viewers: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
    fn default() -> &'a CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
        <CBroadcast_GetBroadcastViewerStats_Response_ViewerStats as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
    pub fn new() -> CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
        ::std::default::Default::default()
    }

    // optional uint32 time = 1;


    pub fn get_time(&self) -> u32 {
        self.time.unwrap_or(0)
    }
    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional uint32 num_viewers = 2;


    pub fn get_num_viewers(&self) -> u32 {
        self.num_viewers.unwrap_or(0)
    }
    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: u32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_viewers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
        CBroadcast_GetBroadcastViewerStats_Response_ViewerStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time",
                |m: &CBroadcast_GetBroadcastViewerStats_Response_ViewerStats| { &m.time },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Response_ViewerStats| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_viewers",
                |m: &CBroadcast_GetBroadcastViewerStats_Response_ViewerStats| { &m.num_viewers },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Response_ViewerStats| { &mut m.num_viewers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastViewerStats_Response_ViewerStats>(
                "CBroadcast_GetBroadcastViewerStats_Response.ViewerStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastViewerStats_Response_ViewerStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastViewerStats_Response_ViewerStats::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.num_viewers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
    // message fields
    country_code: ::protobuf::SingularField<::std::string::String>,
    num_viewers: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
    fn default() -> &'a CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
        <CBroadcast_GetBroadcastViewerStats_Response_CountryStats as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
    pub fn new() -> CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
        ::std::default::Default::default()
    }

    // optional string country_code = 1;


    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_viewers = 2;


    pub fn get_num_viewers(&self) -> u32 {
        self.num_viewers.unwrap_or(0)
    }
    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: u32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_viewers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
        CBroadcast_GetBroadcastViewerStats_Response_CountryStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country_code",
                |m: &CBroadcast_GetBroadcastViewerStats_Response_CountryStats| { &m.country_code },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Response_CountryStats| { &mut m.country_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_viewers",
                |m: &CBroadcast_GetBroadcastViewerStats_Response_CountryStats| { &m.num_viewers },
                |m: &mut CBroadcast_GetBroadcastViewerStats_Response_CountryStats| { &mut m.num_viewers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_GetBroadcastViewerStats_Response_CountryStats>(
                "CBroadcast_GetBroadcastViewerStats_Response.CountryStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_GetBroadcastViewerStats_Response_CountryStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_GetBroadcastViewerStats_Response_CountryStats::new)
    }
}

impl ::protobuf::Clear for CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
    fn clear(&mut self) {
        self.country_code.clear();
        self.num_viewers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_BroadcastViewerState_Notification {
    // message fields
    steamid: ::std::option::Option<u64>,
    state: ::std::option::Option<CBroadcast_BroadcastViewerState_Notification_EViewerState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastViewerState_Notification {
    fn default() -> &'a CBroadcast_BroadcastViewerState_Notification {
        <CBroadcast_BroadcastViewerState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastViewerState_Notification {
    pub fn new() -> CBroadcast_BroadcastViewerState_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .CBroadcast_BroadcastViewerState_Notification.EViewerState state = 2;


    pub fn get_state(&self) -> CBroadcast_BroadcastViewerState_Notification_EViewerState {
        self.state.unwrap_or(CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerNeedsApproval)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CBroadcast_BroadcastViewerState_Notification_EViewerState) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastViewerState_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_BroadcastViewerState_Notification {
        CBroadcast_BroadcastViewerState_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CBroadcast_BroadcastViewerState_Notification| { &m.steamid },
                |m: &mut CBroadcast_BroadcastViewerState_Notification| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CBroadcast_BroadcastViewerState_Notification_EViewerState>>(
                "state",
                |m: &CBroadcast_BroadcastViewerState_Notification| { &m.state },
                |m: &mut CBroadcast_BroadcastViewerState_Notification| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_BroadcastViewerState_Notification>(
                "CBroadcast_BroadcastViewerState_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_BroadcastViewerState_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_BroadcastViewerState_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_BroadcastViewerState_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_BroadcastViewerState_Notification {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_BroadcastViewerState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_BroadcastViewerState_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CBroadcast_BroadcastViewerState_Notification_EViewerState {
    k_EViewerNeedsApproval = 1,
    k_EViewerWatching = 2,
    k_EViewerLeft = 3,
}

impl ::protobuf::ProtobufEnum for CBroadcast_BroadcastViewerState_Notification_EViewerState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CBroadcast_BroadcastViewerState_Notification_EViewerState> {
        match value {
            1 => ::std::option::Option::Some(CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerNeedsApproval),
            2 => ::std::option::Option::Some(CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerWatching),
            3 => ::std::option::Option::Some(CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerLeft),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CBroadcast_BroadcastViewerState_Notification_EViewerState] = &[
            CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerNeedsApproval,
            CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerWatching,
            CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerLeft,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CBroadcast_BroadcastViewerState_Notification_EViewerState>("CBroadcast_BroadcastViewerState_Notification.EViewerState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CBroadcast_BroadcastViewerState_Notification_EViewerState {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CBroadcast_BroadcastViewerState_Notification_EViewerState {
    fn default() -> Self {
        CBroadcast_BroadcastViewerState_Notification_EViewerState::k_EViewerNeedsApproval
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_BroadcastViewerState_Notification_EViewerState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WaitingBroadcastViewer_Notification {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WaitingBroadcastViewer_Notification {
    fn default() -> &'a CBroadcast_WaitingBroadcastViewer_Notification {
        <CBroadcast_WaitingBroadcastViewer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WaitingBroadcastViewer_Notification {
    pub fn new() -> CBroadcast_WaitingBroadcastViewer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WaitingBroadcastViewer_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WaitingBroadcastViewer_Notification {
        CBroadcast_WaitingBroadcastViewer_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_WaitingBroadcastViewer_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_WaitingBroadcastViewer_Notification| { &mut m.broadcast_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WaitingBroadcastViewer_Notification>(
                "CBroadcast_WaitingBroadcastViewer_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WaitingBroadcastViewer_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WaitingBroadcastViewer_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WaitingBroadcastViewer_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WaitingBroadcastViewer_Notification {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WaitingBroadcastViewer_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WaitingBroadcastViewer_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_BroadcastUploadStarted_Notification {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    upload_token: ::protobuf::SingularField<::std::string::String>,
    upload_address: ::protobuf::SingularField<::std::string::String>,
    http_address: ::protobuf::SingularField<::std::string::String>,
    broadcast_upload_id: ::std::option::Option<u64>,
    heartbeat_interval_seconds: ::std::option::Option<u32>,
    is_rtmp: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastUploadStarted_Notification {
    fn default() -> &'a CBroadcast_BroadcastUploadStarted_Notification {
        <CBroadcast_BroadcastUploadStarted_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastUploadStarted_Notification {
    pub fn new() -> CBroadcast_BroadcastUploadStarted_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional string upload_token = 2;


    pub fn get_upload_token(&self) -> &str {
        match self.upload_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_upload_token(&mut self) {
        self.upload_token.clear();
    }

    pub fn has_upload_token(&self) -> bool {
        self.upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_token(&mut self, v: ::std::string::String) {
        self.upload_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_token(&mut self) -> &mut ::std::string::String {
        if self.upload_token.is_none() {
            self.upload_token.set_default();
        }
        self.upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_token(&mut self) -> ::std::string::String {
        self.upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string upload_address = 3;


    pub fn get_upload_address(&self) -> &str {
        match self.upload_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_upload_address(&mut self) {
        self.upload_address.clear();
    }

    pub fn has_upload_address(&self) -> bool {
        self.upload_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_address(&mut self, v: ::std::string::String) {
        self.upload_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_address(&mut self) -> &mut ::std::string::String {
        if self.upload_address.is_none() {
            self.upload_address.set_default();
        }
        self.upload_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_address(&mut self) -> ::std::string::String {
        self.upload_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_address = 4;


    pub fn get_http_address(&self) -> &str {
        match self.http_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_http_address(&mut self) {
        self.http_address.clear();
    }

    pub fn has_http_address(&self) -> bool {
        self.http_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_address(&mut self, v: ::std::string::String) {
        self.http_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_address(&mut self) -> &mut ::std::string::String {
        if self.http_address.is_none() {
            self.http_address.set_default();
        }
        self.http_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_address(&mut self) -> ::std::string::String {
        self.http_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcast_upload_id = 5;


    pub fn get_broadcast_upload_id(&self) -> u64 {
        self.broadcast_upload_id.unwrap_or(0)
    }
    pub fn clear_broadcast_upload_id(&mut self) {
        self.broadcast_upload_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_upload_id(&self) -> bool {
        self.broadcast_upload_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_upload_id(&mut self, v: u64) {
        self.broadcast_upload_id = ::std::option::Option::Some(v);
    }

    // optional uint32 heartbeat_interval_seconds = 6;


    pub fn get_heartbeat_interval_seconds(&self) -> u32 {
        self.heartbeat_interval_seconds.unwrap_or(0)
    }
    pub fn clear_heartbeat_interval_seconds(&mut self) {
        self.heartbeat_interval_seconds = ::std::option::Option::None;
    }

    pub fn has_heartbeat_interval_seconds(&self) -> bool {
        self.heartbeat_interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_interval_seconds(&mut self, v: u32) {
        self.heartbeat_interval_seconds = ::std::option::Option::Some(v);
    }

    // optional bool is_rtmp = 7;


    pub fn get_is_rtmp(&self) -> bool {
        self.is_rtmp.unwrap_or(false)
    }
    pub fn clear_is_rtmp(&mut self) {
        self.is_rtmp = ::std::option::Option::None;
    }

    pub fn has_is_rtmp(&self) -> bool {
        self.is_rtmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_rtmp(&mut self, v: bool) {
        self.is_rtmp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastUploadStarted_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.upload_token)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.upload_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_address)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_upload_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.heartbeat_interval_seconds = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_rtmp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(ref v) = self.upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.upload_address.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.http_address.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.broadcast_upload_id {
            my_size += 9;
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_rtmp {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.upload_token.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.upload_address.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.http_address.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.broadcast_upload_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.heartbeat_interval_seconds {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_rtmp {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_BroadcastUploadStarted_Notification {
        CBroadcast_BroadcastUploadStarted_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_BroadcastUploadStarted_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_BroadcastUploadStarted_Notification| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upload_token",
                |m: &CBroadcast_BroadcastUploadStarted_Notification| { &m.upload_token },
                |m: &mut CBroadcast_BroadcastUploadStarted_Notification| { &mut m.upload_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upload_address",
                |m: &CBroadcast_BroadcastUploadStarted_Notification| { &m.upload_address },
                |m: &mut CBroadcast_BroadcastUploadStarted_Notification| { &mut m.upload_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "http_address",
                |m: &CBroadcast_BroadcastUploadStarted_Notification| { &m.http_address },
                |m: &mut CBroadcast_BroadcastUploadStarted_Notification| { &mut m.http_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_upload_id",
                |m: &CBroadcast_BroadcastUploadStarted_Notification| { &m.broadcast_upload_id },
                |m: &mut CBroadcast_BroadcastUploadStarted_Notification| { &mut m.broadcast_upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "heartbeat_interval_seconds",
                |m: &CBroadcast_BroadcastUploadStarted_Notification| { &m.heartbeat_interval_seconds },
                |m: &mut CBroadcast_BroadcastUploadStarted_Notification| { &mut m.heartbeat_interval_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_rtmp",
                |m: &CBroadcast_BroadcastUploadStarted_Notification| { &m.is_rtmp },
                |m: &mut CBroadcast_BroadcastUploadStarted_Notification| { &mut m.is_rtmp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_BroadcastUploadStarted_Notification>(
                "CBroadcast_BroadcastUploadStarted_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_BroadcastUploadStarted_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_BroadcastUploadStarted_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_BroadcastUploadStarted_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_BroadcastUploadStarted_Notification {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.upload_token.clear();
        self.upload_address.clear();
        self.http_address.clear();
        self.broadcast_upload_id = ::std::option::Option::None;
        self.heartbeat_interval_seconds = ::std::option::Option::None;
        self.is_rtmp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_BroadcastUploadStarted_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_BroadcastUploadStarted_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_StopBroadcastUpload_Notification {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    broadcast_relay_id: ::std::option::Option<u64>,
    upload_result: ::std::option::Option<u32>,
    too_many_poor_uploads: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_StopBroadcastUpload_Notification {
    fn default() -> &'a CBroadcast_StopBroadcastUpload_Notification {
        <CBroadcast_StopBroadcastUpload_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_StopBroadcastUpload_Notification {
    pub fn new() -> CBroadcast_StopBroadcastUpload_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcast_relay_id = 2;


    pub fn get_broadcast_relay_id(&self) -> u64 {
        self.broadcast_relay_id.unwrap_or(0)
    }
    pub fn clear_broadcast_relay_id(&mut self) {
        self.broadcast_relay_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_relay_id(&self) -> bool {
        self.broadcast_relay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_relay_id(&mut self, v: u64) {
        self.broadcast_relay_id = ::std::option::Option::Some(v);
    }

    // optional uint32 upload_result = 3;


    pub fn get_upload_result(&self) -> u32 {
        self.upload_result.unwrap_or(0)
    }
    pub fn clear_upload_result(&mut self) {
        self.upload_result = ::std::option::Option::None;
    }

    pub fn has_upload_result(&self) -> bool {
        self.upload_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_result(&mut self, v: u32) {
        self.upload_result = ::std::option::Option::Some(v);
    }

    // optional bool too_many_poor_uploads = 4;


    pub fn get_too_many_poor_uploads(&self) -> bool {
        self.too_many_poor_uploads.unwrap_or(false)
    }
    pub fn clear_too_many_poor_uploads(&mut self) {
        self.too_many_poor_uploads = ::std::option::Option::None;
    }

    pub fn has_too_many_poor_uploads(&self) -> bool {
        self.too_many_poor_uploads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_too_many_poor_uploads(&mut self, v: bool) {
        self.too_many_poor_uploads = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_StopBroadcastUpload_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_relay_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.upload_result = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.too_many_poor_uploads = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.broadcast_relay_id {
            my_size += 9;
        }
        if let Some(v) = self.upload_result {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.too_many_poor_uploads {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.broadcast_relay_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.upload_result {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.too_many_poor_uploads {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_StopBroadcastUpload_Notification {
        CBroadcast_StopBroadcastUpload_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_StopBroadcastUpload_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_StopBroadcastUpload_Notification| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_relay_id",
                |m: &CBroadcast_StopBroadcastUpload_Notification| { &m.broadcast_relay_id },
                |m: &mut CBroadcast_StopBroadcastUpload_Notification| { &mut m.broadcast_relay_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "upload_result",
                |m: &CBroadcast_StopBroadcastUpload_Notification| { &m.upload_result },
                |m: &mut CBroadcast_StopBroadcastUpload_Notification| { &mut m.upload_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "too_many_poor_uploads",
                |m: &CBroadcast_StopBroadcastUpload_Notification| { &m.too_many_poor_uploads },
                |m: &mut CBroadcast_StopBroadcastUpload_Notification| { &mut m.too_many_poor_uploads },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_StopBroadcastUpload_Notification>(
                "CBroadcast_StopBroadcastUpload_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_StopBroadcastUpload_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_StopBroadcastUpload_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_StopBroadcastUpload_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_StopBroadcastUpload_Notification {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.broadcast_relay_id = ::std::option::Option::None;
        self.upload_result = ::std::option::Option::None;
        self.too_many_poor_uploads = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_StopBroadcastUpload_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_StopBroadcastUpload_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SessionClosed_Notification {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SessionClosed_Notification {
    fn default() -> &'a CBroadcast_SessionClosed_Notification {
        <CBroadcast_SessionClosed_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SessionClosed_Notification {
    pub fn new() -> CBroadcast_SessionClosed_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_SessionClosed_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SessionClosed_Notification {
        CBroadcast_SessionClosed_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_SessionClosed_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_SessionClosed_Notification| { &mut m.broadcast_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SessionClosed_Notification>(
                "CBroadcast_SessionClosed_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SessionClosed_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SessionClosed_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SessionClosed_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SessionClosed_Notification {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SessionClosed_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SessionClosed_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_ViewerBroadcastInvite_Notification {
    // message fields
    broadcaster_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_ViewerBroadcastInvite_Notification {
    fn default() -> &'a CBroadcast_ViewerBroadcastInvite_Notification {
        <CBroadcast_ViewerBroadcastInvite_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_ViewerBroadcastInvite_Notification {
    pub fn new() -> CBroadcast_ViewerBroadcastInvite_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcaster_steamid = 1;


    pub fn get_broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }
    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_ViewerBroadcastInvite_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcaster_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcaster_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_ViewerBroadcastInvite_Notification {
        CBroadcast_ViewerBroadcastInvite_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcaster_steamid",
                |m: &CBroadcast_ViewerBroadcastInvite_Notification| { &m.broadcaster_steamid },
                |m: &mut CBroadcast_ViewerBroadcastInvite_Notification| { &mut m.broadcaster_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_ViewerBroadcastInvite_Notification>(
                "CBroadcast_ViewerBroadcastInvite_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_ViewerBroadcastInvite_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_ViewerBroadcastInvite_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_ViewerBroadcastInvite_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_ViewerBroadcastInvite_Notification {
    fn clear(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_ViewerBroadcastInvite_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_ViewerBroadcastInvite_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_BroadcastStatus_Notification {
    // message fields
    broadcast_id: ::std::option::Option<u64>,
    num_viewers: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastStatus_Notification {
    fn default() -> &'a CBroadcast_BroadcastStatus_Notification {
        <CBroadcast_BroadcastStatus_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastStatus_Notification {
    pub fn new() -> CBroadcast_BroadcastStatus_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_id = 1;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_viewers = 2;


    pub fn get_num_viewers(&self) -> i32 {
        self.num_viewers.unwrap_or(0)
    }
    pub fn clear_num_viewers(&mut self) {
        self.num_viewers = ::std::option::Option::None;
    }

    pub fn has_num_viewers(&self) -> bool {
        self.num_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_viewers(&mut self, v: i32) {
        self.num_viewers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastStatus_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_viewers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_id {
            my_size += 9;
        }
        if let Some(v) = self.num_viewers {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.num_viewers {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_BroadcastStatus_Notification {
        CBroadcast_BroadcastStatus_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CBroadcast_BroadcastStatus_Notification| { &m.broadcast_id },
                |m: &mut CBroadcast_BroadcastStatus_Notification| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_viewers",
                |m: &CBroadcast_BroadcastStatus_Notification| { &m.num_viewers },
                |m: &mut CBroadcast_BroadcastStatus_Notification| { &mut m.num_viewers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_BroadcastStatus_Notification>(
                "CBroadcast_BroadcastStatus_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_BroadcastStatus_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_BroadcastStatus_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_BroadcastStatus_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_BroadcastStatus_Notification {
    fn clear(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
        self.num_viewers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_BroadcastStatus_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_BroadcastStatus_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_BroadcastChannelLive_Notification {
    // message fields
    broadcast_channel_id: ::std::option::Option<u64>,
    broadcast_channel_name: ::protobuf::SingularField<::std::string::String>,
    broadcast_channel_avatar: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_BroadcastChannelLive_Notification {
    fn default() -> &'a CBroadcast_BroadcastChannelLive_Notification {
        <CBroadcast_BroadcastChannelLive_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_BroadcastChannelLive_Notification {
    pub fn new() -> CBroadcast_BroadcastChannelLive_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;


    pub fn get_broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string broadcast_channel_name = 2;


    pub fn get_broadcast_channel_name(&self) -> &str {
        match self.broadcast_channel_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_broadcast_channel_name(&mut self) {
        self.broadcast_channel_name.clear();
    }

    pub fn has_broadcast_channel_name(&self) -> bool {
        self.broadcast_channel_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_name(&mut self, v: ::std::string::String) {
        self.broadcast_channel_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast_channel_name(&mut self) -> &mut ::std::string::String {
        if self.broadcast_channel_name.is_none() {
            self.broadcast_channel_name.set_default();
        }
        self.broadcast_channel_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_broadcast_channel_name(&mut self) -> ::std::string::String {
        self.broadcast_channel_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string broadcast_channel_avatar = 3;


    pub fn get_broadcast_channel_avatar(&self) -> &str {
        match self.broadcast_channel_avatar.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_broadcast_channel_avatar(&mut self) {
        self.broadcast_channel_avatar.clear();
    }

    pub fn has_broadcast_channel_avatar(&self) -> bool {
        self.broadcast_channel_avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_avatar(&mut self, v: ::std::string::String) {
        self.broadcast_channel_avatar = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast_channel_avatar(&mut self) -> &mut ::std::string::String {
        if self.broadcast_channel_avatar.is_none() {
            self.broadcast_channel_avatar.set_default();
        }
        self.broadcast_channel_avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_broadcast_channel_avatar(&mut self) -> ::std::string::String {
        self.broadcast_channel_avatar.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_BroadcastChannelLive_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcast_channel_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcast_channel_avatar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 9;
        }
        if let Some(ref v) = self.broadcast_channel_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.broadcast_channel_avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.broadcast_channel_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.broadcast_channel_avatar.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_BroadcastChannelLive_Notification {
        CBroadcast_BroadcastChannelLive_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_channel_id",
                |m: &CBroadcast_BroadcastChannelLive_Notification| { &m.broadcast_channel_id },
                |m: &mut CBroadcast_BroadcastChannelLive_Notification| { &mut m.broadcast_channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "broadcast_channel_name",
                |m: &CBroadcast_BroadcastChannelLive_Notification| { &m.broadcast_channel_name },
                |m: &mut CBroadcast_BroadcastChannelLive_Notification| { &mut m.broadcast_channel_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "broadcast_channel_avatar",
                |m: &CBroadcast_BroadcastChannelLive_Notification| { &m.broadcast_channel_avatar },
                |m: &mut CBroadcast_BroadcastChannelLive_Notification| { &mut m.broadcast_channel_avatar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_BroadcastChannelLive_Notification>(
                "CBroadcast_BroadcastChannelLive_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_BroadcastChannelLive_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_BroadcastChannelLive_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_BroadcastChannelLive_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_BroadcastChannelLive_Notification {
    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.broadcast_channel_name.clear();
        self.broadcast_channel_avatar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_BroadcastChannelLive_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_BroadcastChannelLive_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_SendThumbnailToRelay_Notification {
    // message fields
    thumbnail_upload_token: ::protobuf::SingularField<::std::string::String>,
    thumbnail_broadcast_session_id: ::std::option::Option<u64>,
    thumbnail_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    thumbnail_width: ::std::option::Option<u32>,
    thumbnail_height: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_SendThumbnailToRelay_Notification {
    fn default() -> &'a CBroadcast_SendThumbnailToRelay_Notification {
        <CBroadcast_SendThumbnailToRelay_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_SendThumbnailToRelay_Notification {
    pub fn new() -> CBroadcast_SendThumbnailToRelay_Notification {
        ::std::default::Default::default()
    }

    // optional string thumbnail_upload_token = 1;


    pub fn get_thumbnail_upload_token(&self) -> &str {
        match self.thumbnail_upload_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbnail_upload_token(&mut self) {
        self.thumbnail_upload_token.clear();
    }

    pub fn has_thumbnail_upload_token(&self) -> bool {
        self.thumbnail_upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_upload_token(&mut self, v: ::std::string::String) {
        self.thumbnail_upload_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_upload_token(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_upload_token.is_none() {
            self.thumbnail_upload_token.set_default();
        }
        self.thumbnail_upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_upload_token(&mut self) -> ::std::string::String {
        self.thumbnail_upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 thumbnail_broadcast_session_id = 2;


    pub fn get_thumbnail_broadcast_session_id(&self) -> u64 {
        self.thumbnail_broadcast_session_id.unwrap_or(0)
    }
    pub fn clear_thumbnail_broadcast_session_id(&mut self) {
        self.thumbnail_broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_thumbnail_broadcast_session_id(&self) -> bool {
        self.thumbnail_broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_broadcast_session_id(&mut self, v: u64) {
        self.thumbnail_broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional bytes thumbnail_data = 3;


    pub fn get_thumbnail_data(&self) -> &[u8] {
        match self.thumbnail_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_thumbnail_data(&mut self) {
        self.thumbnail_data.clear();
    }

    pub fn has_thumbnail_data(&self) -> bool {
        self.thumbnail_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnail_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnail_data.is_none() {
            self.thumbnail_data.set_default();
        }
        self.thumbnail_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_data(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnail_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 thumbnail_width = 4;


    pub fn get_thumbnail_width(&self) -> u32 {
        self.thumbnail_width.unwrap_or(0)
    }
    pub fn clear_thumbnail_width(&mut self) {
        self.thumbnail_width = ::std::option::Option::None;
    }

    pub fn has_thumbnail_width(&self) -> bool {
        self.thumbnail_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_width(&mut self, v: u32) {
        self.thumbnail_width = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnail_height = 5;


    pub fn get_thumbnail_height(&self) -> u32 {
        self.thumbnail_height.unwrap_or(0)
    }
    pub fn clear_thumbnail_height(&mut self) {
        self.thumbnail_height = ::std::option::Option::None;
    }

    pub fn has_thumbnail_height(&self) -> bool {
        self.thumbnail_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_height(&mut self, v: u32) {
        self.thumbnail_height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_SendThumbnailToRelay_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnail_upload_token)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.thumbnail_broadcast_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.thumbnail_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.thumbnail_width = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.thumbnail_height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.thumbnail_upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.thumbnail_broadcast_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.thumbnail_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.thumbnail_width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbnail_height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.thumbnail_upload_token.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.thumbnail_broadcast_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.thumbnail_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.thumbnail_width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.thumbnail_height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_SendThumbnailToRelay_Notification {
        CBroadcast_SendThumbnailToRelay_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_upload_token",
                |m: &CBroadcast_SendThumbnailToRelay_Notification| { &m.thumbnail_upload_token },
                |m: &mut CBroadcast_SendThumbnailToRelay_Notification| { &mut m.thumbnail_upload_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "thumbnail_broadcast_session_id",
                |m: &CBroadcast_SendThumbnailToRelay_Notification| { &m.thumbnail_broadcast_session_id },
                |m: &mut CBroadcast_SendThumbnailToRelay_Notification| { &mut m.thumbnail_broadcast_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "thumbnail_data",
                |m: &CBroadcast_SendThumbnailToRelay_Notification| { &m.thumbnail_data },
                |m: &mut CBroadcast_SendThumbnailToRelay_Notification| { &mut m.thumbnail_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "thumbnail_width",
                |m: &CBroadcast_SendThumbnailToRelay_Notification| { &m.thumbnail_width },
                |m: &mut CBroadcast_SendThumbnailToRelay_Notification| { &mut m.thumbnail_width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "thumbnail_height",
                |m: &CBroadcast_SendThumbnailToRelay_Notification| { &m.thumbnail_height },
                |m: &mut CBroadcast_SendThumbnailToRelay_Notification| { &mut m.thumbnail_height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_SendThumbnailToRelay_Notification>(
                "CBroadcast_SendThumbnailToRelay_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_SendThumbnailToRelay_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_SendThumbnailToRelay_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_SendThumbnailToRelay_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_SendThumbnailToRelay_Notification {
    fn clear(&mut self) {
        self.thumbnail_upload_token.clear();
        self.thumbnail_broadcast_session_id = ::std::option::Option::None;
        self.thumbnail_data.clear();
        self.thumbnail_width = ::std::option::Option::None;
        self.thumbnail_height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_SendThumbnailToRelay_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_SendThumbnailToRelay_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCNeedTURNServer_Notification {
    // message fields
    broadcast_session_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCNeedTURNServer_Notification {
    fn default() -> &'a CBroadcast_WebRTCNeedTURNServer_Notification {
        <CBroadcast_WebRTCNeedTURNServer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCNeedTURNServer_Notification {
    pub fn new() -> CBroadcast_WebRTCNeedTURNServer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;


    pub fn get_broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }
    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCNeedTURNServer_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_session_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCNeedTURNServer_Notification {
        CBroadcast_WebRTCNeedTURNServer_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_session_id",
                |m: &CBroadcast_WebRTCNeedTURNServer_Notification| { &m.broadcast_session_id },
                |m: &mut CBroadcast_WebRTCNeedTURNServer_Notification| { &mut m.broadcast_session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCNeedTURNServer_Notification>(
                "CBroadcast_WebRTCNeedTURNServer_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCNeedTURNServer_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCNeedTURNServer_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCNeedTURNServer_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCNeedTURNServer_Notification {
    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCNeedTURNServer_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCNeedTURNServer_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCStart_Notification {
    // message fields
    broadcast_session_id: ::std::option::Option<u64>,
    webrtc_session_id: ::std::option::Option<u64>,
    viewer_steamid: ::std::option::Option<u64>,
    viewer_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCStart_Notification {
    fn default() -> &'a CBroadcast_WebRTCStart_Notification {
        <CBroadcast_WebRTCStart_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCStart_Notification {
    pub fn new() -> CBroadcast_WebRTCStart_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;


    pub fn get_broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }
    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_steamid = 3;


    pub fn get_viewer_steamid(&self) -> u64 {
        self.viewer_steamid.unwrap_or(0)
    }
    pub fn clear_viewer_steamid(&mut self) {
        self.viewer_steamid = ::std::option::Option::None;
    }

    pub fn has_viewer_steamid(&self) -> bool {
        self.viewer_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_steamid(&mut self, v: u64) {
        self.viewer_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 viewer_token = 4;


    pub fn get_viewer_token(&self) -> u64 {
        self.viewer_token.unwrap_or(0)
    }
    pub fn clear_viewer_token(&mut self) {
        self.viewer_token = ::std::option::Option::None;
    }

    pub fn has_viewer_token(&self) -> bool {
        self.viewer_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer_token(&mut self, v: u64) {
        self.viewer_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCStart_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.viewer_steamid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.viewer_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 9;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(v) = self.viewer_steamid {
            my_size += 9;
        }
        if let Some(v) = self.viewer_token {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.viewer_steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.viewer_token {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCStart_Notification {
        CBroadcast_WebRTCStart_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_session_id",
                |m: &CBroadcast_WebRTCStart_Notification| { &m.broadcast_session_id },
                |m: &mut CBroadcast_WebRTCStart_Notification| { &mut m.broadcast_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCStart_Notification| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCStart_Notification| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "viewer_steamid",
                |m: &CBroadcast_WebRTCStart_Notification| { &m.viewer_steamid },
                |m: &mut CBroadcast_WebRTCStart_Notification| { &mut m.viewer_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "viewer_token",
                |m: &CBroadcast_WebRTCStart_Notification| { &m.viewer_token },
                |m: &mut CBroadcast_WebRTCStart_Notification| { &mut m.viewer_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCStart_Notification>(
                "CBroadcast_WebRTCStart_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCStart_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCStart_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCStart_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCStart_Notification {
    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.viewer_steamid = ::std::option::Option::None;
        self.viewer_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCStart_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCStart_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCSetAnswer_Notification {
    // message fields
    broadcast_session_id: ::std::option::Option<u64>,
    webrtc_session_id: ::std::option::Option<u64>,
    answer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCSetAnswer_Notification {
    fn default() -> &'a CBroadcast_WebRTCSetAnswer_Notification {
        <CBroadcast_WebRTCSetAnswer_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCSetAnswer_Notification {
    pub fn new() -> CBroadcast_WebRTCSetAnswer_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;


    pub fn get_broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }
    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional string answer = 3;


    pub fn get_answer(&self) -> &str {
        match self.answer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    pub fn has_answer(&self) -> bool {
        self.answer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.answer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        if self.answer.is_none() {
            self.answer.set_default();
        }
        self.answer.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        self.answer.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCSetAnswer_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.answer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 9;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.answer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.answer.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCSetAnswer_Notification {
        CBroadcast_WebRTCSetAnswer_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_session_id",
                |m: &CBroadcast_WebRTCSetAnswer_Notification| { &m.broadcast_session_id },
                |m: &mut CBroadcast_WebRTCSetAnswer_Notification| { &mut m.broadcast_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCSetAnswer_Notification| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCSetAnswer_Notification| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "answer",
                |m: &CBroadcast_WebRTCSetAnswer_Notification| { &m.answer },
                |m: &mut CBroadcast_WebRTCSetAnswer_Notification| { &mut m.answer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCSetAnswer_Notification>(
                "CBroadcast_WebRTCSetAnswer_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCSetAnswer_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCSetAnswer_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCSetAnswer_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCSetAnswer_Notification {
    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.answer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCSetAnswer_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCSetAnswer_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CBroadcast_WebRTCAddViewerCandidate_Notification {
    // message fields
    broadcast_session_id: ::std::option::Option<u64>,
    webrtc_session_id: ::std::option::Option<u64>,
    pub candidate: ::protobuf::SingularPtrField<CBroadcast_WebRTC_Candidate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBroadcast_WebRTCAddViewerCandidate_Notification {
    fn default() -> &'a CBroadcast_WebRTCAddViewerCandidate_Notification {
        <CBroadcast_WebRTCAddViewerCandidate_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CBroadcast_WebRTCAddViewerCandidate_Notification {
    pub fn new() -> CBroadcast_WebRTCAddViewerCandidate_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_session_id = 1;


    pub fn get_broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }
    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 webrtc_session_id = 2;


    pub fn get_webrtc_session_id(&self) -> u64 {
        self.webrtc_session_id.unwrap_or(0)
    }
    pub fn clear_webrtc_session_id(&mut self) {
        self.webrtc_session_id = ::std::option::Option::None;
    }

    pub fn has_webrtc_session_id(&self) -> bool {
        self.webrtc_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc_session_id(&mut self, v: u64) {
        self.webrtc_session_id = ::std::option::Option::Some(v);
    }

    // optional .CBroadcast_WebRTC_Candidate candidate = 3;


    pub fn get_candidate(&self) -> &CBroadcast_WebRTC_Candidate {
        self.candidate.as_ref().unwrap_or_else(|| <CBroadcast_WebRTC_Candidate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: CBroadcast_WebRTC_Candidate) {
        self.candidate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut CBroadcast_WebRTC_Candidate {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> CBroadcast_WebRTC_Candidate {
        self.candidate.take().unwrap_or_else(|| CBroadcast_WebRTC_Candidate::new())
    }
}

impl ::protobuf::Message for CBroadcast_WebRTCAddViewerCandidate_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.candidate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.webrtc_session_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_session_id {
            my_size += 9;
        }
        if let Some(v) = self.webrtc_session_id {
            my_size += 9;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broadcast_session_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.webrtc_session_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBroadcast_WebRTCAddViewerCandidate_Notification {
        CBroadcast_WebRTCAddViewerCandidate_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_session_id",
                |m: &CBroadcast_WebRTCAddViewerCandidate_Notification| { &m.broadcast_session_id },
                |m: &mut CBroadcast_WebRTCAddViewerCandidate_Notification| { &mut m.broadcast_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "webrtc_session_id",
                |m: &CBroadcast_WebRTCAddViewerCandidate_Notification| { &m.webrtc_session_id },
                |m: &mut CBroadcast_WebRTCAddViewerCandidate_Notification| { &mut m.webrtc_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CBroadcast_WebRTC_Candidate>>(
                "candidate",
                |m: &CBroadcast_WebRTCAddViewerCandidate_Notification| { &m.candidate },
                |m: &mut CBroadcast_WebRTCAddViewerCandidate_Notification| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBroadcast_WebRTCAddViewerCandidate_Notification>(
                "CBroadcast_WebRTCAddViewerCandidate_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CBroadcast_WebRTCAddViewerCandidate_Notification {
        static instance: ::protobuf::rt::LazyV2<CBroadcast_WebRTCAddViewerCandidate_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBroadcast_WebRTCAddViewerCandidate_Notification::new)
    }
}

impl ::protobuf::Clear for CBroadcast_WebRTCAddViewerCandidate_Notification {
    fn clear(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
        self.webrtc_session_id = ::std::option::Option::None;
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBroadcast_WebRTCAddViewerCandidate_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBroadcast_WebRTCAddViewerCandidate_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EBroadcastWatchLocation {
    k_EBroadcastWatchLocation_Invalid = 0,
    k_EBroadcastWatchLocation_SteamTV_Tab = 1,
    k_EBroadcastWatchLocation_SteamTV_WatchParty = 2,
    k_EBroadcastWatchLocation_Chat_Tab = 3,
    k_EBroadcastWatchLocation_Chat_WatchParty = 4,
    k_EBroadcastWatchLocation_CommunityPage = 5,
    k_EBroadcastWatchLocation_StoreAppPage = 6,
    k_EBroadcastWatchLocation_InGame = 7,
    k_EBroadcastWatchLocation_BigPicture = 8,
    k_EBroadcastWatchLocation_SalesPage = 9,
    k_EBroadcastWatchLocation_CuratorPage = 10,
    k_EBroadcastWatchLocation_DeveloperPage = 11,
    k_EBroadcastWatchLocation_Chat_Friends = 12,
    k_EBroadcastWatchLocation_SteamTV_Web = 13,
}

impl ::protobuf::ProtobufEnum for EBroadcastWatchLocation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastWatchLocation> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid),
            1 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Tab),
            2 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_WatchParty),
            3 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Tab),
            4 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_WatchParty),
            5 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_CommunityPage),
            6 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_StoreAppPage),
            7 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_InGame),
            8 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_BigPicture),
            9 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SalesPage),
            10 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_CuratorPage),
            11 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_DeveloperPage),
            12 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Friends),
            13 => ::std::option::Option::Some(EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Web),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EBroadcastWatchLocation] = &[
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Tab,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_WatchParty,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Tab,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_WatchParty,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_CommunityPage,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_StoreAppPage,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_InGame,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_BigPicture,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_SalesPage,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_CuratorPage,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_DeveloperPage,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_Chat_Friends,
            EBroadcastWatchLocation::k_EBroadcastWatchLocation_SteamTV_Web,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EBroadcastWatchLocation>("EBroadcastWatchLocation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EBroadcastWatchLocation {
}

impl ::std::default::Default for EBroadcastWatchLocation {
    fn default() -> Self {
        EBroadcastWatchLocation::k_EBroadcastWatchLocation_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EBroadcastWatchLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EBroadcastChatPermission {
    k_EBroadcastChatPermissionPublic = 0,
    k_EBroadcastChatPermissionOwnsApp = 1,
}

impl ::protobuf::ProtobufEnum for EBroadcastChatPermission {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastChatPermission> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastChatPermission::k_EBroadcastChatPermissionPublic),
            1 => ::std::option::Option::Some(EBroadcastChatPermission::k_EBroadcastChatPermissionOwnsApp),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EBroadcastChatPermission] = &[
            EBroadcastChatPermission::k_EBroadcastChatPermissionPublic,
            EBroadcastChatPermission::k_EBroadcastChatPermissionOwnsApp,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EBroadcastChatPermission>("EBroadcastChatPermission", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EBroadcastChatPermission {
}

impl ::std::default::Default for EBroadcastChatPermission {
    fn default() -> Self {
        EBroadcastChatPermission::k_EBroadcastChatPermissionPublic
    }
}

impl ::protobuf::reflect::ProtobufValue for EBroadcastChatPermission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)steammessages_broadcast.steamclient.proto\x1a,steammessages_unified_b\
    ase.steamclient.proto\"\xe2\x02\n(CBroadcast_BeginBroadcastSession_Reque\
    st\x12\x1e\n\npermission\x18\x01\x20\x01(\x05R\npermission\x12\x16\n\x06\
    gameid\x18\x02\x20\x01(\x04R\x06gameid\x12,\n\x12client_instance_id\x18\
    \x03\x20\x01(\x04R\x10clientInstanceId\x12\x14\n\x05title\x18\x04\x20\
    \x01(\tR\x05title\x12\x16\n\x06cellid\x18\x05\x20\x01(\rR\x06cellid\x12\
    \x1d\n\nrtmp_token\x18\x06\x20\x01(\x04R\trtmpToken\x12)\n\x10thumbnail_\
    upload\x18\x07\x20\x01(\x08R\x0fthumbnailUpload\x12\x1f\n\x0bclient_beta\
    \x18\x08\x20\x01(\tR\nclientBeta\x12\x14\n\x05sysid\x18\t\x20\x01(\rR\
    \x05sysid\x12!\n\x0callow_webrtc\x18\n\x20\x01(\x08R\x0ballowWebrtc\"\
    \x8b\x04\n)CBroadcast_BeginBroadcastSession_Response\x12!\n\x0cbroadcast\
    _id\x18\x01\x20\x01(\x06R\x0bbroadcastId\x12h\n\x18thumbnail_upload_addr\
    ess\x18\x02\x20\x01(\tR\x16thumbnailUploadAddressB.\x82\xb5\x18*Http\x20\
    address\x20to\x20upload\x20the\x20thumbnail\x20data.\x12{\n\x16thumbnail\
    _upload_token\x18\x03\x20\x01(\tR\x14thumbnailUploadTokenBE\x82\xb5\x18A\
    token\x20to\x20authorize\x20as\x20broadcaster\x20to\x20upload\x20content\
    \x20to\x20the\x20relay.\x12e\n\x1athumbnail_interval_seconds\x18\x04\x20\
    \x01(\rR\x18thumbnailIntervalSecondsB'\x82\xb5\x18#how\x20many\x20second\
    s\x20between\x20thumbnails\x12m\n\x1aheartbeat_interval_seconds\x18\x05\
    \x20\x01(\rR\x18heartbeatIntervalSecondsB/\x82\xb5\x18+how\x20many\x20se\
    conds\x20between\x20session\x20heartbeats\"K\n&CBroadcast_EndBroadcastSe\
    ssion_Request\x12!\n\x0cbroadcast_id\x18\x01\x20\x01(\x06R\x0bbroadcastI\
    d\")\n'CBroadcast_EndBroadcastSession_Response\"\xe0\x02\n'CBroadcast_St\
    artBroadcastUpload_Request\x12!\n\x0cbroadcast_id\x18\x01\x20\x01(\x06R\
    \x0bbroadcastId\x12\x16\n\x06cellid\x18\x02\x20\x01(\rR\x06cellid\x12\
    \x17\n\x07as_rtmp\x18\x03\x20\x01(\x08R\x06asRtmp\x12#\n\rdelay_seconds\
    \x18\x04\x20\x01(\rR\x0cdelaySeconds\x12]\n\nrtmp_token\x18\x05\x20\x01(\
    \x04:\x010R\trtmpTokenB;\x82\xb5\x187Only\x20set\x20during\x20RTMP\x20up\
    loads;\x20secret\x20key\x20from\x20the\x20user.\x12*\n\x11upload_ip_addr\
    ess\x18\x06\x20\x01(\rR\x0fuploadIpAddress\x12\x1b\n\tis_replay\x18\x07\
    \x20\x01(\x08R\x08isReplay\x12\x14\n\x05sysid\x18\x08\x20\x01(\rR\x05sys\
    id\"\xec\x01\n(CBroadcast_StartBroadcastUpload_Response\x12!\n\x0cupload\
    _token\x18\x01\x20\x01(\tR\x0buploadToken\x12%\n\x0eupload_address\x18\
    \x02\x20\x01(\tR\ruploadAddress\x12.\n\x13broadcast_upload_id\x18\x03\
    \x20\x01(\x06R\x11broadcastUploadId\x12#\n\renable_replay\x18\x06\x20\
    \x01(\x08R\x0cenableReplay\x12!\n\x0chttp_address\x18\x07\x20\x01(\tR\
    \x0bhttpAddress\"\x88\x01\n1CBroadcast_NotifyBroadcastUploadStop_Notific\
    ation\x12.\n\x13broadcast_upload_id\x18\x01\x20\x01(\x06R\x11broadcastUp\
    loadId\x12#\n\rupload_result\x18\x02\x20\x01(\rR\x0cuploadResult\"\xd9\
    \x03\n!CBroadcast_WatchBroadcast_Request\x122\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamidB\x18\x82\xb5\x18\x14broadcaster\x20steamID.\x12m\n\
    \x15existing_broadcast_id\x18\x02\x20\x01(\x06R\x13existingBroadcastIdB9\
    \x82\xb5\x185broadcast\x20session\x20ID\x20(optional,\x20rejoin\x20if\
    \x20specified).\x12o\n\x0cviewer_token\x18\x03\x20\x01(\x06R\x0bviewerTo\
    kenBL\x82\xb5\x18Hviewer\x20token\x20received\x20from\x20last\x20WatchRe\
    quest\x20call,\x20from\x20browser\x20storage.\x12\x1f\n\x0bclient_cell\
    \x18\x05\x20\x01(\rR\nclientCell\x12b\n\x0ewatch_location\x18\x06\x20\
    \x01(\x0e2\x18.EBroadcastWatchLocation:!k_EBroadcastWatchLocation_Invali\
    dR\rwatchLocation\x12\x1b\n\tis_webrtc\x18\x07\x20\x01(\x08R\x08isWebrtc\
    \"\xfd\t\n\"CBroadcast_WatchBroadcast_Response\x12e\n\x08response\x18\
    \x01\x20\x01(\x0e22.CBroadcast_WatchBroadcast_Response.EWatchResponse:\
    \x15k_EWatchResponseReadyR\x08response\x12\x17\n\x07mpd_url\x18\x02\x20\
    \x01(\tR\x06mpdUrl\x12!\n\x0cbroadcast_id\x18\x03\x20\x01(\x06R\x0bbroad\
    castId\x12\x16\n\x06gameid\x18\x04\x20\x01(\x04R\x06gameid\x12\x14\n\x05\
    title\x18\x05\x20\x01(\tR\x05title\x12\x1f\n\x0bnum_viewers\x18\x06\x20\
    \x01(\rR\nnumViewers\x12\x1e\n\npermission\x18\x07\x20\x01(\x05R\npermis\
    sion\x12\x17\n\x07is_rtmp\x18\x08\x20\x01(\x08R\x06isRtmp\x12#\n\rsecond\
    s_delay\x18\t\x20\x01(\x05R\x0csecondsDelay\x12!\n\x0cviewer_token\x18\n\
    \x20\x01(\x06R\x0bviewerToken\x12-\n\x13hls_m3u8_master_url\x18\x0b\x20\
    \x01(\tR\x10hlsM3u8MasterUrl\x12-\n\x12heartbeat_interval\x18\x0c\x20\
    \x01(\x05R\x11heartbeatInterval\x12#\n\rthumbnail_url\x18\r\x20\x01(\tR\
    \x0cthumbnailUrl\x12\x1b\n\tis_webrtc\x18\x0e\x20\x01(\x08R\x08isWebrtc\
    \x12*\n\x11webrtc_session_id\x18\x0f\x20\x01(\x06R\x0fwebrtcSessionId\
    \x12(\n\x10webrtc_offer_sdp\x18\x10\x20\x01(\tR\x0ewebrtcOfferSdp\x12,\n\
    \x12webrtc_turn_server\x18\x11\x20\x01(\tR\x10webrtcTurnServer\x12\x1b\n\
    \tis_replay\x18\x12\x20\x01(\x08R\x08isReplay\x12\x1a\n\x08duration\x18\
    \x13\x20\x01(\x05R\x08duration\x125\n\x17cdn_auth_url_parameters\x18\x14\
    \x20\x01(\tR\x14cdnAuthUrlParameters\"\xcf\x03\n\x0eEWatchResponse\x12\
    \x19\n\x15k_EWatchResponseReady\x10\x01\x12\x20\n\x1ck_EWatchResponseNot\
    Available\x10\x02\x12&\n\"k_EWatchResponseWaitingForApproval\x10\x03\x12\
    #\n\x1fk_EWatchResponseWaitingForStart\x10\x04\x12\"\n\x1ek_EWatchRespon\
    seInvalidSession\x10\x05\x12%\n!k_EWatchResponseTooManyBroadcasts\x10\
    \x06\x12'\n#k_EWatchResponseWaitingForReconnect\x10\x07\x12&\n\"k_EWatch\
    ResponseSystemNotSupported\x10\x08\x12\"\n\x1ek_EWatchResponseUserRestri\
    cted\x10\t\x12#\n\x1fk_EWatchResponseClientOutOfDate\x10\n\x12%\n!k_EWat\
    chResponsePoorUploadQuality\x10\x0b\x12'\n#k_EWatchResponseMissingSubscr\
    iption\x10\x0c\"\xe1\x02\n*CBroadcast_HeartbeatBroadcast_Notification\
    \x122\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamidB\x18\x82\xb5\x18\x14\
    broadcaster\x20steamID.\x12<\n\x0cbroadcast_id\x18\x02\x20\x01(\x06R\x0b\
    broadcastIdB\x19\x82\xb5\x18\x15broadcast\x20session\x20ID.\x12o\n\x0cvi\
    ewer_token\x18\x03\x20\x01(\x06R\x0bviewerTokenBL\x82\xb5\x18Hviewer\x20\
    token\x20received\x20from\x20last\x20WatchRequest\x20call,\x20from\x20br\
    owser\x20storage.\x12P\n\x0erepresentation\x18\x04\x20\x01(\rR\x0erepres\
    entationB(\x82\xb5\x18$video\x20stream\x20representation\x20watching\"\
    \x92\x02\n-CBroadcast_StopWatchingBroadcast_Notification\x122\n\x07steam\
    id\x18\x01\x20\x01(\x06R\x07steamidB\x18\x82\xb5\x18\x14broadcaster\x20s\
    teamID.\x12<\n\x0cbroadcast_id\x18\x02\x20\x01(\x06R\x0bbroadcastIdB\x19\
    \x82\xb5\x18\x15broadcast\x20session\x20ID.\x12o\n\x0cviewer_token\x18\
    \x03\x20\x01(\x06R\x0bviewerTokenBL\x82\xb5\x18Hviewer\x20token\x20recei\
    ved\x20from\x20last\x20WatchRequest\x20call,\x20from\x20browser\x20stora\
    ge.\"\xc6\x01\n%CBroadcast_GetBroadcastStatus_Request\x122\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamidB\x18\x82\xb5\x18\x14broadcaster\x20ste\
    amID.\x12i\n\x0cbroadcast_id\x18\x02\x20\x01(\x06R\x0bbroadcastIdBF\x82\
    \xb5\x18Bbroadcast\x20session\x20ID\x20to\x20proof\x20that\x20user\x20is\
    \x20allowed\x20to\x20see\x20details.\"\xfe\x03\n&CBroadcast_GetBroadcast\
    Status_Response\x12\x16\n\x06gameid\x18\x01\x20\x01(\x04R\x06gameid\x12\
    \x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x1f\n\x0bnum_viewers\
    \x18\x03\x20\x01(\rR\nnumViewers\x12\x1e\n\npermission\x18\x04\x20\x01(\
    \x05R\npermission\x12\x17\n\x07is_rtmp\x18\x05\x20\x01(\x08R\x06isRtmp\
    \x12#\n\rseconds_delay\x18\x06\x20\x01(\x05R\x0csecondsDelay\x12!\n\x0ci\
    s_publisher\x18\x07\x20\x01(\x08R\x0bisPublisher\x12#\n\rthumbnail_url\
    \x18\x08\x20\x01(\tR\x0cthumbnailUrl\x12'\n\x0fupdate_interval\x18\t\x20\
    \x01(\x05R\x0eupdateInterval\x12!\n\x0cis_uploading\x18\n\x20\x01(\x08R\
    \x0bisUploading\x12\x1a\n\x08duration\x18\x0b\x20\x01(\rR\x08duration\
    \x12\x1b\n\tis_replay\x18\x0c\x20\x01(\x08R\x08isReplay\x12(\n\x10is_cap\
    turing_vod\x18\r\x20\x01(\x08R\x0eisCapturingVod\x120\n\x14is_store_whit\
    elisted\x18\x0e\x20\x01(\x08R\x12isStoreWhitelisted\"g\n(CBroadcast_GetB\
    roadcastThumbnail_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07\
    steamid\x12!\n\x0cbroadcast_id\x18\x02\x20\x01(\x06R\x0bbroadcastId\"\
    \xb6\x01\n)CBroadcast_GetBroadcastThumbnail_Response\x12#\n\rthumbnail_u\
    rl\x18\x01\x20\x01(\tR\x0cthumbnailUrl\x12'\n\x0fupdate_interval\x18\x02\
    \x20\x01(\x05R\x0eupdateInterval\x12\x1f\n\x0bnum_viewers\x18\x03\x20\
    \x01(\x05R\nnumViewers\x12\x1a\n\x08duration\x18\x04\x20\x01(\x05R\x08du\
    ration\"m\n$CBroadcast_InviteToBroadcast_Request\x12\x18\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamid\x12+\n\x11approval_response\x18\x02\
    \x20\x01(\x08R\x10approvalResponse\"A\n%CBroadcast_InviteToBroadcast_Res\
    ponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"\xa7\x01\n-\
    CBroadcast_SendBroadcastStateToServer_Request\x12\x1e\n\npermission\x18\
    \x01\x20\x01(\x05R\npermission\x12\x16\n\x06gameid\x18\x02\x20\x01(\x04R\
    \x06gameid\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12(\n\x10gam\
    e_data_config\x18\x04\x20\x01(\tR\x0egameDataConfig\"0\n.CBroadcast_Send\
    BroadcastStateToServer_Response\"\\\n7CBroadcast_NotifyBroadcastSessionH\
    eartbeat_Notification\x12!\n\x0cbroadcast_id\x18\x01\x20\x01(\x06R\x0bbr\
    oadcastId\"\xa4\x01\n'CBroadcast_GetBroadcastChatInfo_Request\x12\x18\n\
    \x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12!\n\x0cbroadcast_id\x18\
    \x02\x20\x01(\x06R\x0bbroadcastId\x12\x1b\n\tclient_ip\x18\x03\x20\x01(\
    \rR\x08clientIp\x12\x1f\n\x0bclient_cell\x18\x04\x20\x01(\rR\nclientCell\
    \"\x97\x01\n(CBroadcast_GetBroadcastChatInfo_Response\x12\x17\n\x07chat_\
    id\x18\x01\x20\x01(\x06R\x06chatId\x12*\n\x11view_url_template\x18\x03\
    \x20\x01(\tR\x0fviewUrlTemplate\x12&\n\x0fflair_group_ids\x18\x04\x20\
    \x03(\rR\rflairGroupIds\"\x9e\x02\n\"CBroadcast_PostChatMessage_Request\
    \x12\x17\n\x07chat_id\x18\x01\x20\x01(\x06R\x06chatId\x12\x18\n\x07messa\
    ge\x18\x02\x20\x01(\tR\x07message\x12\x1f\n\x0binstance_id\x18\x03\x20\
    \x01(\rR\ninstanceId\x12`\n\x08language\x18\x04\x20\x01(\r:\x010R\x08lan\
    guageBA\x82\xb5\x18=ELanguage\x20of\x20the\x20user\x20posting\x20the\x20\
    message,\x20default\x20is\x20english\x12B\n\x0ccountry_code\x18\x05\x20\
    \x01(\tR\x0bcountryCodeB\x1f\x82\xb5\x18\x1bThe\x20two\x20letter\x20coun\
    try\x20code\"\xad\x01\n#CBroadcast_PostChatMessage_Response\x12!\n\x0cpe\
    rsona_name\x18\x01\x20\x01(\tR\x0bpersonaName\x12\x17\n\x07in_game\x18\
    \x02\x20\x01(\x08R\x06inGame\x12\x16\n\x06result\x18\x03\x20\x01(\x05R\
    \x06result\x122\n\x15cooldown_time_seconds\x18\x04\x20\x01(\x05R\x13cool\
    downTimeSeconds\"Z\n)CBroadcast_UpdateChatMessageFlair_Request\x12\x17\n\
    \x07chat_id\x18\x01\x20\x01(\x06R\x06chatId\x12\x14\n\x05flair\x18\x02\
    \x20\x01(\tR\x05flair\"s\n*CBroadcast_UpdateChatMessageFlair_Response\
    \x12\x16\n\x06result\x18\x01\x20\x01(\x05R\x06result\x12\x17\n\x07chat_i\
    d\x18\x02\x20\x01(\x06R\x06chatId\x12\x14\n\x05flair\x18\x03\x20\x01(\tR\
    \x05flair\"|\n(CBroadcast_MuteBroadcastChatUser_Request\x12\x17\n\x07cha\
    t_id\x18\x01\x20\x01(\x06R\x06chatId\x12!\n\x0cuser_steamid\x18\x02\x20\
    \x01(\x06R\x0buserSteamid\x12\x14\n\x05muted\x18\x03\x20\x01(\x08R\x05mu\
    ted\"+\n)CBroadcast_MuteBroadcastChatUser_Response\"c\n%CBroadcast_Remov\
    eUserChatText_Request\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x06R\x06chat\
    Id\x12!\n\x0cuser_steamid\x18\x02\x20\x01(\x06R\x0buserSteamid\"(\n&CBro\
    adcast_RemoveUserChatText_Response\"j\n,CBroadcast_GetBroadcastChatUserN\
    ames_Request\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x06R\x06chatId\x12!\n\
    \x0cuser_steamid\x18\x02\x20\x03(\x06R\x0buserSteamid\"\xd4\x01\n-CBroad\
    cast_GetBroadcastChatUserNames_Response\x12_\n\rpersona_names\x18\x01\
    \x20\x03(\x0b2:.CBroadcast_GetBroadcastChatUserNames_Response.PersonaNam\
    eR\x0cpersonaNames\x1aB\n\x0bPersonaName\x12\x19\n\x08steam_id\x18\x01\
    \x20\x01(\x06R\x07steamId\x12\x18\n\x07persona\x18\x02\x20\x01(\tR\x07pe\
    rsona\"\xe2\x01\n!CBroadcast_StartBuildClip_Request\x12\x18\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamid\x120\n\x14broadcast_session_id\x18\x02\
    \x20\x01(\x06R\x12broadcastSessionId\x12#\n\rfirst_segment\x18\x03\x20\
    \x01(\x05R\x0cfirstSegment\x12!\n\x0cnum_segments\x18\x04\x20\x01(\x05R\
    \x0bnumSegments\x12)\n\x10clip_description\x18\x05\x20\x01(\tR\x0fclipDe\
    scription\"P\n\"CBroadcast_StartBuildClip_Response\x12*\n\x11broadcast_c\
    lip_id\x18\x01\x20\x01(\x06R\x0fbroadcastClipId\"S\n%CBroadcast_GetBuild\
    ClipStatus_Request\x12*\n\x11broadcast_clip_id\x18\x01\x20\x01(\x06R\x0f\
    broadcastClipId\"(\n&CBroadcast_GetBuildClipStatus_Response\"\xf9\x01\n!\
    CBroadcast_SetClipDetails_Request\x127\n\x11broadcast_clip_id\x18\x01\
    \x20\x01(\x04R\x0fbroadcastClipIdB\x0b\x82\xb5\x18\x07Clip\x20ID\x129\n\
    \nstart_time\x18\x02\x20\x01(\rR\tstartTimeB\x1a\x82\xb5\x18\x16start\
    \x20time\x20of\x20the\x20clip\x123\n\x08end_time\x18\x03\x20\x01(\rR\x07\
    endTimeB\x18\x82\xb5\x18\x14end\x20time\x20of\x20the\x20clip\x12+\n\x11v\
    ideo_description\x18\x04\x20\x01(\tR\x10videoDescription\"$\n\"CBroadcas\
    t_SetClipDetails_Response\"y\n!CBroadcast_GetClipDetails_Request\x12T\n\
    \x11broadcast_clip_id\x18\x01\x20\x01(\x04R\x0fbroadcastClipIdB(\x82\xb5\
    \x18$List\x20of\x20clip\x20IDs\x20we\x20want\x20details\x20for\"\xe5\x05\
    \n\"CBroadcast_GetClipDetails_Response\x12A\n\x11broadcast_clip_id\x18\
    \x01\x20\x01(\x04R\x0fbroadcastClipIdB\x15\x82\xb5\x18\x11broadcast\x20c\
    lip\x20ID\x127\n\x08video_id\x18\x02\x20\x01(\x04R\x07videoIdB\x1c\x82\
    \xb5\x18\x18matching\x20unique\x20video\x20ID\x127\n\nchannel_id\x18\x03\
    \x20\x01(\x04R\tchannelIdB\x18\x82\xb5\x18\x14Broadcast\x20Channel\x20ID\
    \x127\n\x06app_id\x18\x04\x20\x01(\rR\x05appIdB\x20\x82\xb5\x18\x1cApp\
    \x20ID\x20stream\x20is\x20tagged\x20with\x12R\n\x15accountid_broadcaster\
    \x18\x05\x20\x01(\rR\x14accountidBroadcasterB\x1d\x82\xb5\x18\x19Account\
    \x20ID\x20of\x20broadcaster\x12M\n\x13accountid_clipmaker\x18\x06\x20\
    \x01(\rR\x12accountidClipmakerB\x1c\x82\xb5\x18\x18Account\x20ID\x20of\
    \x20clip-maker\x12W\n\x11video_description\x18\x07\x20\x01(\tR\x10videoD\
    escriptionB*\x82\xb5\x18&Short\x20name\x20or\x20description\x20of\x20thi\
    s\x20clip\x12F\n\nstart_time\x18\x08\x20\x01(\rR\tstartTimeB'\x82\xb5\
    \x18#Wall\x20time\x20clip\x20was\x20broadcasted\x20live\x12J\n\x13length\
    _milliseconds\x18\t\x20\x01(\rR\x12lengthMillisecondsB\x19\x82\xb5\x18\
    \x15length\x20of\x20video\x20in\x20MS\x12A\n\x0ethumbnail_path\x18\n\x20\
    \x01(\tR\rthumbnailPathB\x1a\x82\xb5\x18\x16Path\x20for\x20thumbnail\x20\
    URL\"\xdb\x05\n\x1eCBroadcast_SetRTMPInfo_Request\x121\n\x14broadcast_pe\
    rmission\x18\x01\x20\x01(\x05R\x13broadcastPermission\x12!\n\x0cupdate_t\
    oken\x18\x02\x20\x01(\x08R\x0bupdateToken\x12'\n\x0fbroadcast_delay\x18\
    \x03\x20\x01(\x05R\x0ebroadcastDelay\x12\x15\n\x06app_id\x18\x04\x20\x01\
    (\rR\x05appId\x12&\n\x0frequired_app_id\x18\x05\x20\x01(\rR\rrequiredApp\
    Id\x12\xb5\x01\n\x19broadcast_chat_permission\x18\x06\x20\x01(\x0e2\x19.\
    EBroadcastChatPermission:\x20k_EBroadcastChatPermissionPublicR\x17broadc\
    astChatPermissionB<\x82\xb5\x188Who\x20is\x20permitted\x20to\x20send\x20\
    a\x20chat\x20message\x20during\x20broadcast\x12_\n\x10broadcast_buffer\
    \x18\x07\x20\x01(\x05R\x0fbroadcastBufferB4\x82\xb5\x180Previous\x20seco\
    nds\x20we\x20keep\x20of\x20the\x20stream\x20available\x12G\n\x07steamid\
    \x18\x08\x20\x01(\x06R\x07steamidB-\x82\xb5\x18)broadcaster\x20steamID\
    \x20if\x20not\x20logged-in\x20user\x12R\n\x0fchat_rate_limit\x18\t\x20\
    \x01(\rR\rchatRateLimitB*\x82\xb5\x18&Seconds\x20required\x20between\x20\
    chat\x20messages\x12E\n\renable_replay\x18\n\x20\x01(\x08R\x0cenableRepl\
    ayB\x20\x82\xb5\x18\x1cEnable\x20replay\x20of\x20last\x20upload\"!\n\x1f\
    CBroadcast_SetRTMPInfo_Response\"y\n\x1eCBroadcast_GetRTMPInfo_Request\
    \x12\x0e\n\x02ip\x18\x01\x20\x01(\rR\x02ip\x12G\n\x07steamid\x18\x02\x20\
    \x01(\x06R\x07steamidB-\x82\xb5\x18)broadcaster\x20steamID\x20if\x20not\
    \x20logged-in\x20user\"\xd0\x05\n\x1fCBroadcast_GetRTMPInfo_Response\x12\
    1\n\x14broadcast_permission\x18\x01\x20\x01(\x05R\x13broadcastPermission\
    \x12\x1b\n\trtmp_host\x18\x02\x20\x01(\tR\x08rtmpHost\x12\x1d\n\nrtmp_to\
    ken\x18\x03\x20\x01(\tR\trtmpToken\x12'\n\x0fbroadcast_delay\x18\x04\x20\
    \x01(\x05R\x0ebroadcastDelay\x12\x15\n\x06app_id\x18\x05\x20\x01(\rR\x05\
    appId\x12&\n\x0frequired_app_id\x18\x06\x20\x01(\rR\rrequiredAppId\x12\
    \xb5\x01\n\x19broadcast_chat_permission\x18\x07\x20\x01(\x0e2\x19.EBroad\
    castChatPermission:\x20k_EBroadcastChatPermissionPublicR\x17broadcastCha\
    tPermissionB<\x82\xb5\x188Who\x20is\x20permitted\x20to\x20send\x20a\x20c\
    hat\x20message\x20during\x20broadcast\x12P\n\x10broadcast_buffer\x18\x08\
    \x20\x01(\x05R\x0fbroadcastBufferB%\x82\xb5\x18!Seconds\x20we\x20keep\
    \x20streams\x20available\x121\n\x07steamid\x18\t\x20\x01(\x06R\x07steami\
    dB\x17\x82\xb5\x18\x13broadcaster\x20steamID\x12R\n\x0fchat_rate_limit\
    \x18\n\x20\x01(\rR\rchatRateLimitB*\x82\xb5\x18&Seconds\x20required\x20b\
    etween\x20chat\x20messages\x12E\n\renable_replay\x18\x0b\x20\x01(\x08R\
    \x0cenableReplayB\x20\x82\xb5\x18\x1cEnable\x20replay\x20of\x20last\x20u\
    pload\"\x81\x01\n,CBroadcast_WebRTCHaveTURNServer_Notification\x120\n\
    \x14broadcast_session_id\x18\x01\x20\x01(\x06R\x12broadcastSessionId\x12\
    \x1f\n\x0bturn_server\x18\x02\x20\x01(\tR\nturnServer\"\xda\x01\n$CBroad\
    cast_WebRTCStartResult_Request\x12*\n\x11webrtc_session_id\x18\x01\x20\
    \x01(\x06R\x0fwebrtcSessionId\x12\x18\n\x07started\x18\x02\x20\x01(\x08R\
    \x07started\x12\x14\n\x05offer\x18\x03\x20\x01(\tR\x05offer\x12!\n\x0cre\
    solution_x\x18\x04\x20\x01(\rR\x0bresolutionX\x12!\n\x0cresolution_y\x18\
    \x05\x20\x01(\rR\x0bresolutionY\x12\x10\n\x03fps\x18\x06\x20\x01(\rR\x03\
    fps\"'\n%CBroadcast_WebRTCStartResult_Response\"N\n\x20CBroadcast_WebRTC\
    Stopped_Request\x12*\n\x11webrtc_session_id\x18\x01\x20\x01(\x06R\x0fweb\
    rtcSessionId\"#\n!CBroadcast_WebRTCStopped_Response\"\x99\x01\n\"CBroadc\
    ast_WebRTCSetAnswer_Request\x12/\n\x13broadcaster_steamid\x18\x01\x20\
    \x01(\x06R\x12broadcasterSteamid\x12*\n\x11webrtc_session_id\x18\x02\x20\
    \x01(\x06R\x0fwebrtcSessionId\x12\x16\n\x06answer\x18\x03\x20\x01(\tR\
    \x06answer\"%\n#CBroadcast_WebRTCSetAnswer_Response\"C\n)CBroadcast_WebR\
    TCLookupTURNServer_Request\x12\x16\n\x06cellid\x18\x01\x20\x01(\rR\x06ce\
    llid\"M\n*CBroadcast_WebRTCLookupTURNServer_Response\x12\x1f\n\x0bturn_s\
    erver\x18\x01\x20\x01(\tR\nturnServer\"|\n\x1bCBroadcast_WebRTC_Candidat\
    e\x12\x17\n\x07sdp_mid\x18\x01\x20\x01(\tR\x06sdpMid\x12&\n\x0fsdp_mline\
    _index\x18\x02\x20\x01(\x05R\rsdpMlineIndex\x12\x1c\n\tcandidate\x18\x03\
    \x20\x01(\tR\tcandidate\"\x93\x01\n)CBroadcast_WebRTCAddHostCandidate_Re\
    quest\x12*\n\x11webrtc_session_id\x18\x01\x20\x01(\x06R\x0fwebrtcSession\
    Id\x12:\n\tcandidate\x18\x02\x20\x01(\x0b2\x1c.CBroadcast_WebRTC_Candida\
    teR\tcandidate\",\n*CBroadcast_WebRTCAddHostCandidate_Response\"\xc6\x01\
    \n+CBroadcast_WebRTCAddViewerCandidate_Request\x12/\n\x13broadcaster_ste\
    amid\x18\x01\x20\x01(\x06R\x12broadcasterSteamid\x12*\n\x11webrtc_sessio\
    n_id\x18\x02\x20\x01(\x06R\x0fwebrtcSessionId\x12:\n\tcandidate\x18\x03\
    \x20\x01(\x0b2\x1c.CBroadcast_WebRTC_CandidateR\tcandidate\".\n,CBroadca\
    st_WebRTCAddViewerCandidate_Response\"\xbc\x01\n*CBroadcast_WebRTCGetHos\
    tCandidates_Request\x12/\n\x13broadcaster_steamid\x18\x01\x20\x01(\x06R\
    \x12broadcasterSteamid\x12*\n\x11webrtc_session_id\x18\x02\x20\x01(\x06R\
    \x0fwebrtcSessionId\x121\n\x14candidate_generation\x18\x03\x20\x01(\rR\
    \x13candidateGeneration\"\x9e\x01\n+CBroadcast_WebRTCGetHostCandidates_R\
    esponse\x121\n\x14candidate_generation\x18\x01\x20\x01(\rR\x13candidateG\
    eneration\x12<\n\ncandidates\x18\x02\x20\x03(\x0b2\x1c.CBroadcast_WebRTC\
    _CandidateR\ncandidates\"\xd7\x03\n*CBroadcast_GetBroadcastUploadStats_R\
    equest\x12D\n\trow_limit\x18\x01\x20\x01(\r:\x03100R\x08rowLimitB\"\x82\
    \xb5\x18\x1eHow\x20many\x20at\x20maximum\x20to\x20return.\x120\n\nstart_\
    time\x18\x02\x20\x01(\r:\x010R\tstartTimeB\x0e\x82\xb5\x18\nStart\x20tim\
    e\x12Z\n\tupload_id\x18\x03\x20\x01(\x04R\x08uploadIdB=\x82\xb5\x189Opti\
    onal\x20relay\x20upload\x20ID\x20-\x20not\x20compatible\x20with\x20sessi\
    on_id\x12r\n\x07steamid\x18\x04\x20\x01(\x06R\x07steamidBX\x82\xb5\x18TO\
    ptional\x20the\x20steamid\x20whose\x20stats\x20you\x20want,\x20otherwise\
    \x20the\x20user\x20logged\x20in\x20-\x20admin\x20only\x12a\n\nsession_id\
    \x18\x05\x20\x01(\x04R\tsessionIdBB\x82\xb5\x18>Optional\x20broadcast\
    \x20session\x20ID\x20-\x20not\x20compatiable\x20with\x20upload_id\"\xa9\
    \x0b\n+CBroadcast_GetBroadcastUploadStats_Response\x12[\n\x0cupload_stat\
    s\x18\x01\x20\x03(\x0b28.CBroadcast_GetBroadcastUploadStats_Response.Upl\
    oadStatsR\x0buploadStats\x1a\x9c\n\n\x0bUploadStats\x12)\n\rupload_resul\
    t\x18\x01\x20\x01(\rR\x0cuploadResultB\x04\x82\xb5\x18\0\x12D\n\x0ctime_\
    stopped\x18\x02\x20\x01(\rR\x0btimeStoppedB!\x82\xb5\x18\x1dtime\x20broa\
    dcast\x20upload\x20stopped\x12G\n\x10seconds_uploaded\x18\x03\x20\x01(\r\
    R\x0fsecondsUploadedB\x1c\x82\xb5\x18\x18seconds\x20of\x20vido\x20upload\
    ed\x12;\n\x0bmax_viewers\x18\x04\x20\x01(\rR\nmaxViewersB\x1a\x82\xb5\
    \x18\x16max\x20concurrent\x20viewers\x12;\n\x0cresolution_x\x18\x05\x20\
    \x01(\rR\x0bresolutionXB\x18\x82\xb5\x18\x14horizontal\x20resultion\x129\
    \n\x0cresolution_y\x18\x06\x20\x01(\rR\x0bresolutionYB\x16\x82\xb5\x18\
    \x12vertical\x20resultion\x12)\n\ravg_bandwidth\x18\x07\x20\x01(\rR\x0ca\
    vgBandwidthB\x04\x82\xb5\x18\0\x12G\n\x0btotal_bytes\x18\x08\x20\x01(\
    \x04R\ntotalBytesB&\x82\xb5\x18\"total\x20byte\x20uploaded\x20by\x20broa\
    dcaster\x12+\n\x06app_id\x18\t\x20\x01(\rR\x05appIdB\x14\x82\xb5\x18\x10\
    game\x20broadcasted\x12O\n\x14total_unique_viewers\x18\n\x20\x01(\rR\x12\
    totalUniqueViewersB\x1d\x82\xb5\x18\x19total\x20unique\x20viewers\x20see\
    n\x12f\n\x15total_seconds_watched\x18\x0b\x20\x01(\x04R\x13totalSecondsW\
    atchedB2\x82\xb5\x18.total\x20number\x20of\x20seconds\x20watched\x20by\
    \x20all\x20viewers\x12D\n\x0ctime_started\x18\x0c\x20\x01(\rR\x0btimeSta\
    rtedB!\x82\xb5\x18\x1dtime\x20broadcast\x20upload\x20started\x12:\n\tupl\
    oad_id\x18\r\x20\x01(\x04R\x08uploadIdB\x1d\x82\xb5\x18\x19broadcast\x20\
    relay\x20upload\x20id\x12A\n\rlocal_address\x18\x0e\x20\x01(\tR\x0clocal\
    AddressB\x1c\x82\xb5\x18\x18upload\x20to\x20server\x20address\x12E\n\x0e\
    remote_address\x18\x0f\x20\x01(\tR\rremoteAddressB\x1e\x82\xb5\x18\x1aup\
    load\x20from\x20client\x20address\x12A\n\x11frames_per_second\x18\x10\
    \x20\x01(\rR\x0fframesPerSecondB\x15\x82\xb5\x18\x11frames\x20per\x20sec\
    ond\x12S\n\x13num_representations\x18\x11\x20\x01(\rR\x12numRepresentati\
    onsB\"\x82\xb5\x18\x1enumber\x20of\x20video\x20represetations\x12(\n\x08\
    app_name\x18\x12\x20\x01(\tR\x07appNameB\r\x82\xb5\x18\tgame\x20name\x12\
    =\n\tis_replay\x18\x13\x20\x01(\x08R\x08isReplayB\x20\x82\xb5\x18\x1crep\
    lay\x20of\x20previous\x20recording\x127\n\nsession_id\x18\x14\x20\x01(\
    \x04R\tsessionIdB\x18\x82\xb5\x18\x14broadcast\x20session\x20id\"\xd0\
    \x01\n*CBroadcast_GetBroadcastViewerStats_Request\x12:\n\tupload_id\x18\
    \x01\x20\x01(\x04R\x08uploadIdB\x1d\x82\xb5\x18\x19Get\x20stats\x20for\
    \x20this\x20stream\x12f\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamidBL\
    \x82\xb5\x18HOptional:\x20The\x20steamid\x20of\x20the\x20broadcast\x20wh\
    ose\x20details\x20you\x20are\x20requesting.\"\xde\x03\n+CBroadcast_GetBr\
    oadcastViewerStats_Response\x12[\n\x0cviewer_stats\x18\x01\x20\x03(\x0b2\
    8.CBroadcast_GetBroadcastViewerStats_Response.ViewerStatsR\x0bviewerStat\
    s\x12^\n\rcountry_stats\x18\x02\x20\x03(\x0b29.CBroadcast_GetBroadcastVi\
    ewerStats_Response.CountryStatsR\x0ccountryStats\x1au\n\x0bViewerStats\
    \x12&\n\x04time\x18\x01\x20\x01(\rR\x04timeB\x12\x82\xb5\x18\x0etime\x20\
    of\x20record\x12>\n\x0bnum_viewers\x18\x02\x20\x01(\rR\nnumViewersB\x1d\
    \x82\xb5\x18\x19current\x20number\x20of\x20viewers\x1a{\n\x0cCountryStat\
    s\x123\n\x0ccountry_code\x18\x01\x20\x01(\tR\x0bcountryCodeB\x10\x82\xb5\
    \x18\x0ccountry\x20code\x126\n\x0bnum_viewers\x18\x02\x20\x01(\rR\nnumVi\
    ewersB\x15\x82\xb5\x18\x11number\x20of\x20viewers\"\x88\x02\n,CBroadcast\
    _BroadcastViewerState_Notification\x12\x18\n\x07steamid\x18\x01\x20\x01(\
    \x06R\x07steamid\x12h\n\x05state\x18\x02\x20\x01(\x0e2:.CBroadcast_Broad\
    castViewerState_Notification.EViewerState:\x16k_EViewerNeedsApprovalR\
    \x05state\"T\n\x0cEViewerState\x12\x1a\n\x16k_EViewerNeedsApproval\x10\
    \x01\x12\x15\n\x11k_EViewerWatching\x10\x02\x12\x11\n\rk_EViewerLeft\x10\
    \x03\"S\n.CBroadcast_WaitingBroadcastViewer_Notification\x12!\n\x0cbroad\
    cast_id\x18\x01\x20\x01(\x06R\x0bbroadcastId\"\xf8\x02\n.CBroadcast_Broa\
    dcastUploadStarted_Notification\x12!\n\x0cbroadcast_id\x18\x01\x20\x01(\
    \x06R\x0bbroadcastId\x12!\n\x0cupload_token\x18\x02\x20\x01(\tR\x0buploa\
    dToken\x12%\n\x0eupload_address\x18\x03\x20\x01(\tR\ruploadAddress\x12!\
    \n\x0chttp_address\x18\x04\x20\x01(\tR\x0bhttpAddress\x12.\n\x13broadcas\
    t_upload_id\x18\x05\x20\x01(\x06R\x11broadcastUploadId\x12m\n\x1aheartbe\
    at_interval_seconds\x18\x06\x20\x01(\rR\x18heartbeatIntervalSecondsB/\
    \x82\xb5\x18+how\x20many\x20seconds\x20between\x20session\x20heartbeats\
    \x12\x17\n\x07is_rtmp\x18\x07\x20\x01(\x08R\x06isRtmp\"\xd6\x01\n+CBroad\
    cast_StopBroadcastUpload_Notification\x12!\n\x0cbroadcast_id\x18\x01\x20\
    \x01(\x06R\x0bbroadcastId\x12,\n\x12broadcast_relay_id\x18\x02\x20\x01(\
    \x06R\x10broadcastRelayId\x12#\n\rupload_result\x18\x03\x20\x01(\rR\x0cu\
    ploadResult\x121\n\x15too_many_poor_uploads\x18\x04\x20\x01(\x08R\x12too\
    ManyPoorUploads\"J\n%CBroadcast_SessionClosed_Notification\x12!\n\x0cbro\
    adcast_id\x18\x01\x20\x01(\x06R\x0bbroadcastId\"`\n-CBroadcast_ViewerBro\
    adcastInvite_Notification\x12/\n\x13broadcaster_steamid\x18\x01\x20\x01(\
    \x06R\x12broadcasterSteamid\"m\n'CBroadcast_BroadcastStatus_Notification\
    \x12!\n\x0cbroadcast_id\x18\x01\x20\x01(\x06R\x0bbroadcastId\x12\x1f\n\
    \x0bnum_viewers\x18\x02\x20\x01(\x05R\nnumViewers\"\xd0\x01\n,CBroadcast\
    _BroadcastChannelLive_Notification\x120\n\x14broadcast_channel_id\x18\
    \x01\x20\x01(\x06R\x12broadcastChannelId\x124\n\x16broadcast_channel_nam\
    e\x18\x02\x20\x01(\tR\x14broadcastChannelName\x128\n\x18broadcast_channe\
    l_avatar\x18\x03\x20\x01(\tR\x16broadcastChannelAvatar\"\xa4\x02\n,CBroa\
    dcast_SendThumbnailToRelay_Notification\x124\n\x16thumbnail_upload_token\
    \x18\x01\x20\x01(\tR\x14thumbnailUploadToken\x12C\n\x1ethumbnail_broadca\
    st_session_id\x18\x02\x20\x01(\x06R\x1bthumbnailBroadcastSessionId\x12%\
    \n\x0ethumbnail_data\x18\x03\x20\x01(\x0cR\rthumbnailData\x12'\n\x0fthum\
    bnail_width\x18\x04\x20\x01(\rR\x0ethumbnailWidth\x12)\n\x10thumbnail_he\
    ight\x18\x05\x20\x01(\rR\x0fthumbnailHeight\"`\n,CBroadcast_WebRTCNeedTU\
    RNServer_Notification\x120\n\x14broadcast_session_id\x18\x01\x20\x01(\
    \x06R\x12broadcastSessionId\"\xcd\x01\n#CBroadcast_WebRTCStart_Notificat\
    ion\x120\n\x14broadcast_session_id\x18\x01\x20\x01(\x06R\x12broadcastSes\
    sionId\x12*\n\x11webrtc_session_id\x18\x02\x20\x01(\x06R\x0fwebrtcSessio\
    nId\x12%\n\x0eviewer_steamid\x18\x03\x20\x01(\x06R\rviewerSteamid\x12!\n\
    \x0cviewer_token\x18\x04\x20\x01(\x06R\x0bviewerToken\"\x9f\x01\n'CBroad\
    cast_WebRTCSetAnswer_Notification\x120\n\x14broadcast_session_id\x18\x01\
    \x20\x01(\x06R\x12broadcastSessionId\x12*\n\x11webrtc_session_id\x18\x02\
    \x20\x01(\x06R\x0fwebrtcSessionId\x12\x16\n\x06answer\x18\x03\x20\x01(\t\
    R\x06answer\"\xcc\x01\n0CBroadcast_WebRTCAddViewerCandidate_Notification\
    \x120\n\x14broadcast_session_id\x18\x01\x20\x01(\x06R\x12broadcastSessio\
    nId\x12*\n\x11webrtc_session_id\x18\x02\x20\x01(\x06R\x0fwebrtcSessionId\
    \x12:\n\tcandidate\x18\x03\x20\x01(\x0b2\x1c.CBroadcast_WebRTC_Candidate\
    R\tcandidate*\xf5\x04\n\x17EBroadcastWatchLocation\x12%\n!k_EBroadcastWa\
    tchLocation_Invalid\x10\0\x12)\n%k_EBroadcastWatchLocation_SteamTV_Tab\
    \x10\x01\x120\n,k_EBroadcastWatchLocation_SteamTV_WatchParty\x10\x02\x12\
    &\n\"k_EBroadcastWatchLocation_Chat_Tab\x10\x03\x12-\n)k_EBroadcastWatch\
    Location_Chat_WatchParty\x10\x04\x12+\n'k_EBroadcastWatchLocation_Commun\
    ityPage\x10\x05\x12*\n&k_EBroadcastWatchLocation_StoreAppPage\x10\x06\
    \x12$\n\x20k_EBroadcastWatchLocation_InGame\x10\x07\x12(\n$k_EBroadcastW\
    atchLocation_BigPicture\x10\x08\x12'\n#k_EBroadcastWatchLocation_SalesPa\
    ge\x10\t\x12)\n%k_EBroadcastWatchLocation_CuratorPage\x10\n\x12+\n'k_EBr\
    oadcastWatchLocation_DeveloperPage\x10\x0b\x12*\n&k_EBroadcastWatchLocat\
    ion_Chat_Friends\x10\x0c\x12)\n%k_EBroadcastWatchLocation_SteamTV_Web\
    \x10\r*g\n\x18EBroadcastChatPermission\x12$\n\x20k_EBroadcastChatPermiss\
    ionPublic\x10\0\x12%\n!k_EBroadcastChatPermissionOwnsApp\x10\x012\x86+\n\
    \tBroadcast\x12\xed\x01\n\x15BeginBroadcastSession\x12).CBroadcast_Begin\
    BroadcastSession_Request\x1a*.CBroadcast_BeginBroadcastSession_Response\
    \"}\x82\xb5\x18yRequest\x20from\x20client\x20to\x20directory\x20to\x20be\
    gin\x20a\x20broadcast\x20session.\x20No\x20data\x20being\x20sent\x20to\
    \x20relay;\x20just\x20available\x20for\x20broadcast.\x12\xba\x01\n\x13En\
    dBroadcastSession\x12'.CBroadcast_EndBroadcastSession_Request\x1a(.CBroa\
    dcast_EndBroadcastSession_Response\"P\x82\xb5\x18LRequest\x20from\x20cli\
    ent\x20to\x20stop\x20a\x20broadcast\x20session.\x20Any\x20uploads\x20wil\
    l\x20terminate.\x12\xac\x01\n\x14StartBroadcastUpload\x12(.CBroadcast_St\
    artBroadcastUpload_Request\x1a).CBroadcast_StartBroadcastUpload_Response\
    \"?\x82\xb5\x18;Request\x20from\x20client\x20to\x20begin\x20sending\x20v\
    ideo\x20for\x20a\x20broadcast.\x12\x99\x01\n\x19NotifyBroadcastUploadSto\
    p\x122.CBroadcast_NotifyBroadcastUploadStop_Notification\x1a\x0b.NoRespo\
    nse\";\x82\xb5\x187Tells\x20directory\x20that\x20client\x20stopped\x20up\
    loading\x20broadcast\x12\x87\x01\n\x0eWatchBroadcast\x12\".CBroadcast_Wa\
    tchBroadcast_Request\x1a#.CBroadcast_WatchBroadcast_Response\",\x82\xb5\
    \x18(Request\x20from\x20viewer\x20to\x20watch\x20a\x20broadcast\x12\x81\
    \x01\n\x12HeartbeatBroadcast\x12+.CBroadcast_HeartbeatBroadcast_Notifica\
    tion\x1a\x0b.NoResponse\"1\x82\xb5\x18-Notify\x20directory\x20that\x20us\
    er\x20is\x20still\x20watching.\x12\xc1\x01\n\x15StopWatchingBroadcast\
    \x12..CBroadcast_StopWatchingBroadcast_Notification\x1a\x0b.NoResponse\"\
    k\x82\xb5\x18gRequest\x20to\x20immediately\x20stop\x20watching\x20a\x20b\
    roadcast.\x20Optional\x20Method,\x20if\x20not\x20called,\x20viewer\x20wi\
    ll\x20time\x20out.\x12\x96\x01\n\x12GetBroadcastStatus\x12&.CBroadcast_G\
    etBroadcastStatus_Request\x1a'.CBroadcast_GetBroadcastStatus_Response\"/\
    \x82\xb5\x18+Request\x20from\x20viewer\x20about\x20broadcast\x20details\
    \x12\x97\x01\n\x15GetBroadcastThumbnail\x12).CBroadcast_GetBroadcastThum\
    bnail_Request\x1a*.CBroadcast_GetBroadcastThumbnail_Response\"'\x82\xb5\
    \x18#Request\x20thumbnail\x20URL\x20for\x20broadcast\x12\xa2\x01\n\x11In\
    viteToBroadcast\x12%.CBroadcast_InviteToBroadcast_Request\x1a&.CBroadcas\
    t_InviteToBroadcast_Response\">\x82\xb5\x18:Invites\x20another\x20steam\
    \x20user\x20to\x20watch\x20the\x20caller's\x20broadcast\x12\xc8\x01\n\
    \x1aSendBroadcastStateToServer\x12..CBroadcast_SendBroadcastStateToServe\
    r_Request\x1a/.CBroadcast_SendBroadcastStateToServer_Response\"I\x82\xb5\
    \x18ESends\x20users\x20current\x20broadcast\x20state\x20(permissions,\
    \x20game)\x20to\x20the\x20server\x12\xa2\x01\n\x1fNotifyBroadcastSession\
    Heartbeat\x128.CBroadcast_NotifyBroadcastSessionHeartbeat_Notification\
    \x1a\x0b.NoResponse\"8\x82\xb5\x184Tells\x20directory\x20broadcast\x20se\
    ssion\x20is\x20still\x20available\x12\x94\x01\n\x14GetBroadcastChatInfo\
    \x12(.CBroadcast_GetBroadcastChatInfo_Request\x1a).CBroadcast_GetBroadca\
    stChatInfo_Response\"'\x82\xb5\x18#Gets\x20chat\x20room\x20info\x20for\
    \x20a\x20broadcast\x12\x8a\x01\n\x0fPostChatMessage\x12#.CBroadcast_Post\
    ChatMessage_Request\x1a$.CBroadcast_PostChatMessage_Response\",\x82\xb5\
    \x18(Post\x20chat\x20message\x20to\x20specified\x20chat\x20room\x12\xab\
    \x01\n\x16UpdateChatMessageFlair\x12*.CBroadcast_UpdateChatMessageFlair_\
    Request\x1a+.CBroadcast_UpdateChatMessageFlair_Response\"8\x82\xb5\x184U\
    pdate\x20chat\x20message\x20flair\x20in\x20the\x20specified\x20chat\x20r\
    oom\x12\x96\x01\n\x15MuteBroadcastChatUser\x12).CBroadcast_MuteBroadcast\
    ChatUser_Request\x1a*.CBroadcast_MuteBroadcastChatUser_Response\"&\x82\
    \xb5\x18\"Mute\x20a\x20user\x20in\x20your\x20broadcast\x20chat\x12\x94\
    \x01\n\x12RemoveUserChatText\x12&.CBroadcast_RemoveUserChatText_Request\
    \x1a'.CBroadcast_RemoveUserChatText_Response\"-\x82\xb5\x18)Tell\x20all\
    \x20viewers\x20to\x20remove\x20user\x20chat\x20text\x12\xa3\x01\n\x19Get\
    BroadcastChatUserNames\x12-.CBroadcast_GetBroadcastChatUserNames_Request\
    \x1a..CBroadcast_GetBroadcastChatUserNames_Response\"'\x82\xb5\x18#Get\
    \x20names\x20for\x20list\x20of\x20users\x20in\x20chat\x12~\n\x0eStartBui\
    ldClip\x12\".CBroadcast_StartBuildClip_Request\x1a#.CBroadcast_StartBuil\
    dClip_Response\"#\x82\xb5\x18\x1fStart\x20building\x20a\x20broadcast\x20\
    clip\x12\x8a\x01\n\x12GetBuildClipStatus\x12&.CBroadcast_GetBuildClipSta\
    tus_Request\x1a'.CBroadcast_GetBuildClipStatus_Response\"#\x82\xb5\x18\
    \x1fStart\x20building\x20a\x20broadcast\x20clip\x12w\n\x0eSetClipDetails\
    \x12\".CBroadcast_SetClipDetails_Request\x1a#.CBroadcast_SetClipDetails_\
    Response\"\x1c\x82\xb5\x18\x18Updates\x20a\x20broadcast\x20clip\x12~\n\
    \x0eGetClipDetails\x12\".CBroadcast_GetClipDetails_Request\x1a#.CBroadca\
    st_GetClipDetails_Response\"#\x82\xb5\x18\x1fGet\x20details\x20for\x20Br\
    oadcast\x20Clips\x12n\n\x0bSetRTMPInfo\x12\x1f.CBroadcast_SetRTMPInfo_Re\
    quest\x1a\x20.CBroadcast_SetRTMPInfo_Response\"\x1c\x82\xb5\x18\x18Sets\
    \x20RTMP\x20broadcast\x20info\x12n\n\x0bGetRTMPInfo\x12\x1f.CBroadcast_G\
    etRTMPInfo_Request\x1a\x20.CBroadcast_GetRTMPInfo_Response\"\x1c\x82\xb5\
    \x18\x18Gets\x20RTMP\x20broadcast\x20info\x12\x9e\x01\n\x1aNotifyWebRTCH\
    aveTURNServer\x12-.CBroadcast_WebRTCHaveTURNServer_Notification\x1a\x0b.\
    NoResponse\"D\x82\xb5\x18@Notification\x20from\x20client\x20to\x20server\
    \x20with\x20the\x20client's\x20TURN\x20server\x12\xac\x01\n\x11WebRTCSta\
    rtResult\x12%.CBroadcast_WebRTCStartResult_Request\x1a&.CBroadcast_WebRT\
    CStartResult_Response\"H\x82\xb5\x18DNotify\x20the\x20server\x20that\x20\
    a\x20WebRTC\x20session\x20has\x20been\x20created\x20by\x20the\x20host\
    \x12\xa0\x01\n\rWebRTCStopped\x12!.CBroadcast_WebRTCStopped_Request\x1a\
    \".CBroadcast_WebRTCStopped_Response\"H\x82\xb5\x18DNotify\x20the\x20ser\
    ver\x20that\x20a\x20WebRTC\x20session\x20has\x20been\x20stopped\x20by\
    \x20the\x20host\x12\xa8\x01\n\x0fWebRTCSetAnswer\x12#.CBroadcast_WebRTCS\
    etAnswer_Request\x1a$.CBroadcast_WebRTCSetAnswer_Response\"J\x82\xb5\x18\
    FNotify\x20the\x20server\x20that\x20a\x20WebRTC\x20session\x20has\x20bee\
    n\x20created\x20by\x20the\x20viewer\x12\xa2\x01\n\x16WebRTCLookupTURNSer\
    ver\x12*.CBroadcast_WebRTCLookupTURNServer_Request\x1a+.CBroadcast_WebRT\
    CLookupTURNServer_Response\"/\x82\xb5\x18+Lookup\x20the\x20best\x20TURN\
    \x20server\x20for\x20this\x20client\x12\xb1\x01\n\x16WebRTCAddHostCandid\
    ate\x12*.CBroadcast_WebRTCAddHostCandidate_Request\x1a+.CBroadcast_WebRT\
    CAddHostCandidate_Response\">\x82\xb5\x18:Add\x20an\x20ICE\x20candidate\
    \x20for\x20the\x20host\x20side\x20of\x20a\x20WebRTC\x20session\x12\xb9\
    \x01\n\x18WebRTCAddViewerCandidate\x12,.CBroadcast_WebRTCAddViewerCandid\
    ate_Request\x1a-.CBroadcast_WebRTCAddViewerCandidate_Response\"@\x82\xb5\
    \x18<Add\x20an\x20ICE\x20candidate\x20for\x20the\x20viewer\x20side\x20of\
    \x20a\x20WebRTC\x20session\x12\xb6\x01\n\x17WebRTCGetHostCandidates\x12+\
    .CBroadcast_WebRTCGetHostCandidates_Request\x1a,.CBroadcast_WebRTCGetHos\
    tCandidates_Response\"@\x82\xb5\x18<Get\x20the\x20ICE\x20candidates\x20f\
    or\x20the\x20host\x20side\x20of\x20a\x20WebRTC\x20session\x12\x9e\x01\n\
    \x17GetBroadcastUploadStats\x12+.CBroadcast_GetBroadcastUploadStats_Requ\
    est\x1a,.CBroadcast_GetBroadcastUploadStats_Response\"(\x82\xb5\x18$Gets\
    \x20broadcast\x20upload\x20stats\x20for\x20user\x12\x9f\x01\n\x17GetBroa\
    dcastViewerStats\x12+.CBroadcast_GetBroadcastViewerStats_Request\x1a,.CB\
    roadcast_GetBroadcastViewerStats_Response\")\x82\xb5\x18%Gets\x20viewer\
    \x20stats\x20for\x20given\x20broadcast\x1a*\x82\xb5\x18&Methods\x20for\
    \x20Steam\x20broadcast\x20operations2\xc4\x11\n\x0fBroadcastClient\x12\
    \xa1\x01\n\x1aNotifyBroadcastViewerState\x12-.CBroadcast_BroadcastViewer\
    State_Notification\x1a\x0b.NoResponse\"G\x82\xb5\x18CNotification\x20fro\
    m\x20server\x20to\x20client\x20that\x20a\x20viewers\x20state\x20has\x20c\
    hanged\x12\xbd\x01\n\x1cNotifyWaitingBroadcastViewer\x12/.CBroadcast_Wai\
    tingBroadcastViewer_Notification\x1a\x0b.NoResponse\"_\x82\xb5\x18[Notif\
    ication\x20from\x20server\x20to\x20client\x20one\x20or\x20more\x20users\
    \x20is\x20waiting\x20for\x20user\x20to\x20start\x20broadcast\x12\xa7\x01\
    \n\x1cNotifyBroadcastUploadStarted\x12/.CBroadcast_BroadcastUploadStarte\
    d_Notification\x1a\x0b.NoResponse\"I\x82\xb5\x18ENotification\x20from\
    \x20server\x20to\x20client\x20with\x20information\x20about\x20a\x20broad\
    cast\x12\xd6\x01\n\x19NotifyStopBroadcastUpload\x12,.CBroadcast_StopBroa\
    dcastUpload_Notification\x1a\x0b.NoResponse\"~\x82\xb5\x18zNotification\
    \x20from\x20server\x20to\x20client\x20telling\x20it\x20to\x20stop\x20upl\
    oading\x20when\x20the\x20last\x20viewer\x20has\x20disconnected\x20from\
    \x20their\x20broadcast\x12\xb5\x01\n\x13NotifySessionClosed\x12&.CBroadc\
    ast_SessionClosed_Notification\x1a\x0b.NoResponse\"i\x82\xb5\x18eNotific\
    ation\x20from\x20server\x20to\x20client\x20telling\x20it\x20a\x20session\
    \x20has\x20been\x20closed\x20unexpectedly\x20by\x20the\x20directory\x12\
    \xc3\x01\n\x1bNotifyViewerBroadcastInvite\x12..CBroadcast_ViewerBroadcas\
    tInvite_Notification\x1a\x0b.NoResponse\"g\x82\xb5\x18cNotification\x20f\
    rom\x20server\x20to\x20client\x20that\x20a\x20broadcaster\x20is\x20invit\
    ing\x20a\x20viewer\x20to\x20watch\x20their\x20broadcast\x12\x95\x01\n\
    \x15NotifyBroadcastStatus\x12(.CBroadcast_BroadcastStatus_Notification\
    \x1a\x0b.NoResponse\"E\x82\xb5\x18ANotification\x20from\x20server\x20to\
    \x20client\x20about\x20current\x20broadcast\x20status\x12\x9f\x01\n\x1aN\
    otifyBroadcastChannelLive\x12-.CBroadcast_BroadcastChannelLive_Notificat\
    ion\x1a\x0b.NoResponse\"E\x82\xb5\x18ANotification\x20from\x20server\x20\
    to\x20client\x20about\x20current\x20broadcast\x20status\x12p\n\x14SendTh\
    umbnailToRelay\x12-.CBroadcast_SendThumbnailToRelay_Notification\x1a\x0b\
    .NoResponse\"\x1c\x82\xb5\x18\x18Send\x20thumbnails\x20to\x20relay\x12\
    \xa7\x01\n\x1aNotifyWebRTCNeedTURNServer\x12-.CBroadcast_WebRTCNeedTURNS\
    erver_Notification\x1a\x0b.NoResponse\"M\x82\xb5\x18INotification\x20fro\
    m\x20server\x20to\x20client\x20that\x20it\x20needs\x20the\x20client's\
    \x20TURN\x20server\x12\x94\x01\n\x11NotifyWebRTCStart\x12$.CBroadcast_We\
    bRTCStart_Notification\x1a\x0b.NoResponse\"L\x82\xb5\x18HNotification\
    \x20from\x20server\x20to\x20client\x20that\x20it\x20should\x20start\x20a\
    \x20WebRTC\x20session\x12\x9f\x01\n\x15NotifyWebRTCSetAnswer\x12(.CBroad\
    cast_WebRTCSetAnswer_Notification\x1a\x0b.NoResponse\"O\x82\xb5\x18KNoti\
    fication\x20from\x20server\x20to\x20client\x20about\x20the\x20broadcast\
    \x20viewer\x20WebRTC\x20answer\x12\xb6\x01\n\x1eNotifyWebRTCAddViewerCan\
    didate\x121.CBroadcast_WebRTCAddViewerCandidate_Notification\x1a\x0b.NoR\
    esponse\"T\x82\xb5\x18PNotification\x20from\x20server\x20to\x20client\
    \x20about\x20a\x20broadcast\x20viewer\x20WebRTC\x20ICE\x20candidate\x1a\
    \x04\xc0\xb5\x18\x02B\x03\x80\x01\x01J\xf2\xf0\x01\n\x07\x12\x05\0\0\xf0\
    \x05\x01\n\t\n\x02\x03\0\x12\x03\0\06\n\x08\n\x01\x08\x12\x03\x02\0\"\n\
    \t\n\x02\x08\x10\x12\x03\x02\0\"\n\n\n\x02\x05\0\x12\x04\x04\0\x13\x01\n\
    \n\n\x03\x05\0\x01\x12\x03\x04\x05\x1c\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x05\x08.\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x05\x08)\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x03\x05,-\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x06\x082\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x06\x08-\n\x0c\n\x05\x05\0\x02\x01\
    \x02\x12\x03\x0601\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x07\x089\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x07\x084\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x0778\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x08\x08/\n\x0c\n\x05\
    \x05\0\x02\x03\x01\x12\x03\x08\x08*\n\x0c\n\x05\x05\0\x02\x03\x02\x12\
    \x03\x08-.\n\x0b\n\x04\x05\0\x02\x04\x12\x03\t\x086\n\x0c\n\x05\x05\0\
    \x02\x04\x01\x12\x03\t\x081\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\t45\n\
    \x0b\n\x04\x05\0\x02\x05\x12\x03\n\x084\n\x0c\n\x05\x05\0\x02\x05\x01\
    \x12\x03\n\x08/\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\n23\n\x0b\n\x04\
    \x05\0\x02\x06\x12\x03\x0b\x083\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\
    \x0b\x08.\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0b12\n\x0b\n\x04\x05\0\
    \x02\x07\x12\x03\x0c\x08-\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x0c\x08(\
    \n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x0c+,\n\x0b\n\x04\x05\0\x02\x08\
    \x12\x03\r\x081\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\r\x08,\n\x0c\n\x05\
    \x05\0\x02\x08\x02\x12\x03\r/0\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0e\x080\
    \n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x0e\x08+\n\x0c\n\x05\x05\0\x02\t\
    \x02\x12\x03\x0e./\n\x0b\n\x04\x05\0\x02\n\x12\x03\x0f\x083\n\x0c\n\x05\
    \x05\0\x02\n\x01\x12\x03\x0f\x08-\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\
    \x0f02\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x10\x085\n\x0c\n\x05\x05\0\x02\
    \x0b\x01\x12\x03\x10\x08/\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x1024\n\
    \x0b\n\x04\x05\0\x02\x0c\x12\x03\x11\x084\n\x0c\n\x05\x05\0\x02\x0c\x01\
    \x12\x03\x11\x08.\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x1113\n\x0b\n\
    \x04\x05\0\x02\r\x12\x03\x12\x083\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\
    \x12\x08-\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x1202\n\n\n\x02\x05\x01\
    \x12\x04\x15\0\x18\x01\n\n\n\x03\x05\x01\x01\x12\x03\x15\x05\x1d\n\x0b\n\
    \x04\x05\x01\x02\0\x12\x03\x16\x08-\n\x0c\n\x05\x05\x01\x02\0\x01\x12\
    \x03\x16\x08(\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x16+,\n\x0b\n\x04\
    \x05\x01\x02\x01\x12\x03\x17\x08.\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\
    \x03\x17\x08)\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x17,-\n\n\n\x02\
    \x04\0\x12\x04\x1a\0%\x01\n\n\n\x03\x04\0\x01\x12\x03\x1a\x080\n\x0b\n\
    \x04\x04\0\x02\0\x12\x03\x1b\x08&\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\
    \x1b\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x1b\x11\x16\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\x1b\x17!\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \x1b$%\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x1c\x08#\n\x0c\n\x05\x04\0\x02\
    \x01\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x1c\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x1c\x18\x1e\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\x1c!\"\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x1d\
    \x08/\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\
    \0\x02\x02\x05\x12\x03\x1d\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\
    \x1d\x18*\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x1d-.\n\x0b\n\x04\x04\0\
    \x02\x03\x12\x03\x1e\x08\"\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x1e\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x1e\x11\x17\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\x1e\x18\x1d\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\
    \x1e\x20!\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x1f\x08#\n\x0c\n\x05\x04\0\
    \x02\x04\x04\x12\x03\x1f\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\
    \x1f\x11\x17\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1f\x18\x1e\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x03\x1f!\"\n\x0b\n\x04\x04\0\x02\x05\x12\x03\
    \x20\x08'\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x05\x05\x12\x03\x20\x11\x17\n\x0c\n\x05\x04\0\x02\x05\x01\x12\
    \x03\x20\x18\"\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x20%&\n\x0b\n\x04\
    \x04\0\x02\x06\x12\x03!\x08+\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03!\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03!\x11\x15\n\x0c\n\x05\x04\0\
    \x02\x06\x01\x12\x03!\x16&\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03!)*\n\
    \x0b\n\x04\x04\0\x02\x07\x12\x03\"\x08(\n\x0c\n\x05\x04\0\x02\x07\x04\
    \x12\x03\"\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\"\x11\x17\n\x0c\
    \n\x05\x04\0\x02\x07\x01\x12\x03\"\x18#\n\x0c\n\x05\x04\0\x02\x07\x03\
    \x12\x03\"&'\n\x0b\n\x04\x04\0\x02\x08\x12\x03#\x08\"\n\x0c\n\x05\x04\0\
    \x02\x08\x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03#\x11\
    \x17\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03#\x18\x1d\n\x0c\n\x05\x04\0\
    \x02\x08\x03\x12\x03#\x20!\n\x0b\n\x04\x04\0\x02\t\x12\x03$\x08(\n\x0c\n\
    \x05\x04\0\x02\t\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\0\x02\t\x05\x12\
    \x03$\x11\x15\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03$\x16\"\n\x0c\n\x05\x04\
    \0\x02\t\x03\x12\x03$%'\n\n\n\x02\x04\x01\x12\x04'\0-\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03'\x081\n\x0b\n\x04\x04\x01\x02\0\x12\x03(\x08*\n\x0c\n\
    \x05\x04\x01\x02\0\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\
    \x12\x03(\x11\x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03(\x19%\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03(()\n\x0b\n\x04\x04\x01\x02\x01\x12\x03)\
    \x08t\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03)\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x01\x05\x12\x03)\x11\x17\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03)\x180\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03)34\n\x0c\n\x05\x04\
    \x01\x02\x01\x08\x12\x03)5s\n\x0f\n\x08\x04\x01\x02\x01\x08\xd0\x86\x03\
    \x12\x03)6r\n\x0c\n\x04\x04\x01\x02\x02\x12\x04*\x08\x89\x01\n\x0c\n\x05\
    \x04\x01\x02\x02\x04\x12\x03*\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\
    \x12\x03*\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03*\x18.\n\x0c\n\
    \x05\x04\x01\x02\x02\x03\x12\x03*12\n\r\n\x05\x04\x01\x02\x02\x08\x12\
    \x04*3\x88\x01\n\x10\n\x08\x04\x01\x02\x02\x08\xd0\x86\x03\x12\x04*4\x87\
    \x01\n\x0b\n\x04\x04\x01\x02\x03\x12\x03+\x08o\n\x0c\n\x05\x04\x01\x02\
    \x03\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03+\x11\
    \x17\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03+\x182\n\x0c\n\x05\x04\x01\
    \x02\x03\x03\x12\x03+56\n\x0c\n\x05\x04\x01\x02\x03\x08\x12\x03+7n\n\x0f\
    \n\x08\x04\x01\x02\x03\x08\xd0\x86\x03\x12\x03+8m\n\x0b\n\x04\x04\x01\
    \x02\x04\x12\x03,\x08w\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03,\x08\x10\
    \n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03,\x11\x17\n\x0c\n\x05\x04\x01\
    \x02\x04\x01\x12\x03,\x182\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03,56\n\
    \x0c\n\x05\x04\x01\x02\x04\x08\x12\x03,7v\n\x0f\n\x08\x04\x01\x02\x04\
    \x08\xd0\x86\x03\x12\x03,8u\n\n\n\x02\x04\x02\x12\x04/\01\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03/\x08.\n\x0b\n\x04\x04\x02\x02\0\x12\x030\x08*\n\x0c\
    \n\x05\x04\x02\x02\0\x04\x12\x030\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x030\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x030\x19%\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x030()\n\n\n\x02\x04\x03\x12\x043\04\x01\n\n\
    \n\x03\x04\x03\x01\x12\x033\x08/\n\n\n\x02\x04\x04\x12\x046\0?\x01\n\n\n\
    \x03\x04\x04\x01\x12\x036\x08/\n\x0b\n\x04\x04\x04\x02\0\x12\x037\x08*\n\
    \x0c\n\x05\x04\x04\x02\0\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x037\x11\x18\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x037\x19%\n\x0c\
    \n\x05\x04\x04\x02\0\x03\x12\x037()\n\x0b\n\x04\x04\x04\x02\x01\x12\x038\
    \x08#\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x01\x05\x12\x038\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x038\x18\x1e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x038!\"\n\x0b\n\x04\
    \x04\x04\x02\x02\x12\x039\x08\"\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x039\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x039\x11\x15\n\x0c\n\x05\
    \x04\x04\x02\x02\x01\x12\x039\x16\x1d\n\x0c\n\x05\x04\x04\x02\x02\x03\
    \x12\x039\x20!\n\x0b\n\x04\x04\x04\x02\x03\x12\x03:\x08*\n\x0c\n\x05\x04\
    \x04\x02\x03\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\
    \x03:\x11\x17\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03:\x18%\n\x0c\n\x05\
    \x04\x04\x02\x03\x03\x12\x03:()\n\x0c\n\x04\x04\x04\x02\x04\x12\x04;\x08\
    \x80\x01\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03;\x08\x10\n\x0c\n\x05\
    \x04\x04\x02\x04\x05\x12\x03;\x11\x17\n\x0c\n\x05\x04\x04\x02\x04\x01\
    \x12\x03;\x18\"\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03;%&\n\x0c\n\x05\
    \x04\x04\x02\x04\x08\x12\x03;'\x7f\n\x0c\n\x05\x04\x04\x02\x04\x07\x12\
    \x03;23\n\x0f\n\x08\x04\x04\x02\x04\x08\xd0\x86\x03\x12\x03;5~\n\x0b\n\
    \x04\x04\x04\x02\x05\x12\x03<\x08.\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\
    \x03<\x08\x10\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03<\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x05\x01\x12\x03<\x18)\n\x0c\n\x05\x04\x04\x02\x05\x03\
    \x12\x03<,-\n\x0b\n\x04\x04\x04\x02\x06\x12\x03=\x08$\n\x0c\n\x05\x04\
    \x04\x02\x06\x04\x12\x03=\x08\x10\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\
    \x03=\x11\x15\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x03=\x16\x1f\n\x0c\n\
    \x05\x04\x04\x02\x06\x03\x12\x03=\"#\n\x0b\n\x04\x04\x04\x02\x07\x12\x03\
    >\x08\"\n\x0c\n\x05\x04\x04\x02\x07\x04\x12\x03>\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x07\x05\x12\x03>\x11\x17\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\
    \x03>\x18\x1d\n\x0c\n\x05\x04\x04\x02\x07\x03\x12\x03>\x20!\n\n\n\x02\
    \x04\x05\x12\x04A\0G\x01\n\n\n\x03\x04\x05\x01\x12\x03A\x080\n\x0b\n\x04\
    \x04\x05\x02\0\x12\x03B\x08)\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03B\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03B\x11\x17\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03B\x18$\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03B'(\n\x0b\
    \n\x04\x04\x05\x02\x01\x12\x03C\x08+\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\
    \x03C\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03C\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\x01\x01\x12\x03C\x18&\n\x0c\n\x05\x04\x05\x02\x01\x03\
    \x12\x03C)*\n\x0b\n\x04\x04\x05\x02\x02\x12\x03D\x081\n\x0c\n\x05\x04\
    \x05\x02\x02\x04\x12\x03D\x08\x10\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\
    \x03D\x11\x18\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03D\x19,\n\x0c\n\x05\
    \x04\x05\x02\x02\x03\x12\x03D/0\n\x0b\n\x04\x04\x05\x02\x03\x12\x03E\x08\
    (\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03E\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x03\x05\x12\x03E\x11\x15\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03E\
    \x16#\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03E&'\n\x0b\n\x04\x04\x05\x02\
    \x04\x12\x03F\x08)\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x03F\x08\x10\n\
    \x0c\n\x05\x04\x05\x02\x04\x05\x12\x03F\x11\x17\n\x0c\n\x05\x04\x05\x02\
    \x04\x01\x12\x03F\x18$\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03F'(\n\n\n\
    \x02\x04\x06\x12\x04I\0L\x01\n\n\n\x03\x04\x06\x01\x12\x03I\x089\n\x0b\n\
    \x04\x04\x06\x02\0\x12\x03J\x081\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03J\
    \x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03J\x11\x18\n\x0c\n\x05\x04\
    \x06\x02\0\x01\x12\x03J\x19,\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03J/0\n\
    \x0b\n\x04\x04\x06\x02\x01\x12\x03K\x08*\n\x0c\n\x05\x04\x06\x02\x01\x04\
    \x12\x03K\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03K\x11\x17\n\x0c\
    \n\x05\x04\x06\x02\x01\x01\x12\x03K\x18%\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03K()\n\n\n\x02\x04\x07\x12\x04N\0U\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03N\x08)\n\x0b\n\x04\x04\x07\x02\0\x12\x03O\x08N\n\x0c\n\x05\x04\x07\
    \x02\0\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03O\x11\
    \x18\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03O\x19\x20\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03O#$\n\x0c\n\x05\x04\x07\x02\0\x08\x12\x03O%M\n\x0f\n\
    \x08\x04\x07\x02\0\x08\xd0\x86\x03\x12\x03O&L\n\x0b\n\x04\x04\x07\x02\
    \x01\x12\x03P\x08}\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03P\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x01\x05\x12\x03P\x11\x18\n\x0c\n\x05\x04\x07\x02\
    \x01\x01\x12\x03P\x19.\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03P12\n\x0c\
    \n\x05\x04\x07\x02\x01\x08\x12\x03P3|\n\x0f\n\x08\x04\x07\x02\x01\x08\
    \xd0\x86\x03\x12\x03P4{\n\x0c\n\x04\x04\x07\x02\x02\x12\x04Q\x08\x87\x01\
    \n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\x07\
    \x02\x02\x05\x12\x03Q\x11\x18\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03Q\
    \x19%\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03Q()\n\r\n\x05\x04\x07\x02\
    \x02\x08\x12\x04Q*\x86\x01\n\x10\n\x08\x04\x07\x02\x02\x08\xd0\x86\x03\
    \x12\x04Q+\x85\x01\n\x0b\n\x04\x04\x07\x02\x03\x12\x03R\x08(\n\x0c\n\x05\
    \x04\x07\x02\x03\x04\x12\x03R\x08\x10\n\x0c\n\x05\x04\x07\x02\x03\x05\
    \x12\x03R\x11\x17\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03R\x18#\n\x0c\n\
    \x05\x04\x07\x02\x03\x03\x12\x03R&'\n\x0b\n\x04\x04\x07\x02\x04\x12\x03S\
    \x08k\n\x0c\n\x05\x04\x07\x02\x04\x04\x12\x03S\x08\x10\n\x0c\n\x05\x04\
    \x07\x02\x04\x06\x12\x03S\x11)\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03S*\
    8\n\x0c\n\x05\x04\x07\x02\x04\x03\x12\x03S;<\n\x0c\n\x05\x04\x07\x02\x04\
    \x08\x12\x03S=j\n\x0c\n\x05\x04\x07\x02\x04\x07\x12\x03SHi\n\x0b\n\x04\
    \x04\x07\x02\x05\x12\x03T\x08$\n\x0c\n\x05\x04\x07\x02\x05\x04\x12\x03T\
    \x08\x10\n\x0c\n\x05\x04\x07\x02\x05\x05\x12\x03T\x11\x15\n\x0c\n\x05\
    \x04\x07\x02\x05\x01\x12\x03T\x16\x1f\n\x0c\n\x05\x04\x07\x02\x05\x03\
    \x12\x03T\"#\n\n\n\x02\x04\x08\x12\x04W\0{\x01\n\n\n\x03\x04\x08\x01\x12\
    \x03W\x08*\n\x0c\n\x04\x04\x08\x04\0\x12\x04X\x08e\t\n\x0c\n\x05\x04\x08\
    \x04\0\x01\x12\x03X\r\x1b\n\r\n\x06\x04\x08\x04\0\x02\0\x12\x03Y\x10*\n\
    \x0e\n\x07\x04\x08\x04\0\x02\0\x01\x12\x03Y\x10%\n\x0e\n\x07\x04\x08\x04\
    \0\x02\0\x02\x12\x03Y()\n\r\n\x06\x04\x08\x04\0\x02\x01\x12\x03Z\x101\n\
    \x0e\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x03Z\x10,\n\x0e\n\x07\x04\x08\
    \x04\0\x02\x01\x02\x12\x03Z/0\n\r\n\x06\x04\x08\x04\0\x02\x02\x12\x03[\
    \x107\n\x0e\n\x07\x04\x08\x04\0\x02\x02\x01\x12\x03[\x102\n\x0e\n\x07\
    \x04\x08\x04\0\x02\x02\x02\x12\x03[56\n\r\n\x06\x04\x08\x04\0\x02\x03\
    \x12\x03\\\x104\n\x0e\n\x07\x04\x08\x04\0\x02\x03\x01\x12\x03\\\x10/\n\
    \x0e\n\x07\x04\x08\x04\0\x02\x03\x02\x12\x03\\23\n\r\n\x06\x04\x08\x04\0\
    \x02\x04\x12\x03]\x103\n\x0e\n\x07\x04\x08\x04\0\x02\x04\x01\x12\x03]\
    \x10.\n\x0e\n\x07\x04\x08\x04\0\x02\x04\x02\x12\x03]12\n\r\n\x06\x04\x08\
    \x04\0\x02\x05\x12\x03^\x106\n\x0e\n\x07\x04\x08\x04\0\x02\x05\x01\x12\
    \x03^\x101\n\x0e\n\x07\x04\x08\x04\0\x02\x05\x02\x12\x03^45\n\r\n\x06\
    \x04\x08\x04\0\x02\x06\x12\x03_\x108\n\x0e\n\x07\x04\x08\x04\0\x02\x06\
    \x01\x12\x03_\x103\n\x0e\n\x07\x04\x08\x04\0\x02\x06\x02\x12\x03_67\n\r\
    \n\x06\x04\x08\x04\0\x02\x07\x12\x03`\x107\n\x0e\n\x07\x04\x08\x04\0\x02\
    \x07\x01\x12\x03`\x102\n\x0e\n\x07\x04\x08\x04\0\x02\x07\x02\x12\x03`56\
    \n\r\n\x06\x04\x08\x04\0\x02\x08\x12\x03a\x103\n\x0e\n\x07\x04\x08\x04\0\
    \x02\x08\x01\x12\x03a\x10.\n\x0e\n\x07\x04\x08\x04\0\x02\x08\x02\x12\x03\
    a12\n\r\n\x06\x04\x08\x04\0\x02\t\x12\x03b\x105\n\x0e\n\x07\x04\x08\x04\
    \0\x02\t\x01\x12\x03b\x10/\n\x0e\n\x07\x04\x08\x04\0\x02\t\x02\x12\x03b2\
    4\n\r\n\x06\x04\x08\x04\0\x02\n\x12\x03c\x107\n\x0e\n\x07\x04\x08\x04\0\
    \x02\n\x01\x12\x03c\x101\n\x0e\n\x07\x04\x08\x04\0\x02\n\x02\x12\x03c46\
    \n\r\n\x06\x04\x08\x04\0\x02\x0b\x12\x03d\x109\n\x0e\n\x07\x04\x08\x04\0\
    \x02\x0b\x01\x12\x03d\x103\n\x0e\n\x07\x04\x08\x04\0\x02\x0b\x02\x12\x03\
    d68\n\x0b\n\x04\x04\x08\x02\0\x12\x03g\x08s\n\x0c\n\x05\x04\x08\x02\0\
    \x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03g\x11C\n\x0c\
    \n\x05\x04\x08\x02\0\x01\x12\x03gDL\n\x0c\n\x05\x04\x08\x02\0\x03\x12\
    \x03gOP\n\x0c\n\x05\x04\x08\x02\0\x08\x12\x03gQr\n\x0c\n\x05\x04\x08\x02\
    \0\x07\x12\x03g\\q\n\x0b\n\x04\x04\x08\x02\x01\x12\x03h\x08$\n\x0c\n\x05\
    \x04\x08\x02\x01\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\x05\
    \x12\x03h\x11\x17\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03h\x18\x1f\n\x0c\
    \n\x05\x04\x08\x02\x01\x03\x12\x03h\"#\n\x0b\n\x04\x04\x08\x02\x02\x12\
    \x03i\x08*\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03i\x08\x10\n\x0c\n\x05\
    \x04\x08\x02\x02\x05\x12\x03i\x11\x18\n\x0c\n\x05\x04\x08\x02\x02\x01\
    \x12\x03i\x19%\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03i()\n\x0b\n\x04\
    \x04\x08\x02\x03\x12\x03j\x08#\n\x0c\n\x05\x04\x08\x02\x03\x04\x12\x03j\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03j\x11\x17\n\x0c\n\x05\
    \x04\x08\x02\x03\x01\x12\x03j\x18\x1e\n\x0c\n\x05\x04\x08\x02\x03\x03\
    \x12\x03j!\"\n\x0b\n\x04\x04\x08\x02\x04\x12\x03k\x08\"\n\x0c\n\x05\x04\
    \x08\x02\x04\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\
    \x03k\x11\x17\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03k\x18\x1d\n\x0c\n\
    \x05\x04\x08\x02\x04\x03\x12\x03k\x20!\n\x0b\n\x04\x04\x08\x02\x05\x12\
    \x03l\x08(\n\x0c\n\x05\x04\x08\x02\x05\x04\x12\x03l\x08\x10\n\x0c\n\x05\
    \x04\x08\x02\x05\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x08\x02\x05\x01\
    \x12\x03l\x18#\n\x0c\n\x05\x04\x08\x02\x05\x03\x12\x03l&'\n\x0b\n\x04\
    \x04\x08\x02\x06\x12\x03m\x08&\n\x0c\n\x05\x04\x08\x02\x06\x04\x12\x03m\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\x06\x05\x12\x03m\x11\x16\n\x0c\n\x05\
    \x04\x08\x02\x06\x01\x12\x03m\x17!\n\x0c\n\x05\x04\x08\x02\x06\x03\x12\
    \x03m$%\n\x0b\n\x04\x04\x08\x02\x07\x12\x03n\x08\"\n\x0c\n\x05\x04\x08\
    \x02\x07\x04\x12\x03n\x08\x10\n\x0c\n\x05\x04\x08\x02\x07\x05\x12\x03n\
    \x11\x15\n\x0c\n\x05\x04\x08\x02\x07\x01\x12\x03n\x16\x1d\n\x0c\n\x05\
    \x04\x08\x02\x07\x03\x12\x03n\x20!\n\x0b\n\x04\x04\x08\x02\x08\x12\x03o\
    \x08)\n\x0c\n\x05\x04\x08\x02\x08\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\
    \x08\x02\x08\x05\x12\x03o\x11\x16\n\x0c\n\x05\x04\x08\x02\x08\x01\x12\
    \x03o\x17$\n\x0c\n\x05\x04\x08\x02\x08\x03\x12\x03o'(\n\x0b\n\x04\x04\
    \x08\x02\t\x12\x03p\x08+\n\x0c\n\x05\x04\x08\x02\t\x04\x12\x03p\x08\x10\
    \n\x0c\n\x05\x04\x08\x02\t\x05\x12\x03p\x11\x18\n\x0c\n\x05\x04\x08\x02\
    \t\x01\x12\x03p\x19%\n\x0c\n\x05\x04\x08\x02\t\x03\x12\x03p(*\n\x0b\n\
    \x04\x04\x08\x02\n\x12\x03q\x081\n\x0c\n\x05\x04\x08\x02\n\x04\x12\x03q\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\n\x05\x12\x03q\x11\x17\n\x0c\n\x05\x04\
    \x08\x02\n\x01\x12\x03q\x18+\n\x0c\n\x05\x04\x08\x02\n\x03\x12\x03q.0\n\
    \x0b\n\x04\x04\x08\x02\x0b\x12\x03r\x08/\n\x0c\n\x05\x04\x08\x02\x0b\x04\
    \x12\x03r\x08\x10\n\x0c\n\x05\x04\x08\x02\x0b\x05\x12\x03r\x11\x16\n\x0c\
    \n\x05\x04\x08\x02\x0b\x01\x12\x03r\x17)\n\x0c\n\x05\x04\x08\x02\x0b\x03\
    \x12\x03r,.\n\x0b\n\x04\x04\x08\x02\x0c\x12\x03s\x08+\n\x0c\n\x05\x04\
    \x08\x02\x0c\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x08\x02\x0c\x05\x12\
    \x03s\x11\x17\n\x0c\n\x05\x04\x08\x02\x0c\x01\x12\x03s\x18%\n\x0c\n\x05\
    \x04\x08\x02\x0c\x03\x12\x03s(*\n\x0b\n\x04\x04\x08\x02\r\x12\x03t\x08%\
    \n\x0c\n\x05\x04\x08\x02\r\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\x08\x02\
    \r\x05\x12\x03t\x11\x15\n\x0c\n\x05\x04\x08\x02\r\x01\x12\x03t\x16\x1f\n\
    \x0c\n\x05\x04\x08\x02\r\x03\x12\x03t\"$\n\x0b\n\x04\x04\x08\x02\x0e\x12\
    \x03u\x080\n\x0c\n\x05\x04\x08\x02\x0e\x04\x12\x03u\x08\x10\n\x0c\n\x05\
    \x04\x08\x02\x0e\x05\x12\x03u\x11\x18\n\x0c\n\x05\x04\x08\x02\x0e\x01\
    \x12\x03u\x19*\n\x0c\n\x05\x04\x08\x02\x0e\x03\x12\x03u-/\n\x0b\n\x04\
    \x04\x08\x02\x0f\x12\x03v\x08.\n\x0c\n\x05\x04\x08\x02\x0f\x04\x12\x03v\
    \x08\x10\n\x0c\n\x05\x04\x08\x02\x0f\x05\x12\x03v\x11\x17\n\x0c\n\x05\
    \x04\x08\x02\x0f\x01\x12\x03v\x18(\n\x0c\n\x05\x04\x08\x02\x0f\x03\x12\
    \x03v+-\n\x0b\n\x04\x04\x08\x02\x10\x12\x03w\x080\n\x0c\n\x05\x04\x08\
    \x02\x10\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\x08\x02\x10\x05\x12\x03w\
    \x11\x17\n\x0c\n\x05\x04\x08\x02\x10\x01\x12\x03w\x18*\n\x0c\n\x05\x04\
    \x08\x02\x10\x03\x12\x03w-/\n\x0b\n\x04\x04\x08\x02\x11\x12\x03x\x08%\n\
    \x0c\n\x05\x04\x08\x02\x11\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\x08\x02\
    \x11\x05\x12\x03x\x11\x15\n\x0c\n\x05\x04\x08\x02\x11\x01\x12\x03x\x16\
    \x1f\n\x0c\n\x05\x04\x08\x02\x11\x03\x12\x03x\"$\n\x0b\n\x04\x04\x08\x02\
    \x12\x12\x03y\x08%\n\x0c\n\x05\x04\x08\x02\x12\x04\x12\x03y\x08\x10\n\
    \x0c\n\x05\x04\x08\x02\x12\x05\x12\x03y\x11\x16\n\x0c\n\x05\x04\x08\x02\
    \x12\x01\x12\x03y\x17\x1f\n\x0c\n\x05\x04\x08\x02\x12\x03\x12\x03y\"$\n\
    \x0b\n\x04\x04\x08\x02\x13\x12\x03z\x085\n\x0c\n\x05\x04\x08\x02\x13\x04\
    \x12\x03z\x08\x10\n\x0c\n\x05\x04\x08\x02\x13\x05\x12\x03z\x11\x17\n\x0c\
    \n\x05\x04\x08\x02\x13\x01\x12\x03z\x18/\n\x0c\n\x05\x04\x08\x02\x13\x03\
    \x12\x03z24\n\x0b\n\x02\x04\t\x12\x05}\0\x82\x01\x01\n\n\n\x03\x04\t\x01\
    \x12\x03}\x082\n\x0b\n\x04\x04\t\x02\0\x12\x03~\x08N\n\x0c\n\x05\x04\t\
    \x02\0\x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03~\x11\x18\
    \n\x0c\n\x05\x04\t\x02\0\x01\x12\x03~\x19\x20\n\x0c\n\x05\x04\t\x02\0\
    \x03\x12\x03~#$\n\x0c\n\x05\x04\t\x02\0\x08\x12\x03~%M\n\x0f\n\x08\x04\t\
    \x02\0\x08\xd0\x86\x03\x12\x03~&L\n\x0b\n\x04\x04\t\x02\x01\x12\x03\x7f\
    \x08T\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\
    \t\x02\x01\x05\x12\x03\x7f\x11\x18\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03\
    \x7f\x19%\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03\x7f()\n\x0c\n\x05\x04\t\
    \x02\x01\x08\x12\x03\x7f*S\n\x0f\n\x08\x04\t\x02\x01\x08\xd0\x86\x03\x12\
    \x03\x7f+R\n\r\n\x04\x04\t\x02\x02\x12\x05\x80\x01\x08\x87\x01\n\r\n\x05\
    \x04\t\x02\x02\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\
    \x12\x04\x80\x01\x11\x18\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x80\x01\x19\
    %\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x80\x01()\n\x0e\n\x05\x04\t\x02\
    \x02\x08\x12\x05\x80\x01*\x86\x01\n\x11\n\x08\x04\t\x02\x02\x08\xd0\x86\
    \x03\x12\x05\x80\x01+\x85\x01\n\x0c\n\x04\x04\t\x02\x03\x12\x04\x81\x01\
    \x08d\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\
    \t\x02\x03\x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\t\x02\x03\x01\x12\
    \x04\x81\x01\x18&\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\x81\x01)*\n\r\n\
    \x05\x04\t\x02\x03\x08\x12\x04\x81\x01+c\n\x10\n\x08\x04\t\x02\x03\x08\
    \xd0\x86\x03\x12\x04\x81\x01,b\n\x0c\n\x02\x04\n\x12\x06\x84\x01\0\x88\
    \x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x84\x01\x085\n\x0c\n\x04\x04\n\
    \x02\0\x12\x04\x85\x01\x08N\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x85\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x85\x01\x11\x18\n\r\n\x05\x04\
    \n\x02\0\x01\x12\x04\x85\x01\x19\x20\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \x85\x01#$\n\r\n\x05\x04\n\x02\0\x08\x12\x04\x85\x01%M\n\x10\n\x08\x04\n\
    \x02\0\x08\xd0\x86\x03\x12\x04\x85\x01&L\n\x0c\n\x04\x04\n\x02\x01\x12\
    \x04\x86\x01\x08T\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x86\x01\x08\x10\n\
    \r\n\x05\x04\n\x02\x01\x05\x12\x04\x86\x01\x11\x18\n\r\n\x05\x04\n\x02\
    \x01\x01\x12\x04\x86\x01\x19%\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x86\
    \x01()\n\r\n\x05\x04\n\x02\x01\x08\x12\x04\x86\x01*S\n\x10\n\x08\x04\n\
    \x02\x01\x08\xd0\x86\x03\x12\x04\x86\x01+R\n\r\n\x04\x04\n\x02\x02\x12\
    \x05\x87\x01\x08\x87\x01\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\x87\x01\x08\
    \x10\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\x87\x01\x11\x18\n\r\n\x05\x04\n\
    \x02\x02\x01\x12\x04\x87\x01\x19%\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\
    \x87\x01()\n\x0e\n\x05\x04\n\x02\x02\x08\x12\x05\x87\x01*\x86\x01\n\x11\
    \n\x08\x04\n\x02\x02\x08\xd0\x86\x03\x12\x05\x87\x01+\x85\x01\n\x0c\n\
    \x02\x04\x0b\x12\x06\x8a\x01\0\x8d\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\x8a\x01\x08-\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x8b\x01\x08N\n\r\n\
    \x05\x04\x0b\x02\0\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\
    \x05\x12\x04\x8b\x01\x11\x18\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x8b\x01\
    \x19\x20\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8b\x01#$\n\r\n\x05\x04\x0b\
    \x02\0\x08\x12\x04\x8b\x01%M\n\x10\n\x08\x04\x0b\x02\0\x08\xd0\x86\x03\
    \x12\x04\x8b\x01&L\n\r\n\x04\x04\x0b\x02\x01\x12\x05\x8c\x01\x08\x81\x01\
    \n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x0b\
    \x02\x01\x05\x12\x04\x8c\x01\x11\x18\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\x8c\x01\x19%\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x8c\x01()\n\x0e\
    \n\x05\x04\x0b\x02\x01\x08\x12\x05\x8c\x01*\x80\x01\n\x10\n\x08\x04\x0b\
    \x02\x01\x08\xd0\x86\x03\x12\x04\x8c\x01+\x7f\n\x0c\n\x02\x04\x0c\x12\
    \x06\x8f\x01\0\x9e\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x8f\x01\x08.\
    \n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x90\x01\x08#\n\r\n\x05\x04\x0c\x02\0\
    \x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x90\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x90\x01\x18\x1e\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x90\x01!\"\n\x0c\n\x04\x04\x0c\x02\x01\x12\
    \x04\x91\x01\x08\"\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\x91\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x91\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\x91\x01\x18\x1d\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\x91\x01\x20!\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\x92\x01\x08(\n\r\n\
    \x05\x04\x0c\x02\x02\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x02\x05\x12\x04\x92\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\
    \x92\x01\x18#\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x92\x01&'\n\x0c\n\
    \x04\x04\x0c\x02\x03\x12\x04\x93\x01\x08&\n\r\n\x05\x04\x0c\x02\x03\x04\
    \x12\x04\x93\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\x93\x01\
    \x11\x16\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x93\x01\x17!\n\r\n\x05\
    \x04\x0c\x02\x03\x03\x12\x04\x93\x01$%\n\x0c\n\x04\x04\x0c\x02\x04\x12\
    \x04\x94\x01\x08\"\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\x94\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\x94\x01\x11\x15\n\r\n\x05\x04\x0c\
    \x02\x04\x01\x12\x04\x94\x01\x16\x1d\n\r\n\x05\x04\x0c\x02\x04\x03\x12\
    \x04\x94\x01\x20!\n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\x95\x01\x08)\n\r\n\
    \x05\x04\x0c\x02\x05\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x05\x05\x12\x04\x95\x01\x11\x16\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\
    \x95\x01\x17$\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\x95\x01'(\n\x0c\n\
    \x04\x04\x0c\x02\x06\x12\x04\x96\x01\x08'\n\r\n\x05\x04\x0c\x02\x06\x04\
    \x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\x96\x01\
    \x11\x15\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\x96\x01\x16\"\n\r\n\x05\
    \x04\x0c\x02\x06\x03\x12\x04\x96\x01%&\n\x0c\n\x04\x04\x0c\x02\x07\x12\
    \x04\x97\x01\x08*\n\r\n\x05\x04\x0c\x02\x07\x04\x12\x04\x97\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\x97\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x07\x01\x12\x04\x97\x01\x18%\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\
    \x97\x01()\n\x0c\n\x04\x04\x0c\x02\x08\x12\x04\x98\x01\x08+\n\r\n\x05\
    \x04\x0c\x02\x08\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x08\
    \x05\x12\x04\x98\x01\x11\x16\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\x98\
    \x01\x17&\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\x98\x01)*\n\x0c\n\x04\
    \x04\x0c\x02\t\x12\x04\x99\x01\x08(\n\r\n\x05\x04\x0c\x02\t\x04\x12\x04\
    \x99\x01\x08\x10\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\x99\x01\x11\x15\n\r\
    \n\x05\x04\x0c\x02\t\x01\x12\x04\x99\x01\x16\"\n\r\n\x05\x04\x0c\x02\t\
    \x03\x12\x04\x99\x01%'\n\x0c\n\x04\x04\x0c\x02\n\x12\x04\x9a\x01\x08&\n\
    \r\n\x05\x04\x0c\x02\n\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \n\x05\x12\x04\x9a\x01\x11\x17\n\r\n\x05\x04\x0c\x02\n\x01\x12\x04\x9a\
    \x01\x18\x20\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\x9a\x01#%\n\x0c\n\x04\
    \x04\x0c\x02\x0b\x12\x04\x9b\x01\x08%\n\r\n\x05\x04\x0c\x02\x0b\x04\x12\
    \x04\x9b\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x0b\x05\x12\x04\x9b\x01\x11\
    \x15\n\r\n\x05\x04\x0c\x02\x0b\x01\x12\x04\x9b\x01\x16\x1f\n\r\n\x05\x04\
    \x0c\x02\x0b\x03\x12\x04\x9b\x01\"$\n\x0c\n\x04\x04\x0c\x02\x0c\x12\x04\
    \x9c\x01\x08,\n\r\n\x05\x04\x0c\x02\x0c\x04\x12\x04\x9c\x01\x08\x10\n\r\
    \n\x05\x04\x0c\x02\x0c\x05\x12\x04\x9c\x01\x11\x15\n\r\n\x05\x04\x0c\x02\
    \x0c\x01\x12\x04\x9c\x01\x16&\n\r\n\x05\x04\x0c\x02\x0c\x03\x12\x04\x9c\
    \x01)+\n\x0c\n\x04\x04\x0c\x02\r\x12\x04\x9d\x01\x080\n\r\n\x05\x04\x0c\
    \x02\r\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x0c\x02\r\x05\x12\x04\
    \x9d\x01\x11\x15\n\r\n\x05\x04\x0c\x02\r\x01\x12\x04\x9d\x01\x16*\n\r\n\
    \x05\x04\x0c\x02\r\x03\x12\x04\x9d\x01-/\n\x0c\n\x02\x04\r\x12\x06\xa0\
    \x01\0\xa3\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xa0\x01\x080\n\x0c\n\
    \x04\x04\r\x02\0\x12\x04\xa1\x01\x08%\n\r\n\x05\x04\r\x02\0\x04\x12\x04\
    \xa1\x01\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xa1\x01\x11\x18\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\xa1\x01\x19\x20\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xa1\x01#$\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xa2\x01\x08*\n\r\n\
    \x05\x04\r\x02\x01\x04\x12\x04\xa2\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\
    \x05\x12\x04\xa2\x01\x11\x18\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa2\x01\
    \x19%\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xa2\x01()\n\x0c\n\x02\x04\x0e\
    \x12\x06\xa5\x01\0\xaa\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa5\x01\
    \x081\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xa6\x01\x08*\n\r\n\x05\x04\x0e\
    \x02\0\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\
    \xa6\x01\x11\x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xa6\x01\x18%\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\xa6\x01()\n\x0c\n\x04\x04\x0e\x02\x01\x12\
    \x04\xa7\x01\x08+\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xa7\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xa7\x01\x11\x16\n\r\n\x05\x04\x0e\
    \x02\x01\x01\x12\x04\xa7\x01\x17&\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xa7\x01)*\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xa8\x01\x08'\n\r\n\x05\
    \x04\x0e\x02\x02\x04\x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\
    \x05\x12\x04\xa8\x01\x11\x16\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa8\
    \x01\x17\"\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xa8\x01%&\n\x0c\n\x04\
    \x04\x0e\x02\x03\x12\x04\xa9\x01\x08$\n\r\n\x05\x04\x0e\x02\x03\x04\x12\
    \x04\xa9\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xa9\x01\x11\
    \x16\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xa9\x01\x17\x1f\n\r\n\x05\x04\
    \x0e\x02\x03\x03\x12\x04\xa9\x01\"#\n\x0c\n\x02\x04\x0f\x12\x06\xac\x01\
    \0\xaf\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xac\x01\x08,\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\xad\x01\x08%\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\
    \xad\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xad\x01\x11\x18\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\xad\x01\x19\x20\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xad\x01#$\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xae\x01\x08,\
    \n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\xae\x01\x11\x15\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xae\x01\x16'\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xae\x01*+\n\x0c\
    \n\x02\x04\x10\x12\x06\xb1\x01\0\xb3\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\xb1\x01\x08-\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xb2\x01\x08\"\n\r\n\
    \x05\x04\x10\x02\0\x04\x12\x04\xb2\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\xb2\x01\x11\x15\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xb2\x01\
    \x16\x1d\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb2\x01\x20!\n\x0c\n\x02\
    \x04\x11\x12\x06\xb5\x01\0\xba\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xb5\x01\x085\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xb6\x01\x08&\n\r\n\x05\
    \x04\x11\x02\0\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\
    \x12\x04\xb6\x01\x11\x16\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb6\x01\x17\
    !\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb6\x01$%\n\x0c\n\x04\x04\x11\x02\
    \x01\x12\x04\xb7\x01\x08#\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xb7\x01\
    \x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xb7\x01\x11\x17\n\r\n\x05\
    \x04\x11\x02\x01\x01\x12\x04\xb7\x01\x18\x1e\n\r\n\x05\x04\x11\x02\x01\
    \x03\x12\x04\xb7\x01!\"\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xb8\x01\x08\
    \"\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\
    \x11\x02\x02\x05\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\xb8\x01\x18\x1d\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xb8\x01\
    \x20!\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xb9\x01\x08-\n\r\n\x05\x04\x11\
    \x02\x03\x04\x12\x04\xb9\x01\x08\x10\n\r\n\x05\x04\x11\x02\x03\x05\x12\
    \x04\xb9\x01\x11\x17\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xb9\x01\x18(\
    \n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xb9\x01+,\n\x0c\n\x02\x04\x12\x12\
    \x06\xbc\x01\0\xbd\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xbc\x01\x086\
    \n\x0c\n\x02\x04\x13\x12\x06\xbf\x01\0\xc1\x01\x01\n\x0b\n\x03\x04\x13\
    \x01\x12\x04\xbf\x01\x08?\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xc0\x01\x08*\
    \n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xc0\x01\x08\x10\n\r\n\x05\x04\x13\
    \x02\0\x05\x12\x04\xc0\x01\x11\x18\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \xc0\x01\x19%\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xc0\x01()\n\x0c\n\x02\
    \x04\x14\x12\x06\xc3\x01\0\xc8\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xc3\x01\x08/\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xc4\x01\x08%\n\r\n\x05\
    \x04\x14\x02\0\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\
    \x12\x04\xc4\x01\x11\x18\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xc4\x01\x19\
    \x20\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xc4\x01#$\n\x0c\n\x04\x04\x14\
    \x02\x01\x12\x04\xc5\x01\x08*\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xc5\
    \x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xc5\x01\x11\x18\n\r\n\
    \x05\x04\x14\x02\x01\x01\x12\x04\xc5\x01\x19%\n\r\n\x05\x04\x14\x02\x01\
    \x03\x12\x04\xc5\x01()\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xc6\x01\x08&\
    \n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x14\
    \x02\x02\x05\x12\x04\xc6\x01\x11\x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\
    \x04\xc6\x01\x18!\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xc6\x01$%\n\x0c\
    \n\x04\x04\x14\x02\x03\x12\x04\xc7\x01\x08(\n\r\n\x05\x04\x14\x02\x03\
    \x04\x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\xc7\
    \x01\x11\x17\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xc7\x01\x18#\n\r\n\
    \x05\x04\x14\x02\x03\x03\x12\x04\xc7\x01&'\n\x0c\n\x02\x04\x15\x12\x06\
    \xca\x01\0\xce\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xca\x01\x080\n\
    \x0c\n\x04\x04\x15\x02\0\x12\x04\xcb\x01\x08%\n\r\n\x05\x04\x15\x02\0\
    \x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xcb\x01\
    \x11\x18\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xcb\x01\x19\x20\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\xcb\x01#$\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\
    \xcc\x01\x08.\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xcc\x01\x08\x10\n\r\
    \n\x05\x04\x15\x02\x01\x05\x12\x04\xcc\x01\x11\x17\n\r\n\x05\x04\x15\x02\
    \x01\x01\x12\x04\xcc\x01\x18)\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xcc\
    \x01,-\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xcd\x01\x08,\n\r\n\x05\x04\
    \x15\x02\x02\x04\x12\x04\xcd\x01\x08\x10\n\r\n\x05\x04\x15\x02\x02\x05\
    \x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xcd\x01\
    \x18'\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xcd\x01*+\n\x0c\n\x02\x04\
    \x16\x12\x06\xd0\x01\0\xd6\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xd0\
    \x01\x08*\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xd1\x01\x08%\n\r\n\x05\x04\
    \x16\x02\0\x04\x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\
    \x04\xd1\x01\x11\x18\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xd1\x01\x19\x20\
    \n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xd1\x01#$\n\x0c\n\x04\x04\x16\x02\
    \x01\x12\x04\xd2\x01\x08$\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xd2\x01\
    \x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xd2\x01\x11\x17\n\r\n\x05\
    \x04\x16\x02\x01\x01\x12\x04\xd2\x01\x18\x1f\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\xd2\x01\"#\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xd3\x01\x08(\
    \n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xd3\x01\x08\x10\n\r\n\x05\x04\x16\
    \x02\x02\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\
    \x04\xd3\x01\x18#\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xd3\x01&'\n\r\n\
    \x04\x04\x16\x02\x03\x12\x05\xd4\x01\x08\x84\x01\n\r\n\x05\x04\x16\x02\
    \x03\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\
    \xd4\x01\x11\x17\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xd4\x01\x18\x20\n\
    \r\n\x05\x04\x16\x02\x03\x03\x12\x04\xd4\x01#$\n\x0e\n\x05\x04\x16\x02\
    \x03\x08\x12\x05\xd4\x01%\x83\x01\n\r\n\x05\x04\x16\x02\x03\x07\x12\x04\
    \xd4\x0101\n\x11\n\x08\x04\x16\x02\x03\x08\xd0\x86\x03\x12\x05\xd4\x013\
    \x82\x01\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\xd5\x01\x08Y\n\r\n\x05\x04\
    \x16\x02\x04\x04\x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x16\x02\x04\x05\
    \x12\x04\xd5\x01\x11\x17\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\xd5\x01\
    \x18$\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\xd5\x01'(\n\r\n\x05\x04\x16\
    \x02\x04\x08\x12\x04\xd5\x01)X\n\x10\n\x08\x04\x16\x02\x04\x08\xd0\x86\
    \x03\x12\x04\xd5\x01*W\n\x0c\n\x02\x04\x17\x12\x06\xd8\x01\0\xdd\x01\x01\
    \n\x0b\n\x03\x04\x17\x01\x12\x04\xd8\x01\x08+\n\x0c\n\x04\x04\x17\x02\0\
    \x12\x04\xd9\x01\x08)\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xd9\x01\x08\
    \x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\xd9\x01\x18$\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\
    \xd9\x01'(\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xda\x01\x08\"\n\r\n\x05\
    \x04\x17\x02\x01\x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x17\x02\x01\
    \x05\x12\x04\xda\x01\x11\x15\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xda\
    \x01\x16\x1d\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xda\x01\x20!\n\x0c\n\
    \x04\x04\x17\x02\x02\x12\x04\xdb\x01\x08\"\n\r\n\x05\x04\x17\x02\x02\x04\
    \x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xdb\x01\
    \x11\x16\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xdb\x01\x17\x1d\n\r\n\x05\
    \x04\x17\x02\x02\x03\x12\x04\xdb\x01\x20!\n\x0c\n\x04\x04\x17\x02\x03\
    \x12\x04\xdc\x01\x081\n\r\n\x05\x04\x17\x02\x03\x04\x12\x04\xdc\x01\x08\
    \x10\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xdc\x01\x11\x16\n\r\n\x05\x04\
    \x17\x02\x03\x01\x12\x04\xdc\x01\x17,\n\r\n\x05\x04\x17\x02\x03\x03\x12\
    \x04\xdc\x01/0\n\x0c\n\x02\x04\x18\x12\x06\xdf\x01\0\xe2\x01\x01\n\x0b\n\
    \x03\x04\x18\x01\x12\x04\xdf\x01\x081\n\x0c\n\x04\x04\x18\x02\0\x12\x04\
    \xe0\x01\x08%\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xe0\x01\x08\x10\n\r\n\
    \x05\x04\x18\x02\0\x05\x12\x04\xe0\x01\x11\x18\n\r\n\x05\x04\x18\x02\0\
    \x01\x12\x04\xe0\x01\x19\x20\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xe0\x01\
    #$\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xe1\x01\x08\"\n\r\n\x05\x04\x18\
    \x02\x01\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\
    \x04\xe1\x01\x11\x17\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xe1\x01\x18\
    \x1d\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xe1\x01\x20!\n\x0c\n\x02\x04\
    \x19\x12\x06\xe4\x01\0\xe8\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xe4\
    \x01\x082\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xe5\x01\x08\"\n\r\n\x05\x04\
    \x19\x02\0\x04\x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\
    \x04\xe5\x01\x11\x16\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xe5\x01\x17\x1d\
    \n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xe5\x01\x20!\n\x0c\n\x04\x04\x19\
    \x02\x01\x12\x04\xe6\x01\x08%\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xe6\
    \x01\x08\x10\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xe6\x01\x11\x18\n\r\n\
    \x05\x04\x19\x02\x01\x01\x12\x04\xe6\x01\x19\x20\n\r\n\x05\x04\x19\x02\
    \x01\x03\x12\x04\xe6\x01#$\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xe7\x01\
    \x08\"\n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\
    \x04\x19\x02\x02\x05\x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\x19\x02\x02\
    \x01\x12\x04\xe7\x01\x18\x1d\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xe7\
    \x01\x20!\n\x0c\n\x02\x04\x1a\x12\x06\xea\x01\0\xee\x01\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\xea\x01\x080\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xeb\
    \x01\x08%\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xeb\x01\x08\x10\n\r\n\x05\
    \x04\x1a\x02\0\x05\x12\x04\xeb\x01\x11\x18\n\r\n\x05\x04\x1a\x02\0\x01\
    \x12\x04\xeb\x01\x19\x20\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xeb\x01#$\n\
    \x0c\n\x04\x04\x1a\x02\x01\x12\x04\xec\x01\x08*\n\r\n\x05\x04\x1a\x02\
    \x01\x04\x12\x04\xec\x01\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\
    \xec\x01\x11\x18\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xec\x01\x19%\n\r\
    \n\x05\x04\x1a\x02\x01\x03\x12\x04\xec\x01()\n\x0c\n\x04\x04\x1a\x02\x02\
    \x12\x04\xed\x01\x08\x20\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\xed\x01\
    \x08\x10\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xed\x01\x11\x15\n\r\n\x05\
    \x04\x1a\x02\x02\x01\x12\x04\xed\x01\x16\x1b\n\r\n\x05\x04\x1a\x02\x02\
    \x03\x12\x04\xed\x01\x1e\x1f\n\x0c\n\x02\x04\x1b\x12\x06\xf0\x01\0\xf1\
    \x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xf0\x01\x081\n\x0c\n\x02\x04\
    \x1c\x12\x06\xf3\x01\0\xf6\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xf3\
    \x01\x08-\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xf4\x01\x08%\n\r\n\x05\x04\
    \x1c\x02\0\x04\x12\x04\xf4\x01\x08\x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\
    \x04\xf4\x01\x11\x18\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf4\x01\x19\x20\
    \n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xf4\x01#$\n\x0c\n\x04\x04\x1c\x02\
    \x01\x12\x04\xf5\x01\x08*\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xf5\x01\
    \x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xf5\x01\x11\x18\n\r\n\x05\
    \x04\x1c\x02\x01\x01\x12\x04\xf5\x01\x19%\n\r\n\x05\x04\x1c\x02\x01\x03\
    \x12\x04\xf5\x01()\n\x0c\n\x02\x04\x1d\x12\x06\xf8\x01\0\xf9\x01\x01\n\
    \x0b\n\x03\x04\x1d\x01\x12\x04\xf8\x01\x08.\n\x0c\n\x02\x04\x1e\x12\x06\
    \xfb\x01\0\xfe\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xfb\x01\x084\n\
    \x0c\n\x04\x04\x1e\x02\0\x12\x04\xfc\x01\x08%\n\r\n\x05\x04\x1e\x02\0\
    \x04\x12\x04\xfc\x01\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xfc\x01\
    \x11\x18\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xfc\x01\x19\x20\n\r\n\x05\
    \x04\x1e\x02\0\x03\x12\x04\xfc\x01#$\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\
    \xfd\x01\x08*\n\r\n\x05\x04\x1e\x02\x01\x04\x12\x04\xfd\x01\x08\x10\n\r\
    \n\x05\x04\x1e\x02\x01\x05\x12\x04\xfd\x01\x11\x18\n\r\n\x05\x04\x1e\x02\
    \x01\x01\x12\x04\xfd\x01\x19%\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xfd\
    \x01()\n\x0c\n\x02\x04\x1f\x12\x06\x80\x02\0\x87\x02\x01\n\x0b\n\x03\x04\
    \x1f\x01\x12\x04\x80\x02\x085\n\x0e\n\x04\x04\x1f\x03\0\x12\x06\x81\x02\
    \x08\x84\x02\t\n\r\n\x05\x04\x1f\x03\0\x01\x12\x04\x81\x02\x10\x1b\n\x0e\
    \n\x06\x04\x1f\x03\0\x02\0\x12\x04\x82\x02\x10.\n\x0f\n\x07\x04\x1f\x03\
    \0\x02\0\x04\x12\x04\x82\x02\x10\x18\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x05\
    \x12\x04\x82\x02\x19\x20\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x01\x12\x04\x82\
    \x02!)\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x03\x12\x04\x82\x02,-\n\x0e\n\x06\
    \x04\x1f\x03\0\x02\x01\x12\x04\x83\x02\x10,\n\x0f\n\x07\x04\x1f\x03\0\
    \x02\x01\x04\x12\x04\x83\x02\x10\x18\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\
    \x05\x12\x04\x83\x02\x19\x1f\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x01\x12\
    \x04\x83\x02\x20'\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x03\x12\x04\x83\x02*\
    +\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x86\x02\x08^\n\r\n\x05\x04\x1f\x02\0\
    \x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\x86\x02\
    \x11K\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x86\x02LY\n\r\n\x05\x04\x1f\
    \x02\0\x03\x12\x04\x86\x02\\]\n\x0c\n\x02\x04\x20\x12\x06\x89\x02\0\x8f\
    \x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x89\x02\x08)\n\x0c\n\x04\x04\
    \x20\x02\0\x12\x04\x8a\x02\x08%\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\x8a\
    \x02\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x8a\x02\x11\x18\n\r\n\
    \x05\x04\x20\x02\0\x01\x12\x04\x8a\x02\x19\x20\n\r\n\x05\x04\x20\x02\0\
    \x03\x12\x04\x8a\x02#$\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x8b\x02\x082\
    \n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\x20\
    \x02\x01\x05\x12\x04\x8b\x02\x11\x18\n\r\n\x05\x04\x20\x02\x01\x01\x12\
    \x04\x8b\x02\x19-\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x8b\x0201\n\x0c\
    \n\x04\x04\x20\x02\x02\x12\x04\x8c\x02\x08)\n\r\n\x05\x04\x20\x02\x02\
    \x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\x8c\
    \x02\x11\x16\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x8c\x02\x17$\n\r\n\
    \x05\x04\x20\x02\x02\x03\x12\x04\x8c\x02'(\n\x0c\n\x04\x04\x20\x02\x03\
    \x12\x04\x8d\x02\x08(\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x8d\x02\x08\
    \x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\x8d\x02\x11\x16\n\r\n\x05\x04\
    \x20\x02\x03\x01\x12\x04\x8d\x02\x17#\n\r\n\x05\x04\x20\x02\x03\x03\x12\
    \x04\x8d\x02&'\n\x0c\n\x04\x04\x20\x02\x04\x12\x04\x8e\x02\x08-\n\r\n\
    \x05\x04\x20\x02\x04\x04\x12\x04\x8e\x02\x08\x10\n\r\n\x05\x04\x20\x02\
    \x04\x05\x12\x04\x8e\x02\x11\x17\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\
    \x8e\x02\x18(\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\x8e\x02+,\n\x0c\n\
    \x02\x04!\x12\x06\x91\x02\0\x93\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\x91\
    \x02\x08*\n\x0c\n\x04\x04!\x02\0\x12\x04\x92\x02\x08/\n\r\n\x05\x04!\x02\
    \0\x04\x12\x04\x92\x02\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\x92\x02\
    \x11\x18\n\r\n\x05\x04!\x02\0\x01\x12\x04\x92\x02\x19*\n\r\n\x05\x04!\
    \x02\0\x03\x12\x04\x92\x02-.\n\x0c\n\x02\x04\"\x12\x06\x95\x02\0\x97\x02\
    \x01\n\x0b\n\x03\x04\"\x01\x12\x04\x95\x02\x08-\n\x0c\n\x04\x04\"\x02\0\
    \x12\x04\x96\x02\x08/\n\r\n\x05\x04\"\x02\0\x04\x12\x04\x96\x02\x08\x10\
    \n\r\n\x05\x04\"\x02\0\x05\x12\x04\x96\x02\x11\x18\n\r\n\x05\x04\"\x02\0\
    \x01\x12\x04\x96\x02\x19*\n\r\n\x05\x04\"\x02\0\x03\x12\x04\x96\x02-.\n\
    \x0c\n\x02\x04#\x12\x06\x99\x02\0\x9a\x02\x01\n\x0b\n\x03\x04#\x01\x12\
    \x04\x99\x02\x08.\n\x0c\n\x02\x04$\x12\x06\x9c\x02\0\xa1\x02\x01\n\x0b\n\
    \x03\x04$\x01\x12\x04\x9c\x02\x08)\n\x0c\n\x04\x04$\x02\0\x12\x04\x9d\
    \x02\x08J\n\r\n\x05\x04$\x02\0\x04\x12\x04\x9d\x02\x08\x10\n\r\n\x05\x04\
    $\x02\0\x05\x12\x04\x9d\x02\x11\x17\n\r\n\x05\x04$\x02\0\x01\x12\x04\x9d\
    \x02\x18)\n\r\n\x05\x04$\x02\0\x03\x12\x04\x9d\x02,-\n\r\n\x05\x04$\x02\
    \0\x08\x12\x04\x9d\x02.I\n\x10\n\x08\x04$\x02\0\x08\xd0\x86\x03\x12\x04\
    \x9d\x02/H\n\x0c\n\x04\x04$\x02\x01\x12\x04\x9e\x02\x08R\n\r\n\x05\x04$\
    \x02\x01\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\
    \x9e\x02\x11\x17\n\r\n\x05\x04$\x02\x01\x01\x12\x04\x9e\x02\x18\"\n\r\n\
    \x05\x04$\x02\x01\x03\x12\x04\x9e\x02%&\n\r\n\x05\x04$\x02\x01\x08\x12\
    \x04\x9e\x02'Q\n\x10\n\x08\x04$\x02\x01\x08\xd0\x86\x03\x12\x04\x9e\x02(\
    P\n\x0c\n\x04\x04$\x02\x02\x12\x04\x9f\x02\x08N\n\r\n\x05\x04$\x02\x02\
    \x04\x12\x04\x9f\x02\x08\x10\n\r\n\x05\x04$\x02\x02\x05\x12\x04\x9f\x02\
    \x11\x17\n\r\n\x05\x04$\x02\x02\x01\x12\x04\x9f\x02\x18\x20\n\r\n\x05\
    \x04$\x02\x02\x03\x12\x04\x9f\x02#$\n\r\n\x05\x04$\x02\x02\x08\x12\x04\
    \x9f\x02%M\n\x10\n\x08\x04$\x02\x02\x08\xd0\x86\x03\x12\x04\x9f\x02&L\n\
    \x0c\n\x04\x04$\x02\x03\x12\x04\xa0\x02\x08.\n\r\n\x05\x04$\x02\x03\x04\
    \x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xa0\x02\x11\
    \x17\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xa0\x02\x18)\n\r\n\x05\x04$\x02\
    \x03\x03\x12\x04\xa0\x02,-\n\x0c\n\x02\x04%\x12\x06\xa3\x02\0\xa4\x02\
    \x01\n\x0b\n\x03\x04%\x01\x12\x04\xa3\x02\x08*\n\x0c\n\x02\x04&\x12\x06\
    \xa6\x02\0\xa8\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xa6\x02\x08)\n\x0c\n\
    \x04\x04&\x02\0\x12\x04\xa7\x02\x08g\n\r\n\x05\x04&\x02\0\x04\x12\x04\
    \xa7\x02\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\xa7\x02\x11\x17\n\r\n\
    \x05\x04&\x02\0\x01\x12\x04\xa7\x02\x18)\n\r\n\x05\x04&\x02\0\x03\x12\
    \x04\xa7\x02,-\n\r\n\x05\x04&\x02\0\x08\x12\x04\xa7\x02.f\n\x10\n\x08\
    \x04&\x02\0\x08\xd0\x86\x03\x12\x04\xa7\x02/e\n\x0c\n\x02\x04'\x12\x06\
    \xaa\x02\0\xb5\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xaa\x02\x08*\n\x0c\n\
    \x04\x04'\x02\0\x12\x04\xab\x02\x08T\n\r\n\x05\x04'\x02\0\x04\x12\x04\
    \xab\x02\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\xab\x02\x11\x17\n\r\n\
    \x05\x04'\x02\0\x01\x12\x04\xab\x02\x18)\n\r\n\x05\x04'\x02\0\x03\x12\
    \x04\xab\x02,-\n\r\n\x05\x04'\x02\0\x08\x12\x04\xab\x02.S\n\x10\n\x08\
    \x04'\x02\0\x08\xd0\x86\x03\x12\x04\xab\x02/R\n\x0c\n\x04\x04'\x02\x01\
    \x12\x04\xac\x02\x08R\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xac\x02\x08\x10\
    \n\r\n\x05\x04'\x02\x01\x05\x12\x04\xac\x02\x11\x17\n\r\n\x05\x04'\x02\
    \x01\x01\x12\x04\xac\x02\x18\x20\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xac\
    \x02#$\n\r\n\x05\x04'\x02\x01\x08\x12\x04\xac\x02%Q\n\x10\n\x08\x04'\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xac\x02&P\n\x0c\n\x04\x04'\x02\x02\x12\x04\
    \xad\x02\x08P\n\r\n\x05\x04'\x02\x02\x04\x12\x04\xad\x02\x08\x10\n\r\n\
    \x05\x04'\x02\x02\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04'\x02\x02\x01\
    \x12\x04\xad\x02\x18\"\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xad\x02%&\n\r\
    \n\x05\x04'\x02\x02\x08\x12\x04\xad\x02'O\n\x10\n\x08\x04'\x02\x02\x08\
    \xd0\x86\x03\x12\x04\xad\x02(N\n\x0c\n\x04\x04'\x02\x03\x12\x04\xae\x02\
    \x08T\n\r\n\x05\x04'\x02\x03\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04'\
    \x02\x03\x05\x12\x04\xae\x02\x11\x17\n\r\n\x05\x04'\x02\x03\x01\x12\x04\
    \xae\x02\x18\x1e\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xae\x02!\"\n\r\n\x05\
    \x04'\x02\x03\x08\x12\x04\xae\x02#S\n\x10\n\x08\x04'\x02\x03\x08\xd0\x86\
    \x03\x12\x04\xae\x02$R\n\x0c\n\x04\x04'\x02\x04\x12\x04\xaf\x02\x08`\n\r\
    \n\x05\x04'\x02\x04\x04\x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04'\x02\x04\
    \x05\x12\x04\xaf\x02\x11\x17\n\r\n\x05\x04'\x02\x04\x01\x12\x04\xaf\x02\
    \x18-\n\r\n\x05\x04'\x02\x04\x03\x12\x04\xaf\x0201\n\r\n\x05\x04'\x02\
    \x04\x08\x12\x04\xaf\x022_\n\x10\n\x08\x04'\x02\x04\x08\xd0\x86\x03\x12\
    \x04\xaf\x023^\n\x0c\n\x04\x04'\x02\x05\x12\x04\xb0\x02\x08]\n\r\n\x05\
    \x04'\x02\x05\x04\x12\x04\xb0\x02\x08\x10\n\r\n\x05\x04'\x02\x05\x05\x12\
    \x04\xb0\x02\x11\x17\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xb0\x02\x18+\n\r\
    \n\x05\x04'\x02\x05\x03\x12\x04\xb0\x02./\n\r\n\x05\x04'\x02\x05\x08\x12\
    \x04\xb0\x020\\\n\x10\n\x08\x04'\x02\x05\x08\xd0\x86\x03\x12\x04\xb0\x02\
    1[\n\x0c\n\x04\x04'\x02\x06\x12\x04\xb1\x02\x08i\n\r\n\x05\x04'\x02\x06\
    \x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04'\x02\x06\x05\x12\x04\xb1\x02\
    \x11\x17\n\r\n\x05\x04'\x02\x06\x01\x12\x04\xb1\x02\x18)\n\r\n\x05\x04'\
    \x02\x06\x03\x12\x04\xb1\x02,-\n\r\n\x05\x04'\x02\x06\x08\x12\x04\xb1\
    \x02.h\n\x10\n\x08\x04'\x02\x06\x08\xd0\x86\x03\x12\x04\xb1\x02/g\n\x0c\
    \n\x04\x04'\x02\x07\x12\x04\xb2\x02\x08_\n\r\n\x05\x04'\x02\x07\x04\x12\
    \x04\xb2\x02\x08\x10\n\r\n\x05\x04'\x02\x07\x05\x12\x04\xb2\x02\x11\x17\
    \n\r\n\x05\x04'\x02\x07\x01\x12\x04\xb2\x02\x18\"\n\r\n\x05\x04'\x02\x07\
    \x03\x12\x04\xb2\x02%&\n\r\n\x05\x04'\x02\x07\x08\x12\x04\xb2\x02'^\n\
    \x10\n\x08\x04'\x02\x07\x08\xd0\x86\x03\x12\x04\xb2\x02(]\n\x0c\n\x04\
    \x04'\x02\x08\x12\x04\xb3\x02\x08Z\n\r\n\x05\x04'\x02\x08\x04\x12\x04\
    \xb3\x02\x08\x10\n\r\n\x05\x04'\x02\x08\x05\x12\x04\xb3\x02\x11\x17\n\r\
    \n\x05\x04'\x02\x08\x01\x12\x04\xb3\x02\x18+\n\r\n\x05\x04'\x02\x08\x03\
    \x12\x04\xb3\x02./\n\r\n\x05\x04'\x02\x08\x08\x12\x04\xb3\x020Y\n\x10\n\
    \x08\x04'\x02\x08\x08\xd0\x86\x03\x12\x04\xb3\x021X\n\x0c\n\x04\x04'\x02\
    \t\x12\x04\xb4\x02\x08W\n\r\n\x05\x04'\x02\t\x04\x12\x04\xb4\x02\x08\x10\
    \n\r\n\x05\x04'\x02\t\x05\x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04'\x02\t\
    \x01\x12\x04\xb4\x02\x18&\n\r\n\x05\x04'\x02\t\x03\x12\x04\xb4\x02)+\n\r\
    \n\x05\x04'\x02\t\x08\x12\x04\xb4\x02,V\n\x10\n\x08\x04'\x02\t\x08\xd0\
    \x86\x03\x12\x04\xb4\x02-U\n\x0c\n\x02\x04(\x12\x06\xb7\x02\0\xc2\x02\
    \x01\n\x0b\n\x03\x04(\x01\x12\x04\xb7\x02\x08&\n\x0c\n\x04\x04(\x02\0\
    \x12\x04\xb8\x02\x080\n\r\n\x05\x04(\x02\0\x04\x12\x04\xb8\x02\x08\x10\n\
    \r\n\x05\x04(\x02\0\x05\x12\x04\xb8\x02\x11\x16\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\xb8\x02\x17+\n\r\n\x05\x04(\x02\0\x03\x12\x04\xb8\x02./\n\x0c\n\
    \x04\x04(\x02\x01\x12\x04\xb9\x02\x08'\n\r\n\x05\x04(\x02\x01\x04\x12\
    \x04\xb9\x02\x08\x10\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xb9\x02\x11\x15\
    \n\r\n\x05\x04(\x02\x01\x01\x12\x04\xb9\x02\x16\"\n\r\n\x05\x04(\x02\x01\
    \x03\x12\x04\xb9\x02%&\n\x0c\n\x04\x04(\x02\x02\x12\x04\xba\x02\x08+\n\r\
    \n\x05\x04(\x02\x02\x04\x12\x04\xba\x02\x08\x10\n\r\n\x05\x04(\x02\x02\
    \x05\x12\x04\xba\x02\x11\x16\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xba\x02\
    \x17&\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xba\x02)*\n\x0c\n\x04\x04(\x02\
    \x03\x12\x04\xbb\x02\x08#\n\r\n\x05\x04(\x02\x03\x04\x12\x04\xbb\x02\x08\
    \x10\n\r\n\x05\x04(\x02\x03\x05\x12\x04\xbb\x02\x11\x17\n\r\n\x05\x04(\
    \x02\x03\x01\x12\x04\xbb\x02\x18\x1e\n\r\n\x05\x04(\x02\x03\x03\x12\x04\
    \xbb\x02!\"\n\x0c\n\x04\x04(\x02\x04\x12\x04\xbc\x02\x08,\n\r\n\x05\x04(\
    \x02\x04\x04\x12\x04\xbc\x02\x08\x10\n\r\n\x05\x04(\x02\x04\x05\x12\x04\
    \xbc\x02\x11\x17\n\r\n\x05\x04(\x02\x04\x01\x12\x04\xbc\x02\x18'\n\r\n\
    \x05\x04(\x02\x04\x03\x12\x04\xbc\x02*+\n\r\n\x04\x04(\x02\x05\x12\x05\
    \xbd\x02\x08\xc2\x01\n\r\n\x05\x04(\x02\x05\x04\x12\x04\xbd\x02\x08\x10\
    \n\r\n\x05\x04(\x02\x05\x06\x12\x04\xbd\x02\x11*\n\r\n\x05\x04(\x02\x05\
    \x01\x12\x04\xbd\x02+D\n\r\n\x05\x04(\x02\x05\x03\x12\x04\xbd\x02GH\n\
    \x0e\n\x05\x04(\x02\x05\x08\x12\x05\xbd\x02I\xc1\x01\n\r\n\x05\x04(\x02\
    \x05\x07\x12\x04\xbd\x02Tt\n\x11\n\x08\x04(\x02\x05\x08\xd0\x86\x03\x12\
    \x05\xbd\x02v\xc0\x01\n\x0c\n\x04\x04(\x02\x06\x12\x04\xbe\x02\x08q\n\r\
    \n\x05\x04(\x02\x06\x04\x12\x04\xbe\x02\x08\x10\n\r\n\x05\x04(\x02\x06\
    \x05\x12\x04\xbe\x02\x11\x16\n\r\n\x05\x04(\x02\x06\x01\x12\x04\xbe\x02\
    \x17'\n\r\n\x05\x04(\x02\x06\x03\x12\x04\xbe\x02*+\n\r\n\x05\x04(\x02\
    \x06\x08\x12\x04\xbe\x02,p\n\x10\n\x08\x04(\x02\x06\x08\xd0\x86\x03\x12\
    \x04\xbe\x02-o\n\x0c\n\x04\x04(\x02\x07\x12\x04\xbf\x02\x08c\n\r\n\x05\
    \x04(\x02\x07\x04\x12\x04\xbf\x02\x08\x10\n\r\n\x05\x04(\x02\x07\x05\x12\
    \x04\xbf\x02\x11\x18\n\r\n\x05\x04(\x02\x07\x01\x12\x04\xbf\x02\x19\x20\
    \n\r\n\x05\x04(\x02\x07\x03\x12\x04\xbf\x02#$\n\r\n\x05\x04(\x02\x07\x08\
    \x12\x04\xbf\x02%b\n\x10\n\x08\x04(\x02\x07\x08\xd0\x86\x03\x12\x04\xbf\
    \x02&a\n\x0c\n\x04\x04(\x02\x08\x12\x04\xc0\x02\x08g\n\r\n\x05\x04(\x02\
    \x08\x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04(\x02\x08\x05\x12\x04\xc0\
    \x02\x11\x17\n\r\n\x05\x04(\x02\x08\x01\x12\x04\xc0\x02\x18'\n\r\n\x05\
    \x04(\x02\x08\x03\x12\x04\xc0\x02*+\n\r\n\x05\x04(\x02\x08\x08\x12\x04\
    \xc0\x02,f\n\x10\n\x08\x04(\x02\x08\x08\xd0\x86\x03\x12\x04\xc0\x02-e\n\
    \x0c\n\x04\x04(\x02\t\x12\x04\xc1\x02\x08Z\n\r\n\x05\x04(\x02\t\x04\x12\
    \x04\xc1\x02\x08\x10\n\r\n\x05\x04(\x02\t\x05\x12\x04\xc1\x02\x11\x15\n\
    \r\n\x05\x04(\x02\t\x01\x12\x04\xc1\x02\x16#\n\r\n\x05\x04(\x02\t\x03\
    \x12\x04\xc1\x02&(\n\r\n\x05\x04(\x02\t\x08\x12\x04\xc1\x02)Y\n\x10\n\
    \x08\x04(\x02\t\x08\xd0\x86\x03\x12\x04\xc1\x02*X\n\x0c\n\x02\x04)\x12\
    \x06\xc4\x02\0\xc5\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xc4\x02\x08'\n\
    \x0c\n\x02\x04*\x12\x06\xc7\x02\0\xca\x02\x01\n\x0b\n\x03\x04*\x01\x12\
    \x04\xc7\x02\x08&\n\x0c\n\x04\x04*\x02\0\x12\x04\xc8\x02\x08\x1f\n\r\n\
    \x05\x04*\x02\0\x04\x12\x04\xc8\x02\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\
    \x04\xc8\x02\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xc8\x02\x18\x1a\n\
    \r\n\x05\x04*\x02\0\x03\x12\x04\xc8\x02\x1d\x1e\n\x0c\n\x04\x04*\x02\x01\
    \x12\x04\xc9\x02\x08c\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xc9\x02\x08\x10\
    \n\r\n\x05\x04*\x02\x01\x05\x12\x04\xc9\x02\x11\x18\n\r\n\x05\x04*\x02\
    \x01\x01\x12\x04\xc9\x02\x19\x20\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xc9\
    \x02#$\n\r\n\x05\x04*\x02\x01\x08\x12\x04\xc9\x02%b\n\x10\n\x08\x04*\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xc9\x02&a\n\x0c\n\x02\x04+\x12\x06\xcc\x02\
    \0\xd8\x02\x01\n\x0b\n\x03\x04+\x01\x12\x04\xcc\x02\x08'\n\x0c\n\x04\x04\
    +\x02\0\x12\x04\xcd\x02\x080\n\r\n\x05\x04+\x02\0\x04\x12\x04\xcd\x02\
    \x08\x10\n\r\n\x05\x04+\x02\0\x05\x12\x04\xcd\x02\x11\x16\n\r\n\x05\x04+\
    \x02\0\x01\x12\x04\xcd\x02\x17+\n\r\n\x05\x04+\x02\0\x03\x12\x04\xcd\x02\
    ./\n\x0c\n\x04\x04+\x02\x01\x12\x04\xce\x02\x08&\n\r\n\x05\x04+\x02\x01\
    \x04\x12\x04\xce\x02\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xce\x02\
    \x11\x17\n\r\n\x05\x04+\x02\x01\x01\x12\x04\xce\x02\x18!\n\r\n\x05\x04+\
    \x02\x01\x03\x12\x04\xce\x02$%\n\x0c\n\x04\x04+\x02\x02\x12\x04\xcf\x02\
    \x08'\n\r\n\x05\x04+\x02\x02\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04+\
    \x02\x02\x05\x12\x04\xcf\x02\x11\x17\n\r\n\x05\x04+\x02\x02\x01\x12\x04\
    \xcf\x02\x18\"\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xcf\x02%&\n\x0c\n\x04\
    \x04+\x02\x03\x12\x04\xd0\x02\x08+\n\r\n\x05\x04+\x02\x03\x04\x12\x04\
    \xd0\x02\x08\x10\n\r\n\x05\x04+\x02\x03\x05\x12\x04\xd0\x02\x11\x16\n\r\
    \n\x05\x04+\x02\x03\x01\x12\x04\xd0\x02\x17&\n\r\n\x05\x04+\x02\x03\x03\
    \x12\x04\xd0\x02)*\n\x0c\n\x04\x04+\x02\x04\x12\x04\xd1\x02\x08#\n\r\n\
    \x05\x04+\x02\x04\x04\x12\x04\xd1\x02\x08\x10\n\r\n\x05\x04+\x02\x04\x05\
    \x12\x04\xd1\x02\x11\x17\n\r\n\x05\x04+\x02\x04\x01\x12\x04\xd1\x02\x18\
    \x1e\n\r\n\x05\x04+\x02\x04\x03\x12\x04\xd1\x02!\"\n\x0c\n\x04\x04+\x02\
    \x05\x12\x04\xd2\x02\x08,\n\r\n\x05\x04+\x02\x05\x04\x12\x04\xd2\x02\x08\
    \x10\n\r\n\x05\x04+\x02\x05\x05\x12\x04\xd2\x02\x11\x17\n\r\n\x05\x04+\
    \x02\x05\x01\x12\x04\xd2\x02\x18'\n\r\n\x05\x04+\x02\x05\x03\x12\x04\xd2\
    \x02*+\n\r\n\x04\x04+\x02\x06\x12\x05\xd3\x02\x08\xc2\x01\n\r\n\x05\x04+\
    \x02\x06\x04\x12\x04\xd3\x02\x08\x10\n\r\n\x05\x04+\x02\x06\x06\x12\x04\
    \xd3\x02\x11*\n\r\n\x05\x04+\x02\x06\x01\x12\x04\xd3\x02+D\n\r\n\x05\x04\
    +\x02\x06\x03\x12\x04\xd3\x02GH\n\x0e\n\x05\x04+\x02\x06\x08\x12\x05\xd3\
    \x02I\xc1\x01\n\r\n\x05\x04+\x02\x06\x07\x12\x04\xd3\x02Tt\n\x11\n\x08\
    \x04+\x02\x06\x08\xd0\x86\x03\x12\x05\xd3\x02v\xc0\x01\n\x0c\n\x04\x04+\
    \x02\x07\x12\x04\xd4\x02\x08b\n\r\n\x05\x04+\x02\x07\x04\x12\x04\xd4\x02\
    \x08\x10\n\r\n\x05\x04+\x02\x07\x05\x12\x04\xd4\x02\x11\x16\n\r\n\x05\
    \x04+\x02\x07\x01\x12\x04\xd4\x02\x17'\n\r\n\x05\x04+\x02\x07\x03\x12\
    \x04\xd4\x02*+\n\r\n\x05\x04+\x02\x07\x08\x12\x04\xd4\x02,a\n\x10\n\x08\
    \x04+\x02\x07\x08\xd0\x86\x03\x12\x04\xd4\x02-`\n\x0c\n\x04\x04+\x02\x08\
    \x12\x04\xd5\x02\x08M\n\r\n\x05\x04+\x02\x08\x04\x12\x04\xd5\x02\x08\x10\
    \n\r\n\x05\x04+\x02\x08\x05\x12\x04\xd5\x02\x11\x18\n\r\n\x05\x04+\x02\
    \x08\x01\x12\x04\xd5\x02\x19\x20\n\r\n\x05\x04+\x02\x08\x03\x12\x04\xd5\
    \x02#$\n\r\n\x05\x04+\x02\x08\x08\x12\x04\xd5\x02%L\n\x10\n\x08\x04+\x02\
    \x08\x08\xd0\x86\x03\x12\x04\xd5\x02&K\n\x0c\n\x04\x04+\x02\t\x12\x04\
    \xd6\x02\x08h\n\r\n\x05\x04+\x02\t\x04\x12\x04\xd6\x02\x08\x10\n\r\n\x05\
    \x04+\x02\t\x05\x12\x04\xd6\x02\x11\x17\n\r\n\x05\x04+\x02\t\x01\x12\x04\
    \xd6\x02\x18'\n\r\n\x05\x04+\x02\t\x03\x12\x04\xd6\x02*,\n\r\n\x05\x04+\
    \x02\t\x08\x12\x04\xd6\x02-g\n\x10\n\x08\x04+\x02\t\x08\xd0\x86\x03\x12\
    \x04\xd6\x02.f\n\x0c\n\x04\x04+\x02\n\x12\x04\xd7\x02\x08Z\n\r\n\x05\x04\
    +\x02\n\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04+\x02\n\x05\x12\x04\xd7\
    \x02\x11\x15\n\r\n\x05\x04+\x02\n\x01\x12\x04\xd7\x02\x16#\n\r\n\x05\x04\
    +\x02\n\x03\x12\x04\xd7\x02&(\n\r\n\x05\x04+\x02\n\x08\x12\x04\xd7\x02)Y\
    \n\x10\n\x08\x04+\x02\n\x08\xd0\x86\x03\x12\x04\xd7\x02*X\n\x0c\n\x02\
    \x04,\x12\x06\xda\x02\0\xdd\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xda\x02\
    \x084\n\x0c\n\x04\x04,\x02\0\x12\x04\xdb\x02\x082\n\r\n\x05\x04,\x02\0\
    \x04\x12\x04\xdb\x02\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\xdb\x02\
    \x11\x18\n\r\n\x05\x04,\x02\0\x01\x12\x04\xdb\x02\x19-\n\r\n\x05\x04,\
    \x02\0\x03\x12\x04\xdb\x0201\n\x0c\n\x04\x04,\x02\x01\x12\x04\xdc\x02\
    \x08(\n\r\n\x05\x04,\x02\x01\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04,\
    \x02\x01\x05\x12\x04\xdc\x02\x11\x17\n\r\n\x05\x04,\x02\x01\x01\x12\x04\
    \xdc\x02\x18#\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xdc\x02&'\n\x0c\n\x02\
    \x04-\x12\x06\xdf\x02\0\xe6\x02\x01\n\x0b\n\x03\x04-\x01\x12\x04\xdf\x02\
    \x08,\n\x0c\n\x04\x04-\x02\0\x12\x04\xe0\x02\x08/\n\r\n\x05\x04-\x02\0\
    \x04\x12\x04\xe0\x02\x08\x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\xe0\x02\
    \x11\x18\n\r\n\x05\x04-\x02\0\x01\x12\x04\xe0\x02\x19*\n\r\n\x05\x04-\
    \x02\0\x03\x12\x04\xe0\x02-.\n\x0c\n\x04\x04-\x02\x01\x12\x04\xe1\x02\
    \x08\"\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xe1\x02\x08\x10\n\r\n\x05\x04-\
    \x02\x01\x05\x12\x04\xe1\x02\x11\x15\n\r\n\x05\x04-\x02\x01\x01\x12\x04\
    \xe1\x02\x16\x1d\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xe1\x02\x20!\n\x0c\n\
    \x04\x04-\x02\x02\x12\x04\xe2\x02\x08\"\n\r\n\x05\x04-\x02\x02\x04\x12\
    \x04\xe2\x02\x08\x10\n\r\n\x05\x04-\x02\x02\x05\x12\x04\xe2\x02\x11\x17\
    \n\r\n\x05\x04-\x02\x02\x01\x12\x04\xe2\x02\x18\x1d\n\r\n\x05\x04-\x02\
    \x02\x03\x12\x04\xe2\x02\x20!\n\x0c\n\x04\x04-\x02\x03\x12\x04\xe3\x02\
    \x08)\n\r\n\x05\x04-\x02\x03\x04\x12\x04\xe3\x02\x08\x10\n\r\n\x05\x04-\
    \x02\x03\x05\x12\x04\xe3\x02\x11\x17\n\r\n\x05\x04-\x02\x03\x01\x12\x04\
    \xe3\x02\x18$\n\r\n\x05\x04-\x02\x03\x03\x12\x04\xe3\x02'(\n\x0c\n\x04\
    \x04-\x02\x04\x12\x04\xe4\x02\x08)\n\r\n\x05\x04-\x02\x04\x04\x12\x04\
    \xe4\x02\x08\x10\n\r\n\x05\x04-\x02\x04\x05\x12\x04\xe4\x02\x11\x17\n\r\
    \n\x05\x04-\x02\x04\x01\x12\x04\xe4\x02\x18$\n\r\n\x05\x04-\x02\x04\x03\
    \x12\x04\xe4\x02'(\n\x0c\n\x04\x04-\x02\x05\x12\x04\xe5\x02\x08\x20\n\r\
    \n\x05\x04-\x02\x05\x04\x12\x04\xe5\x02\x08\x10\n\r\n\x05\x04-\x02\x05\
    \x05\x12\x04\xe5\x02\x11\x17\n\r\n\x05\x04-\x02\x05\x01\x12\x04\xe5\x02\
    \x18\x1b\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xe5\x02\x1e\x1f\n\x0c\n\x02\
    \x04.\x12\x06\xe8\x02\0\xe9\x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\xe8\x02\
    \x08-\n\x0c\n\x02\x04/\x12\x06\xeb\x02\0\xed\x02\x01\n\x0b\n\x03\x04/\
    \x01\x12\x04\xeb\x02\x08(\n\x0c\n\x04\x04/\x02\0\x12\x04\xec\x02\x08/\n\
    \r\n\x05\x04/\x02\0\x04\x12\x04\xec\x02\x08\x10\n\r\n\x05\x04/\x02\0\x05\
    \x12\x04\xec\x02\x11\x18\n\r\n\x05\x04/\x02\0\x01\x12\x04\xec\x02\x19*\n\
    \r\n\x05\x04/\x02\0\x03\x12\x04\xec\x02-.\n\x0c\n\x02\x040\x12\x06\xef\
    \x02\0\xf0\x02\x01\n\x0b\n\x03\x040\x01\x12\x04\xef\x02\x08)\n\x0c\n\x02\
    \x041\x12\x06\xf2\x02\0\xf6\x02\x01\n\x0b\n\x03\x041\x01\x12\x04\xf2\x02\
    \x08*\n\x0c\n\x04\x041\x02\0\x12\x04\xf3\x02\x081\n\r\n\x05\x041\x02\0\
    \x04\x12\x04\xf3\x02\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xf3\x02\
    \x11\x18\n\r\n\x05\x041\x02\0\x01\x12\x04\xf3\x02\x19,\n\r\n\x05\x041\
    \x02\0\x03\x12\x04\xf3\x02/0\n\x0c\n\x04\x041\x02\x01\x12\x04\xf4\x02\
    \x08/\n\r\n\x05\x041\x02\x01\x04\x12\x04\xf4\x02\x08\x10\n\r\n\x05\x041\
    \x02\x01\x05\x12\x04\xf4\x02\x11\x18\n\r\n\x05\x041\x02\x01\x01\x12\x04\
    \xf4\x02\x19*\n\r\n\x05\x041\x02\x01\x03\x12\x04\xf4\x02-.\n\x0c\n\x04\
    \x041\x02\x02\x12\x04\xf5\x02\x08#\n\r\n\x05\x041\x02\x02\x04\x12\x04\
    \xf5\x02\x08\x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xf5\x02\x11\x17\n\r\
    \n\x05\x041\x02\x02\x01\x12\x04\xf5\x02\x18\x1e\n\r\n\x05\x041\x02\x02\
    \x03\x12\x04\xf5\x02!\"\n\x0c\n\x02\x042\x12\x06\xf8\x02\0\xf9\x02\x01\n\
    \x0b\n\x03\x042\x01\x12\x04\xf8\x02\x08+\n\x0c\n\x02\x043\x12\x06\xfb\
    \x02\0\xfd\x02\x01\n\x0b\n\x03\x043\x01\x12\x04\xfb\x02\x081\n\x0c\n\x04\
    \x043\x02\0\x12\x04\xfc\x02\x08#\n\r\n\x05\x043\x02\0\x04\x12\x04\xfc\
    \x02\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\xfc\x02\x11\x17\n\r\n\x05\
    \x043\x02\0\x01\x12\x04\xfc\x02\x18\x1e\n\r\n\x05\x043\x02\0\x03\x12\x04\
    \xfc\x02!\"\n\x0c\n\x02\x044\x12\x06\xff\x02\0\x81\x03\x01\n\x0b\n\x03\
    \x044\x01\x12\x04\xff\x02\x082\n\x0c\n\x04\x044\x02\0\x12\x04\x80\x03\
    \x08(\n\r\n\x05\x044\x02\0\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\x044\
    \x02\0\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\x044\x02\0\x01\x12\x04\x80\
    \x03\x18#\n\r\n\x05\x044\x02\0\x03\x12\x04\x80\x03&'\n\x0c\n\x02\x045\
    \x12\x06\x83\x03\0\x87\x03\x01\n\x0b\n\x03\x045\x01\x12\x04\x83\x03\x08#\
    \n\x0c\n\x04\x045\x02\0\x12\x04\x84\x03\x08$\n\r\n\x05\x045\x02\0\x04\
    \x12\x04\x84\x03\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\x84\x03\x11\
    \x17\n\r\n\x05\x045\x02\0\x01\x12\x04\x84\x03\x18\x1f\n\r\n\x05\x045\x02\
    \0\x03\x12\x04\x84\x03\"#\n\x0c\n\x04\x045\x02\x01\x12\x04\x85\x03\x08+\
    \n\r\n\x05\x045\x02\x01\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x045\x02\
    \x01\x05\x12\x04\x85\x03\x11\x16\n\r\n\x05\x045\x02\x01\x01\x12\x04\x85\
    \x03\x17&\n\r\n\x05\x045\x02\x01\x03\x12\x04\x85\x03)*\n\x0c\n\x04\x045\
    \x02\x02\x12\x04\x86\x03\x08&\n\r\n\x05\x045\x02\x02\x04\x12\x04\x86\x03\
    \x08\x10\n\r\n\x05\x045\x02\x02\x05\x12\x04\x86\x03\x11\x17\n\r\n\x05\
    \x045\x02\x02\x01\x12\x04\x86\x03\x18!\n\r\n\x05\x045\x02\x02\x03\x12\
    \x04\x86\x03$%\n\x0c\n\x02\x046\x12\x06\x89\x03\0\x8c\x03\x01\n\x0b\n\
    \x03\x046\x01\x12\x04\x89\x03\x081\n\x0c\n\x04\x046\x02\0\x12\x04\x8a\
    \x03\x08/\n\r\n\x05\x046\x02\0\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\
    6\x02\0\x05\x12\x04\x8a\x03\x11\x18\n\r\n\x05\x046\x02\0\x01\x12\x04\x8a\
    \x03\x19*\n\r\n\x05\x046\x02\0\x03\x12\x04\x8a\x03-.\n\x0c\n\x04\x046\
    \x02\x01\x12\x04\x8b\x03\x08<\n\r\n\x05\x046\x02\x01\x04\x12\x04\x8b\x03\
    \x08\x10\n\r\n\x05\x046\x02\x01\x06\x12\x04\x8b\x03\x11-\n\r\n\x05\x046\
    \x02\x01\x01\x12\x04\x8b\x03.7\n\r\n\x05\x046\x02\x01\x03\x12\x04\x8b\
    \x03:;\n\x0c\n\x02\x047\x12\x06\x8e\x03\0\x8f\x03\x01\n\x0b\n\x03\x047\
    \x01\x12\x04\x8e\x03\x082\n\x0c\n\x02\x048\x12\x06\x91\x03\0\x95\x03\x01\
    \n\x0b\n\x03\x048\x01\x12\x04\x91\x03\x083\n\x0c\n\x04\x048\x02\0\x12\
    \x04\x92\x03\x081\n\r\n\x05\x048\x02\0\x04\x12\x04\x92\x03\x08\x10\n\r\n\
    \x05\x048\x02\0\x05\x12\x04\x92\x03\x11\x18\n\r\n\x05\x048\x02\0\x01\x12\
    \x04\x92\x03\x19,\n\r\n\x05\x048\x02\0\x03\x12\x04\x92\x03/0\n\x0c\n\x04\
    \x048\x02\x01\x12\x04\x93\x03\x08/\n\r\n\x05\x048\x02\x01\x04\x12\x04\
    \x93\x03\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\x04\x93\x03\x11\x18\n\r\
    \n\x05\x048\x02\x01\x01\x12\x04\x93\x03\x19*\n\r\n\x05\x048\x02\x01\x03\
    \x12\x04\x93\x03-.\n\x0c\n\x04\x048\x02\x02\x12\x04\x94\x03\x08<\n\r\n\
    \x05\x048\x02\x02\x04\x12\x04\x94\x03\x08\x10\n\r\n\x05\x048\x02\x02\x06\
    \x12\x04\x94\x03\x11-\n\r\n\x05\x048\x02\x02\x01\x12\x04\x94\x03.7\n\r\n\
    \x05\x048\x02\x02\x03\x12\x04\x94\x03:;\n\x0c\n\x02\x049\x12\x06\x97\x03\
    \0\x98\x03\x01\n\x0b\n\x03\x049\x01\x12\x04\x97\x03\x084\n\x0c\n\x02\x04\
    :\x12\x06\x9a\x03\0\x9e\x03\x01\n\x0b\n\x03\x04:\x01\x12\x04\x9a\x03\x08\
    2\n\x0c\n\x04\x04:\x02\0\x12\x04\x9b\x03\x081\n\r\n\x05\x04:\x02\0\x04\
    \x12\x04\x9b\x03\x08\x10\n\r\n\x05\x04:\x02\0\x05\x12\x04\x9b\x03\x11\
    \x18\n\r\n\x05\x04:\x02\0\x01\x12\x04\x9b\x03\x19,\n\r\n\x05\x04:\x02\0\
    \x03\x12\x04\x9b\x03/0\n\x0c\n\x04\x04:\x02\x01\x12\x04\x9c\x03\x08/\n\r\
    \n\x05\x04:\x02\x01\x04\x12\x04\x9c\x03\x08\x10\n\r\n\x05\x04:\x02\x01\
    \x05\x12\x04\x9c\x03\x11\x18\n\r\n\x05\x04:\x02\x01\x01\x12\x04\x9c\x03\
    \x19*\n\r\n\x05\x04:\x02\x01\x03\x12\x04\x9c\x03-.\n\x0c\n\x04\x04:\x02\
    \x02\x12\x04\x9d\x03\x081\n\r\n\x05\x04:\x02\x02\x04\x12\x04\x9d\x03\x08\
    \x10\n\r\n\x05\x04:\x02\x02\x05\x12\x04\x9d\x03\x11\x17\n\r\n\x05\x04:\
    \x02\x02\x01\x12\x04\x9d\x03\x18,\n\r\n\x05\x04:\x02\x02\x03\x12\x04\x9d\
    \x03/0\n\x0c\n\x02\x04;\x12\x06\xa0\x03\0\xa3\x03\x01\n\x0b\n\x03\x04;\
    \x01\x12\x04\xa0\x03\x083\n\x0c\n\x04\x04;\x02\0\x12\x04\xa1\x03\x081\n\
    \r\n\x05\x04;\x02\0\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04;\x02\0\x05\
    \x12\x04\xa1\x03\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\xa1\x03\x18,\n\
    \r\n\x05\x04;\x02\0\x03\x12\x04\xa1\x03/0\n\x0c\n\x04\x04;\x02\x01\x12\
    \x04\xa2\x03\x08=\n\r\n\x05\x04;\x02\x01\x04\x12\x04\xa2\x03\x08\x10\n\r\
    \n\x05\x04;\x02\x01\x06\x12\x04\xa2\x03\x11-\n\r\n\x05\x04;\x02\x01\x01\
    \x12\x04\xa2\x03.8\n\r\n\x05\x04;\x02\x01\x03\x12\x04\xa2\x03;<\n\x0c\n\
    \x02\x04<\x12\x06\xa5\x03\0\xab\x03\x01\n\x0b\n\x03\x04<\x01\x12\x04\xa5\
    \x03\x082\n\x0c\n\x04\x04<\x02\0\x12\x04\xa6\x03\x08h\n\r\n\x05\x04<\x02\
    \0\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04<\x02\0\x05\x12\x04\xa6\x03\
    \x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\xa6\x03\x18!\n\r\n\x05\x04<\
    \x02\0\x03\x12\x04\xa6\x03$%\n\r\n\x05\x04<\x02\0\x08\x12\x04\xa6\x03&g\
    \n\r\n\x05\x04<\x02\0\x07\x12\x04\xa6\x0314\n\x10\n\x08\x04<\x02\0\x08\
    \xd0\x86\x03\x12\x04\xa6\x036f\n\x0c\n\x04\x04<\x02\x01\x12\x04\xa7\x03\
    \x08S\n\r\n\x05\x04<\x02\x01\x04\x12\x04\xa7\x03\x08\x10\n\r\n\x05\x04<\
    \x02\x01\x05\x12\x04\xa7\x03\x11\x17\n\r\n\x05\x04<\x02\x01\x01\x12\x04\
    \xa7\x03\x18\"\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xa7\x03%&\n\r\n\x05\
    \x04<\x02\x01\x08\x12\x04\xa7\x03'R\n\r\n\x05\x04<\x02\x01\x07\x12\x04\
    \xa7\x0323\n\x10\n\x08\x04<\x02\x01\x08\xd0\x86\x03\x12\x04\xa7\x035Q\n\
    \x0c\n\x04\x04<\x02\x02\x12\x04\xa8\x03\x08t\n\r\n\x05\x04<\x02\x02\x04\
    \x12\x04\xa8\x03\x08\x10\n\r\n\x05\x04<\x02\x02\x05\x12\x04\xa8\x03\x11\
    \x17\n\r\n\x05\x04<\x02\x02\x01\x12\x04\xa8\x03\x18!\n\r\n\x05\x04<\x02\
    \x02\x03\x12\x04\xa8\x03$%\n\r\n\x05\x04<\x02\x02\x08\x12\x04\xa8\x03&s\
    \n\x10\n\x08\x04<\x02\x02\x08\xd0\x86\x03\x12\x04\xa8\x03'r\n\r\n\x04\
    \x04<\x02\x03\x12\x05\xa9\x03\x08\x8e\x01\n\r\n\x05\x04<\x02\x03\x04\x12\
    \x04\xa9\x03\x08\x10\n\r\n\x05\x04<\x02\x03\x05\x12\x04\xa9\x03\x11\x18\
    \n\r\n\x05\x04<\x02\x03\x01\x12\x04\xa9\x03\x19\x20\n\r\n\x05\x04<\x02\
    \x03\x03\x12\x04\xa9\x03#$\n\x0e\n\x05\x04<\x02\x03\x08\x12\x05\xa9\x03%\
    \x8d\x01\n\x11\n\x08\x04<\x02\x03\x08\xd0\x86\x03\x12\x05\xa9\x03&\x8c\
    \x01\n\x0c\n\x04\x04<\x02\x04\x12\x04\xaa\x03\x08z\n\r\n\x05\x04<\x02\
    \x04\x04\x12\x04\xaa\x03\x08\x10\n\r\n\x05\x04<\x02\x04\x05\x12\x04\xaa\
    \x03\x11\x17\n\r\n\x05\x04<\x02\x04\x01\x12\x04\xaa\x03\x18\"\n\r\n\x05\
    \x04<\x02\x04\x03\x12\x04\xaa\x03%&\n\r\n\x05\x04<\x02\x04\x08\x12\x04\
    \xaa\x03'y\n\x10\n\x08\x04<\x02\x04\x08\xd0\x86\x03\x12\x04\xaa\x03(x\n\
    \x0c\n\x02\x04=\x12\x06\xad\x03\0\xc6\x03\x01\n\x0b\n\x03\x04=\x01\x12\
    \x04\xad\x03\x083\n\x0e\n\x04\x04=\x03\0\x12\x06\xae\x03\x08\xc3\x03\t\n\
    \r\n\x05\x04=\x03\0\x01\x12\x04\xae\x03\x10\x1b\n\x0e\n\x06\x04=\x03\0\
    \x02\0\x12\x04\xaf\x03\x10G\n\x0f\n\x07\x04=\x03\0\x02\0\x04\x12\x04\xaf\
    \x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\0\x05\x12\x04\xaf\x03\x19\x1f\n\
    \x0f\n\x07\x04=\x03\0\x02\0\x01\x12\x04\xaf\x03\x20-\n\x0f\n\x07\x04=\
    \x03\0\x02\0\x03\x12\x04\xaf\x0301\n\x0f\n\x07\x04=\x03\0\x02\0\x08\x12\
    \x04\xaf\x032F\n\x12\n\n\x04=\x03\0\x02\0\x08\xd0\x86\x03\x12\x04\xaf\
    \x033E\n\x0e\n\x06\x04=\x03\0\x02\x01\x12\x04\xb0\x03\x10c\n\x0f\n\x07\
    \x04=\x03\0\x02\x01\x04\x12\x04\xb0\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\
    \x02\x01\x05\x12\x04\xb0\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x01\x01\
    \x12\x04\xb0\x03\x20,\n\x0f\n\x07\x04=\x03\0\x02\x01\x03\x12\x04\xb0\x03\
    /0\n\x0f\n\x07\x04=\x03\0\x02\x01\x08\x12\x04\xb0\x031b\n\x12\n\n\x04=\
    \x03\0\x02\x01\x08\xd0\x86\x03\x12\x04\xb0\x032a\n\x0e\n\x06\x04=\x03\0\
    \x02\x02\x12\x04\xb1\x03\x10b\n\x0f\n\x07\x04=\x03\0\x02\x02\x04\x12\x04\
    \xb1\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\x02\x05\x12\x04\xb1\x03\x19\
    \x1f\n\x0f\n\x07\x04=\x03\0\x02\x02\x01\x12\x04\xb1\x03\x200\n\x0f\n\x07\
    \x04=\x03\0\x02\x02\x03\x12\x04\xb1\x0334\n\x0f\n\x07\x04=\x03\0\x02\x02\
    \x08\x12\x04\xb1\x035a\n\x12\n\n\x04=\x03\0\x02\x02\x08\xd0\x86\x03\x12\
    \x04\xb1\x036`\n\x0e\n\x06\x04=\x03\0\x02\x03\x12\x04\xb2\x03\x10[\n\x0f\
    \n\x07\x04=\x03\0\x02\x03\x04\x12\x04\xb2\x03\x10\x18\n\x0f\n\x07\x04=\
    \x03\0\x02\x03\x05\x12\x04\xb2\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\
    \x03\x01\x12\x04\xb2\x03\x20+\n\x0f\n\x07\x04=\x03\0\x02\x03\x03\x12\x04\
    \xb2\x03./\n\x0f\n\x07\x04=\x03\0\x02\x03\x08\x12\x04\xb2\x030Z\n\x12\n\
    \n\x04=\x03\0\x02\x03\x08\xd0\x86\x03\x12\x04\xb2\x031Y\n\x0e\n\x06\x04=\
    \x03\0\x02\x04\x12\x04\xb3\x03\x10Z\n\x0f\n\x07\x04=\x03\0\x02\x04\x04\
    \x12\x04\xb3\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\x04\x05\x12\x04\xb3\
    \x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x04\x01\x12\x04\xb3\x03\x20,\n\
    \x0f\n\x07\x04=\x03\0\x02\x04\x03\x12\x04\xb3\x03/0\n\x0f\n\x07\x04=\x03\
    \0\x02\x04\x08\x12\x04\xb3\x031Y\n\x12\n\n\x04=\x03\0\x02\x04\x08\xd0\
    \x86\x03\x12\x04\xb3\x032X\n\x0e\n\x06\x04=\x03\0\x02\x05\x12\x04\xb4\
    \x03\x10X\n\x0f\n\x07\x04=\x03\0\x02\x05\x04\x12\x04\xb4\x03\x10\x18\n\
    \x0f\n\x07\x04=\x03\0\x02\x05\x05\x12\x04\xb4\x03\x19\x1f\n\x0f\n\x07\
    \x04=\x03\0\x02\x05\x01\x12\x04\xb4\x03\x20,\n\x0f\n\x07\x04=\x03\0\x02\
    \x05\x03\x12\x04\xb4\x03/0\n\x0f\n\x07\x04=\x03\0\x02\x05\x08\x12\x04\
    \xb4\x031W\n\x12\n\n\x04=\x03\0\x02\x05\x08\xd0\x86\x03\x12\x04\xb4\x032\
    V\n\x0e\n\x06\x04=\x03\0\x02\x06\x12\x04\xb5\x03\x10G\n\x0f\n\x07\x04=\
    \x03\0\x02\x06\x04\x12\x04\xb5\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\
    \x06\x05\x12\x04\xb5\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x06\x01\x12\
    \x04\xb5\x03\x20-\n\x0f\n\x07\x04=\x03\0\x02\x06\x03\x12\x04\xb5\x0301\n\
    \x0f\n\x07\x04=\x03\0\x02\x06\x08\x12\x04\xb5\x032F\n\x12\n\n\x04=\x03\0\
    \x02\x06\x08\xd0\x86\x03\x12\x04\xb5\x033E\n\x0e\n\x06\x04=\x03\0\x02\
    \x07\x12\x04\xb6\x03\x10g\n\x0f\n\x07\x04=\x03\0\x02\x07\x04\x12\x04\xb6\
    \x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\x07\x05\x12\x04\xb6\x03\x19\x1f\
    \n\x0f\n\x07\x04=\x03\0\x02\x07\x01\x12\x04\xb6\x03\x20+\n\x0f\n\x07\x04\
    =\x03\0\x02\x07\x03\x12\x04\xb6\x03./\n\x0f\n\x07\x04=\x03\0\x02\x07\x08\
    \x12\x04\xb6\x030f\n\x12\n\n\x04=\x03\0\x02\x07\x08\xd0\x86\x03\x12\x04\
    \xb6\x031e\n\x0e\n\x06\x04=\x03\0\x02\x08\x12\x04\xb7\x03\x10P\n\x0f\n\
    \x07\x04=\x03\0\x02\x08\x04\x12\x04\xb7\x03\x10\x18\n\x0f\n\x07\x04=\x03\
    \0\x02\x08\x05\x12\x04\xb7\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x08\
    \x01\x12\x04\xb7\x03\x20&\n\x0f\n\x07\x04=\x03\0\x02\x08\x03\x12\x04\xb7\
    \x03)*\n\x0f\n\x07\x04=\x03\0\x02\x08\x08\x12\x04\xb7\x03+O\n\x12\n\n\
    \x04=\x03\0\x02\x08\x08\xd0\x86\x03\x12\x04\xb7\x03,N\n\x0e\n\x06\x04=\
    \x03\0\x02\t\x12\x04\xb8\x03\x10h\n\x0f\n\x07\x04=\x03\0\x02\t\x04\x12\
    \x04\xb8\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\t\x05\x12\x04\xb8\x03\
    \x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\t\x01\x12\x04\xb8\x03\x204\n\x0f\n\
    \x07\x04=\x03\0\x02\t\x03\x12\x04\xb8\x0379\n\x0f\n\x07\x04=\x03\0\x02\t\
    \x08\x12\x04\xb8\x03:g\n\x12\n\n\x04=\x03\0\x02\t\x08\xd0\x86\x03\x12\
    \x04\xb8\x03;f\n\x0e\n\x06\x04=\x03\0\x02\n\x12\x04\xb9\x03\x10~\n\x0f\n\
    \x07\x04=\x03\0\x02\n\x04\x12\x04\xb9\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\
    \x02\n\x05\x12\x04\xb9\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\n\x01\x12\
    \x04\xb9\x03\x205\n\x0f\n\x07\x04=\x03\0\x02\n\x03\x12\x04\xb9\x038:\n\
    \x0f\n\x07\x04=\x03\0\x02\n\x08\x12\x04\xb9\x03;}\n\x12\n\n\x04=\x03\0\
    \x02\n\x08\xd0\x86\x03\x12\x04\xb9\x03<|\n\x0e\n\x06\x04=\x03\0\x02\x0b\
    \x12\x04\xba\x03\x10d\n\x0f\n\x07\x04=\x03\0\x02\x0b\x04\x12\x04\xba\x03\
    \x10\x18\n\x0f\n\x07\x04=\x03\0\x02\x0b\x05\x12\x04\xba\x03\x19\x1f\n\
    \x0f\n\x07\x04=\x03\0\x02\x0b\x01\x12\x04\xba\x03\x20,\n\x0f\n\x07\x04=\
    \x03\0\x02\x0b\x03\x12\x04\xba\x03/1\n\x0f\n\x07\x04=\x03\0\x02\x0b\x08\
    \x12\x04\xba\x032c\n\x12\n\n\x04=\x03\0\x02\x0b\x08\xd0\x86\x03\x12\x04\
    \xba\x033b\n\x0e\n\x06\x04=\x03\0\x02\x0c\x12\x04\xbb\x03\x10]\n\x0f\n\
    \x07\x04=\x03\0\x02\x0c\x04\x12\x04\xbb\x03\x10\x18\n\x0f\n\x07\x04=\x03\
    \0\x02\x0c\x05\x12\x04\xbb\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x0c\
    \x01\x12\x04\xbb\x03\x20)\n\x0f\n\x07\x04=\x03\0\x02\x0c\x03\x12\x04\xbb\
    \x03,.\n\x0f\n\x07\x04=\x03\0\x02\x0c\x08\x12\x04\xbb\x03/\\\n\x12\n\n\
    \x04=\x03\0\x02\x0c\x08\xd0\x86\x03\x12\x04\xbb\x030[\n\x0e\n\x06\x04=\
    \x03\0\x02\r\x12\x04\xbc\x03\x10`\n\x0f\n\x07\x04=\x03\0\x02\r\x04\x12\
    \x04\xbc\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\r\x05\x12\x04\xbc\x03\
    \x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\r\x01\x12\x04\xbc\x03\x20-\n\x0f\n\
    \x07\x04=\x03\0\x02\r\x03\x12\x04\xbc\x0302\n\x0f\n\x07\x04=\x03\0\x02\r\
    \x08\x12\x04\xbc\x033_\n\x12\n\n\x04=\x03\0\x02\r\x08\xd0\x86\x03\x12\
    \x04\xbc\x034^\n\x0e\n\x06\x04=\x03\0\x02\x0e\x12\x04\xbd\x03\x10c\n\x0f\
    \n\x07\x04=\x03\0\x02\x0e\x04\x12\x04\xbd\x03\x10\x18\n\x0f\n\x07\x04=\
    \x03\0\x02\x0e\x05\x12\x04\xbd\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\
    \x0e\x01\x12\x04\xbd\x03\x20.\n\x0f\n\x07\x04=\x03\0\x02\x0e\x03\x12\x04\
    \xbd\x0313\n\x0f\n\x07\x04=\x03\0\x02\x0e\x08\x12\x04\xbd\x034b\n\x12\n\
    \n\x04=\x03\0\x02\x0e\x08\xd0\x86\x03\x12\x04\xbd\x035a\n\x0e\n\x06\x04=\
    \x03\0\x02\x0f\x12\x04\xbe\x03\x10]\n\x0f\n\x07\x04=\x03\0\x02\x0f\x04\
    \x12\x04\xbe\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\x0f\x05\x12\x04\xbe\
    \x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x0f\x01\x12\x04\xbe\x03\x201\n\
    \x0f\n\x07\x04=\x03\0\x02\x0f\x03\x12\x04\xbe\x0346\n\x0f\n\x07\x04=\x03\
    \0\x02\x0f\x08\x12\x04\xbe\x037\\\n\x12\n\n\x04=\x03\0\x02\x0f\x08\xd0\
    \x86\x03\x12\x04\xbe\x038[\n\x0e\n\x06\x04=\x03\0\x02\x10\x12\x04\xbf\
    \x03\x10l\n\x0f\n\x07\x04=\x03\0\x02\x10\x04\x12\x04\xbf\x03\x10\x18\n\
    \x0f\n\x07\x04=\x03\0\x02\x10\x05\x12\x04\xbf\x03\x19\x1f\n\x0f\n\x07\
    \x04=\x03\0\x02\x10\x01\x12\x04\xbf\x03\x203\n\x0f\n\x07\x04=\x03\0\x02\
    \x10\x03\x12\x04\xbf\x0368\n\x0f\n\x07\x04=\x03\0\x02\x10\x08\x12\x04\
    \xbf\x039k\n\x12\n\n\x04=\x03\0\x02\x10\x08\xd0\x86\x03\x12\x04\xbf\x03:\
    j\n\x0e\n\x06\x04=\x03\0\x02\x11\x12\x04\xc0\x03\x10L\n\x0f\n\x07\x04=\
    \x03\0\x02\x11\x04\x12\x04\xc0\x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\
    \x11\x05\x12\x04\xc0\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x11\x01\x12\
    \x04\xc0\x03\x20(\n\x0f\n\x07\x04=\x03\0\x02\x11\x03\x12\x04\xc0\x03+-\n\
    \x0f\n\x07\x04=\x03\0\x02\x11\x08\x12\x04\xc0\x03.K\n\x12\n\n\x04=\x03\0\
    \x02\x11\x08\xd0\x86\x03\x12\x04\xc0\x03/J\n\x0e\n\x06\x04=\x03\0\x02\
    \x12\x12\x04\xc1\x03\x10^\n\x0f\n\x07\x04=\x03\0\x02\x12\x04\x12\x04\xc1\
    \x03\x10\x18\n\x0f\n\x07\x04=\x03\0\x02\x12\x05\x12\x04\xc1\x03\x19\x1d\
    \n\x0f\n\x07\x04=\x03\0\x02\x12\x01\x12\x04\xc1\x03\x1e'\n\x0f\n\x07\x04\
    =\x03\0\x02\x12\x03\x12\x04\xc1\x03*,\n\x0f\n\x07\x04=\x03\0\x02\x12\x08\
    \x12\x04\xc1\x03-]\n\x12\n\n\x04=\x03\0\x02\x12\x08\xd0\x86\x03\x12\x04\
    \xc1\x03.\\\n\x0e\n\x06\x04=\x03\0\x02\x13\x12\x04\xc2\x03\x10Y\n\x0f\n\
    \x07\x04=\x03\0\x02\x13\x04\x12\x04\xc2\x03\x10\x18\n\x0f\n\x07\x04=\x03\
    \0\x02\x13\x05\x12\x04\xc2\x03\x19\x1f\n\x0f\n\x07\x04=\x03\0\x02\x13\
    \x01\x12\x04\xc2\x03\x20*\n\x0f\n\x07\x04=\x03\0\x02\x13\x03\x12\x04\xc2\
    \x03-/\n\x0f\n\x07\x04=\x03\0\x02\x13\x08\x12\x04\xc2\x030X\n\x12\n\n\
    \x04=\x03\0\x02\x13\x08\xd0\x86\x03\x12\x04\xc2\x031W\n\x0c\n\x04\x04=\
    \x02\0\x12\x04\xc5\x03\x08[\n\r\n\x05\x04=\x02\0\x04\x12\x04\xc5\x03\x08\
    \x10\n\r\n\x05\x04=\x02\0\x06\x12\x04\xc5\x03\x11I\n\r\n\x05\x04=\x02\0\
    \x01\x12\x04\xc5\x03JV\n\r\n\x05\x04=\x02\0\x03\x12\x04\xc5\x03YZ\n\x0c\
    \n\x02\x04>\x12\x06\xc8\x03\0\xcb\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\
    \xc8\x03\x082\n\x0c\n\x04\x04>\x02\0\x12\x04\xc9\x03\x08T\n\r\n\x05\x04>\
    \x02\0\x04\x12\x04\xc9\x03\x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\xc9\
    \x03\x11\x17\n\r\n\x05\x04>\x02\0\x01\x12\x04\xc9\x03\x18!\n\r\n\x05\x04\
    >\x02\0\x03\x12\x04\xc9\x03$%\n\r\n\x05\x04>\x02\0\x08\x12\x04\xc9\x03&S\
    \n\x10\n\x08\x04>\x02\0\x08\xd0\x86\x03\x12\x04\xc9\x03'R\n\r\n\x04\x04>\
    \x02\x01\x12\x05\xca\x03\x08\x82\x01\n\r\n\x05\x04>\x02\x01\x04\x12\x04\
    \xca\x03\x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xca\x03\x11\x18\n\r\
    \n\x05\x04>\x02\x01\x01\x12\x04\xca\x03\x19\x20\n\r\n\x05\x04>\x02\x01\
    \x03\x12\x04\xca\x03#$\n\x0e\n\x05\x04>\x02\x01\x08\x12\x05\xca\x03%\x81\
    \x01\n\x11\n\x08\x04>\x02\x01\x08\xd0\x86\x03\x12\x05\xca\x03&\x80\x01\n\
    \x0c\n\x02\x04?\x12\x06\xcd\x03\0\xda\x03\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\xcd\x03\x083\n\x0e\n\x04\x04?\x03\0\x12\x06\xce\x03\x08\xd1\x03\t\n\
    \r\n\x05\x04?\x03\0\x01\x12\x04\xce\x03\x10\x1b\n\x0e\n\x06\x04?\x03\0\
    \x02\0\x12\x04\xcf\x03\x10L\n\x0f\n\x07\x04?\x03\0\x02\0\x04\x12\x04\xcf\
    \x03\x10\x18\n\x0f\n\x07\x04?\x03\0\x02\0\x05\x12\x04\xcf\x03\x19\x1f\n\
    \x0f\n\x07\x04?\x03\0\x02\0\x01\x12\x04\xcf\x03\x20$\n\x0f\n\x07\x04?\
    \x03\0\x02\0\x03\x12\x04\xcf\x03'(\n\x0f\n\x07\x04?\x03\0\x02\0\x08\x12\
    \x04\xcf\x03)K\n\x12\n\n\x04?\x03\0\x02\0\x08\xd0\x86\x03\x12\x04\xcf\
    \x03*J\n\x0e\n\x06\x04?\x03\0\x02\x01\x12\x04\xd0\x03\x10^\n\x0f\n\x07\
    \x04?\x03\0\x02\x01\x04\x12\x04\xd0\x03\x10\x18\n\x0f\n\x07\x04?\x03\0\
    \x02\x01\x05\x12\x04\xd0\x03\x19\x1f\n\x0f\n\x07\x04?\x03\0\x02\x01\x01\
    \x12\x04\xd0\x03\x20+\n\x0f\n\x07\x04?\x03\0\x02\x01\x03\x12\x04\xd0\x03\
    ./\n\x0f\n\x07\x04?\x03\0\x02\x01\x08\x12\x04\xd0\x030]\n\x12\n\n\x04?\
    \x03\0\x02\x01\x08\xd0\x86\x03\x12\x04\xd0\x031\\\n\x0e\n\x04\x04?\x03\
    \x01\x12\x06\xd3\x03\x08\xd6\x03\t\n\r\n\x05\x04?\x03\x01\x01\x12\x04\
    \xd3\x03\x10\x1c\n\x0e\n\x06\x04?\x03\x01\x02\0\x12\x04\xd4\x03\x10R\n\
    \x0f\n\x07\x04?\x03\x01\x02\0\x04\x12\x04\xd4\x03\x10\x18\n\x0f\n\x07\
    \x04?\x03\x01\x02\0\x05\x12\x04\xd4\x03\x19\x1f\n\x0f\n\x07\x04?\x03\x01\
    \x02\0\x01\x12\x04\xd4\x03\x20,\n\x0f\n\x07\x04?\x03\x01\x02\0\x03\x12\
    \x04\xd4\x03/0\n\x0f\n\x07\x04?\x03\x01\x02\0\x08\x12\x04\xd4\x031Q\n\
    \x12\n\n\x04?\x03\x01\x02\0\x08\xd0\x86\x03\x12\x04\xd4\x032P\n\x0e\n\
    \x06\x04?\x03\x01\x02\x01\x12\x04\xd5\x03\x10V\n\x0f\n\x07\x04?\x03\x01\
    \x02\x01\x04\x12\x04\xd5\x03\x10\x18\n\x0f\n\x07\x04?\x03\x01\x02\x01\
    \x05\x12\x04\xd5\x03\x19\x1f\n\x0f\n\x07\x04?\x03\x01\x02\x01\x01\x12\
    \x04\xd5\x03\x20+\n\x0f\n\x07\x04?\x03\x01\x02\x01\x03\x12\x04\xd5\x03./\
    \n\x0f\n\x07\x04?\x03\x01\x02\x01\x08\x12\x04\xd5\x030U\n\x12\n\n\x04?\
    \x03\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xd5\x031T\n\x0c\n\x04\x04?\x02\
    \0\x12\x04\xd8\x03\x08[\n\r\n\x05\x04?\x02\0\x04\x12\x04\xd8\x03\x08\x10\
    \n\r\n\x05\x04?\x02\0\x06\x12\x04\xd8\x03\x11I\n\r\n\x05\x04?\x02\0\x01\
    \x12\x04\xd8\x03JV\n\r\n\x05\x04?\x02\0\x03\x12\x04\xd8\x03YZ\n\x0c\n\
    \x04\x04?\x02\x01\x12\x04\xd9\x03\x08]\n\r\n\x05\x04?\x02\x01\x04\x12\
    \x04\xd9\x03\x08\x10\n\r\n\x05\x04?\x02\x01\x06\x12\x04\xd9\x03\x11J\n\r\
    \n\x05\x04?\x02\x01\x01\x12\x04\xd9\x03KX\n\r\n\x05\x04?\x02\x01\x03\x12\
    \x04\xd9\x03[\\\n\x0c\n\x02\x04@\x12\x06\xdc\x03\0\xe5\x03\x01\n\x0b\n\
    \x03\x04@\x01\x12\x04\xdc\x03\x084\n\x0e\n\x04\x04@\x04\0\x12\x06\xdd\
    \x03\x08\xe1\x03\t\n\r\n\x05\x04@\x04\0\x01\x12\x04\xdd\x03\r\x19\n\x0e\
    \n\x06\x04@\x04\0\x02\0\x12\x04\xde\x03\x10+\n\x0f\n\x07\x04@\x04\0\x02\
    \0\x01\x12\x04\xde\x03\x10&\n\x0f\n\x07\x04@\x04\0\x02\0\x02\x12\x04\xde\
    \x03)*\n\x0e\n\x06\x04@\x04\0\x02\x01\x12\x04\xdf\x03\x10&\n\x0f\n\x07\
    \x04@\x04\0\x02\x01\x01\x12\x04\xdf\x03\x10!\n\x0f\n\x07\x04@\x04\0\x02\
    \x01\x02\x12\x04\xdf\x03$%\n\x0e\n\x06\x04@\x04\0\x02\x02\x12\x04\xe0\
    \x03\x10\"\n\x0f\n\x07\x04@\x04\0\x02\x02\x01\x12\x04\xe0\x03\x10\x1d\n\
    \x0f\n\x07\x04@\x04\0\x02\x02\x02\x12\x04\xe0\x03\x20!\n\x0c\n\x04\x04@\
    \x02\0\x12\x04\xe3\x03\x08%\n\r\n\x05\x04@\x02\0\x04\x12\x04\xe3\x03\x08\
    \x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\xe3\x03\x11\x18\n\r\n\x05\x04@\x02\
    \0\x01\x12\x04\xe3\x03\x19\x20\n\r\n\x05\x04@\x02\0\x03\x12\x04\xe3\x03#\
    $\n\x0c\n\x04\x04@\x02\x01\x12\x04\xe4\x03\x08y\n\r\n\x05\x04@\x02\x01\
    \x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x04@\x02\x01\x06\x12\x04\xe4\x03\
    \x11K\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xe4\x03LQ\n\r\n\x05\x04@\x02\
    \x01\x03\x12\x04\xe4\x03TU\n\r\n\x05\x04@\x02\x01\x08\x12\x04\xe4\x03Vx\
    \n\r\n\x05\x04@\x02\x01\x07\x12\x04\xe4\x03aw\n\x0c\n\x02\x04A\x12\x06\
    \xe7\x03\0\xe9\x03\x01\n\x0b\n\x03\x04A\x01\x12\x04\xe7\x03\x086\n\x0c\n\
    \x04\x04A\x02\0\x12\x04\xe8\x03\x08*\n\r\n\x05\x04A\x02\0\x04\x12\x04\
    \xe8\x03\x08\x10\n\r\n\x05\x04A\x02\0\x05\x12\x04\xe8\x03\x11\x18\n\r\n\
    \x05\x04A\x02\0\x01\x12\x04\xe8\x03\x19%\n\r\n\x05\x04A\x02\0\x03\x12\
    \x04\xe8\x03()\n\x0c\n\x02\x04B\x12\x06\xeb\x03\0\xf3\x03\x01\n\x0b\n\
    \x03\x04B\x01\x12\x04\xeb\x03\x086\n\x0c\n\x04\x04B\x02\0\x12\x04\xec\
    \x03\x08*\n\r\n\x05\x04B\x02\0\x04\x12\x04\xec\x03\x08\x10\n\r\n\x05\x04\
    B\x02\0\x05\x12\x04\xec\x03\x11\x18\n\r\n\x05\x04B\x02\0\x01\x12\x04\xec\
    \x03\x19%\n\r\n\x05\x04B\x02\0\x03\x12\x04\xec\x03()\n\x0c\n\x04\x04B\
    \x02\x01\x12\x04\xed\x03\x08)\n\r\n\x05\x04B\x02\x01\x04\x12\x04\xed\x03\
    \x08\x10\n\r\n\x05\x04B\x02\x01\x05\x12\x04\xed\x03\x11\x17\n\r\n\x05\
    \x04B\x02\x01\x01\x12\x04\xed\x03\x18$\n\r\n\x05\x04B\x02\x01\x03\x12\
    \x04\xed\x03'(\n\x0c\n\x04\x04B\x02\x02\x12\x04\xee\x03\x08+\n\r\n\x05\
    \x04B\x02\x02\x04\x12\x04\xee\x03\x08\x10\n\r\n\x05\x04B\x02\x02\x05\x12\
    \x04\xee\x03\x11\x17\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xee\x03\x18&\n\r\
    \n\x05\x04B\x02\x02\x03\x12\x04\xee\x03)*\n\x0c\n\x04\x04B\x02\x03\x12\
    \x04\xef\x03\x08)\n\r\n\x05\x04B\x02\x03\x04\x12\x04\xef\x03\x08\x10\n\r\
    \n\x05\x04B\x02\x03\x05\x12\x04\xef\x03\x11\x17\n\r\n\x05\x04B\x02\x03\
    \x01\x12\x04\xef\x03\x18$\n\r\n\x05\x04B\x02\x03\x03\x12\x04\xef\x03'(\n\
    \x0c\n\x04\x04B\x02\x04\x12\x04\xf0\x03\x081\n\r\n\x05\x04B\x02\x04\x04\
    \x12\x04\xf0\x03\x08\x10\n\r\n\x05\x04B\x02\x04\x05\x12\x04\xf0\x03\x11\
    \x18\n\r\n\x05\x04B\x02\x04\x01\x12\x04\xf0\x03\x19,\n\r\n\x05\x04B\x02\
    \x04\x03\x12\x04\xf0\x03/0\n\x0c\n\x04\x04B\x02\x05\x12\x04\xf1\x03\x08w\
    \n\r\n\x05\x04B\x02\x05\x04\x12\x04\xf1\x03\x08\x10\n\r\n\x05\x04B\x02\
    \x05\x05\x12\x04\xf1\x03\x11\x17\n\r\n\x05\x04B\x02\x05\x01\x12\x04\xf1\
    \x03\x182\n\r\n\x05\x04B\x02\x05\x03\x12\x04\xf1\x0356\n\r\n\x05\x04B\
    \x02\x05\x08\x12\x04\xf1\x037v\n\x10\n\x08\x04B\x02\x05\x08\xd0\x86\x03\
    \x12\x04\xf1\x038u\n\x0c\n\x04\x04B\x02\x06\x12\x04\xf2\x03\x08\"\n\r\n\
    \x05\x04B\x02\x06\x04\x12\x04\xf2\x03\x08\x10\n\r\n\x05\x04B\x02\x06\x05\
    \x12\x04\xf2\x03\x11\x15\n\r\n\x05\x04B\x02\x06\x01\x12\x04\xf2\x03\x16\
    \x1d\n\r\n\x05\x04B\x02\x06\x03\x12\x04\xf2\x03\x20!\n\x0c\n\x02\x04C\
    \x12\x06\xf5\x03\0\xfa\x03\x01\n\x0b\n\x03\x04C\x01\x12\x04\xf5\x03\x083\
    \n\x0c\n\x04\x04C\x02\0\x12\x04\xf6\x03\x08*\n\r\n\x05\x04C\x02\0\x04\
    \x12\x04\xf6\x03\x08\x10\n\r\n\x05\x04C\x02\0\x05\x12\x04\xf6\x03\x11\
    \x18\n\r\n\x05\x04C\x02\0\x01\x12\x04\xf6\x03\x19%\n\r\n\x05\x04C\x02\0\
    \x03\x12\x04\xf6\x03()\n\x0c\n\x04\x04C\x02\x01\x12\x04\xf7\x03\x080\n\r\
    \n\x05\x04C\x02\x01\x04\x12\x04\xf7\x03\x08\x10\n\r\n\x05\x04C\x02\x01\
    \x05\x12\x04\xf7\x03\x11\x18\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xf7\x03\
    \x19+\n\r\n\x05\x04C\x02\x01\x03\x12\x04\xf7\x03./\n\x0c\n\x04\x04C\x02\
    \x02\x12\x04\xf8\x03\x08*\n\r\n\x05\x04C\x02\x02\x04\x12\x04\xf8\x03\x08\
    \x10\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xf8\x03\x11\x17\n\r\n\x05\x04C\
    \x02\x02\x01\x12\x04\xf8\x03\x18%\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xf8\
    \x03()\n\x0c\n\x04\x04C\x02\x03\x12\x04\xf9\x03\x080\n\r\n\x05\x04C\x02\
    \x03\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04C\x02\x03\x05\x12\x04\xf9\
    \x03\x11\x15\n\r\n\x05\x04C\x02\x03\x01\x12\x04\xf9\x03\x16+\n\r\n\x05\
    \x04C\x02\x03\x03\x12\x04\xf9\x03./\n\x0c\n\x02\x04D\x12\x06\xfc\x03\0\
    \xfe\x03\x01\n\x0b\n\x03\x04D\x01\x12\x04\xfc\x03\x08-\n\x0c\n\x04\x04D\
    \x02\0\x12\x04\xfd\x03\x08*\n\r\n\x05\x04D\x02\0\x04\x12\x04\xfd\x03\x08\
    \x10\n\r\n\x05\x04D\x02\0\x05\x12\x04\xfd\x03\x11\x18\n\r\n\x05\x04D\x02\
    \0\x01\x12\x04\xfd\x03\x19%\n\r\n\x05\x04D\x02\0\x03\x12\x04\xfd\x03()\n\
    \x0c\n\x02\x04E\x12\x06\x80\x04\0\x82\x04\x01\n\x0b\n\x03\x04E\x01\x12\
    \x04\x80\x04\x085\n\x0c\n\x04\x04E\x02\0\x12\x04\x81\x04\x081\n\r\n\x05\
    \x04E\x02\0\x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\
    \x81\x04\x11\x18\n\r\n\x05\x04E\x02\0\x01\x12\x04\x81\x04\x19,\n\r\n\x05\
    \x04E\x02\0\x03\x12\x04\x81\x04/0\n\x0c\n\x02\x04F\x12\x06\x84\x04\0\x87\
    \x04\x01\n\x0b\n\x03\x04F\x01\x12\x04\x84\x04\x08/\n\x0c\n\x04\x04F\x02\
    \0\x12\x04\x85\x04\x08*\n\r\n\x05\x04F\x02\0\x04\x12\x04\x85\x04\x08\x10\
    \n\r\n\x05\x04F\x02\0\x05\x12\x04\x85\x04\x11\x18\n\r\n\x05\x04F\x02\0\
    \x01\x12\x04\x85\x04\x19%\n\r\n\x05\x04F\x02\0\x03\x12\x04\x85\x04()\n\
    \x0c\n\x04\x04F\x02\x01\x12\x04\x86\x04\x08'\n\r\n\x05\x04F\x02\x01\x04\
    \x12\x04\x86\x04\x08\x10\n\r\n\x05\x04F\x02\x01\x05\x12\x04\x86\x04\x11\
    \x16\n\r\n\x05\x04F\x02\x01\x01\x12\x04\x86\x04\x17\"\n\r\n\x05\x04F\x02\
    \x01\x03\x12\x04\x86\x04%&\n\x0c\n\x02\x04G\x12\x06\x89\x04\0\x8d\x04\
    \x01\n\x0b\n\x03\x04G\x01\x12\x04\x89\x04\x084\n\x0c\n\x04\x04G\x02\0\
    \x12\x04\x8a\x04\x082\n\r\n\x05\x04G\x02\0\x04\x12\x04\x8a\x04\x08\x10\n\
    \r\n\x05\x04G\x02\0\x05\x12\x04\x8a\x04\x11\x18\n\r\n\x05\x04G\x02\0\x01\
    \x12\x04\x8a\x04\x19-\n\r\n\x05\x04G\x02\0\x03\x12\x04\x8a\x0401\n\x0c\n\
    \x04\x04G\x02\x01\x12\x04\x8b\x04\x083\n\r\n\x05\x04G\x02\x01\x04\x12\
    \x04\x8b\x04\x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\x8b\x04\x11\x17\
    \n\r\n\x05\x04G\x02\x01\x01\x12\x04\x8b\x04\x18.\n\r\n\x05\x04G\x02\x01\
    \x03\x12\x04\x8b\x0412\n\x0c\n\x04\x04G\x02\x02\x12\x04\x8c\x04\x085\n\r\
    \n\x05\x04G\x02\x02\x04\x12\x04\x8c\x04\x08\x10\n\r\n\x05\x04G\x02\x02\
    \x05\x12\x04\x8c\x04\x11\x17\n\r\n\x05\x04G\x02\x02\x01\x12\x04\x8c\x04\
    \x180\n\r\n\x05\x04G\x02\x02\x03\x12\x04\x8c\x0434\n\x0c\n\x02\x04H\x12\
    \x06\x8f\x04\0\x95\x04\x01\n\x0b\n\x03\x04H\x01\x12\x04\x8f\x04\x084\n\
    \x0c\n\x04\x04H\x02\0\x12\x04\x90\x04\x083\n\r\n\x05\x04H\x02\0\x04\x12\
    \x04\x90\x04\x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\x90\x04\x11\x17\n\
    \r\n\x05\x04H\x02\0\x01\x12\x04\x90\x04\x18.\n\r\n\x05\x04H\x02\0\x03\
    \x12\x04\x90\x0412\n\x0c\n\x04\x04H\x02\x01\x12\x04\x91\x04\x08<\n\r\n\
    \x05\x04H\x02\x01\x04\x12\x04\x91\x04\x08\x10\n\r\n\x05\x04H\x02\x01\x05\
    \x12\x04\x91\x04\x11\x18\n\r\n\x05\x04H\x02\x01\x01\x12\x04\x91\x04\x197\
    \n\r\n\x05\x04H\x02\x01\x03\x12\x04\x91\x04:;\n\x0c\n\x04\x04H\x02\x02\
    \x12\x04\x92\x04\x08*\n\r\n\x05\x04H\x02\x02\x04\x12\x04\x92\x04\x08\x10\
    \n\r\n\x05\x04H\x02\x02\x05\x12\x04\x92\x04\x11\x16\n\r\n\x05\x04H\x02\
    \x02\x01\x12\x04\x92\x04\x17%\n\r\n\x05\x04H\x02\x02\x03\x12\x04\x92\x04\
    ()\n\x0c\n\x04\x04H\x02\x03\x12\x04\x93\x04\x08,\n\r\n\x05\x04H\x02\x03\
    \x04\x12\x04\x93\x04\x08\x10\n\r\n\x05\x04H\x02\x03\x05\x12\x04\x93\x04\
    \x11\x17\n\r\n\x05\x04H\x02\x03\x01\x12\x04\x93\x04\x18'\n\r\n\x05\x04H\
    \x02\x03\x03\x12\x04\x93\x04*+\n\x0c\n\x04\x04H\x02\x04\x12\x04\x94\x04\
    \x08-\n\r\n\x05\x04H\x02\x04\x04\x12\x04\x94\x04\x08\x10\n\r\n\x05\x04H\
    \x02\x04\x05\x12\x04\x94\x04\x11\x17\n\r\n\x05\x04H\x02\x04\x01\x12\x04\
    \x94\x04\x18(\n\r\n\x05\x04H\x02\x04\x03\x12\x04\x94\x04+,\n\x0c\n\x02\
    \x04I\x12\x06\x97\x04\0\x99\x04\x01\n\x0b\n\x03\x04I\x01\x12\x04\x97\x04\
    \x084\n\x0c\n\x04\x04I\x02\0\x12\x04\x98\x04\x082\n\r\n\x05\x04I\x02\0\
    \x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\x98\x04\
    \x11\x18\n\r\n\x05\x04I\x02\0\x01\x12\x04\x98\x04\x19-\n\r\n\x05\x04I\
    \x02\0\x03\x12\x04\x98\x0401\n\x0c\n\x02\x04J\x12\x06\x9b\x04\0\xa0\x04\
    \x01\n\x0b\n\x03\x04J\x01\x12\x04\x9b\x04\x08+\n\x0c\n\x04\x04J\x02\0\
    \x12\x04\x9c\x04\x082\n\r\n\x05\x04J\x02\0\x04\x12\x04\x9c\x04\x08\x10\n\
    \r\n\x05\x04J\x02\0\x05\x12\x04\x9c\x04\x11\x18\n\r\n\x05\x04J\x02\0\x01\
    \x12\x04\x9c\x04\x19-\n\r\n\x05\x04J\x02\0\x03\x12\x04\x9c\x0401\n\x0c\n\
    \x04\x04J\x02\x01\x12\x04\x9d\x04\x08/\n\r\n\x05\x04J\x02\x01\x04\x12\
    \x04\x9d\x04\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\x9d\x04\x11\x18\
    \n\r\n\x05\x04J\x02\x01\x01\x12\x04\x9d\x04\x19*\n\r\n\x05\x04J\x02\x01\
    \x03\x12\x04\x9d\x04-.\n\x0c\n\x04\x04J\x02\x02\x12\x04\x9e\x04\x08,\n\r\
    \n\x05\x04J\x02\x02\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\x04J\x02\x02\
    \x05\x12\x04\x9e\x04\x11\x18\n\r\n\x05\x04J\x02\x02\x01\x12\x04\x9e\x04\
    \x19'\n\r\n\x05\x04J\x02\x02\x03\x12\x04\x9e\x04*+\n\x0c\n\x04\x04J\x02\
    \x03\x12\x04\x9f\x04\x08*\n\r\n\x05\x04J\x02\x03\x04\x12\x04\x9f\x04\x08\
    \x10\n\r\n\x05\x04J\x02\x03\x05\x12\x04\x9f\x04\x11\x18\n\r\n\x05\x04J\
    \x02\x03\x01\x12\x04\x9f\x04\x19%\n\r\n\x05\x04J\x02\x03\x03\x12\x04\x9f\
    \x04()\n\x0c\n\x02\x04K\x12\x06\xa2\x04\0\xa6\x04\x01\n\x0b\n\x03\x04K\
    \x01\x12\x04\xa2\x04\x08/\n\x0c\n\x04\x04K\x02\0\x12\x04\xa3\x04\x082\n\
    \r\n\x05\x04K\x02\0\x04\x12\x04\xa3\x04\x08\x10\n\r\n\x05\x04K\x02\0\x05\
    \x12\x04\xa3\x04\x11\x18\n\r\n\x05\x04K\x02\0\x01\x12\x04\xa3\x04\x19-\n\
    \r\n\x05\x04K\x02\0\x03\x12\x04\xa3\x0401\n\x0c\n\x04\x04K\x02\x01\x12\
    \x04\xa4\x04\x08/\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xa4\x04\x08\x10\n\r\
    \n\x05\x04K\x02\x01\x05\x12\x04\xa4\x04\x11\x18\n\r\n\x05\x04K\x02\x01\
    \x01\x12\x04\xa4\x04\x19*\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xa4\x04-.\n\
    \x0c\n\x04\x04K\x02\x02\x12\x04\xa5\x04\x08#\n\r\n\x05\x04K\x02\x02\x04\
    \x12\x04\xa5\x04\x08\x10\n\r\n\x05\x04K\x02\x02\x05\x12\x04\xa5\x04\x11\
    \x17\n\r\n\x05\x04K\x02\x02\x01\x12\x04\xa5\x04\x18\x1e\n\r\n\x05\x04K\
    \x02\x02\x03\x12\x04\xa5\x04!\"\n\x0c\n\x02\x04L\x12\x06\xa8\x04\0\xac\
    \x04\x01\n\x0b\n\x03\x04L\x01\x12\x04\xa8\x04\x088\n\x0c\n\x04\x04L\x02\
    \0\x12\x04\xa9\x04\x082\n\r\n\x05\x04L\x02\0\x04\x12\x04\xa9\x04\x08\x10\
    \n\r\n\x05\x04L\x02\0\x05\x12\x04\xa9\x04\x11\x18\n\r\n\x05\x04L\x02\0\
    \x01\x12\x04\xa9\x04\x19-\n\r\n\x05\x04L\x02\0\x03\x12\x04\xa9\x0401\n\
    \x0c\n\x04\x04L\x02\x01\x12\x04\xaa\x04\x08/\n\r\n\x05\x04L\x02\x01\x04\
    \x12\x04\xaa\x04\x08\x10\n\r\n\x05\x04L\x02\x01\x05\x12\x04\xaa\x04\x11\
    \x18\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xaa\x04\x19*\n\r\n\x05\x04L\x02\
    \x01\x03\x12\x04\xaa\x04-.\n\x0c\n\x04\x04L\x02\x02\x12\x04\xab\x04\x08<\
    \n\r\n\x05\x04L\x02\x02\x04\x12\x04\xab\x04\x08\x10\n\r\n\x05\x04L\x02\
    \x02\x06\x12\x04\xab\x04\x11-\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xab\x04\
    .7\n\r\n\x05\x04L\x02\x02\x03\x12\x04\xab\x04:;\n\x0c\n\x02\x06\0\x12\
    \x06\xae\x04\0\xb8\x05\x01\n\x0b\n\x03\x06\0\x01\x12\x04\xae\x04\x08\x11\
    \n\x0b\n\x03\x06\0\x03\x12\x04\xaf\x04\x08P\n\x0e\n\x06\x06\0\x03\xd0\
    \x86\x03\x12\x04\xaf\x04\x08P\n\x0e\n\x04\x06\0\x02\0\x12\x06\xb1\x04\
    \x08\xb3\x04\t\n\r\n\x05\x06\0\x02\0\x01\x12\x04\xb1\x04\x0c!\n\r\n\x05\
    \x06\0\x02\0\x02\x12\x04\xb1\x04#L\n\x0e\n\x05\x06\0\x02\0\x03\x12\x05\
    \xb1\x04W\x81\x01\n\x0e\n\x05\x06\0\x02\0\x04\x12\x05\xb2\x04\x10\xaa\
    \x01\n\x11\n\x08\x06\0\x02\0\x04\xd0\x86\x03\x12\x05\xb2\x04\x10\xaa\x01\
    \n\x0e\n\x04\x06\0\x02\x01\x12\x06\xb5\x04\x08\xb7\x04\t\n\r\n\x05\x06\0\
    \x02\x01\x01\x12\x04\xb5\x04\x0c\x1f\n\r\n\x05\x06\0\x02\x01\x02\x12\x04\
    \xb5\x04!H\n\r\n\x05\x06\0\x02\x01\x03\x12\x04\xb5\x04S{\n\r\n\x05\x06\0\
    \x02\x01\x04\x12\x04\xb6\x04\x10}\n\x10\n\x08\x06\0\x02\x01\x04\xd0\x86\
    \x03\x12\x04\xb6\x04\x10}\n\x0e\n\x04\x06\0\x02\x02\x12\x06\xb9\x04\x08\
    \xbb\x04\t\n\r\n\x05\x06\0\x02\x02\x01\x12\x04\xb9\x04\x0c\x20\n\r\n\x05\
    \x06\0\x02\x02\x02\x12\x04\xb9\x04\"J\n\r\n\x05\x06\0\x02\x02\x03\x12\
    \x04\xb9\x04U~\n\r\n\x05\x06\0\x02\x02\x04\x12\x04\xba\x04\x10l\n\x10\n\
    \x08\x06\0\x02\x02\x04\xd0\x86\x03\x12\x04\xba\x04\x10l\n\x0e\n\x04\x06\
    \0\x02\x03\x12\x06\xbd\x04\x08\xbf\x04\t\n\r\n\x05\x06\0\x02\x03\x01\x12\
    \x04\xbd\x04\x0c%\n\r\n\x05\x06\0\x02\x03\x02\x12\x04\xbd\x04'Y\n\r\n\
    \x05\x06\0\x02\x03\x03\x12\x04\xbd\x04do\n\r\n\x05\x06\0\x02\x03\x04\x12\
    \x04\xbe\x04\x10h\n\x10\n\x08\x06\0\x02\x03\x04\xd0\x86\x03\x12\x04\xbe\
    \x04\x10h\n\x0e\n\x04\x06\0\x02\x04\x12\x06\xc1\x04\x08\xc3\x04\t\n\r\n\
    \x05\x06\0\x02\x04\x01\x12\x04\xc1\x04\x0c\x1a\n\r\n\x05\x06\0\x02\x04\
    \x02\x12\x04\xc1\x04\x1c>\n\r\n\x05\x06\0\x02\x04\x03\x12\x04\xc1\x04Il\
    \n\r\n\x05\x06\0\x02\x04\x04\x12\x04\xc2\x04\x10Y\n\x10\n\x08\x06\0\x02\
    \x04\x04\xd0\x86\x03\x12\x04\xc2\x04\x10Y\n\x0e\n\x04\x06\0\x02\x05\x12\
    \x06\xc5\x04\x08\xc7\x04\t\n\r\n\x05\x06\0\x02\x05\x01\x12\x04\xc5\x04\
    \x0c\x1e\n\r\n\x05\x06\0\x02\x05\x02\x12\x04\xc5\x04\x20K\n\r\n\x05\x06\
    \0\x02\x05\x03\x12\x04\xc5\x04Va\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\xc6\
    \x04\x10^\n\x10\n\x08\x06\0\x02\x05\x04\xd0\x86\x03\x12\x04\xc6\x04\x10^\
    \n\x0e\n\x04\x06\0\x02\x06\x12\x06\xc9\x04\x08\xcb\x04\t\n\r\n\x05\x06\0\
    \x02\x06\x01\x12\x04\xc9\x04\x0c!\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\
    \xc9\x04#Q\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\xc9\x04\\g\n\x0e\n\x05\
    \x06\0\x02\x06\x04\x12\x05\xca\x04\x10\x98\x01\n\x11\n\x08\x06\0\x02\x06\
    \x04\xd0\x86\x03\x12\x05\xca\x04\x10\x98\x01\n\x0e\n\x04\x06\0\x02\x07\
    \x12\x06\xcd\x04\x08\xcf\x04\t\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\xcd\
    \x04\x0c\x1e\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\xcd\x04\x20F\n\r\n\x05\
    \x06\0\x02\x07\x03\x12\x04\xcd\x04Qx\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\
    \xce\x04\x10\\\n\x10\n\x08\x06\0\x02\x07\x04\xd0\x86\x03\x12\x04\xce\x04\
    \x10\\\n\x0e\n\x04\x06\0\x02\x08\x12\x06\xd1\x04\x08\xd3\x04\t\n\r\n\x05\
    \x06\0\x02\x08\x01\x12\x04\xd1\x04\x0c!\n\r\n\x05\x06\0\x02\x08\x02\x12\
    \x04\xd1\x04#L\n\x0e\n\x05\x06\0\x02\x08\x03\x12\x05\xd1\x04W\x81\x01\n\
    \r\n\x05\x06\0\x02\x08\x04\x12\x04\xd2\x04\x10T\n\x10\n\x08\x06\0\x02\
    \x08\x04\xd0\x86\x03\x12\x04\xd2\x04\x10T\n\x0e\n\x04\x06\0\x02\t\x12\
    \x06\xd5\x04\x08\xd7\x04\t\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xd5\x04\x0c\
    \x1d\n\r\n\x05\x06\0\x02\t\x02\x12\x04\xd5\x04\x1fD\n\r\n\x05\x06\0\x02\
    \t\x03\x12\x04\xd5\x04Ou\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xd6\x04\x10k\
    \n\x10\n\x08\x06\0\x02\t\x04\xd0\x86\x03\x12\x04\xd6\x04\x10k\n\x0e\n\
    \x04\x06\0\x02\n\x12\x06\xd9\x04\x08\xdb\x04\t\n\r\n\x05\x06\0\x02\n\x01\
    \x12\x04\xd9\x04\x0c&\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xd9\x04(V\n\x0e\
    \n\x05\x06\0\x02\n\x03\x12\x05\xd9\x04a\x90\x01\n\r\n\x05\x06\0\x02\n\
    \x04\x12\x04\xda\x04\x10v\n\x10\n\x08\x06\0\x02\n\x04\xd0\x86\x03\x12\
    \x04\xda\x04\x10v\n\x0e\n\x04\x06\0\x02\x0b\x12\x06\xdd\x04\x08\xdf\x04\
    \t\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\xdd\x04\x0c+\n\r\n\x05\x06\0\x02\
    \x0b\x02\x12\x04\xdd\x04-e\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xdd\x04p{\
    \n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xde\x04\x10e\n\x10\n\x08\x06\0\x02\
    \x0b\x04\xd0\x86\x03\x12\x04\xde\x04\x10e\n\x0e\n\x04\x06\0\x02\x0c\x12\
    \x06\xe1\x04\x08\xe3\x04\t\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xe1\x04\
    \x0c\x20\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xe1\x04\"J\n\r\n\x05\x06\0\
    \x02\x0c\x03\x12\x04\xe1\x04U~\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xe2\
    \x04\x10T\n\x10\n\x08\x06\0\x02\x0c\x04\xd0\x86\x03\x12\x04\xe2\x04\x10T\
    \n\x0e\n\x04\x06\0\x02\r\x12\x06\xe5\x04\x08\xe7\x04\t\n\r\n\x05\x06\0\
    \x02\r\x01\x12\x04\xe5\x04\x0c\x1b\n\r\n\x05\x06\0\x02\r\x02\x12\x04\xe5\
    \x04\x1d@\n\r\n\x05\x06\0\x02\r\x03\x12\x04\xe5\x04Ko\n\r\n\x05\x06\0\
    \x02\r\x04\x12\x04\xe6\x04\x10Y\n\x10\n\x08\x06\0\x02\r\x04\xd0\x86\x03\
    \x12\x04\xe6\x04\x10Y\n\x0e\n\x04\x06\0\x02\x0e\x12\x06\xe9\x04\x08\xeb\
    \x04\t\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\xe9\x04\x0c\"\n\r\n\x05\x06\0\
    \x02\x0e\x02\x12\x04\xe9\x04$N\n\x0e\n\x05\x06\0\x02\x0e\x03\x12\x05\xe9\
    \x04Y\x84\x01\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\xea\x04\x10e\n\x10\n\
    \x08\x06\0\x02\x0e\x04\xd0\x86\x03\x12\x04\xea\x04\x10e\n\x0e\n\x04\x06\
    \0\x02\x0f\x12\x06\xed\x04\x08\xef\x04\t\n\r\n\x05\x06\0\x02\x0f\x01\x12\
    \x04\xed\x04\x0c!\n\r\n\x05\x06\0\x02\x0f\x02\x12\x04\xed\x04#L\n\x0e\n\
    \x05\x06\0\x02\x0f\x03\x12\x05\xed\x04W\x81\x01\n\r\n\x05\x06\0\x02\x0f\
    \x04\x12\x04\xee\x04\x10S\n\x10\n\x08\x06\0\x02\x0f\x04\xd0\x86\x03\x12\
    \x04\xee\x04\x10S\n\x0e\n\x04\x06\0\x02\x10\x12\x06\xf1\x04\x08\xf3\x04\
    \t\n\r\n\x05\x06\0\x02\x10\x01\x12\x04\xf1\x04\x0c\x1e\n\r\n\x05\x06\0\
    \x02\x10\x02\x12\x04\xf1\x04\x20F\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\
    \xf1\x04Qx\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xf2\x04\x10Z\n\x10\n\x08\
    \x06\0\x02\x10\x04\xd0\x86\x03\x12\x04\xf2\x04\x10Z\n\x0e\n\x04\x06\0\
    \x02\x11\x12\x06\xf5\x04\x08\xf7\x04\t\n\r\n\x05\x06\0\x02\x11\x01\x12\
    \x04\xf5\x04\x0c%\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\xf5\x04'T\n\x0e\n\
    \x05\x06\0\x02\x11\x03\x12\x05\xf5\x04_\x8d\x01\n\r\n\x05\x06\0\x02\x11\
    \x04\x12\x04\xf6\x04\x10T\n\x10\n\x08\x06\0\x02\x11\x04\xd0\x86\x03\x12\
    \x04\xf6\x04\x10T\n\x0e\n\x04\x06\0\x02\x12\x12\x06\xf9\x04\x08\xfb\x04\
    \t\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\xf9\x04\x0c\x1a\n\r\n\x05\x06\0\
    \x02\x12\x02\x12\x04\xf9\x04\x1c>\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\
    \xf9\x04Il\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xfa\x04\x10P\n\x10\n\x08\
    \x06\0\x02\x12\x04\xd0\x86\x03\x12\x04\xfa\x04\x10P\n\x0e\n\x04\x06\0\
    \x02\x13\x12\x06\xfd\x04\x08\xff\x04\t\n\r\n\x05\x06\0\x02\x13\x01\x12\
    \x04\xfd\x04\x0c\x1e\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\xfd\x04\x20F\n\
    \r\n\x05\x06\0\x02\x13\x03\x12\x04\xfd\x04Qx\n\r\n\x05\x06\0\x02\x13\x04\
    \x12\x04\xfe\x04\x10P\n\x10\n\x08\x06\0\x02\x13\x04\xd0\x86\x03\x12\x04\
    \xfe\x04\x10P\n\x0e\n\x04\x06\0\x02\x14\x12\x06\x81\x05\x08\x83\x05\t\n\
    \r\n\x05\x06\0\x02\x14\x01\x12\x04\x81\x05\x0c\x1a\n\r\n\x05\x06\0\x02\
    \x14\x02\x12\x04\x81\x05\x1c>\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\x81\
    \x05Il\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\x82\x05\x10I\n\x10\n\x08\x06\
    \0\x02\x14\x04\xd0\x86\x03\x12\x04\x82\x05\x10I\n\x0e\n\x04\x06\0\x02\
    \x15\x12\x06\x85\x05\x08\x87\x05\t\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\
    \x85\x05\x0c\x1a\n\r\n\x05\x06\0\x02\x15\x02\x12\x04\x85\x05\x1c>\n\r\n\
    \x05\x06\0\x02\x15\x03\x12\x04\x85\x05Il\n\r\n\x05\x06\0\x02\x15\x04\x12\
    \x04\x86\x05\x10P\n\x10\n\x08\x06\0\x02\x15\x04\xd0\x86\x03\x12\x04\x86\
    \x05\x10P\n\x0e\n\x04\x06\0\x02\x16\x12\x06\x89\x05\x08\x8b\x05\t\n\r\n\
    \x05\x06\0\x02\x16\x01\x12\x04\x89\x05\x0c\x17\n\r\n\x05\x06\0\x02\x16\
    \x02\x12\x04\x89\x05\x198\n\r\n\x05\x06\0\x02\x16\x03\x12\x04\x89\x05Cc\
    \n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x8a\x05\x10I\n\x10\n\x08\x06\0\x02\
    \x16\x04\xd0\x86\x03\x12\x04\x8a\x05\x10I\n\x0e\n\x04\x06\0\x02\x17\x12\
    \x06\x8d\x05\x08\x8f\x05\t\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\x8d\x05\
    \x0c\x17\n\r\n\x05\x06\0\x02\x17\x02\x12\x04\x8d\x05\x198\n\r\n\x05\x06\
    \0\x02\x17\x03\x12\x04\x8d\x05Cc\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\x8e\
    \x05\x10I\n\x10\n\x08\x06\0\x02\x17\x04\xd0\x86\x03\x12\x04\x8e\x05\x10I\
    \n\x0e\n\x04\x06\0\x02\x18\x12\x06\x91\x05\x08\x93\x05\t\n\r\n\x05\x06\0\
    \x02\x18\x01\x12\x04\x91\x05\x0c&\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\
    \x91\x05(U\n\r\n\x05\x06\0\x02\x18\x03\x12\x04\x91\x05`k\n\r\n\x05\x06\0\
    \x02\x18\x04\x12\x04\x92\x05\x10q\n\x10\n\x08\x06\0\x02\x18\x04\xd0\x86\
    \x03\x12\x04\x92\x05\x10q\n\x0e\n\x04\x06\0\x02\x19\x12\x06\x95\x05\x08\
    \x97\x05\t\n\r\n\x05\x06\0\x02\x19\x01\x12\x04\x95\x05\x0c\x1d\n\r\n\x05\
    \x06\0\x02\x19\x02\x12\x04\x95\x05\x1fD\n\r\n\x05\x06\0\x02\x19\x03\x12\
    \x04\x95\x05Ou\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\x96\x05\x10u\n\x10\n\
    \x08\x06\0\x02\x19\x04\xd0\x86\x03\x12\x04\x96\x05\x10u\n\x0e\n\x04\x06\
    \0\x02\x1a\x12\x06\x99\x05\x08\x9b\x05\t\n\r\n\x05\x06\0\x02\x1a\x01\x12\
    \x04\x99\x05\x0c\x19\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\x99\x05\x1b<\n\
    \r\n\x05\x06\0\x02\x1a\x03\x12\x04\x99\x05Gi\n\r\n\x05\x06\0\x02\x1a\x04\
    \x12\x04\x9a\x05\x10u\n\x10\n\x08\x06\0\x02\x1a\x04\xd0\x86\x03\x12\x04\
    \x9a\x05\x10u\n\x0e\n\x04\x06\0\x02\x1b\x12\x06\x9d\x05\x08\x9f\x05\t\n\
    \r\n\x05\x06\0\x02\x1b\x01\x12\x04\x9d\x05\x0c\x1b\n\r\n\x05\x06\0\x02\
    \x1b\x02\x12\x04\x9d\x05\x1d@\n\r\n\x05\x06\0\x02\x1b\x03\x12\x04\x9d\
    \x05Ko\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\x9e\x05\x10w\n\x10\n\x08\x06\
    \0\x02\x1b\x04\xd0\x86\x03\x12\x04\x9e\x05\x10w\n\x0e\n\x04\x06\0\x02\
    \x1c\x12\x06\xa1\x05\x08\xa3\x05\t\n\r\n\x05\x06\0\x02\x1c\x01\x12\x04\
    \xa1\x05\x0c\"\n\r\n\x05\x06\0\x02\x1c\x02\x12\x04\xa1\x05$N\n\x0e\n\x05\
    \x06\0\x02\x1c\x03\x12\x05\xa1\x05Y\x84\x01\n\r\n\x05\x06\0\x02\x1c\x04\
    \x12\x04\xa2\x05\x10\\\n\x10\n\x08\x06\0\x02\x1c\x04\xd0\x86\x03\x12\x04\
    \xa2\x05\x10\\\n\x0e\n\x04\x06\0\x02\x1d\x12\x06\xa5\x05\x08\xa7\x05\t\n\
    \r\n\x05\x06\0\x02\x1d\x01\x12\x04\xa5\x05\x0c\"\n\r\n\x05\x06\0\x02\x1d\
    \x02\x12\x04\xa5\x05$N\n\x0e\n\x05\x06\0\x02\x1d\x03\x12\x05\xa5\x05Y\
    \x84\x01\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xa6\x05\x10k\n\x10\n\x08\
    \x06\0\x02\x1d\x04\xd0\x86\x03\x12\x04\xa6\x05\x10k\n\x0e\n\x04\x06\0\
    \x02\x1e\x12\x06\xa9\x05\x08\xab\x05\t\n\r\n\x05\x06\0\x02\x1e\x01\x12\
    \x04\xa9\x05\x0c$\n\r\n\x05\x06\0\x02\x1e\x02\x12\x04\xa9\x05&R\n\x0e\n\
    \x05\x06\0\x02\x1e\x03\x12\x05\xa9\x05]\x8a\x01\n\r\n\x05\x06\0\x02\x1e\
    \x04\x12\x04\xaa\x05\x10m\n\x10\n\x08\x06\0\x02\x1e\x04\xd0\x86\x03\x12\
    \x04\xaa\x05\x10m\n\x0e\n\x04\x06\0\x02\x1f\x12\x06\xad\x05\x08\xaf\x05\
    \t\n\r\n\x05\x06\0\x02\x1f\x01\x12\x04\xad\x05\x0c#\n\r\n\x05\x06\0\x02\
    \x1f\x02\x12\x04\xad\x05%P\n\x0e\n\x05\x06\0\x02\x1f\x03\x12\x05\xad\x05\
    [\x87\x01\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xae\x05\x10m\n\x10\n\x08\
    \x06\0\x02\x1f\x04\xd0\x86\x03\x12\x04\xae\x05\x10m\n\x0e\n\x04\x06\0\
    \x02\x20\x12\x06\xb1\x05\x08\xb3\x05\t\n\r\n\x05\x06\0\x02\x20\x01\x12\
    \x04\xb1\x05\x0c#\n\r\n\x05\x06\0\x02\x20\x02\x12\x04\xb1\x05%P\n\x0e\n\
    \x05\x06\0\x02\x20\x03\x12\x05\xb1\x05[\x87\x01\n\r\n\x05\x06\0\x02\x20\
    \x04\x12\x04\xb2\x05\x10U\n\x10\n\x08\x06\0\x02\x20\x04\xd0\x86\x03\x12\
    \x04\xb2\x05\x10U\n\x0e\n\x04\x06\0\x02!\x12\x06\xb5\x05\x08\xb7\x05\t\n\
    \r\n\x05\x06\0\x02!\x01\x12\x04\xb5\x05\x0c#\n\r\n\x05\x06\0\x02!\x02\
    \x12\x04\xb5\x05%P\n\x0e\n\x05\x06\0\x02!\x03\x12\x05\xb5\x05[\x87\x01\n\
    \r\n\x05\x06\0\x02!\x04\x12\x04\xb6\x05\x10V\n\x10\n\x08\x06\0\x02!\x04\
    \xd0\x86\x03\x12\x04\xb6\x05\x10V\n\x0c\n\x02\x06\x01\x12\x06\xba\x05\0\
    \xf0\x05\x01\n\x0b\n\x03\x06\x01\x01\x12\x04\xba\x05\x08\x17\n\x0b\n\x03\
    \x06\x01\x03\x12\x04\xbb\x05\x08K\n\x0e\n\x06\x06\x01\x03\xd8\x86\x03\
    \x12\x04\xbb\x05\x08K\n\x0e\n\x04\x06\x01\x02\0\x12\x06\xbd\x05\x08\xbf\
    \x05\t\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\xbd\x05\x0c&\n\r\n\x05\x06\
    \x01\x02\0\x02\x12\x04\xbd\x05(U\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\xbd\
    \x05`k\n\r\n\x05\x06\x01\x02\0\x04\x12\x04\xbe\x05\x10t\n\x10\n\x08\x06\
    \x01\x02\0\x04\xd0\x86\x03\x12\x04\xbe\x05\x10t\n\x0e\n\x04\x06\x01\x02\
    \x01\x12\x06\xc1\x05\x08\xc3\x05\t\n\r\n\x05\x06\x01\x02\x01\x01\x12\x04\
    \xc1\x05\x0c(\n\r\n\x05\x06\x01\x02\x01\x02\x12\x04\xc1\x05*Y\n\r\n\x05\
    \x06\x01\x02\x01\x03\x12\x04\xc1\x05do\n\x0e\n\x05\x06\x01\x02\x01\x04\
    \x12\x05\xc2\x05\x10\x8c\x01\n\x11\n\x08\x06\x01\x02\x01\x04\xd0\x86\x03\
    \x12\x05\xc2\x05\x10\x8c\x01\n\x0e\n\x04\x06\x01\x02\x02\x12\x06\xc5\x05\
    \x08\xc7\x05\t\n\r\n\x05\x06\x01\x02\x02\x01\x12\x04\xc5\x05\x0c(\n\r\n\
    \x05\x06\x01\x02\x02\x02\x12\x04\xc5\x05*Y\n\r\n\x05\x06\x01\x02\x02\x03\
    \x12\x04\xc5\x05do\n\r\n\x05\x06\x01\x02\x02\x04\x12\x04\xc6\x05\x10v\n\
    \x10\n\x08\x06\x01\x02\x02\x04\xd0\x86\x03\x12\x04\xc6\x05\x10v\n\x0e\n\
    \x04\x06\x01\x02\x03\x12\x06\xc9\x05\x08\xcb\x05\t\n\r\n\x05\x06\x01\x02\
    \x03\x01\x12\x04\xc9\x05\x0c%\n\r\n\x05\x06\x01\x02\x03\x02\x12\x04\xc9\
    \x05'S\n\r\n\x05\x06\x01\x02\x03\x03\x12\x04\xc9\x05^i\n\x0e\n\x05\x06\
    \x01\x02\x03\x04\x12\x05\xca\x05\x10\xab\x01\n\x11\n\x08\x06\x01\x02\x03\
    \x04\xd0\x86\x03\x12\x05\xca\x05\x10\xab\x01\n\x0e\n\x04\x06\x01\x02\x04\
    \x12\x06\xcd\x05\x08\xcf\x05\t\n\r\n\x05\x06\x01\x02\x04\x01\x12\x04\xcd\
    \x05\x0c\x1f\n\r\n\x05\x06\x01\x02\x04\x02\x12\x04\xcd\x05!G\n\r\n\x05\
    \x06\x01\x02\x04\x03\x12\x04\xcd\x05R]\n\x0e\n\x05\x06\x01\x02\x04\x04\
    \x12\x05\xce\x05\x10\x96\x01\n\x11\n\x08\x06\x01\x02\x04\x04\xd0\x86\x03\
    \x12\x05\xce\x05\x10\x96\x01\n\x0e\n\x04\x06\x01\x02\x05\x12\x06\xd1\x05\
    \x08\xd3\x05\t\n\r\n\x05\x06\x01\x02\x05\x01\x12\x04\xd1\x05\x0c'\n\r\n\
    \x05\x06\x01\x02\x05\x02\x12\x04\xd1\x05)W\n\r\n\x05\x06\x01\x02\x05\x03\
    \x12\x04\xd1\x05bm\n\x0e\n\x05\x06\x01\x02\x05\x04\x12\x05\xd2\x05\x10\
    \x94\x01\n\x11\n\x08\x06\x01\x02\x05\x04\xd0\x86\x03\x12\x05\xd2\x05\x10\
    \x94\x01\n\x0e\n\x04\x06\x01\x02\x06\x12\x06\xd5\x05\x08\xd7\x05\t\n\r\n\
    \x05\x06\x01\x02\x06\x01\x12\x04\xd5\x05\x0c!\n\r\n\x05\x06\x01\x02\x06\
    \x02\x12\x04\xd5\x05#K\n\r\n\x05\x06\x01\x02\x06\x03\x12\x04\xd5\x05Va\n\
    \r\n\x05\x06\x01\x02\x06\x04\x12\x04\xd6\x05\x10r\n\x10\n\x08\x06\x01\
    \x02\x06\x04\xd0\x86\x03\x12\x04\xd6\x05\x10r\n\x0e\n\x04\x06\x01\x02\
    \x07\x12\x06\xd9\x05\x08\xdb\x05\t\n\r\n\x05\x06\x01\x02\x07\x01\x12\x04\
    \xd9\x05\x0c&\n\r\n\x05\x06\x01\x02\x07\x02\x12\x04\xd9\x05(U\n\r\n\x05\
    \x06\x01\x02\x07\x03\x12\x04\xd9\x05`k\n\r\n\x05\x06\x01\x02\x07\x04\x12\
    \x04\xda\x05\x10r\n\x10\n\x08\x06\x01\x02\x07\x04\xd0\x86\x03\x12\x04\
    \xda\x05\x10r\n\x0e\n\x04\x06\x01\x02\x08\x12\x06\xdd\x05\x08\xdf\x05\t\
    \n\r\n\x05\x06\x01\x02\x08\x01\x12\x04\xdd\x05\x0c\x20\n\r\n\x05\x06\x01\
    \x02\x08\x02\x12\x04\xdd\x05\"O\n\r\n\x05\x06\x01\x02\x08\x03\x12\x04\
    \xdd\x05Ze\n\r\n\x05\x06\x01\x02\x08\x04\x12\x04\xde\x05\x10I\n\x10\n\
    \x08\x06\x01\x02\x08\x04\xd0\x86\x03\x12\x04\xde\x05\x10I\n\x0e\n\x04\
    \x06\x01\x02\t\x12\x06\xe1\x05\x08\xe3\x05\t\n\r\n\x05\x06\x01\x02\t\x01\
    \x12\x04\xe1\x05\x0c&\n\r\n\x05\x06\x01\x02\t\x02\x12\x04\xe1\x05(U\n\r\
    \n\x05\x06\x01\x02\t\x03\x12\x04\xe1\x05`k\n\r\n\x05\x06\x01\x02\t\x04\
    \x12\x04\xe2\x05\x10z\n\x10\n\x08\x06\x01\x02\t\x04\xd0\x86\x03\x12\x04\
    \xe2\x05\x10z\n\x0e\n\x04\x06\x01\x02\n\x12\x06\xe5\x05\x08\xe7\x05\t\n\
    \r\n\x05\x06\x01\x02\n\x01\x12\x04\xe5\x05\x0c\x1d\n\r\n\x05\x06\x01\x02\
    \n\x02\x12\x04\xe5\x05\x1fC\n\r\n\x05\x06\x01\x02\n\x03\x12\x04\xe5\x05N\
    Y\n\r\n\x05\x06\x01\x02\n\x04\x12\x04\xe6\x05\x10y\n\x10\n\x08\x06\x01\
    \x02\n\x04\xd0\x86\x03\x12\x04\xe6\x05\x10y\n\x0e\n\x04\x06\x01\x02\x0b\
    \x12\x06\xe9\x05\x08\xeb\x05\t\n\r\n\x05\x06\x01\x02\x0b\x01\x12\x04\xe9\
    \x05\x0c!\n\r\n\x05\x06\x01\x02\x0b\x02\x12\x04\xe9\x05#K\n\r\n\x05\x06\
    \x01\x02\x0b\x03\x12\x04\xe9\x05Va\n\r\n\x05\x06\x01\x02\x0b\x04\x12\x04\
    \xea\x05\x10|\n\x10\n\x08\x06\x01\x02\x0b\x04\xd0\x86\x03\x12\x04\xea\
    \x05\x10|\n\x0e\n\x04\x06\x01\x02\x0c\x12\x06\xed\x05\x08\xef\x05\t\n\r\
    \n\x05\x06\x01\x02\x0c\x01\x12\x04\xed\x05\x0c*\n\r\n\x05\x06\x01\x02\
    \x0c\x02\x12\x04\xed\x05,]\n\r\n\x05\x06\x01\x02\x0c\x03\x12\x04\xed\x05\
    hs\n\x0e\n\x05\x06\x01\x02\x0c\x04\x12\x05\xee\x05\x10\x81\x01\n\x11\n\
    \x08\x06\x01\x02\x0c\x04\xd0\x86\x03\x12\x05\xee\x05\x10\x81\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
