// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steamdatagram_messages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgSteamDatagramRouterPingReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramRouterPingReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.client_timestamp)
    pub client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.latency_datacenter_ids)
    pub latency_datacenter_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.latency_ping_ms)
    pub latency_ping_ms: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.your_public_ip)
    pub your_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.server_time)
    pub server_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.scoring_penalty_relay_cluster)
    pub scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.route_exceptions)
    pub route_exceptions: ::std::vec::Vec<cmsg_steam_datagram_router_ping_reply::RouteException>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterPingReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply {
        <CMsgSteamDatagramRouterPingReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply {
    pub fn new() -> CMsgSteamDatagramRouterPingReply {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp = 1;

    pub fn client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 4;

    pub fn your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }

    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 5;

    pub fn server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }

    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 6;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 7;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 8;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 9;

    pub fn scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }

    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramRouterPingReply {
    const NAME: &'static str = "CMsgSteamDatagramRouterPingReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    is.read_repeated_packed_fixed32_into(&mut self.latency_datacenter_ids)?;
                },
                21 => {
                    self.latency_datacenter_ids.push(is.read_fixed32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.latency_ping_ms)?;
                },
                24 => {
                    self.latency_ping_ms.push(is.read_uint32()?);
                },
                37 => {
                    self.your_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.server_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                49 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                56 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.route_exceptions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_fixed32_size(2, &self.latency_datacenter_ids);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(3, &self.latency_ping_ms);
        if let Some(v) = self.your_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.route_exceptions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(1, v)?;
        }
        os.write_repeated_packed_fixed32(2, &self.latency_datacenter_ids)?;
        os.write_repeated_packed_uint32(3, &self.latency_ping_ms)?;
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(9, v)?;
        }
        for v in &self.route_exceptions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramRouterPingReply {
        CMsgSteamDatagramRouterPingReply::new()
    }

    fn clear(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
        self.latency_datacenter_ids.clear();
        self.latency_ping_ms.clear();
        self.your_public_ip = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.route_exceptions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply {
        static instance: CMsgSteamDatagramRouterPingReply = CMsgSteamDatagramRouterPingReply {
            client_timestamp: ::std::option::Option::None,
            latency_datacenter_ids: ::std::vec::Vec::new(),
            latency_ping_ms: ::std::vec::Vec::new(),
            your_public_ip: ::std::option::Option::None,
            server_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            client_cookie: ::std::option::Option::None,
            scoring_penalty_relay_cluster: ::std::option::Option::None,
            route_exceptions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramRouterPingReply`
pub mod cmsg_steam_datagram_router_ping_reply {
    // @@protoc_insertion_point(message:CMsgSteamDatagramRouterPingReply.RouteException)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RouteException {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.RouteException.data_center_id)
        pub data_center_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.RouteException.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.RouteException.penalty)
        pub penalty: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterPingReply.RouteException.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RouteException {
        fn default() -> &'a RouteException {
            <RouteException as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RouteException {
        pub fn new() -> RouteException {
            ::std::default::Default::default()
        }

        // optional fixed32 data_center_id = 1;

        pub fn data_center_id(&self) -> u32 {
            self.data_center_id.unwrap_or(0)
        }

        pub fn clear_data_center_id(&mut self) {
            self.data_center_id = ::std::option::Option::None;
        }

        pub fn has_data_center_id(&self) -> bool {
            self.data_center_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_center_id(&mut self, v: u32) {
            self.data_center_id = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 2;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 penalty = 3;

        pub fn penalty(&self) -> u32 {
            self.penalty.unwrap_or(0)
        }

        pub fn clear_penalty(&mut self) {
            self.penalty = ::std::option::Option::None;
        }

        pub fn has_penalty(&self) -> bool {
            self.penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_penalty(&mut self, v: u32) {
            self.penalty = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RouteException {
        const NAME: &'static str = "RouteException";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.data_center_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data_center_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.flags {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.penalty {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.data_center_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.penalty {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RouteException {
            RouteException::new()
        }

        fn clear(&mut self) {
            self.data_center_id = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.penalty = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RouteException {
            static instance: RouteException = RouteException {
                data_center_id: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                penalty: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameserverPing {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.legacy_client_session)
    pub legacy_client_session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.client_timestamp)
    pub client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.router_timestamp)
    pub router_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.router_gameserver_latency)
    pub router_gameserver_latency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.seq_number_router)
    pub seq_number_router: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.seq_number_e2e)
    pub seq_number_e2e: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.relay_session_id)
    pub relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPing {
    fn default() -> &'a CMsgSteamDatagramGameserverPing {
        <CMsgSteamDatagramGameserverPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPing {
    pub fn new() -> CMsgSteamDatagramGameserverPing {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_client_session = 1;

    pub fn legacy_client_session(&self) -> u32 {
        self.legacy_client_session.unwrap_or(0)
    }

    pub fn clear_legacy_client_session(&mut self) {
        self.legacy_client_session = ::std::option::Option::None;
    }

    pub fn has_legacy_client_session(&self) -> bool {
        self.legacy_client_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_session(&mut self, v: u32) {
        self.legacy_client_session = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 2;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_timestamp = 3;

    pub fn client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 router_timestamp = 4;

    pub fn router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }

    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 router_gameserver_latency = 5;

    pub fn router_gameserver_latency(&self) -> u32 {
        self.router_gameserver_latency.unwrap_or(0)
    }

    pub fn clear_router_gameserver_latency(&mut self) {
        self.router_gameserver_latency = ::std::option::Option::None;
    }

    pub fn has_router_gameserver_latency(&self) -> bool {
        self.router_gameserver_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_gameserver_latency(&mut self, v: u32) {
        self.router_gameserver_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_number_router = 6;

    pub fn seq_number_router(&self) -> u32 {
        self.seq_number_router.unwrap_or(0)
    }

    pub fn clear_seq_number_router(&mut self) {
        self.seq_number_router = ::std::option::Option::None;
    }

    pub fn has_seq_number_router(&self) -> bool {
        self.seq_number_router.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_number_router(&mut self, v: u32) {
        self.seq_number_router = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_number_e2e = 7;

    pub fn seq_number_e2e(&self) -> u32 {
        self.seq_number_e2e.unwrap_or(0)
    }

    pub fn clear_seq_number_e2e(&mut self) {
        self.seq_number_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_number_e2e(&self) -> bool {
        self.seq_number_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_number_e2e(&mut self, v: u32) {
        self.seq_number_e2e = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 8;

    pub fn relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }

    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 9;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramGameserverPing {
    const NAME: &'static str = "CMsgSteamDatagramGameserverPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_client_session = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.router_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.router_gameserver_latency = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seq_number_router = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.seq_number_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_session {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.router_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.router_gameserver_latency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seq_number_router {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.seq_number_e2e {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_client_session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.router_gameserver_latency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_number_router {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.seq_number_e2e {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverPing {
        CMsgSteamDatagramGameserverPing::new()
    }

    fn clear(&mut self) {
        self.legacy_client_session = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.client_timestamp = ::std::option::Option::None;
        self.router_timestamp = ::std::option::Option::None;
        self.router_gameserver_latency = ::std::option::Option::None;
        self.seq_number_router = ::std::option::Option::None;
        self.seq_number_e2e = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPing {
        static instance: CMsgSteamDatagramGameserverPing = CMsgSteamDatagramGameserverPing {
            legacy_client_session: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            client_timestamp: ::std::option::Option::None,
            router_timestamp: ::std::option::Option::None,
            router_gameserver_latency: ::std::option::Option::None,
            seq_number_router: ::std::option::Option::None,
            seq_number_e2e: ::std::option::Option::None,
            relay_session_id: ::std::option::Option::None,
            connection_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramRelayToRelayPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramRelayToRelayPing {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.request_timestamp)
    pub request_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.request_date)
    pub request_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.my_pop_id)
    pub my_pop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.your_pop_id)
    pub your_pop_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRelayToRelayPing.checksum)
    pub checksum: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramRelayToRelayPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRelayToRelayPing {
    fn default() -> &'a CMsgSteamDatagramRelayToRelayPing {
        <CMsgSteamDatagramRelayToRelayPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRelayToRelayPing {
    pub fn new() -> CMsgSteamDatagramRelayToRelayPing {
        ::std::default::Default::default()
    }

    // optional fixed32 request_timestamp = 1;

    pub fn request_timestamp(&self) -> u32 {
        self.request_timestamp.unwrap_or(0)
    }

    pub fn clear_request_timestamp(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
    }

    pub fn has_request_timestamp(&self) -> bool {
        self.request_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_timestamp(&mut self, v: u32) {
        self.request_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 request_date = 2;

    pub fn request_date(&self) -> u32 {
        self.request_date.unwrap_or(0)
    }

    pub fn clear_request_date(&mut self) {
        self.request_date = ::std::option::Option::None;
    }

    pub fn has_request_date(&self) -> bool {
        self.request_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_date(&mut self, v: u32) {
        self.request_date = ::std::option::Option::Some(v);
    }

    // optional fixed32 my_pop_id = 3;

    pub fn my_pop_id(&self) -> u32 {
        self.my_pop_id.unwrap_or(0)
    }

    pub fn clear_my_pop_id(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
    }

    pub fn has_my_pop_id(&self) -> bool {
        self.my_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_pop_id(&mut self, v: u32) {
        self.my_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_pop_id = 4;

    pub fn your_pop_id(&self) -> u32 {
        self.your_pop_id.unwrap_or(0)
    }

    pub fn clear_your_pop_id(&mut self) {
        self.your_pop_id = ::std::option::Option::None;
    }

    pub fn has_your_pop_id(&self) -> bool {
        self.your_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_pop_id(&mut self, v: u32) {
        self.your_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 checksum = 5;

    pub fn checksum(&self) -> u32 {
        self.checksum.unwrap_or(0)
    }

    pub fn clear_checksum(&mut self) {
        self.checksum = ::std::option::Option::None;
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: u32) {
        self.checksum = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramRelayToRelayPing {
    const NAME: &'static str = "CMsgSteamDatagramRelayToRelayPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.request_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.request_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.my_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.your_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.checksum = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.request_date {
            my_size += 1 + 4;
        }
        if let Some(v) = self.my_pop_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_pop_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.checksum {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.request_timestamp {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.request_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.my_pop_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.your_pop_id {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.checksum {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramRelayToRelayPing {
        CMsgSteamDatagramRelayToRelayPing::new()
    }

    fn clear(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
        self.request_date = ::std::option::Option::None;
        self.my_pop_id = ::std::option::Option::None;
        self.your_pop_id = ::std::option::Option::None;
        self.checksum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramRelayToRelayPing {
        static instance: CMsgSteamDatagramRelayToRelayPing = CMsgSteamDatagramRelayToRelayPing {
            request_timestamp: ::std::option::Option::None,
            request_date: ::std::option::Option::None,
            my_pop_id: ::std::option::Option::None,
            your_pop_id: ::std::option::Option::None,
            checksum: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramSessionCryptInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramSessionCryptInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.key_type)
    pub key_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_steam_datagram_session_crypt_info::EKeyType>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.key_data)
    pub key_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.nonce)
    pub nonce: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.is_snp)
    pub is_snp: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramSessionCryptInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfo {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfo {
        <CMsgSteamDatagramSessionCryptInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfo {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfo {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1;

    pub fn key_type(&self) -> cmsg_steam_datagram_session_crypt_info::EKeyType {
        match self.key_type {
            Some(e) => e.enum_value_or(cmsg_steam_datagram_session_crypt_info::EKeyType::INVALID),
            None => cmsg_steam_datagram_session_crypt_info::EKeyType::INVALID,
        }
    }

    pub fn clear_key_type(&mut self) {
        self.key_type = ::std::option::Option::None;
    }

    pub fn has_key_type(&self) -> bool {
        self.key_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: cmsg_steam_datagram_session_crypt_info::EKeyType) {
        self.key_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes key_data = 2;

    pub fn key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_data(&mut self) {
        self.key_data = ::std::option::Option::None;
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 nonce = 3;

    pub fn nonce(&self) -> u64 {
        self.nonce.unwrap_or(0)
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // optional bool is_snp = 4;

    pub fn is_snp(&self) -> bool {
        self.is_snp.unwrap_or(false)
    }

    pub fn clear_is_snp(&mut self) {
        self.is_snp = ::std::option::Option::None;
    }

    pub fn has_is_snp(&self) -> bool {
        self.is_snp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_snp(&mut self, v: bool) {
        self.is_snp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramSessionCryptInfo {
    const NAME: &'static str = "CMsgSteamDatagramSessionCryptInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.key_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.key_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                25 => {
                    self.nonce = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.is_snp = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.key_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.nonce {
            my_size += 1 + 8;
        }
        if let Some(v) = self.is_snp {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.key_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.key_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.nonce {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.is_snp {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfo {
        CMsgSteamDatagramSessionCryptInfo::new()
    }

    fn clear(&mut self) {
        self.key_type = ::std::option::Option::None;
        self.key_data = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.is_snp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfo {
        static instance: CMsgSteamDatagramSessionCryptInfo = CMsgSteamDatagramSessionCryptInfo {
            key_type: ::std::option::Option::None,
            key_data: ::std::option::Option::None,
            nonce: ::std::option::Option::None,
            is_snp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramSessionCryptInfo`
pub mod cmsg_steam_datagram_session_crypt_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramSessionCryptInfo.EKeyType)
    pub enum EKeyType {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramSessionCryptInfo.EKeyType.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramSessionCryptInfo.EKeyType.CURVE25519)
        CURVE25519 = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EKeyType {
        const NAME: &'static str = "EKeyType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EKeyType> {
            match value {
                0 => ::std::option::Option::Some(EKeyType::INVALID),
                1 => ::std::option::Option::Some(EKeyType::CURVE25519),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EKeyType> {
            match str {
                "INVALID" => ::std::option::Option::Some(EKeyType::INVALID),
                "CURVE25519" => ::std::option::Option::Some(EKeyType::CURVE25519),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EKeyType] = &[
            EKeyType::INVALID,
            EKeyType::CURVE25519,
        ];
    }

    impl ::std::default::Default for EKeyType {
        fn default() -> Self {
            EKeyType::INVALID
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamDatagramSessionCryptInfoSigned)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramSessionCryptInfoSigned {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfoSigned.info)
    pub info: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfoSigned.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramSessionCryptInfoSigned.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfoSigned {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfoSigned {
        <CMsgSteamDatagramSessionCryptInfoSigned as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfoSigned {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        ::std::default::Default::default()
    }

    // optional bytes info = 1;

    pub fn info(&self) -> &[u8] {
        match self.info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.info.is_none() {
            self.info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::vec::Vec<u8> {
        self.info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramSessionCryptInfoSigned {
    const NAME: &'static str = "CMsgSteamDatagramSessionCryptInfoSigned";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.info = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        CMsgSteamDatagramSessionCryptInfoSigned::new()
    }

    fn clear(&mut self) {
        self.info = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfoSigned {
        static instance: CMsgSteamDatagramSessionCryptInfoSigned = CMsgSteamDatagramSessionCryptInfoSigned {
            info: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameserverSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.challenge_time)
    pub challenge_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.network_config_version)
    pub network_config_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverSessionRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionRequest {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionRequest {
        <CMsgSteamDatagramGameserverSessionRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionRequest {
    pub fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        ::std::default::Default::default()
    }

    // optional bytes ticket = 1;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 challenge_time = 3;

    pub fn challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }

    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 5;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 8;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 6;

    pub fn network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }

    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 7;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramGameserverSessionRequest {
    const NAME: &'static str = "CMsgSteamDatagramGameserverSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                29 => {
                    self.challenge_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.network_config_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.challenge_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.network_config_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.challenge_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        CMsgSteamDatagramGameserverSessionRequest::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionRequest {
        static instance: CMsgSteamDatagramGameserverSessionRequest = CMsgSteamDatagramGameserverSessionRequest {
            ticket: ::std::option::Option::None,
            challenge_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            network_config_version: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverSessionEstablished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramGameserverSessionEstablished {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.gameserver_steam_id)
    pub gameserver_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.legacy_relay_session_id)
    pub legacy_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverSessionEstablished.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionEstablished {
        <CMsgSteamDatagramGameserverSessionEstablished as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionEstablished {
    pub fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameserver_steam_id = 3;

    pub fn gameserver_steam_id(&self) -> u64 {
        self.gameserver_steam_id.unwrap_or(0)
    }

    pub fn clear_gameserver_steam_id(&mut self) {
        self.gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_steam_id(&self) -> bool {
        self.gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_steam_id(&mut self, v: u64) {
        self.gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 4;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_relay_session_id = 5;

    pub fn legacy_relay_session_id(&self) -> u32 {
        self.legacy_relay_session_id.unwrap_or(0)
    }

    pub fn clear_legacy_relay_session_id(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_relay_session_id(&self) -> bool {
        self.legacy_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_relay_session_id(&mut self, v: u32) {
        self.legacy_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 6;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramGameserverSessionEstablished {
    const NAME: &'static str = "CMsgSteamDatagramGameserverSessionEstablished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.gameserver_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.legacy_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gameserver_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.legacy_relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.gameserver_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.legacy_relay_session_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        CMsgSteamDatagramGameserverSessionEstablished::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.gameserver_steam_id = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.legacy_relay_session_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionEstablished {
        static instance: CMsgSteamDatagramGameserverSessionEstablished = CMsgSteamDatagramGameserverSessionEstablished {
            connection_id: ::std::option::Option::None,
            gameserver_steam_id: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            legacy_relay_session_id: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramNoSessionRelayToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNoSessionRelayToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.legacy_relay_session_id)
    pub legacy_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.your_public_ip)
    pub your_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.server_time)
    pub server_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToClient.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNoSessionRelayToClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToClient {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToClient {
        <CMsgSteamDatagramNoSessionRelayToClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToClient {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_relay_session_id = 1;

    pub fn legacy_relay_session_id(&self) -> u32 {
        self.legacy_relay_session_id.unwrap_or(0)
    }

    pub fn clear_legacy_relay_session_id(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_relay_session_id(&self) -> bool {
        self.legacy_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_relay_session_id(&mut self, v: u32) {
        self.legacy_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 7;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 2;

    pub fn your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }

    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 3;

    pub fn server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }

    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramNoSessionRelayToClient {
    const NAME: &'static str = "CMsgSteamDatagramNoSessionRelayToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.your_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.server_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_relay_session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        CMsgSteamDatagramNoSessionRelayToClient::new()
    }

    fn clear(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.your_public_ip = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToClient {
        static instance: CMsgSteamDatagramNoSessionRelayToClient = CMsgSteamDatagramNoSessionRelayToClient {
            legacy_relay_session_id: ::std::option::Option::None,
            connection_id: ::std::option::Option::None,
            your_public_ip: ::std::option::Option::None,
            server_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramNoSessionRelayToServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNoSessionRelayToServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToServer.relay_session_id)
    pub relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToServer.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToServer.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSessionRelayToServer.kludge_pad)
    pub kludge_pad: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNoSessionRelayToServer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToServer {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToServer {
        <CMsgSteamDatagramNoSessionRelayToServer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToServer {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToServer {
        ::std::default::Default::default()
    }

    // optional uint32 relay_session_id = 1;

    pub fn relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }

    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 8;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 kludge_pad = 99;

    pub fn kludge_pad(&self) -> u64 {
        self.kludge_pad.unwrap_or(0)
    }

    pub fn clear_kludge_pad(&mut self) {
        self.kludge_pad = ::std::option::Option::None;
    }

    pub fn has_kludge_pad(&self) -> bool {
        self.kludge_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kludge_pad(&mut self, v: u64) {
        self.kludge_pad = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramNoSessionRelayToServer {
    const NAME: &'static str = "CMsgSteamDatagramNoSessionRelayToServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                793 => {
                    self.kludge_pad = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.kludge_pad {
            my_size += 2 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.relay_session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.kludge_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToServer {
        CMsgSteamDatagramNoSessionRelayToServer::new()
    }

    fn clear(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.kludge_pad = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToServer {
        static instance: CMsgSteamDatagramNoSessionRelayToServer = CMsgSteamDatagramNoSessionRelayToServer {
            relay_session_id: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            kludge_pad: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramDiagnostic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramDiagnostic {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramDiagnostic.severity)
    pub severity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramDiagnostic.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramDiagnostic.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDiagnostic {
    fn default() -> &'a CMsgSteamDatagramDiagnostic {
        <CMsgSteamDatagramDiagnostic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDiagnostic {
    pub fn new() -> CMsgSteamDatagramDiagnostic {
        ::std::default::Default::default()
    }

    // optional uint32 severity = 1;

    pub fn severity(&self) -> u32 {
        self.severity.unwrap_or(0)
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: u32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramDiagnostic {
    const NAME: &'static str = "CMsgSteamDatagramDiagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.severity = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.severity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.severity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramDiagnostic {
        CMsgSteamDatagramDiagnostic::new()
    }

    fn clear(&mut self) {
        self.severity = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramDiagnostic {
        static instance: CMsgSteamDatagramDiagnostic = CMsgSteamDatagramDiagnostic {
            severity: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramDataCenterState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.data_centers)
    pub data_centers: ::std::vec::Vec<cmsg_steam_datagram_data_center_state::DataCenter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState {
    fn default() -> &'a CMsgSteamDatagramDataCenterState {
        <CMsgSteamDatagramDataCenterState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState {
    pub fn new() -> CMsgSteamDatagramDataCenterState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramDataCenterState {
    const NAME: &'static str = "CMsgSteamDatagramDataCenterState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_centers.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.data_centers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramDataCenterState {
        CMsgSteamDatagramDataCenterState::new()
    }

    fn clear(&mut self) {
        self.data_centers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState {
        static instance: CMsgSteamDatagramDataCenterState = CMsgSteamDatagramDataCenterState {
            data_centers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramDataCenterState`
pub mod cmsg_steam_datagram_data_center_state {
    // @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState.Server)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Server {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.Server.address)
        pub address: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.Server.ping_ms)
        pub ping_ms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.Server.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server {
        fn default() -> &'a Server {
            <Server as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Server {
        pub fn new() -> Server {
            ::std::default::Default::default()
        }

        // optional string address = 1;

        pub fn address(&self) -> &str {
            match self.address.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_address(&mut self) {
            self.address = ::std::option::Option::None;
        }

        pub fn has_address(&self) -> bool {
            self.address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_address(&mut self, v: ::std::string::String) {
            self.address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_address(&mut self) -> &mut ::std::string::String {
            if self.address.is_none() {
                self.address = ::std::option::Option::Some(::std::string::String::new());
            }
            self.address.as_mut().unwrap()
        }

        // Take field
        pub fn take_address(&mut self) -> ::std::string::String {
            self.address.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ping_ms = 2;

        pub fn ping_ms(&self) -> u32 {
            self.ping_ms.unwrap_or(0)
        }

        pub fn clear_ping_ms(&mut self) {
            self.ping_ms = ::std::option::Option::None;
        }

        pub fn has_ping_ms(&self) -> bool {
            self.ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_ms(&mut self, v: u32) {
            self.ping_ms = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Server {
        const NAME: &'static str = "Server";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.address = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.address.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.ping_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.address.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.ping_ms {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server {
            Server::new()
        }

        fn clear(&mut self) {
            self.address = ::std::option::Option::None;
            self.ping_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server {
            static instance: Server = Server {
                address: ::std::option::Option::None,
                ping_ms: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState.DataCenter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DataCenter {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.code)
        pub code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.server_sample)
        pub server_sample: ::std::vec::Vec<Server>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.relay_sample)
        pub relay_sample: ::std::vec::Vec<Server>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.DataCenter.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataCenter {
        fn default() -> &'a DataCenter {
            <DataCenter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DataCenter {
        pub fn new() -> DataCenter {
            ::std::default::Default::default()
        }

        // optional string code = 1;

        pub fn code(&self) -> &str {
            match self.code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_code(&mut self) {
            self.code = ::std::option::Option::None;
        }

        pub fn has_code(&self) -> bool {
            self.code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_code(&mut self, v: ::std::string::String) {
            self.code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_code(&mut self) -> &mut ::std::string::String {
            if self.code.is_none() {
                self.code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.code.as_mut().unwrap()
        }

        // Take field
        pub fn take_code(&mut self) -> ::std::string::String {
            self.code.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DataCenter {
        const NAME: &'static str = "DataCenter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.code = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.server_sample.push(is.read_message()?);
                    },
                    26 => {
                        self.relay_sample.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.code.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            for value in &self.server_sample {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.relay_sample {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.code.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.server_sample {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.relay_sample {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataCenter {
            DataCenter::new()
        }

        fn clear(&mut self) {
            self.code = ::std::option::Option::None;
            self.server_sample.clear();
            self.relay_sample.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataCenter {
            static instance: DataCenter = DataCenter {
                code: ::std::option::Option::None,
                server_sample: ::std::vec::Vec::new(),
                relay_sample: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramLinkInstantaneousStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramLinkInstantaneousStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.out_packets_per_sec_x10)
    pub out_packets_per_sec_x10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.out_bytes_per_sec)
    pub out_bytes_per_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.in_packets_per_sec_x10)
    pub in_packets_per_sec_x10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.in_bytes_per_sec)
    pub in_bytes_per_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.ping_ms)
    pub ping_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.packets_dropped_pct)
    pub packets_dropped_pct: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.packets_weird_sequence_pct)
    pub packets_weird_sequence_pct: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.peak_jitter_usec)
    pub peak_jitter_usec: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramLinkInstantaneousStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkInstantaneousStats {
    fn default() -> &'a CMsgSteamDatagramLinkInstantaneousStats {
        <CMsgSteamDatagramLinkInstantaneousStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkInstantaneousStats {
    pub fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        ::std::default::Default::default()
    }

    // optional uint32 out_packets_per_sec_x10 = 1;

    pub fn out_packets_per_sec_x10(&self) -> u32 {
        self.out_packets_per_sec_x10.unwrap_or(0)
    }

    pub fn clear_out_packets_per_sec_x10(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_out_packets_per_sec_x10(&self) -> bool {
        self.out_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_packets_per_sec_x10(&mut self, v: u32) {
        self.out_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 out_bytes_per_sec = 2;

    pub fn out_bytes_per_sec(&self) -> u32 {
        self.out_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_out_bytes_per_sec(&mut self) {
        self.out_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_out_bytes_per_sec(&self) -> bool {
        self.out_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_bytes_per_sec(&mut self, v: u32) {
        self.out_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 in_packets_per_sec_x10 = 3;

    pub fn in_packets_per_sec_x10(&self) -> u32 {
        self.in_packets_per_sec_x10.unwrap_or(0)
    }

    pub fn clear_in_packets_per_sec_x10(&mut self) {
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_in_packets_per_sec_x10(&self) -> bool {
        self.in_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_packets_per_sec_x10(&mut self, v: u32) {
        self.in_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 in_bytes_per_sec = 4;

    pub fn in_bytes_per_sec(&self) -> u32 {
        self.in_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_in_bytes_per_sec(&mut self) {
        self.in_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_in_bytes_per_sec(&self) -> bool {
        self.in_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_bytes_per_sec(&mut self, v: u32) {
        self.in_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ms = 5;

    pub fn ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }

    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_dropped_pct = 6;

    pub fn packets_dropped_pct(&self) -> u32 {
        self.packets_dropped_pct.unwrap_or(0)
    }

    pub fn clear_packets_dropped_pct(&mut self) {
        self.packets_dropped_pct = ::std::option::Option::None;
    }

    pub fn has_packets_dropped_pct(&self) -> bool {
        self.packets_dropped_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_dropped_pct(&mut self, v: u32) {
        self.packets_dropped_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_weird_sequence_pct = 7;

    pub fn packets_weird_sequence_pct(&self) -> u32 {
        self.packets_weird_sequence_pct.unwrap_or(0)
    }

    pub fn clear_packets_weird_sequence_pct(&mut self) {
        self.packets_weird_sequence_pct = ::std::option::Option::None;
    }

    pub fn has_packets_weird_sequence_pct(&self) -> bool {
        self.packets_weird_sequence_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_weird_sequence_pct(&mut self, v: u32) {
        self.packets_weird_sequence_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 peak_jitter_usec = 8;

    pub fn peak_jitter_usec(&self) -> u32 {
        self.peak_jitter_usec.unwrap_or(0)
    }

    pub fn clear_peak_jitter_usec(&mut self) {
        self.peak_jitter_usec = ::std::option::Option::None;
    }

    pub fn has_peak_jitter_usec(&self) -> bool {
        self.peak_jitter_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peak_jitter_usec(&mut self, v: u32) {
        self.peak_jitter_usec = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramLinkInstantaneousStats {
    const NAME: &'static str = "CMsgSteamDatagramLinkInstantaneousStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.out_packets_per_sec_x10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.out_bytes_per_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.in_packets_per_sec_x10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_bytes_per_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.packets_dropped_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.packets_weird_sequence_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.peak_jitter_usec = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.out_packets_per_sec_x10 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.out_bytes_per_sec {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_bytes_per_sec {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.packets_dropped_pct {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.peak_jitter_usec {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.out_packets_per_sec_x10 {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.out_bytes_per_sec {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_bytes_per_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.packets_dropped_pct {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.peak_jitter_usec {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        CMsgSteamDatagramLinkInstantaneousStats::new()
    }

    fn clear(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
        self.out_bytes_per_sec = ::std::option::Option::None;
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
        self.in_bytes_per_sec = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.packets_dropped_pct = ::std::option::Option::None;
        self.packets_weird_sequence_pct = ::std::option::Option::None;
        self.peak_jitter_usec = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkInstantaneousStats {
        static instance: CMsgSteamDatagramLinkInstantaneousStats = CMsgSteamDatagramLinkInstantaneousStats {
            out_packets_per_sec_x10: ::std::option::Option::None,
            out_bytes_per_sec: ::std::option::Option::None,
            in_packets_per_sec_x10: ::std::option::Option::None,
            in_bytes_per_sec: ::std::option::Option::None,
            ping_ms: ::std::option::Option::None,
            packets_dropped_pct: ::std::option::Option::None,
            packets_weird_sequence_pct: ::std::option::Option::None,
            peak_jitter_usec: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramLinkLifetimeStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramLinkLifetimeStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_sent)
    pub packets_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.kb_sent)
    pub kb_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv)
    pub packets_recv: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.kb_recv)
    pub kb_recv: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_sequenced)
    pub packets_recv_sequenced: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_dropped)
    pub packets_recv_dropped: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_out_of_order)
    pub packets_recv_out_of_order: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_duplicate)
    pub packets_recv_duplicate: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_lurch)
    pub packets_recv_lurch: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_100)
    pub quality_histogram_100: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_99)
    pub quality_histogram_99: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_97)
    pub quality_histogram_97: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_95)
    pub quality_histogram_95: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_90)
    pub quality_histogram_90: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_75)
    pub quality_histogram_75: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_50)
    pub quality_histogram_50: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_1)
    pub quality_histogram_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_dead)
    pub quality_histogram_dead: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_2nd)
    pub quality_ntile_2nd: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_5th)
    pub quality_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_25th)
    pub quality_ntile_25th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_50th)
    pub quality_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_25)
    pub ping_histogram_25: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_50)
    pub ping_histogram_50: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_75)
    pub ping_histogram_75: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_100)
    pub ping_histogram_100: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_125)
    pub ping_histogram_125: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_150)
    pub ping_histogram_150: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_200)
    pub ping_histogram_200: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_300)
    pub ping_histogram_300: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_max)
    pub ping_histogram_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_5th)
    pub ping_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_50th)
    pub ping_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_75th)
    pub ping_ntile_75th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_95th)
    pub ping_ntile_95th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_98th)
    pub ping_ntile_98th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_negligible)
    pub jitter_histogram_negligible: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_1)
    pub jitter_histogram_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_2)
    pub jitter_histogram_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_5)
    pub jitter_histogram_5: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_10)
    pub jitter_histogram_10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_20)
    pub jitter_histogram_20: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_max)
    pub txspeed_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_16)
    pub txspeed_histogram_16: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_32)
    pub txspeed_histogram_32: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_64)
    pub txspeed_histogram_64: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_128)
    pub txspeed_histogram_128: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_256)
    pub txspeed_histogram_256: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_512)
    pub txspeed_histogram_512: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_1024)
    pub txspeed_histogram_1024: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_max)
    pub txspeed_histogram_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_5th)
    pub txspeed_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_50th)
    pub txspeed_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_75th)
    pub txspeed_ntile_75th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_95th)
    pub txspeed_ntile_95th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_98th)
    pub txspeed_ntile_98th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_max)
    pub rxspeed_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_16)
    pub rxspeed_histogram_16: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_32)
    pub rxspeed_histogram_32: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_64)
    pub rxspeed_histogram_64: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_128)
    pub rxspeed_histogram_128: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_256)
    pub rxspeed_histogram_256: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_512)
    pub rxspeed_histogram_512: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_1024)
    pub rxspeed_histogram_1024: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_max)
    pub rxspeed_histogram_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_5th)
    pub rxspeed_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_50th)
    pub rxspeed_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_75th)
    pub rxspeed_ntile_75th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_95th)
    pub rxspeed_ntile_95th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_98th)
    pub rxspeed_ntile_98th: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramLinkLifetimeStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkLifetimeStats {
    fn default() -> &'a CMsgSteamDatagramLinkLifetimeStats {
        <CMsgSteamDatagramLinkLifetimeStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkLifetimeStats {
    pub fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        ::std::default::Default::default()
    }

    // optional uint64 packets_sent = 3;

    pub fn packets_sent(&self) -> u64 {
        self.packets_sent.unwrap_or(0)
    }

    pub fn clear_packets_sent(&mut self) {
        self.packets_sent = ::std::option::Option::None;
    }

    pub fn has_packets_sent(&self) -> bool {
        self.packets_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_sent(&mut self, v: u64) {
        self.packets_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_sent = 4;

    pub fn kb_sent(&self) -> u64 {
        self.kb_sent.unwrap_or(0)
    }

    pub fn clear_kb_sent(&mut self) {
        self.kb_sent = ::std::option::Option::None;
    }

    pub fn has_kb_sent(&self) -> bool {
        self.kb_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_sent(&mut self, v: u64) {
        self.kb_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv = 5;

    pub fn packets_recv(&self) -> u64 {
        self.packets_recv.unwrap_or(0)
    }

    pub fn clear_packets_recv(&mut self) {
        self.packets_recv = ::std::option::Option::None;
    }

    pub fn has_packets_recv(&self) -> bool {
        self.packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv(&mut self, v: u64) {
        self.packets_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_recv = 6;

    pub fn kb_recv(&self) -> u64 {
        self.kb_recv.unwrap_or(0)
    }

    pub fn clear_kb_recv(&mut self) {
        self.kb_recv = ::std::option::Option::None;
    }

    pub fn has_kb_recv(&self) -> bool {
        self.kb_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_recv(&mut self, v: u64) {
        self.kb_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_sequenced = 7;

    pub fn packets_recv_sequenced(&self) -> u64 {
        self.packets_recv_sequenced.unwrap_or(0)
    }

    pub fn clear_packets_recv_sequenced(&mut self) {
        self.packets_recv_sequenced = ::std::option::Option::None;
    }

    pub fn has_packets_recv_sequenced(&self) -> bool {
        self.packets_recv_sequenced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_sequenced(&mut self, v: u64) {
        self.packets_recv_sequenced = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_dropped = 8;

    pub fn packets_recv_dropped(&self) -> u64 {
        self.packets_recv_dropped.unwrap_or(0)
    }

    pub fn clear_packets_recv_dropped(&mut self) {
        self.packets_recv_dropped = ::std::option::Option::None;
    }

    pub fn has_packets_recv_dropped(&self) -> bool {
        self.packets_recv_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_dropped(&mut self, v: u64) {
        self.packets_recv_dropped = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_out_of_order = 9;

    pub fn packets_recv_out_of_order(&self) -> u64 {
        self.packets_recv_out_of_order.unwrap_or(0)
    }

    pub fn clear_packets_recv_out_of_order(&mut self) {
        self.packets_recv_out_of_order = ::std::option::Option::None;
    }

    pub fn has_packets_recv_out_of_order(&self) -> bool {
        self.packets_recv_out_of_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_out_of_order(&mut self, v: u64) {
        self.packets_recv_out_of_order = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_duplicate = 10;

    pub fn packets_recv_duplicate(&self) -> u64 {
        self.packets_recv_duplicate.unwrap_or(0)
    }

    pub fn clear_packets_recv_duplicate(&mut self) {
        self.packets_recv_duplicate = ::std::option::Option::None;
    }

    pub fn has_packets_recv_duplicate(&self) -> bool {
        self.packets_recv_duplicate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_duplicate(&mut self, v: u64) {
        self.packets_recv_duplicate = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_lurch = 11;

    pub fn packets_recv_lurch(&self) -> u64 {
        self.packets_recv_lurch.unwrap_or(0)
    }

    pub fn clear_packets_recv_lurch(&mut self) {
        self.packets_recv_lurch = ::std::option::Option::None;
    }

    pub fn has_packets_recv_lurch(&self) -> bool {
        self.packets_recv_lurch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_lurch(&mut self, v: u64) {
        self.packets_recv_lurch = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_100 = 21;

    pub fn quality_histogram_100(&self) -> u32 {
        self.quality_histogram_100.unwrap_or(0)
    }

    pub fn clear_quality_histogram_100(&mut self) {
        self.quality_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_100(&self) -> bool {
        self.quality_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_100(&mut self, v: u32) {
        self.quality_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_99 = 22;

    pub fn quality_histogram_99(&self) -> u32 {
        self.quality_histogram_99.unwrap_or(0)
    }

    pub fn clear_quality_histogram_99(&mut self) {
        self.quality_histogram_99 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_99(&self) -> bool {
        self.quality_histogram_99.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_99(&mut self, v: u32) {
        self.quality_histogram_99 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_97 = 23;

    pub fn quality_histogram_97(&self) -> u32 {
        self.quality_histogram_97.unwrap_or(0)
    }

    pub fn clear_quality_histogram_97(&mut self) {
        self.quality_histogram_97 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_97(&self) -> bool {
        self.quality_histogram_97.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_97(&mut self, v: u32) {
        self.quality_histogram_97 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_95 = 24;

    pub fn quality_histogram_95(&self) -> u32 {
        self.quality_histogram_95.unwrap_or(0)
    }

    pub fn clear_quality_histogram_95(&mut self) {
        self.quality_histogram_95 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_95(&self) -> bool {
        self.quality_histogram_95.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_95(&mut self, v: u32) {
        self.quality_histogram_95 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_90 = 25;

    pub fn quality_histogram_90(&self) -> u32 {
        self.quality_histogram_90.unwrap_or(0)
    }

    pub fn clear_quality_histogram_90(&mut self) {
        self.quality_histogram_90 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_90(&self) -> bool {
        self.quality_histogram_90.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_90(&mut self, v: u32) {
        self.quality_histogram_90 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_75 = 26;

    pub fn quality_histogram_75(&self) -> u32 {
        self.quality_histogram_75.unwrap_or(0)
    }

    pub fn clear_quality_histogram_75(&mut self) {
        self.quality_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_75(&self) -> bool {
        self.quality_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_75(&mut self, v: u32) {
        self.quality_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_50 = 27;

    pub fn quality_histogram_50(&self) -> u32 {
        self.quality_histogram_50.unwrap_or(0)
    }

    pub fn clear_quality_histogram_50(&mut self) {
        self.quality_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_50(&self) -> bool {
        self.quality_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_50(&mut self, v: u32) {
        self.quality_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_1 = 28;

    pub fn quality_histogram_1(&self) -> u32 {
        self.quality_histogram_1.unwrap_or(0)
    }

    pub fn clear_quality_histogram_1(&mut self) {
        self.quality_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_1(&self) -> bool {
        self.quality_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_1(&mut self, v: u32) {
        self.quality_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_dead = 29;

    pub fn quality_histogram_dead(&self) -> u32 {
        self.quality_histogram_dead.unwrap_or(0)
    }

    pub fn clear_quality_histogram_dead(&mut self) {
        self.quality_histogram_dead = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_dead(&self) -> bool {
        self.quality_histogram_dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_dead(&mut self, v: u32) {
        self.quality_histogram_dead = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_2nd = 30;

    pub fn quality_ntile_2nd(&self) -> u32 {
        self.quality_ntile_2nd.unwrap_or(0)
    }

    pub fn clear_quality_ntile_2nd(&mut self) {
        self.quality_ntile_2nd = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_2nd(&self) -> bool {
        self.quality_ntile_2nd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_2nd(&mut self, v: u32) {
        self.quality_ntile_2nd = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_5th = 31;

    pub fn quality_ntile_5th(&self) -> u32 {
        self.quality_ntile_5th.unwrap_or(0)
    }

    pub fn clear_quality_ntile_5th(&mut self) {
        self.quality_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_5th(&self) -> bool {
        self.quality_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_5th(&mut self, v: u32) {
        self.quality_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_25th = 32;

    pub fn quality_ntile_25th(&self) -> u32 {
        self.quality_ntile_25th.unwrap_or(0)
    }

    pub fn clear_quality_ntile_25th(&mut self) {
        self.quality_ntile_25th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_25th(&self) -> bool {
        self.quality_ntile_25th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_25th(&mut self, v: u32) {
        self.quality_ntile_25th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_50th = 33;

    pub fn quality_ntile_50th(&self) -> u32 {
        self.quality_ntile_50th.unwrap_or(0)
    }

    pub fn clear_quality_ntile_50th(&mut self) {
        self.quality_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_50th(&self) -> bool {
        self.quality_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_50th(&mut self, v: u32) {
        self.quality_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_25 = 41;

    pub fn ping_histogram_25(&self) -> u32 {
        self.ping_histogram_25.unwrap_or(0)
    }

    pub fn clear_ping_histogram_25(&mut self) {
        self.ping_histogram_25 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_25(&self) -> bool {
        self.ping_histogram_25.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_25(&mut self, v: u32) {
        self.ping_histogram_25 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_50 = 42;

    pub fn ping_histogram_50(&self) -> u32 {
        self.ping_histogram_50.unwrap_or(0)
    }

    pub fn clear_ping_histogram_50(&mut self) {
        self.ping_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_50(&self) -> bool {
        self.ping_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_50(&mut self, v: u32) {
        self.ping_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_75 = 43;

    pub fn ping_histogram_75(&self) -> u32 {
        self.ping_histogram_75.unwrap_or(0)
    }

    pub fn clear_ping_histogram_75(&mut self) {
        self.ping_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_75(&self) -> bool {
        self.ping_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_75(&mut self, v: u32) {
        self.ping_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_100 = 44;

    pub fn ping_histogram_100(&self) -> u32 {
        self.ping_histogram_100.unwrap_or(0)
    }

    pub fn clear_ping_histogram_100(&mut self) {
        self.ping_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_100(&self) -> bool {
        self.ping_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_100(&mut self, v: u32) {
        self.ping_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_125 = 45;

    pub fn ping_histogram_125(&self) -> u32 {
        self.ping_histogram_125.unwrap_or(0)
    }

    pub fn clear_ping_histogram_125(&mut self) {
        self.ping_histogram_125 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_125(&self) -> bool {
        self.ping_histogram_125.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_125(&mut self, v: u32) {
        self.ping_histogram_125 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_150 = 46;

    pub fn ping_histogram_150(&self) -> u32 {
        self.ping_histogram_150.unwrap_or(0)
    }

    pub fn clear_ping_histogram_150(&mut self) {
        self.ping_histogram_150 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_150(&self) -> bool {
        self.ping_histogram_150.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_150(&mut self, v: u32) {
        self.ping_histogram_150 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_200 = 47;

    pub fn ping_histogram_200(&self) -> u32 {
        self.ping_histogram_200.unwrap_or(0)
    }

    pub fn clear_ping_histogram_200(&mut self) {
        self.ping_histogram_200 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_200(&self) -> bool {
        self.ping_histogram_200.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_200(&mut self, v: u32) {
        self.ping_histogram_200 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_300 = 48;

    pub fn ping_histogram_300(&self) -> u32 {
        self.ping_histogram_300.unwrap_or(0)
    }

    pub fn clear_ping_histogram_300(&mut self) {
        self.ping_histogram_300 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_300(&self) -> bool {
        self.ping_histogram_300.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_300(&mut self, v: u32) {
        self.ping_histogram_300 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_max = 49;

    pub fn ping_histogram_max(&self) -> u32 {
        self.ping_histogram_max.unwrap_or(0)
    }

    pub fn clear_ping_histogram_max(&mut self) {
        self.ping_histogram_max = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_max(&self) -> bool {
        self.ping_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_max(&mut self, v: u32) {
        self.ping_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_5th = 50;

    pub fn ping_ntile_5th(&self) -> u32 {
        self.ping_ntile_5th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_5th(&mut self) {
        self.ping_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_5th(&self) -> bool {
        self.ping_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_5th(&mut self, v: u32) {
        self.ping_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_50th = 51;

    pub fn ping_ntile_50th(&self) -> u32 {
        self.ping_ntile_50th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_50th(&mut self) {
        self.ping_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_50th(&self) -> bool {
        self.ping_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_50th(&mut self, v: u32) {
        self.ping_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_75th = 52;

    pub fn ping_ntile_75th(&self) -> u32 {
        self.ping_ntile_75th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_75th(&mut self) {
        self.ping_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_75th(&self) -> bool {
        self.ping_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_75th(&mut self, v: u32) {
        self.ping_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_95th = 53;

    pub fn ping_ntile_95th(&self) -> u32 {
        self.ping_ntile_95th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_95th(&mut self) {
        self.ping_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_95th(&self) -> bool {
        self.ping_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_95th(&mut self, v: u32) {
        self.ping_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_98th = 54;

    pub fn ping_ntile_98th(&self) -> u32 {
        self.ping_ntile_98th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_98th(&mut self) {
        self.ping_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_98th(&self) -> bool {
        self.ping_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_98th(&mut self, v: u32) {
        self.ping_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_negligible = 61;

    pub fn jitter_histogram_negligible(&self) -> u32 {
        self.jitter_histogram_negligible.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_negligible(&mut self) {
        self.jitter_histogram_negligible = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_negligible(&self) -> bool {
        self.jitter_histogram_negligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_negligible(&mut self, v: u32) {
        self.jitter_histogram_negligible = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_1 = 62;

    pub fn jitter_histogram_1(&self) -> u32 {
        self.jitter_histogram_1.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_1(&mut self) {
        self.jitter_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_1(&self) -> bool {
        self.jitter_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_1(&mut self, v: u32) {
        self.jitter_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_2 = 63;

    pub fn jitter_histogram_2(&self) -> u32 {
        self.jitter_histogram_2.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_2(&mut self) {
        self.jitter_histogram_2 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_2(&self) -> bool {
        self.jitter_histogram_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_2(&mut self, v: u32) {
        self.jitter_histogram_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_5 = 64;

    pub fn jitter_histogram_5(&self) -> u32 {
        self.jitter_histogram_5.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_5(&mut self) {
        self.jitter_histogram_5 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_5(&self) -> bool {
        self.jitter_histogram_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_5(&mut self, v: u32) {
        self.jitter_histogram_5 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_10 = 65;

    pub fn jitter_histogram_10(&self) -> u32 {
        self.jitter_histogram_10.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_10(&mut self) {
        self.jitter_histogram_10 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_10(&self) -> bool {
        self.jitter_histogram_10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_10(&mut self, v: u32) {
        self.jitter_histogram_10 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_20 = 66;

    pub fn jitter_histogram_20(&self) -> u32 {
        self.jitter_histogram_20.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_20(&mut self) {
        self.jitter_histogram_20 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_20(&self) -> bool {
        self.jitter_histogram_20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_20(&mut self, v: u32) {
        self.jitter_histogram_20 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_max = 67;

    pub fn txspeed_max(&self) -> u32 {
        self.txspeed_max.unwrap_or(0)
    }

    pub fn clear_txspeed_max(&mut self) {
        self.txspeed_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_max(&self) -> bool {
        self.txspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_max(&mut self, v: u32) {
        self.txspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_16 = 68;

    pub fn txspeed_histogram_16(&self) -> u32 {
        self.txspeed_histogram_16.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_16(&mut self) {
        self.txspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_16(&self) -> bool {
        self.txspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_16(&mut self, v: u32) {
        self.txspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_32 = 69;

    pub fn txspeed_histogram_32(&self) -> u32 {
        self.txspeed_histogram_32.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_32(&mut self) {
        self.txspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_32(&self) -> bool {
        self.txspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_32(&mut self, v: u32) {
        self.txspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_64 = 70;

    pub fn txspeed_histogram_64(&self) -> u32 {
        self.txspeed_histogram_64.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_64(&mut self) {
        self.txspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_64(&self) -> bool {
        self.txspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_64(&mut self, v: u32) {
        self.txspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_128 = 71;

    pub fn txspeed_histogram_128(&self) -> u32 {
        self.txspeed_histogram_128.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_128(&mut self) {
        self.txspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_128(&self) -> bool {
        self.txspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_128(&mut self, v: u32) {
        self.txspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_256 = 72;

    pub fn txspeed_histogram_256(&self) -> u32 {
        self.txspeed_histogram_256.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_256(&mut self) {
        self.txspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_256(&self) -> bool {
        self.txspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_256(&mut self, v: u32) {
        self.txspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_512 = 73;

    pub fn txspeed_histogram_512(&self) -> u32 {
        self.txspeed_histogram_512.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_512(&mut self) {
        self.txspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_512(&self) -> bool {
        self.txspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_512(&mut self, v: u32) {
        self.txspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_1024 = 74;

    pub fn txspeed_histogram_1024(&self) -> u32 {
        self.txspeed_histogram_1024.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_1024(&mut self) {
        self.txspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_1024(&self) -> bool {
        self.txspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_1024(&mut self, v: u32) {
        self.txspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_max = 75;

    pub fn txspeed_histogram_max(&self) -> u32 {
        self.txspeed_histogram_max.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_max(&mut self) {
        self.txspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_max(&self) -> bool {
        self.txspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_max(&mut self, v: u32) {
        self.txspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_5th = 76;

    pub fn txspeed_ntile_5th(&self) -> u32 {
        self.txspeed_ntile_5th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_5th(&mut self) {
        self.txspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_5th(&self) -> bool {
        self.txspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_5th(&mut self, v: u32) {
        self.txspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_50th = 77;

    pub fn txspeed_ntile_50th(&self) -> u32 {
        self.txspeed_ntile_50th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_50th(&mut self) {
        self.txspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_50th(&self) -> bool {
        self.txspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_50th(&mut self, v: u32) {
        self.txspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_75th = 78;

    pub fn txspeed_ntile_75th(&self) -> u32 {
        self.txspeed_ntile_75th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_75th(&mut self) {
        self.txspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_75th(&self) -> bool {
        self.txspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_75th(&mut self, v: u32) {
        self.txspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_95th = 79;

    pub fn txspeed_ntile_95th(&self) -> u32 {
        self.txspeed_ntile_95th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_95th(&mut self) {
        self.txspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_95th(&self) -> bool {
        self.txspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_95th(&mut self, v: u32) {
        self.txspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_98th = 80;

    pub fn txspeed_ntile_98th(&self) -> u32 {
        self.txspeed_ntile_98th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_98th(&mut self) {
        self.txspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_98th(&self) -> bool {
        self.txspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_98th(&mut self, v: u32) {
        self.txspeed_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_max = 81;

    pub fn rxspeed_max(&self) -> u32 {
        self.rxspeed_max.unwrap_or(0)
    }

    pub fn clear_rxspeed_max(&mut self) {
        self.rxspeed_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_max(&self) -> bool {
        self.rxspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_max(&mut self, v: u32) {
        self.rxspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_16 = 82;

    pub fn rxspeed_histogram_16(&self) -> u32 {
        self.rxspeed_histogram_16.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_16(&mut self) {
        self.rxspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_16(&self) -> bool {
        self.rxspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_16(&mut self, v: u32) {
        self.rxspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_32 = 83;

    pub fn rxspeed_histogram_32(&self) -> u32 {
        self.rxspeed_histogram_32.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_32(&mut self) {
        self.rxspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_32(&self) -> bool {
        self.rxspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_32(&mut self, v: u32) {
        self.rxspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_64 = 84;

    pub fn rxspeed_histogram_64(&self) -> u32 {
        self.rxspeed_histogram_64.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_64(&mut self) {
        self.rxspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_64(&self) -> bool {
        self.rxspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_64(&mut self, v: u32) {
        self.rxspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_128 = 85;

    pub fn rxspeed_histogram_128(&self) -> u32 {
        self.rxspeed_histogram_128.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_128(&mut self) {
        self.rxspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_128(&self) -> bool {
        self.rxspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_128(&mut self, v: u32) {
        self.rxspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_256 = 86;

    pub fn rxspeed_histogram_256(&self) -> u32 {
        self.rxspeed_histogram_256.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_256(&mut self) {
        self.rxspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_256(&self) -> bool {
        self.rxspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_256(&mut self, v: u32) {
        self.rxspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_512 = 87;

    pub fn rxspeed_histogram_512(&self) -> u32 {
        self.rxspeed_histogram_512.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_512(&mut self) {
        self.rxspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_512(&self) -> bool {
        self.rxspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_512(&mut self, v: u32) {
        self.rxspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_1024 = 88;

    pub fn rxspeed_histogram_1024(&self) -> u32 {
        self.rxspeed_histogram_1024.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_1024(&mut self) {
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_1024(&self) -> bool {
        self.rxspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_1024(&mut self, v: u32) {
        self.rxspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_max = 89;

    pub fn rxspeed_histogram_max(&self) -> u32 {
        self.rxspeed_histogram_max.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_max(&mut self) {
        self.rxspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_max(&self) -> bool {
        self.rxspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_max(&mut self, v: u32) {
        self.rxspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_5th = 90;

    pub fn rxspeed_ntile_5th(&self) -> u32 {
        self.rxspeed_ntile_5th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_5th(&mut self) {
        self.rxspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_5th(&self) -> bool {
        self.rxspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_5th(&mut self, v: u32) {
        self.rxspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_50th = 91;

    pub fn rxspeed_ntile_50th(&self) -> u32 {
        self.rxspeed_ntile_50th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_50th(&mut self) {
        self.rxspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_50th(&self) -> bool {
        self.rxspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_50th(&mut self, v: u32) {
        self.rxspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_75th = 92;

    pub fn rxspeed_ntile_75th(&self) -> u32 {
        self.rxspeed_ntile_75th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_75th(&mut self) {
        self.rxspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_75th(&self) -> bool {
        self.rxspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_75th(&mut self, v: u32) {
        self.rxspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_95th = 93;

    pub fn rxspeed_ntile_95th(&self) -> u32 {
        self.rxspeed_ntile_95th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_95th(&mut self) {
        self.rxspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_95th(&self) -> bool {
        self.rxspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_95th(&mut self, v: u32) {
        self.rxspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_98th = 94;

    pub fn rxspeed_ntile_98th(&self) -> u32 {
        self.rxspeed_ntile_98th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_98th(&mut self) {
        self.rxspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_98th(&self) -> bool {
        self.rxspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_98th(&mut self, v: u32) {
        self.rxspeed_ntile_98th = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramLinkLifetimeStats {
    const NAME: &'static str = "CMsgSteamDatagramLinkLifetimeStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.packets_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.kb_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.packets_recv = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.kb_recv = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.packets_recv_sequenced = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.packets_recv_dropped = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.packets_recv_out_of_order = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.packets_recv_duplicate = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.packets_recv_lurch = ::std::option::Option::Some(is.read_uint64()?);
                },
                168 => {
                    self.quality_histogram_100 = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.quality_histogram_99 = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.quality_histogram_97 = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.quality_histogram_95 = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.quality_histogram_90 = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.quality_histogram_75 = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.quality_histogram_50 = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.quality_histogram_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.quality_histogram_dead = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.quality_ntile_2nd = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.quality_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.quality_ntile_25th = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.quality_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.ping_histogram_25 = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.ping_histogram_50 = ::std::option::Option::Some(is.read_uint32()?);
                },
                344 => {
                    self.ping_histogram_75 = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.ping_histogram_100 = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.ping_histogram_125 = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.ping_histogram_150 = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.ping_histogram_200 = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.ping_histogram_300 = ::std::option::Option::Some(is.read_uint32()?);
                },
                392 => {
                    self.ping_histogram_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.ping_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                408 => {
                    self.ping_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.ping_ntile_75th = ::std::option::Option::Some(is.read_uint32()?);
                },
                424 => {
                    self.ping_ntile_95th = ::std::option::Option::Some(is.read_uint32()?);
                },
                432 => {
                    self.ping_ntile_98th = ::std::option::Option::Some(is.read_uint32()?);
                },
                488 => {
                    self.jitter_histogram_negligible = ::std::option::Option::Some(is.read_uint32()?);
                },
                496 => {
                    self.jitter_histogram_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                504 => {
                    self.jitter_histogram_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                512 => {
                    self.jitter_histogram_5 = ::std::option::Option::Some(is.read_uint32()?);
                },
                520 => {
                    self.jitter_histogram_10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                528 => {
                    self.jitter_histogram_20 = ::std::option::Option::Some(is.read_uint32()?);
                },
                536 => {
                    self.txspeed_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                544 => {
                    self.txspeed_histogram_16 = ::std::option::Option::Some(is.read_uint32()?);
                },
                552 => {
                    self.txspeed_histogram_32 = ::std::option::Option::Some(is.read_uint32()?);
                },
                560 => {
                    self.txspeed_histogram_64 = ::std::option::Option::Some(is.read_uint32()?);
                },
                568 => {
                    self.txspeed_histogram_128 = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.txspeed_histogram_256 = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.txspeed_histogram_512 = ::std::option::Option::Some(is.read_uint32()?);
                },
                592 => {
                    self.txspeed_histogram_1024 = ::std::option::Option::Some(is.read_uint32()?);
                },
                600 => {
                    self.txspeed_histogram_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                608 => {
                    self.txspeed_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                616 => {
                    self.txspeed_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                624 => {
                    self.txspeed_ntile_75th = ::std::option::Option::Some(is.read_uint32()?);
                },
                632 => {
                    self.txspeed_ntile_95th = ::std::option::Option::Some(is.read_uint32()?);
                },
                640 => {
                    self.txspeed_ntile_98th = ::std::option::Option::Some(is.read_uint32()?);
                },
                648 => {
                    self.rxspeed_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                656 => {
                    self.rxspeed_histogram_16 = ::std::option::Option::Some(is.read_uint32()?);
                },
                664 => {
                    self.rxspeed_histogram_32 = ::std::option::Option::Some(is.read_uint32()?);
                },
                672 => {
                    self.rxspeed_histogram_64 = ::std::option::Option::Some(is.read_uint32()?);
                },
                680 => {
                    self.rxspeed_histogram_128 = ::std::option::Option::Some(is.read_uint32()?);
                },
                688 => {
                    self.rxspeed_histogram_256 = ::std::option::Option::Some(is.read_uint32()?);
                },
                696 => {
                    self.rxspeed_histogram_512 = ::std::option::Option::Some(is.read_uint32()?);
                },
                704 => {
                    self.rxspeed_histogram_1024 = ::std::option::Option::Some(is.read_uint32()?);
                },
                712 => {
                    self.rxspeed_histogram_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                720 => {
                    self.rxspeed_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                728 => {
                    self.rxspeed_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                736 => {
                    self.rxspeed_ntile_75th = ::std::option::Option::Some(is.read_uint32()?);
                },
                744 => {
                    self.rxspeed_ntile_95th = ::std::option::Option::Some(is.read_uint32()?);
                },
                752 => {
                    self.rxspeed_ntile_98th = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packets_sent {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.kb_sent {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.packets_recv {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.kb_recv {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.packets_recv_sequenced {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.packets_recv_dropped {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.packets_recv_out_of_order {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.packets_recv_duplicate {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.packets_recv_lurch {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.quality_histogram_100 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.quality_histogram_99 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.quality_histogram_97 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.quality_histogram_95 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.quality_histogram_90 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.quality_histogram_75 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.quality_histogram_50 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.quality_histogram_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.quality_histogram_dead {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.quality_ntile_2nd {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.quality_ntile_5th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.quality_ntile_25th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.quality_ntile_50th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.ping_histogram_25 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.ping_histogram_50 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.ping_histogram_75 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.ping_histogram_100 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.ping_histogram_125 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.ping_histogram_150 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.ping_histogram_200 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.ping_histogram_300 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.ping_histogram_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.ping_ntile_5th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(50, v);
        }
        if let Some(v) = self.ping_ntile_50th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.ping_ntile_75th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.ping_ntile_95th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(53, v);
        }
        if let Some(v) = self.ping_ntile_98th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(54, v);
        }
        if let Some(v) = self.jitter_histogram_negligible {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(61, v);
        }
        if let Some(v) = self.jitter_histogram_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(62, v);
        }
        if let Some(v) = self.jitter_histogram_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(63, v);
        }
        if let Some(v) = self.jitter_histogram_5 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(64, v);
        }
        if let Some(v) = self.jitter_histogram_10 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(65, v);
        }
        if let Some(v) = self.jitter_histogram_20 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(66, v);
        }
        if let Some(v) = self.txspeed_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(67, v);
        }
        if let Some(v) = self.txspeed_histogram_16 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(68, v);
        }
        if let Some(v) = self.txspeed_histogram_32 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(69, v);
        }
        if let Some(v) = self.txspeed_histogram_64 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(70, v);
        }
        if let Some(v) = self.txspeed_histogram_128 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.txspeed_histogram_256 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.txspeed_histogram_512 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(73, v);
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(74, v);
        }
        if let Some(v) = self.txspeed_histogram_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(75, v);
        }
        if let Some(v) = self.txspeed_ntile_5th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(76, v);
        }
        if let Some(v) = self.txspeed_ntile_50th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(77, v);
        }
        if let Some(v) = self.txspeed_ntile_75th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(78, v);
        }
        if let Some(v) = self.txspeed_ntile_95th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(79, v);
        }
        if let Some(v) = self.txspeed_ntile_98th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(80, v);
        }
        if let Some(v) = self.rxspeed_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(81, v);
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(82, v);
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(83, v);
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(84, v);
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(85, v);
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(86, v);
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(87, v);
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(88, v);
        }
        if let Some(v) = self.rxspeed_histogram_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(89, v);
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(90, v);
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(91, v);
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(92, v);
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(93, v);
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(94, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.packets_sent {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.kb_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.packets_recv {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.kb_recv {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.packets_recv_sequenced {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.packets_recv_dropped {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.packets_recv_out_of_order {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.packets_recv_duplicate {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.packets_recv_lurch {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.quality_histogram_100 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.quality_histogram_99 {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.quality_histogram_97 {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.quality_histogram_95 {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.quality_histogram_90 {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.quality_histogram_75 {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.quality_histogram_50 {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.quality_histogram_1 {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.quality_histogram_dead {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.quality_ntile_2nd {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.quality_ntile_5th {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.quality_ntile_25th {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.quality_ntile_50th {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.ping_histogram_25 {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.ping_histogram_50 {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.ping_histogram_75 {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.ping_histogram_100 {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.ping_histogram_125 {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.ping_histogram_150 {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.ping_histogram_200 {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.ping_histogram_300 {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.ping_histogram_max {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.ping_ntile_5th {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.ping_ntile_50th {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.ping_ntile_75th {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.ping_ntile_95th {
            os.write_uint32(53, v)?;
        }
        if let Some(v) = self.ping_ntile_98th {
            os.write_uint32(54, v)?;
        }
        if let Some(v) = self.jitter_histogram_negligible {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.jitter_histogram_1 {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.jitter_histogram_2 {
            os.write_uint32(63, v)?;
        }
        if let Some(v) = self.jitter_histogram_5 {
            os.write_uint32(64, v)?;
        }
        if let Some(v) = self.jitter_histogram_10 {
            os.write_uint32(65, v)?;
        }
        if let Some(v) = self.jitter_histogram_20 {
            os.write_uint32(66, v)?;
        }
        if let Some(v) = self.txspeed_max {
            os.write_uint32(67, v)?;
        }
        if let Some(v) = self.txspeed_histogram_16 {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.txspeed_histogram_32 {
            os.write_uint32(69, v)?;
        }
        if let Some(v) = self.txspeed_histogram_64 {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.txspeed_histogram_128 {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.txspeed_histogram_256 {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.txspeed_histogram_512 {
            os.write_uint32(73, v)?;
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.txspeed_histogram_max {
            os.write_uint32(75, v)?;
        }
        if let Some(v) = self.txspeed_ntile_5th {
            os.write_uint32(76, v)?;
        }
        if let Some(v) = self.txspeed_ntile_50th {
            os.write_uint32(77, v)?;
        }
        if let Some(v) = self.txspeed_ntile_75th {
            os.write_uint32(78, v)?;
        }
        if let Some(v) = self.txspeed_ntile_95th {
            os.write_uint32(79, v)?;
        }
        if let Some(v) = self.txspeed_ntile_98th {
            os.write_uint32(80, v)?;
        }
        if let Some(v) = self.rxspeed_max {
            os.write_uint32(81, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            os.write_uint32(82, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            os.write_uint32(83, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            os.write_uint32(84, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            os.write_uint32(85, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            os.write_uint32(86, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            os.write_uint32(87, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            os.write_uint32(88, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_max {
            os.write_uint32(89, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            os.write_uint32(93, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            os.write_uint32(94, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        CMsgSteamDatagramLinkLifetimeStats::new()
    }

    fn clear(&mut self) {
        self.packets_sent = ::std::option::Option::None;
        self.kb_sent = ::std::option::Option::None;
        self.packets_recv = ::std::option::Option::None;
        self.kb_recv = ::std::option::Option::None;
        self.packets_recv_sequenced = ::std::option::Option::None;
        self.packets_recv_dropped = ::std::option::Option::None;
        self.packets_recv_out_of_order = ::std::option::Option::None;
        self.packets_recv_duplicate = ::std::option::Option::None;
        self.packets_recv_lurch = ::std::option::Option::None;
        self.quality_histogram_100 = ::std::option::Option::None;
        self.quality_histogram_99 = ::std::option::Option::None;
        self.quality_histogram_97 = ::std::option::Option::None;
        self.quality_histogram_95 = ::std::option::Option::None;
        self.quality_histogram_90 = ::std::option::Option::None;
        self.quality_histogram_75 = ::std::option::Option::None;
        self.quality_histogram_50 = ::std::option::Option::None;
        self.quality_histogram_1 = ::std::option::Option::None;
        self.quality_histogram_dead = ::std::option::Option::None;
        self.quality_ntile_2nd = ::std::option::Option::None;
        self.quality_ntile_5th = ::std::option::Option::None;
        self.quality_ntile_25th = ::std::option::Option::None;
        self.quality_ntile_50th = ::std::option::Option::None;
        self.ping_histogram_25 = ::std::option::Option::None;
        self.ping_histogram_50 = ::std::option::Option::None;
        self.ping_histogram_75 = ::std::option::Option::None;
        self.ping_histogram_100 = ::std::option::Option::None;
        self.ping_histogram_125 = ::std::option::Option::None;
        self.ping_histogram_150 = ::std::option::Option::None;
        self.ping_histogram_200 = ::std::option::Option::None;
        self.ping_histogram_300 = ::std::option::Option::None;
        self.ping_histogram_max = ::std::option::Option::None;
        self.ping_ntile_5th = ::std::option::Option::None;
        self.ping_ntile_50th = ::std::option::Option::None;
        self.ping_ntile_75th = ::std::option::Option::None;
        self.ping_ntile_95th = ::std::option::Option::None;
        self.ping_ntile_98th = ::std::option::Option::None;
        self.jitter_histogram_negligible = ::std::option::Option::None;
        self.jitter_histogram_1 = ::std::option::Option::None;
        self.jitter_histogram_2 = ::std::option::Option::None;
        self.jitter_histogram_5 = ::std::option::Option::None;
        self.jitter_histogram_10 = ::std::option::Option::None;
        self.jitter_histogram_20 = ::std::option::Option::None;
        self.txspeed_max = ::std::option::Option::None;
        self.txspeed_histogram_16 = ::std::option::Option::None;
        self.txspeed_histogram_32 = ::std::option::Option::None;
        self.txspeed_histogram_64 = ::std::option::Option::None;
        self.txspeed_histogram_128 = ::std::option::Option::None;
        self.txspeed_histogram_256 = ::std::option::Option::None;
        self.txspeed_histogram_512 = ::std::option::Option::None;
        self.txspeed_histogram_1024 = ::std::option::Option::None;
        self.txspeed_histogram_max = ::std::option::Option::None;
        self.txspeed_ntile_5th = ::std::option::Option::None;
        self.txspeed_ntile_50th = ::std::option::Option::None;
        self.txspeed_ntile_75th = ::std::option::Option::None;
        self.txspeed_ntile_95th = ::std::option::Option::None;
        self.txspeed_ntile_98th = ::std::option::Option::None;
        self.rxspeed_max = ::std::option::Option::None;
        self.rxspeed_histogram_16 = ::std::option::Option::None;
        self.rxspeed_histogram_32 = ::std::option::Option::None;
        self.rxspeed_histogram_64 = ::std::option::Option::None;
        self.rxspeed_histogram_128 = ::std::option::Option::None;
        self.rxspeed_histogram_256 = ::std::option::Option::None;
        self.rxspeed_histogram_512 = ::std::option::Option::None;
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
        self.rxspeed_histogram_max = ::std::option::Option::None;
        self.rxspeed_ntile_5th = ::std::option::Option::None;
        self.rxspeed_ntile_50th = ::std::option::Option::None;
        self.rxspeed_ntile_75th = ::std::option::Option::None;
        self.rxspeed_ntile_95th = ::std::option::Option::None;
        self.rxspeed_ntile_98th = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkLifetimeStats {
        static instance: CMsgSteamDatagramLinkLifetimeStats = CMsgSteamDatagramLinkLifetimeStats {
            packets_sent: ::std::option::Option::None,
            kb_sent: ::std::option::Option::None,
            packets_recv: ::std::option::Option::None,
            kb_recv: ::std::option::Option::None,
            packets_recv_sequenced: ::std::option::Option::None,
            packets_recv_dropped: ::std::option::Option::None,
            packets_recv_out_of_order: ::std::option::Option::None,
            packets_recv_duplicate: ::std::option::Option::None,
            packets_recv_lurch: ::std::option::Option::None,
            quality_histogram_100: ::std::option::Option::None,
            quality_histogram_99: ::std::option::Option::None,
            quality_histogram_97: ::std::option::Option::None,
            quality_histogram_95: ::std::option::Option::None,
            quality_histogram_90: ::std::option::Option::None,
            quality_histogram_75: ::std::option::Option::None,
            quality_histogram_50: ::std::option::Option::None,
            quality_histogram_1: ::std::option::Option::None,
            quality_histogram_dead: ::std::option::Option::None,
            quality_ntile_2nd: ::std::option::Option::None,
            quality_ntile_5th: ::std::option::Option::None,
            quality_ntile_25th: ::std::option::Option::None,
            quality_ntile_50th: ::std::option::Option::None,
            ping_histogram_25: ::std::option::Option::None,
            ping_histogram_50: ::std::option::Option::None,
            ping_histogram_75: ::std::option::Option::None,
            ping_histogram_100: ::std::option::Option::None,
            ping_histogram_125: ::std::option::Option::None,
            ping_histogram_150: ::std::option::Option::None,
            ping_histogram_200: ::std::option::Option::None,
            ping_histogram_300: ::std::option::Option::None,
            ping_histogram_max: ::std::option::Option::None,
            ping_ntile_5th: ::std::option::Option::None,
            ping_ntile_50th: ::std::option::Option::None,
            ping_ntile_75th: ::std::option::Option::None,
            ping_ntile_95th: ::std::option::Option::None,
            ping_ntile_98th: ::std::option::Option::None,
            jitter_histogram_negligible: ::std::option::Option::None,
            jitter_histogram_1: ::std::option::Option::None,
            jitter_histogram_2: ::std::option::Option::None,
            jitter_histogram_5: ::std::option::Option::None,
            jitter_histogram_10: ::std::option::Option::None,
            jitter_histogram_20: ::std::option::Option::None,
            txspeed_max: ::std::option::Option::None,
            txspeed_histogram_16: ::std::option::Option::None,
            txspeed_histogram_32: ::std::option::Option::None,
            txspeed_histogram_64: ::std::option::Option::None,
            txspeed_histogram_128: ::std::option::Option::None,
            txspeed_histogram_256: ::std::option::Option::None,
            txspeed_histogram_512: ::std::option::Option::None,
            txspeed_histogram_1024: ::std::option::Option::None,
            txspeed_histogram_max: ::std::option::Option::None,
            txspeed_ntile_5th: ::std::option::Option::None,
            txspeed_ntile_50th: ::std::option::Option::None,
            txspeed_ntile_75th: ::std::option::Option::None,
            txspeed_ntile_95th: ::std::option::Option::None,
            txspeed_ntile_98th: ::std::option::Option::None,
            rxspeed_max: ::std::option::Option::None,
            rxspeed_histogram_16: ::std::option::Option::None,
            rxspeed_histogram_32: ::std::option::Option::None,
            rxspeed_histogram_64: ::std::option::Option::None,
            rxspeed_histogram_128: ::std::option::Option::None,
            rxspeed_histogram_256: ::std::option::Option::None,
            rxspeed_histogram_512: ::std::option::Option::None,
            rxspeed_histogram_1024: ::std::option::Option::None,
            rxspeed_histogram_max: ::std::option::Option::None,
            rxspeed_ntile_5th: ::std::option::Option::None,
            rxspeed_ntile_50th: ::std::option::Option::None,
            rxspeed_ntile_75th: ::std::option::Option::None,
            rxspeed_ntile_95th: ::std::option::Option::None,
            rxspeed_ntile_98th: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionQuality)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionQuality {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionQuality.instantaneous)
    pub instantaneous: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramLinkInstantaneousStats>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionQuality.lifetime)
    pub lifetime: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramLinkLifetimeStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionQuality.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionQuality {
    fn default() -> &'a CMsgSteamDatagramConnectionQuality {
        <CMsgSteamDatagramConnectionQuality as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionQuality {
    pub fn new() -> CMsgSteamDatagramConnectionQuality {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionQuality {
    const NAME: &'static str = "CMsgSteamDatagramConnectionQuality";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.instantaneous)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.lifetime)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.instantaneous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lifetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.instantaneous.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.lifetime.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionQuality {
        CMsgSteamDatagramConnectionQuality::new()
    }

    fn clear(&mut self) {
        self.instantaneous.clear();
        self.lifetime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionQuality {
        static instance: CMsgSteamDatagramConnectionQuality = CMsgSteamDatagramConnectionQuality {
            instantaneous: ::steam_vent_proto_common::protobuf::MessageField::none(),
            lifetime: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsClientToRouter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.c2r)
    pub c2r: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.c2s)
    pub c2s: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.legacy_client_timestamp)
    pub legacy_client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.ack_e2e)
    pub ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.seq_num_c2r)
    pub seq_num_c2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.seq_num_c2s)
    pub seq_num_c2s: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsClientToRouter.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsClientToRouter {
        <CMsgSteamDatagramConnectionStatsClientToRouter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_timestamp = 3;

    pub fn legacy_client_timestamp(&self) -> u32 {
        self.legacy_client_timestamp.unwrap_or(0)
    }

    pub fn clear_legacy_client_timestamp(&mut self) {
        self.legacy_client_timestamp = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp(&self) -> bool {
        self.legacy_client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp(&mut self, v: u32) {
        self.legacy_client_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 6;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 8;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 9;

    pub fn seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }

    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 10;

    pub fn seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }

    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionStatsClientToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsClientToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.c2r)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.c2s)?;
                },
                29 => {
                    self.legacy_client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                37 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                42 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_e2e)?;
                },
                45 => {
                    self.ack_e2e.push(is.read_fixed32()?);
                },
                48 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.seq_num_c2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.seq_num_c2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.c2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.legacy_client_timestamp {
            my_size += 1 + 4;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.c2r.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.c2s.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.legacy_client_timestamp {
            os.write_fixed32(3, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(4, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(5, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        CMsgSteamDatagramConnectionStatsClientToRouter::new()
    }

    fn clear(&mut self) {
        self.c2r.clear();
        self.c2s.clear();
        self.legacy_client_timestamp = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsClientToRouter {
        static instance: CMsgSteamDatagramConnectionStatsClientToRouter = CMsgSteamDatagramConnectionStatsClientToRouter {
            c2r: ::steam_vent_proto_common::protobuf::MessageField::none(),
            c2s: ::steam_vent_proto_common::protobuf::MessageField::none(),
            legacy_client_timestamp: ::std::option::Option::None,
            ack_relay: ::std::vec::Vec::new(),
            ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            seq_num_c2r: ::std::option::Option::None,
            seq_num_c2s: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsClientToRouter`
pub mod cmsg_steam_datagram_connection_stats_client_to_router {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsClientToRouter.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsClientToRouter.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsClientToRouter.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsClientToRouter.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsRouterToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.r2c)
    pub r2c: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.s2c)
    pub s2c: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.legacy_client_timestamp_from_router)
    pub legacy_client_timestamp_from_router: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.legacy_client_timestamp_from_server)
    pub legacy_client_timestamp_from_server: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.router_gameserver_latency)
    pub router_gameserver_latency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.migrate_request_ip)
    pub migrate_request_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.migrate_request_port)
    pub migrate_request_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.scoring_penalty_relay_cluster)
    pub scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.ack_e2e)
    pub ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seq_num_s2c)
    pub seq_num_s2c: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsRouterToClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToClient {
        <CMsgSteamDatagramConnectionStatsRouterToClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_timestamp_from_router = 3;

    pub fn legacy_client_timestamp_from_router(&self) -> u32 {
        self.legacy_client_timestamp_from_router.unwrap_or(0)
    }

    pub fn clear_legacy_client_timestamp_from_router(&mut self) {
        self.legacy_client_timestamp_from_router = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp_from_router(&self) -> bool {
        self.legacy_client_timestamp_from_router.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp_from_router(&mut self, v: u32) {
        self.legacy_client_timestamp_from_router = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_client_timestamp_from_server = 4;

    pub fn legacy_client_timestamp_from_server(&self) -> u32 {
        self.legacy_client_timestamp_from_server.unwrap_or(0)
    }

    pub fn clear_legacy_client_timestamp_from_server(&mut self) {
        self.legacy_client_timestamp_from_server = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp_from_server(&self) -> bool {
        self.legacy_client_timestamp_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp_from_server(&mut self, v: u32) {
        self.legacy_client_timestamp_from_server = ::std::option::Option::Some(v);
    }

    // optional uint32 router_gameserver_latency = 5;

    pub fn router_gameserver_latency(&self) -> u32 {
        self.router_gameserver_latency.unwrap_or(0)
    }

    pub fn clear_router_gameserver_latency(&mut self) {
        self.router_gameserver_latency = ::std::option::Option::None;
    }

    pub fn has_router_gameserver_latency(&self) -> bool {
        self.router_gameserver_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_gameserver_latency(&mut self, v: u32) {
        self.router_gameserver_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 6;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 10;

    pub fn migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }

    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 11;

    pub fn migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }

    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 12;

    pub fn scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }

    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 15;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 8;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2c = 9;

    pub fn seq_num_s2c(&self) -> u32 {
        self.seq_num_s2c.unwrap_or(0)
    }

    pub fn clear_seq_num_s2c(&mut self) {
        self.seq_num_s2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2c(&self) -> bool {
        self.seq_num_s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2c(&mut self, v: u32) {
        self.seq_num_s2c = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToClient {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsRouterToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.r2c)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.s2c)?;
                },
                29 => {
                    self.legacy_client_timestamp_from_router = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.legacy_client_timestamp_from_server = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.router_gameserver_latency = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.migrate_request_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                88 => {
                    self.migrate_request_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                109 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                114 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_e2e)?;
                },
                117 => {
                    self.ack_e2e.push(is.read_fixed32()?);
                },
                120 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                64 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.seq_num_s2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.s2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.legacy_client_timestamp_from_router {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_client_timestamp_from_server {
            my_size += 1 + 4;
        }
        if let Some(v) = self.router_gameserver_latency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.seq_num_s2c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.r2c.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.s2c.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.legacy_client_timestamp_from_router {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_client_timestamp_from_server {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.router_gameserver_latency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(12, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(13, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(14, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.seq_num_s2c {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        CMsgSteamDatagramConnectionStatsRouterToClient::new()
    }

    fn clear(&mut self) {
        self.r2c.clear();
        self.s2c.clear();
        self.legacy_client_timestamp_from_router = ::std::option::Option::None;
        self.legacy_client_timestamp_from_server = ::std::option::Option::None;
        self.router_gameserver_latency = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_s2c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToClient {
        static instance: CMsgSteamDatagramConnectionStatsRouterToClient = CMsgSteamDatagramConnectionStatsRouterToClient {
            r2c: ::steam_vent_proto_common::protobuf::MessageField::none(),
            s2c: ::steam_vent_proto_common::protobuf::MessageField::none(),
            legacy_client_timestamp_from_router: ::std::option::Option::None,
            legacy_client_timestamp_from_server: ::std::option::Option::None,
            router_gameserver_latency: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            migrate_request_ip: ::std::option::Option::None,
            migrate_request_port: ::std::option::Option::None,
            scoring_penalty_relay_cluster: ::std::option::Option::None,
            ack_relay: ::std::vec::Vec::new(),
            ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            seq_num_s2c: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsRouterToClient`
pub mod cmsg_steam_datagram_connection_stats_router_to_client {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsRouterToClient.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToClient.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToClient.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToClient.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsRouterToServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.r2s)
    pub r2s: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.c2s)
    pub c2s: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.legacy_client_timestamp)
    pub legacy_client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.legacy_router_timestamp)
    pub legacy_router_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.ack_e2e)
    pub ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.seq_num_r2s)
    pub seq_num_r2s: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.seq_num_c2s)
    pub seq_num_c2s: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.relay_session_id)
    pub relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsRouterToServer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToServer {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToServer {
        <CMsgSteamDatagramConnectionStatsRouterToServer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToServer {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_timestamp = 3;

    pub fn legacy_client_timestamp(&self) -> u32 {
        self.legacy_client_timestamp.unwrap_or(0)
    }

    pub fn clear_legacy_client_timestamp(&mut self) {
        self.legacy_client_timestamp = ::std::option::Option::None;
    }

    pub fn has_legacy_client_timestamp(&self) -> bool {
        self.legacy_client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_timestamp(&mut self, v: u32) {
        self.legacy_client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_router_timestamp = 4;

    pub fn legacy_router_timestamp(&self) -> u32 {
        self.legacy_router_timestamp.unwrap_or(0)
    }

    pub fn clear_legacy_router_timestamp(&mut self) {
        self.legacy_router_timestamp = ::std::option::Option::None;
    }

    pub fn has_legacy_router_timestamp(&self) -> bool {
        self.legacy_router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_router_timestamp(&mut self, v: u32) {
        self.legacy_router_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 12;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2s = 5;

    pub fn seq_num_r2s(&self) -> u32 {
        self.seq_num_r2s.unwrap_or(0)
    }

    pub fn clear_seq_num_r2s(&mut self) {
        self.seq_num_r2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2s(&self) -> bool {
        self.seq_num_r2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2s(&mut self, v: u32) {
        self.seq_num_r2s = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 6;

    pub fn seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }

    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 7;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 8;

    pub fn relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }

    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 9;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 13;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToServer {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsRouterToServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.r2s)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.c2s)?;
                },
                29 => {
                    self.legacy_client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.legacy_router_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                82 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                85 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                90 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_e2e)?;
                },
                93 => {
                    self.ack_e2e.push(is.read_fixed32()?);
                },
                96 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.seq_num_r2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seq_num_c2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                57 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                64 => {
                    self.relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                109 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.legacy_client_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_router_timestamp {
            my_size += 1 + 4;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.seq_num_r2s {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.r2s.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.c2s.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.legacy_client_timestamp {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_router_timestamp {
            os.write_fixed32(4, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(10, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(11, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.seq_num_r2s {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        CMsgSteamDatagramConnectionStatsRouterToServer::new()
    }

    fn clear(&mut self) {
        self.r2s.clear();
        self.c2s.clear();
        self.legacy_client_timestamp = ::std::option::Option::None;
        self.legacy_router_timestamp = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_r2s = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToServer {
        static instance: CMsgSteamDatagramConnectionStatsRouterToServer = CMsgSteamDatagramConnectionStatsRouterToServer {
            r2s: ::steam_vent_proto_common::protobuf::MessageField::none(),
            c2s: ::steam_vent_proto_common::protobuf::MessageField::none(),
            legacy_client_timestamp: ::std::option::Option::None,
            legacy_router_timestamp: ::std::option::Option::None,
            ack_relay: ::std::vec::Vec::new(),
            ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            seq_num_r2s: ::std::option::Option::None,
            seq_num_c2s: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            relay_session_id: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsRouterToServer`
pub mod cmsg_steam_datagram_connection_stats_router_to_server {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsRouterToServer.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToServer.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToServer.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsRouterToServer.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsServerToRouter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.s2r)
    pub s2r: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.s2c)
    pub s2c: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.ack_e2e)
    pub ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.seq_num_s2r)
    pub seq_num_s2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.seq_num_s2c)
    pub seq_num_s2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.relay_session_id)
    pub relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsServerToRouter.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsServerToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsServerToRouter {
        <CMsgSteamDatagramConnectionStatsServerToRouter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsServerToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 10;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2r = 3;

    pub fn seq_num_s2r(&self) -> u32 {
        self.seq_num_s2r.unwrap_or(0)
    }

    pub fn clear_seq_num_s2r(&mut self) {
        self.seq_num_s2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2r(&self) -> bool {
        self.seq_num_s2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2r(&mut self, v: u32) {
        self.seq_num_s2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2c = 4;

    pub fn seq_num_s2c(&self) -> u32 {
        self.seq_num_s2c.unwrap_or(0)
    }

    pub fn clear_seq_num_s2c(&mut self) {
        self.seq_num_s2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2c(&self) -> bool {
        self.seq_num_s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2c(&mut self, v: u32) {
        self.seq_num_s2c = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 5;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 6;

    pub fn relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }

    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 11;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionStatsServerToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsServerToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.s2r)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.s2c)?;
                },
                66 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                69 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                74 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_e2e)?;
                },
                77 => {
                    self.ack_e2e.push(is.read_fixed32()?);
                },
                80 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.seq_num_s2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.seq_num_s2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                93 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.s2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.s2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.seq_num_s2r {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.seq_num_s2c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.s2r.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.s2c.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(8, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(9, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.seq_num_s2r {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seq_num_s2c {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        CMsgSteamDatagramConnectionStatsServerToRouter::new()
    }

    fn clear(&mut self) {
        self.s2r.clear();
        self.s2c.clear();
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_s2r = ::std::option::Option::None;
        self.seq_num_s2c = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsServerToRouter {
        static instance: CMsgSteamDatagramConnectionStatsServerToRouter = CMsgSteamDatagramConnectionStatsServerToRouter {
            s2r: ::steam_vent_proto_common::protobuf::MessageField::none(),
            s2c: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ack_relay: ::std::vec::Vec::new(),
            ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            seq_num_s2r: ::std::option::Option::None,
            seq_num_s2c: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            relay_session_id: ::std::option::Option::None,
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsServerToRouter`
pub mod cmsg_steam_datagram_connection_stats_server_to_router {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsServerToRouter.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsServerToRouter.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsServerToRouter.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsServerToRouter.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramClientPingSampleRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleRequest.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleRequest {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleRequest {
        <CMsgSteamDatagramClientPingSampleRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleRequest {
    pub fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramClientPingSampleRequest {
    const NAME: &'static str = "CMsgSteamDatagramClientPingSampleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        CMsgSteamDatagramClientPingSampleRequest::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleRequest {
        static instance: CMsgSteamDatagramClientPingSampleRequest = CMsgSteamDatagramClientPingSampleRequest {
            connection_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramClientPingSampleReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.routing_clusters)
    pub routing_clusters: ::std::vec::Vec<cmsg_steam_datagram_client_ping_sample_reply::RoutingCluster>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.data_centers)
    pub data_centers: ::std::vec::Vec<cmsg_steam_datagram_client_ping_sample_reply::DataCenter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply {
        <CMsgSteamDatagramClientPingSampleReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramClientPingSampleReply {
    const NAME: &'static str = "CMsgSteamDatagramClientPingSampleReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.routing_clusters.push(is.read_message()?);
                },
                26 => {
                    self.data_centers.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        for value in &self.routing_clusters {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        for v in &self.routing_clusters {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.data_centers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply {
        CMsgSteamDatagramClientPingSampleReply::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.routing_clusters.clear();
        self.data_centers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply {
        static instance: CMsgSteamDatagramClientPingSampleReply = CMsgSteamDatagramClientPingSampleReply {
            connection_id: ::std::option::Option::None,
            routing_clusters: ::std::vec::Vec::new(),
            data_centers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramClientPingSampleReply`
pub mod cmsg_steam_datagram_client_ping_sample_reply {
    // @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply.RoutingCluster)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RoutingCluster {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.front_ping_ms)
        pub front_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.e2e_ping_ms)
        pub e2e_ping_ms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RoutingCluster {
        fn default() -> &'a RoutingCluster {
            <RoutingCluster as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RoutingCluster {
        pub fn new() -> RoutingCluster {
            ::std::default::Default::default()
        }

        // optional fixed32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 front_ping_ms = 2;

        pub fn front_ping_ms(&self) -> u32 {
            self.front_ping_ms.unwrap_or(0)
        }

        pub fn clear_front_ping_ms(&mut self) {
            self.front_ping_ms = ::std::option::Option::None;
        }

        pub fn has_front_ping_ms(&self) -> bool {
            self.front_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_front_ping_ms(&mut self, v: u32) {
            self.front_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 e2e_ping_ms = 3;

        pub fn e2e_ping_ms(&self) -> u32 {
            self.e2e_ping_ms.unwrap_or(0)
        }

        pub fn clear_e2e_ping_ms(&mut self) {
            self.e2e_ping_ms = ::std::option::Option::None;
        }

        pub fn has_e2e_ping_ms(&self) -> bool {
            self.e2e_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_e2e_ping_ms(&mut self, v: u32) {
            self.e2e_ping_ms = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RoutingCluster {
        const NAME: &'static str = "RoutingCluster";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.front_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.e2e_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.front_ping_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.e2e_ping_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.front_ping_ms {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.e2e_ping_ms {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RoutingCluster {
            RoutingCluster::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.front_ping_ms = ::std::option::Option::None;
            self.e2e_ping_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RoutingCluster {
            static instance: RoutingCluster = RoutingCluster {
                id: ::std::option::Option::None,
                front_ping_ms: ::std::option::Option::None,
                e2e_ping_ms: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply.DataCenter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DataCenter {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.DataCenter.data_center_id)
        pub data_center_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.DataCenter.via_relay_id)
        pub via_relay_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.DataCenter.e2e_ping_ms)
        pub e2e_ping_ms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.DataCenter.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataCenter {
        fn default() -> &'a DataCenter {
            <DataCenter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DataCenter {
        pub fn new() -> DataCenter {
            ::std::default::Default::default()
        }

        // optional fixed32 data_center_id = 1;

        pub fn data_center_id(&self) -> u32 {
            self.data_center_id.unwrap_or(0)
        }

        pub fn clear_data_center_id(&mut self) {
            self.data_center_id = ::std::option::Option::None;
        }

        pub fn has_data_center_id(&self) -> bool {
            self.data_center_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_center_id(&mut self, v: u32) {
            self.data_center_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 via_relay_id = 2;

        pub fn via_relay_id(&self) -> u32 {
            self.via_relay_id.unwrap_or(0)
        }

        pub fn clear_via_relay_id(&mut self) {
            self.via_relay_id = ::std::option::Option::None;
        }

        pub fn has_via_relay_id(&self) -> bool {
            self.via_relay_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_via_relay_id(&mut self, v: u32) {
            self.via_relay_id = ::std::option::Option::Some(v);
        }

        // optional uint32 e2e_ping_ms = 3;

        pub fn e2e_ping_ms(&self) -> u32 {
            self.e2e_ping_ms.unwrap_or(0)
        }

        pub fn clear_e2e_ping_ms(&mut self) {
            self.e2e_ping_ms = ::std::option::Option::None;
        }

        pub fn has_e2e_ping_ms(&self) -> bool {
            self.e2e_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_e2e_ping_ms(&mut self, v: u32) {
            self.e2e_ping_ms = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DataCenter {
        const NAME: &'static str = "DataCenter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.data_center_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    21 => {
                        self.via_relay_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.e2e_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data_center_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.via_relay_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.e2e_ping_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.data_center_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.via_relay_id {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.e2e_ping_ms {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataCenter {
            DataCenter::new()
        }

        fn clear(&mut self) {
            self.data_center_id = ::std::option::Option::None;
            self.via_relay_id = ::std::option::Option::None;
            self.e2e_ping_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataCenter {
            static instance: DataCenter = DataCenter {
                data_center_id: ::std::option::Option::None,
                via_relay_id: ::std::option::Option::None,
                e2e_ping_ms: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramClientSwitchedPrimary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramClientSwitchedPrimary {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_ip)
    pub from_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_port)
    pub from_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_router_cluster)
    pub from_router_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_active_time)
    pub from_active_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_active_packets_recv)
    pub from_active_packets_recv: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_dropped_reason)
    pub from_dropped_reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.gap_ms)
    pub gap_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_quality_now)
    pub from_quality_now: ::steam_vent_proto_common::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.to_quality_now)
    pub to_quality_now: ::steam_vent_proto_common::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_quality_then)
    pub from_quality_then: ::steam_vent_proto_common::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.to_quality_then)
    pub to_quality_then: ::steam_vent_proto_common::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientSwitchedPrimary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientSwitchedPrimary {
    fn default() -> &'a CMsgSteamDatagramClientSwitchedPrimary {
        <CMsgSteamDatagramClientSwitchedPrimary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientSwitchedPrimary {
    pub fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_ip = 2;

    pub fn from_ip(&self) -> u32 {
        self.from_ip.unwrap_or(0)
    }

    pub fn clear_from_ip(&mut self) {
        self.from_ip = ::std::option::Option::None;
    }

    pub fn has_from_ip(&self) -> bool {
        self.from_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_ip(&mut self, v: u32) {
        self.from_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 from_port = 3;

    pub fn from_port(&self) -> u32 {
        self.from_port.unwrap_or(0)
    }

    pub fn clear_from_port(&mut self) {
        self.from_port = ::std::option::Option::None;
    }

    pub fn has_from_port(&self) -> bool {
        self.from_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_port(&mut self, v: u32) {
        self.from_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_router_cluster = 4;

    pub fn from_router_cluster(&self) -> u32 {
        self.from_router_cluster.unwrap_or(0)
    }

    pub fn clear_from_router_cluster(&mut self) {
        self.from_router_cluster = ::std::option::Option::None;
    }

    pub fn has_from_router_cluster(&self) -> bool {
        self.from_router_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_router_cluster(&mut self, v: u32) {
        self.from_router_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_time = 5;

    pub fn from_active_time(&self) -> u32 {
        self.from_active_time.unwrap_or(0)
    }

    pub fn clear_from_active_time(&mut self) {
        self.from_active_time = ::std::option::Option::None;
    }

    pub fn has_from_active_time(&self) -> bool {
        self.from_active_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_time(&mut self, v: u32) {
        self.from_active_time = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_packets_recv = 6;

    pub fn from_active_packets_recv(&self) -> u32 {
        self.from_active_packets_recv.unwrap_or(0)
    }

    pub fn clear_from_active_packets_recv(&mut self) {
        self.from_active_packets_recv = ::std::option::Option::None;
    }

    pub fn has_from_active_packets_recv(&self) -> bool {
        self.from_active_packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_packets_recv(&mut self, v: u32) {
        self.from_active_packets_recv = ::std::option::Option::Some(v);
    }

    // optional string from_dropped_reason = 7;

    pub fn from_dropped_reason(&self) -> &str {
        match self.from_dropped_reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_from_dropped_reason(&mut self) {
        self.from_dropped_reason = ::std::option::Option::None;
    }

    pub fn has_from_dropped_reason(&self) -> bool {
        self.from_dropped_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_dropped_reason(&mut self, v: ::std::string::String) {
        self.from_dropped_reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_dropped_reason(&mut self) -> &mut ::std::string::String {
        if self.from_dropped_reason.is_none() {
            self.from_dropped_reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.from_dropped_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_dropped_reason(&mut self) -> ::std::string::String {
        self.from_dropped_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gap_ms = 8;

    pub fn gap_ms(&self) -> u32 {
        self.gap_ms.unwrap_or(0)
    }

    pub fn clear_gap_ms(&mut self) {
        self.gap_ms = ::std::option::Option::None;
    }

    pub fn has_gap_ms(&self) -> bool {
        self.gap_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gap_ms(&mut self, v: u32) {
        self.gap_ms = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramClientSwitchedPrimary {
    const NAME: &'static str = "CMsgSteamDatagramClientSwitchedPrimary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.from_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.from_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.from_router_cluster = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.from_active_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.from_active_packets_recv = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.from_dropped_reason = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.gap_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.from_quality_now)?;
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.to_quality_now)?;
                },
                90 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.from_quality_then)?;
                },
                98 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.to_quality_then)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.from_router_cluster {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_active_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.from_active_packets_recv {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.from_dropped_reason.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gap_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.from_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.from_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.from_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.from_router_cluster {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.from_active_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.from_active_packets_recv {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.from_dropped_reason.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.gap_ms {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.from_quality_now.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.to_quality_now.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.from_quality_then.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.to_quality_then.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        CMsgSteamDatagramClientSwitchedPrimary::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.from_ip = ::std::option::Option::None;
        self.from_port = ::std::option::Option::None;
        self.from_router_cluster = ::std::option::Option::None;
        self.from_active_time = ::std::option::Option::None;
        self.from_active_packets_recv = ::std::option::Option::None;
        self.from_dropped_reason = ::std::option::Option::None;
        self.gap_ms = ::std::option::Option::None;
        self.from_quality_now.clear();
        self.to_quality_now.clear();
        self.from_quality_then.clear();
        self.to_quality_then.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientSwitchedPrimary {
        static instance: CMsgSteamDatagramClientSwitchedPrimary = CMsgSteamDatagramClientSwitchedPrimary {
            connection_id: ::std::option::Option::None,
            from_ip: ::std::option::Option::None,
            from_port: ::std::option::Option::None,
            from_router_cluster: ::std::option::Option::None,
            from_active_time: ::std::option::Option::None,
            from_active_packets_recv: ::std::option::Option::None,
            from_dropped_reason: ::std::option::Option::None,
            gap_ms: ::std::option::Option::None,
            from_quality_now: ::steam_vent_proto_common::protobuf::MessageField::none(),
            to_quality_now: ::steam_vent_proto_common::protobuf::MessageField::none(),
            from_quality_then: ::steam_vent_proto_common::protobuf::MessageField::none(),
            to_quality_then: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramClientSwitchedPrimary`
pub mod cmsg_steam_datagram_client_switched_primary {
    // @@protoc_insertion_point(message:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RouterQuality {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.front_ping)
        pub front_ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.back_ping)
        pub back_ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.seconds_until_down)
        pub seconds_until_down: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RouterQuality {
        fn default() -> &'a RouterQuality {
            <RouterQuality as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RouterQuality {
        pub fn new() -> RouterQuality {
            ::std::default::Default::default()
        }

        // optional uint32 score = 1;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 front_ping = 2;

        pub fn front_ping(&self) -> u32 {
            self.front_ping.unwrap_or(0)
        }

        pub fn clear_front_ping(&mut self) {
            self.front_ping = ::std::option::Option::None;
        }

        pub fn has_front_ping(&self) -> bool {
            self.front_ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_front_ping(&mut self, v: u32) {
            self.front_ping = ::std::option::Option::Some(v);
        }

        // optional uint32 back_ping = 3;

        pub fn back_ping(&self) -> u32 {
            self.back_ping.unwrap_or(0)
        }

        pub fn clear_back_ping(&mut self) {
            self.back_ping = ::std::option::Option::None;
        }

        pub fn has_back_ping(&self) -> bool {
            self.back_ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_back_ping(&mut self, v: u32) {
            self.back_ping = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_until_down = 4;

        pub fn seconds_until_down(&self) -> u32 {
            self.seconds_until_down.unwrap_or(0)
        }

        pub fn clear_seconds_until_down(&mut self) {
            self.seconds_until_down = ::std::option::Option::None;
        }

        pub fn has_seconds_until_down(&self) -> bool {
            self.seconds_until_down.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_until_down(&mut self, v: u32) {
            self.seconds_until_down = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RouterQuality {
        const NAME: &'static str = "RouterQuality";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.front_ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.back_ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.seconds_until_down = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.front_ping {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.back_ping {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.seconds_until_down {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.score {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.front_ping {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.back_ping {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.seconds_until_down {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RouterQuality {
            RouterQuality::new()
        }

        fn clear(&mut self) {
            self.score = ::std::option::Option::None;
            self.front_ping = ::std::option::Option::None;
            self.back_ping = ::std::option::Option::None;
            self.seconds_until_down = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RouterQuality {
            static instance: RouterQuality = RouterQuality {
                score: ::std::option::Option::None,
                front_ping: ::std::option::Option::None,
                back_ping: ::std::option::Option::None,
                seconds_until_down: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramRouterHealth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramRouterHealth {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.cpu_load)
    pub cpu_load: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.active_sessions)
    pub active_sessions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.data_pkts_sec)
    pub data_pkts_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.other_pkts_sec)
    pub other_pkts_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.cpu_cost_per_user)
    pub cpu_cost_per_user: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.cpu_cost_per_packet)
    pub cpu_cost_per_packet: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.data_centers)
    pub data_centers: ::std::vec::Vec<cmsg_steam_datagram_router_health::DataCenter>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.magic)
    pub magic: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterHealth.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterHealth {
    fn default() -> &'a CMsgSteamDatagramRouterHealth {
        <CMsgSteamDatagramRouterHealth as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterHealth {
    pub fn new() -> CMsgSteamDatagramRouterHealth {
        ::std::default::Default::default()
    }

    // optional float cpu_load = 1;

    pub fn cpu_load(&self) -> f32 {
        self.cpu_load.unwrap_or(0.)
    }

    pub fn clear_cpu_load(&mut self) {
        self.cpu_load = ::std::option::Option::None;
    }

    pub fn has_cpu_load(&self) -> bool {
        self.cpu_load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_load(&mut self, v: f32) {
        self.cpu_load = ::std::option::Option::Some(v);
    }

    // optional uint32 active_sessions = 2;

    pub fn active_sessions(&self) -> u32 {
        self.active_sessions.unwrap_or(0)
    }

    pub fn clear_active_sessions(&mut self) {
        self.active_sessions = ::std::option::Option::None;
    }

    pub fn has_active_sessions(&self) -> bool {
        self.active_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_sessions(&mut self, v: u32) {
        self.active_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 data_pkts_sec = 3;

    pub fn data_pkts_sec(&self) -> u32 {
        self.data_pkts_sec.unwrap_or(0)
    }

    pub fn clear_data_pkts_sec(&mut self) {
        self.data_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_data_pkts_sec(&self) -> bool {
        self.data_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_pkts_sec(&mut self, v: u32) {
        self.data_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 other_pkts_sec = 4;

    pub fn other_pkts_sec(&self) -> u32 {
        self.other_pkts_sec.unwrap_or(0)
    }

    pub fn clear_other_pkts_sec(&mut self) {
        self.other_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_other_pkts_sec(&self) -> bool {
        self.other_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_pkts_sec(&mut self, v: u32) {
        self.other_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_user = 8;

    pub fn cpu_cost_per_user(&self) -> f32 {
        self.cpu_cost_per_user.unwrap_or(0.)
    }

    pub fn clear_cpu_cost_per_user(&mut self) {
        self.cpu_cost_per_user = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_user(&self) -> bool {
        self.cpu_cost_per_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_user(&mut self, v: f32) {
        self.cpu_cost_per_user = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_packet = 9;

    pub fn cpu_cost_per_packet(&self) -> f32 {
        self.cpu_cost_per_packet.unwrap_or(0.)
    }

    pub fn clear_cpu_cost_per_packet(&mut self) {
        self.cpu_cost_per_packet = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_packet(&self) -> bool {
        self.cpu_cost_per_packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_packet(&mut self, v: f32) {
        self.cpu_cost_per_packet = ::std::option::Option::Some(v);
    }

    // optional fixed64 magic = 7;

    pub fn magic(&self) -> u64 {
        self.magic.unwrap_or(0)
    }

    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u64) {
        self.magic = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramRouterHealth {
    const NAME: &'static str = "CMsgSteamDatagramRouterHealth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.cpu_load = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.active_sessions = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.data_pkts_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.other_pkts_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.cpu_cost_per_user = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.cpu_cost_per_packet = ::std::option::Option::Some(is.read_float()?);
                },
                50 => {
                    self.data_centers.push(is.read_message()?);
                },
                57 => {
                    self.magic = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_load {
            my_size += 1 + 4;
        }
        if let Some(v) = self.active_sessions {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.data_pkts_sec {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.other_pkts_sec {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.cpu_cost_per_user {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            my_size += 1 + 4;
        }
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.magic {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cpu_load {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.active_sessions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data_pkts_sec {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.other_pkts_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cpu_cost_per_user {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            os.write_float(9, v)?;
        }
        for v in &self.data_centers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.magic {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramRouterHealth {
        CMsgSteamDatagramRouterHealth::new()
    }

    fn clear(&mut self) {
        self.cpu_load = ::std::option::Option::None;
        self.active_sessions = ::std::option::Option::None;
        self.data_pkts_sec = ::std::option::Option::None;
        self.other_pkts_sec = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.cpu_cost_per_user = ::std::option::Option::None;
        self.cpu_cost_per_packet = ::std::option::Option::None;
        self.data_centers.clear();
        self.magic = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterHealth {
        static instance: CMsgSteamDatagramRouterHealth = CMsgSteamDatagramRouterHealth {
            cpu_load: ::std::option::Option::None,
            active_sessions: ::std::option::Option::None,
            data_pkts_sec: ::std::option::Option::None,
            other_pkts_sec: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            cpu_cost_per_user: ::std::option::Option::None,
            cpu_cost_per_packet: ::std::option::Option::None,
            data_centers: ::std::vec::Vec::new(),
            magic: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramRouterHealth`
pub mod cmsg_steam_datagram_router_health {
    // @@protoc_insertion_point(message:CMsgSteamDatagramRouterHealth.DataCenter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DataCenter {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.DataCenter.datacenter_id)
        pub datacenter_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramRouterHealth.DataCenter.state)
        pub state: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterHealth.DataCenter.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataCenter {
        fn default() -> &'a DataCenter {
            <DataCenter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DataCenter {
        pub fn new() -> DataCenter {
            ::std::default::Default::default()
        }

        // optional fixed32 datacenter_id = 1;

        pub fn datacenter_id(&self) -> u32 {
            self.datacenter_id.unwrap_or(0)
        }

        pub fn clear_datacenter_id(&mut self) {
            self.datacenter_id = ::std::option::Option::None;
        }

        pub fn has_datacenter_id(&self) -> bool {
            self.datacenter_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datacenter_id(&mut self, v: u32) {
            self.datacenter_id = ::std::option::Option::Some(v);
        }

        // optional uint32 state = 2;

        pub fn state(&self) -> u32 {
            self.state.unwrap_or(0)
        }

        pub fn clear_state(&mut self) {
            self.state = ::std::option::Option::None;
        }

        pub fn has_state(&self) -> bool {
            self.state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_state(&mut self, v: u32) {
            self.state = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DataCenter {
        const NAME: &'static str = "DataCenter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.datacenter_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.datacenter_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.datacenter_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.state {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataCenter {
            DataCenter::new()
        }

        fn clear(&mut self) {
            self.datacenter_id = ::std::option::Option::None;
            self.state = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataCenter {
            static instance: DataCenter = DataCenter {
                datacenter_id: ::std::option::Option::None,
                state: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.my_timestamp)
    pub my_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.ping_est_ms)
    pub ping_est_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.virtual_port)
    pub virtual_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.gameserver_relay_session_id)
    pub gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.crypt)
    pub crypt: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramSessionCryptInfoSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.cert)
    pub cert: ::steam_vent_proto_common::protobuf::MessageField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectRequest.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectRequest {
    fn default() -> &'a CMsgSteamDatagramConnectRequest {
        <CMsgSteamDatagramConnectRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectRequest {
    pub fn new() -> CMsgSteamDatagramConnectRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 3;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 4;

    pub fn my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }

    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_est_ms = 5;

    pub fn ping_est_ms(&self) -> u32 {
        self.ping_est_ms.unwrap_or(0)
    }

    pub fn clear_ping_est_ms(&mut self) {
        self.ping_est_ms = ::std::option::Option::None;
    }

    pub fn has_ping_est_ms(&self) -> bool {
        self.ping_est_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_est_ms(&mut self, v: u32) {
        self.ping_est_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 virtual_port = 9;

    pub fn virtual_port(&self) -> u32 {
        self.virtual_port.unwrap_or(0)
    }

    pub fn clear_virtual_port(&mut self) {
        self.virtual_port = ::std::option::Option::None;
    }

    pub fn has_virtual_port(&self) -> bool {
        self.virtual_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_port(&mut self, v: u32) {
        self.virtual_port = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;

    pub fn gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectRequest {
    const NAME: &'static str = "CMsgSteamDatagramConnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.my_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.ping_est_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.virtual_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ping_est_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.virtual_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.ping_est_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.virtual_port {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.crypt.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.cert.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectRequest {
        CMsgSteamDatagramConnectRequest::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.ping_est_ms = ::std::option::Option::None;
        self.virtual_port = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectRequest {
        static instance: CMsgSteamDatagramConnectRequest = CMsgSteamDatagramConnectRequest {
            connection_id: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            my_timestamp: ::std::option::Option::None,
            ping_est_ms: ::std::option::Option::None,
            virtual_port: ::std::option::Option::None,
            gameserver_relay_session_id: ::std::option::Option::None,
            crypt: ::steam_vent_proto_common::protobuf::MessageField::none(),
            cert: ::steam_vent_proto_common::protobuf::MessageField::none(),
            protocol_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectOK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectOK {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.your_timestamp)
    pub your_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.delay_time_usec)
    pub delay_time_usec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.gameserver_relay_session_id)
    pub gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.crypt)
    pub crypt: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramSessionCryptInfoSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.cert)
    pub cert: ::steam_vent_proto_common::protobuf::MessageField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectOK.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectOK.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectOK {
    fn default() -> &'a CMsgSteamDatagramConnectOK {
        <CMsgSteamDatagramConnectOK as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectOK {
    pub fn new() -> CMsgSteamDatagramConnectOK {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 7;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;

    pub fn your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }

    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_time_usec = 4;

    pub fn delay_time_usec(&self) -> u32 {
        self.delay_time_usec.unwrap_or(0)
    }

    pub fn clear_delay_time_usec(&mut self) {
        self.delay_time_usec = ::std::option::Option::None;
    }

    pub fn has_delay_time_usec(&self) -> bool {
        self.delay_time_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_time_usec(&mut self, v: u32) {
        self.delay_time_usec = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;

    pub fn gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectOK {
    const NAME: &'static str = "CMsgSteamDatagramConnectOK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.your_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.delay_time_usec = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.delay_time_usec {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.delay_time_usec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.crypt.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.cert.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectOK {
        CMsgSteamDatagramConnectOK::new()
    }

    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.delay_time_usec = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectOK {
        static instance: CMsgSteamDatagramConnectOK = CMsgSteamDatagramConnectOK {
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            your_timestamp: ::std::option::Option::None,
            delay_time_usec: ::std::option::Option::None,
            gameserver_relay_session_id: ::std::option::Option::None,
            crypt: ::steam_vent_proto_common::protobuf::MessageField::none(),
            cert: ::steam_vent_proto_common::protobuf::MessageField::none(),
            protocol_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionClosed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionClosed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.legacy_client_connection_id)
    pub legacy_client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.peer_steam_id)
    pub peer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.gameserver_relay_session_id)
    pub gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.relay_mode)
    pub relay_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_steam_datagram_connection_closed::ERelayMode>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.debug)
    pub debug: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionClosed.reason_code)
    pub reason_code: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionClosed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionClosed {
    fn default() -> &'a CMsgSteamDatagramConnectionClosed {
        <CMsgSteamDatagramConnectionClosed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionClosed {
    pub fn new() -> CMsgSteamDatagramConnectionClosed {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;

    pub fn legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }

    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 7;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 8;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 peer_steam_id = 3;

    pub fn peer_steam_id(&self) -> u64 {
        self.peer_steam_id.unwrap_or(0)
    }

    pub fn clear_peer_steam_id(&mut self) {
        self.peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_peer_steam_id(&self) -> bool {
        self.peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_steam_id(&mut self, v: u64) {
        self.peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;

    pub fn gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4;

    pub fn relay_mode(&self) -> cmsg_steam_datagram_connection_closed::ERelayMode {
        match self.relay_mode {
            Some(e) => e.enum_value_or(cmsg_steam_datagram_connection_closed::ERelayMode::None),
            None => cmsg_steam_datagram_connection_closed::ERelayMode::None,
        }
    }

    pub fn clear_relay_mode(&mut self) {
        self.relay_mode = ::std::option::Option::None;
    }

    pub fn has_relay_mode(&self) -> bool {
        self.relay_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_mode(&mut self, v: cmsg_steam_datagram_connection_closed::ERelayMode) {
        self.relay_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string debug = 5;

    pub fn debug(&self) -> &str {
        match self.debug.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug(&mut self) {
        self.debug = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::std::string::String) {
        self.debug = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug(&mut self) -> &mut ::std::string::String {
        if self.debug.is_none() {
            self.debug = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug(&mut self) -> ::std::string::String {
        self.debug.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reason_code = 6;

    pub fn reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }

    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionClosed {
    const NAME: &'static str = "CMsgSteamDatagramConnectionClosed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.legacy_client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.peer_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.relay_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.debug = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.reason_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.peer_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.relay_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.debug.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.reason_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.peer_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.relay_mode {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.debug.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionClosed {
        CMsgSteamDatagramConnectionClosed::new()
    }

    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.peer_steam_id = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.relay_mode = ::std::option::Option::None;
        self.debug = ::std::option::Option::None;
        self.reason_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionClosed {
        static instance: CMsgSteamDatagramConnectionClosed = CMsgSteamDatagramConnectionClosed {
            legacy_client_connection_id: ::std::option::Option::None,
            to_connection_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            peer_steam_id: ::std::option::Option::None,
            gameserver_relay_session_id: ::std::option::Option::None,
            relay_mode: ::std::option::Option::None,
            debug: ::std::option::Option::None,
            reason_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionClosed`
pub mod cmsg_steam_datagram_connection_closed {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionClosed.ERelayMode)
    pub enum ERelayMode {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionClosed.ERelayMode.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionClosed.ERelayMode.EndToEnd)
        EndToEnd = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionClosed.ERelayMode.ClosedByPeer)
        ClosedByPeer = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ERelayMode {
        const NAME: &'static str = "ERelayMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERelayMode> {
            match value {
                0 => ::std::option::Option::Some(ERelayMode::None),
                1 => ::std::option::Option::Some(ERelayMode::EndToEnd),
                2 => ::std::option::Option::Some(ERelayMode::ClosedByPeer),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERelayMode> {
            match str {
                "None" => ::std::option::Option::Some(ERelayMode::None),
                "EndToEnd" => ::std::option::Option::Some(ERelayMode::EndToEnd),
                "ClosedByPeer" => ::std::option::Option::Some(ERelayMode::ClosedByPeer),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERelayMode] = &[
            ERelayMode::None,
            ERelayMode::EndToEnd,
            ERelayMode::ClosedByPeer,
        ];
    }

    impl ::std::default::Default for ERelayMode {
        fn default() -> Self {
            ERelayMode::None
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamDatagramNoConnection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramNoConnection {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.legacy_client_connection_id)
    pub legacy_client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.gameserver_relay_session_id)
    pub gameserver_relay_session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.peer_steam_id)
    pub peer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.end_to_end)
    pub end_to_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoConnection.dummy_pad)
    pub dummy_pad: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNoConnection.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoConnection {
    fn default() -> &'a CMsgSteamDatagramNoConnection {
        <CMsgSteamDatagramNoConnection as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoConnection {
    pub fn new() -> CMsgSteamDatagramNoConnection {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;

    pub fn legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }

    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 5;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 6;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;

    pub fn gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }

    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 peer_steam_id = 3;

    pub fn peer_steam_id(&self) -> u64 {
        self.peer_steam_id.unwrap_or(0)
    }

    pub fn clear_peer_steam_id(&mut self) {
        self.peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_peer_steam_id(&self) -> bool {
        self.peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_steam_id(&mut self, v: u64) {
        self.peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool end_to_end = 4;

    pub fn end_to_end(&self) -> bool {
        self.end_to_end.unwrap_or(false)
    }

    pub fn clear_end_to_end(&mut self) {
        self.end_to_end = ::std::option::Option::None;
    }

    pub fn has_end_to_end(&self) -> bool {
        self.end_to_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_to_end(&mut self, v: bool) {
        self.end_to_end = ::std::option::Option::Some(v);
    }

    // optional fixed32 dummy_pad = 1023;

    pub fn dummy_pad(&self) -> u32 {
        self.dummy_pad.unwrap_or(0)
    }

    pub fn clear_dummy_pad(&mut self) {
        self.dummy_pad = ::std::option::Option::None;
    }

    pub fn has_dummy_pad(&self) -> bool {
        self.dummy_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_pad(&mut self, v: u32) {
        self.dummy_pad = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramNoConnection {
    const NAME: &'static str = "CMsgSteamDatagramNoConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.legacy_client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                53 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.gameserver_relay_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                25 => {
                    self.peer_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.end_to_end = ::std::option::Option::Some(is.read_bool()?);
                },
                8189 => {
                    self.dummy_pad = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.peer_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.end_to_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dummy_pad {
            my_size += 2 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.peer_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.end_to_end {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.dummy_pad {
            os.write_fixed32(1023, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNoConnection {
        CMsgSteamDatagramNoConnection::new()
    }

    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.peer_steam_id = ::std::option::Option::None;
        self.end_to_end = ::std::option::Option::None;
        self.dummy_pad = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoConnection {
        static instance: CMsgSteamDatagramNoConnection = CMsgSteamDatagramNoConnection {
            legacy_client_connection_id: ::std::option::Option::None,
            to_connection_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            gameserver_relay_session_id: ::std::option::Option::None,
            peer_steam_id: ::std::option::Option::None,
            end_to_end: ::std::option::Option::None,
            dummy_pad: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PSessionRequestBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PSessionRequestBody {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.challenge_time)
    pub challenge_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.my_connection_id)
    pub my_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.peer_steam_id)
    pub peer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.peer_connection_id)
    pub peer_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.network_config_version)
    pub network_config_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequestBody.public_ip)
    pub public_ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PSessionRequestBody.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequestBody {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequestBody {
        <CMsgSteamDatagramP2PSessionRequestBody as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequestBody {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        ::std::default::Default::default()
    }

    // optional fixed32 challenge_time = 1;

    pub fn challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }

    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 my_connection_id = 3;

    pub fn my_connection_id(&self) -> u32 {
        self.my_connection_id.unwrap_or(0)
    }

    pub fn clear_my_connection_id(&mut self) {
        self.my_connection_id = ::std::option::Option::None;
    }

    pub fn has_my_connection_id(&self) -> bool {
        self.my_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_connection_id(&mut self, v: u32) {
        self.my_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 peer_steam_id = 4;

    pub fn peer_steam_id(&self) -> u64 {
        self.peer_steam_id.unwrap_or(0)
    }

    pub fn clear_peer_steam_id(&mut self) {
        self.peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_peer_steam_id(&self) -> bool {
        self.peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_steam_id(&mut self, v: u64) {
        self.peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 peer_connection_id = 5;

    pub fn peer_connection_id(&self) -> u32 {
        self.peer_connection_id.unwrap_or(0)
    }

    pub fn clear_peer_connection_id(&mut self) {
        self.peer_connection_id = ::std::option::Option::None;
    }

    pub fn has_peer_connection_id(&self) -> bool {
        self.peer_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_connection_id(&mut self, v: u32) {
        self.peer_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 9;

    pub fn network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }

    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional fixed32 public_ip = 10;

    pub fn public_ip(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramP2PSessionRequestBody {
    const NAME: &'static str = "CMsgSteamDatagramP2PSessionRequestBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.challenge_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.my_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.peer_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.peer_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.network_config_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.my_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.peer_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.peer_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.network_config_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.public_ip {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.challenge_time {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.my_connection_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.peer_steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.peer_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.public_ip {
            os.write_fixed32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        CMsgSteamDatagramP2PSessionRequestBody::new()
    }

    fn clear(&mut self) {
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.my_connection_id = ::std::option::Option::None;
        self.peer_steam_id = ::std::option::Option::None;
        self.peer_connection_id = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.public_ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequestBody {
        static instance: CMsgSteamDatagramP2PSessionRequestBody = CMsgSteamDatagramP2PSessionRequestBody {
            challenge_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            my_connection_id: ::std::option::Option::None,
            peer_steam_id: ::std::option::Option::None,
            peer_connection_id: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            network_config_version: ::std::option::Option::None,
            public_ip: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequest.cert)
    pub cert: ::steam_vent_proto_common::protobuf::MessageField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequest.body)
    pub body: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionRequest.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PSessionRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequest {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequest {
        <CMsgSteamDatagramP2PSessionRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequest {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequest {
        ::std::default::Default::default()
    }

    // optional bytes body = 2;

    pub fn body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 3;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramP2PSessionRequest {
    const NAME: &'static str = "CMsgSteamDatagramP2PSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                18 => {
                    self.body = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cert.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequest {
        CMsgSteamDatagramP2PSessionRequest::new()
    }

    fn clear(&mut self) {
        self.cert.clear();
        self.body = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequest {
        static instance: CMsgSteamDatagramP2PSessionRequest = CMsgSteamDatagramP2PSessionRequest {
            cert: ::steam_vent_proto_common::protobuf::MessageField::none(),
            body: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PSessionEstablished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PSessionEstablished {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.relay_routing_id)
    pub relay_routing_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PSessionEstablished.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PSessionEstablished.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramP2PSessionEstablished {
        <CMsgSteamDatagramP2PSessionEstablished as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionEstablished {
    pub fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 3;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed64 relay_routing_id = 4;

    pub fn relay_routing_id(&self) -> u64 {
        self.relay_routing_id.unwrap_or(0)
    }

    pub fn clear_relay_routing_id(&mut self) {
        self.relay_routing_id = ::std::option::Option::None;
    }

    pub fn has_relay_routing_id(&self) -> bool {
        self.relay_routing_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_routing_id(&mut self, v: u64) {
        self.relay_routing_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 5;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramP2PSessionEstablished {
    const NAME: &'static str = "CMsgSteamDatagramP2PSessionEstablished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.relay_routing_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.relay_routing_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.relay_routing_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        CMsgSteamDatagramP2PSessionEstablished::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.relay_routing_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionEstablished {
        static instance: CMsgSteamDatagramP2PSessionEstablished = CMsgSteamDatagramP2PSessionEstablished {
            connection_id: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            relay_routing_id: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PRoutes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PRoutes {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.relay_clusters)
    pub relay_clusters: ::std::vec::Vec<cmsg_steam_datagram_p2proutes::RelayCluster>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.routes)
    pub routes: ::std::vec::Vec<cmsg_steam_datagram_p2proutes::Route>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.revision)
    pub revision: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRoutes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes {
        <CMsgSteamDatagramP2PRoutes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes {
    pub fn new() -> CMsgSteamDatagramP2PRoutes {
        ::std::default::Default::default()
    }

    // optional uint32 revision = 3;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramP2PRoutes {
    const NAME: &'static str = "CMsgSteamDatagramP2PRoutes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.relay_clusters.push(is.read_message()?);
                },
                18 => {
                    self.routes.push(is.read_message()?);
                },
                24 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.relay_clusters {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.revision {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.relay_clusters {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.routes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.revision {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PRoutes {
        CMsgSteamDatagramP2PRoutes::new()
    }

    fn clear(&mut self) {
        self.relay_clusters.clear();
        self.routes.clear();
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes {
        static instance: CMsgSteamDatagramP2PRoutes = CMsgSteamDatagramP2PRoutes {
            relay_clusters: ::std::vec::Vec::new(),
            routes: ::std::vec::Vec::new(),
            revision: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramP2PRoutes`
pub mod cmsg_steam_datagram_p2proutes {
    // @@protoc_insertion_point(message:CMsgSteamDatagramP2PRoutes.RelayCluster)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RelayCluster {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.pop_id)
        pub pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.ping_ms)
        pub ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.score_penalty)
        pub score_penalty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.RelayCluster.session_relay_routing_id)
        pub session_relay_routing_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRoutes.RelayCluster.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RelayCluster {
        fn default() -> &'a RelayCluster {
            <RelayCluster as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RelayCluster {
        pub fn new() -> RelayCluster {
            ::std::default::Default::default()
        }

        // optional fixed32 pop_id = 1;

        pub fn pop_id(&self) -> u32 {
            self.pop_id.unwrap_or(0)
        }

        pub fn clear_pop_id(&mut self) {
            self.pop_id = ::std::option::Option::None;
        }

        pub fn has_pop_id(&self) -> bool {
            self.pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pop_id(&mut self, v: u32) {
            self.pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 ping_ms = 2;

        pub fn ping_ms(&self) -> u32 {
            self.ping_ms.unwrap_or(0)
        }

        pub fn clear_ping_ms(&mut self) {
            self.ping_ms = ::std::option::Option::None;
        }

        pub fn has_ping_ms(&self) -> bool {
            self.ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_ms(&mut self, v: u32) {
            self.ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 score_penalty = 3;

        pub fn score_penalty(&self) -> u32 {
            self.score_penalty.unwrap_or(0)
        }

        pub fn clear_score_penalty(&mut self) {
            self.score_penalty = ::std::option::Option::None;
        }

        pub fn has_score_penalty(&self) -> bool {
            self.score_penalty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_penalty(&mut self, v: u32) {
            self.score_penalty = ::std::option::Option::Some(v);
        }

        // optional fixed64 session_relay_routing_id = 4;

        pub fn session_relay_routing_id(&self) -> u64 {
            self.session_relay_routing_id.unwrap_or(0)
        }

        pub fn clear_session_relay_routing_id(&mut self) {
            self.session_relay_routing_id = ::std::option::Option::None;
        }

        pub fn has_session_relay_routing_id(&self) -> bool {
            self.session_relay_routing_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_session_relay_routing_id(&mut self, v: u64) {
            self.session_relay_routing_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RelayCluster {
        const NAME: &'static str = "RelayCluster";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.score_penalty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    33 => {
                        self.session_relay_routing_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.ping_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.score_penalty {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.session_relay_routing_id {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.pop_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.ping_ms {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.score_penalty {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.session_relay_routing_id {
                os.write_fixed64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RelayCluster {
            RelayCluster::new()
        }

        fn clear(&mut self) {
            self.pop_id = ::std::option::Option::None;
            self.ping_ms = ::std::option::Option::None;
            self.score_penalty = ::std::option::Option::None;
            self.session_relay_routing_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RelayCluster {
            static instance: RelayCluster = RelayCluster {
                pop_id: ::std::option::Option::None,
                ping_ms: ::std::option::Option::None,
                score_penalty: ::std::option::Option::None,
                session_relay_routing_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSteamDatagramP2PRoutes.Route)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Route {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.Route.my_pop_id)
        pub my_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.Route.your_pop_id)
        pub your_pop_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRoutes.Route.score)
        pub score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRoutes.Route.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Route {
        fn default() -> &'a Route {
            <Route as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Route {
        pub fn new() -> Route {
            ::std::default::Default::default()
        }

        // optional fixed32 my_pop_id = 1;

        pub fn my_pop_id(&self) -> u32 {
            self.my_pop_id.unwrap_or(0)
        }

        pub fn clear_my_pop_id(&mut self) {
            self.my_pop_id = ::std::option::Option::None;
        }

        pub fn has_my_pop_id(&self) -> bool {
            self.my_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_my_pop_id(&mut self, v: u32) {
            self.my_pop_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 your_pop_id = 2;

        pub fn your_pop_id(&self) -> u32 {
            self.your_pop_id.unwrap_or(0)
        }

        pub fn clear_your_pop_id(&mut self) {
            self.your_pop_id = ::std::option::Option::None;
        }

        pub fn has_your_pop_id(&self) -> bool {
            self.your_pop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_your_pop_id(&mut self, v: u32) {
            self.your_pop_id = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 3;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Route {
        const NAME: &'static str = "Route";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.my_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    21 => {
                        self.your_pop_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.my_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.your_pop_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.my_pop_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.your_pop_id {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Route {
            Route::new()
        }

        fn clear(&mut self) {
            self.my_pop_id = ::std::option::Option::None;
            self.your_pop_id = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Route {
            static instance: Route = Route {
                my_pop_id: ::std::option::Option::None,
                your_pop_id: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramP2PRendezvous)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramP2PRendezvous {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRendezvous.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRendezvous.routes)
    pub routes: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramP2PRoutes>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRendezvous.ack_peer_routes_revision)
    pub ack_peer_routes_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRendezvous.connect_request)
    pub connect_request: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectRequest>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRendezvous.connect_ok)
    pub connect_ok: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectOK>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramP2PRendezvous.connection_closed)
    pub connection_closed: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionClosed>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramP2PRendezvous.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRendezvous {
    fn default() -> &'a CMsgSteamDatagramP2PRendezvous {
        <CMsgSteamDatagramP2PRendezvous as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRendezvous {
    pub fn new() -> CMsgSteamDatagramP2PRendezvous {
        ::std::default::Default::default()
    }

    // optional fixed32 to_connection_id = 1;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_peer_routes_revision = 3;

    pub fn ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }

    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramP2PRendezvous {
    const NAME: &'static str = "CMsgSteamDatagramP2PRendezvous";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.routes)?;
                },
                24 => {
                    self.ack_peer_routes_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.connect_request)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.connect_ok)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.connection_closed)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.connect_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.connect_ok.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.connection_closed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.routes.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.connect_request.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.connect_ok.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.connection_closed.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramP2PRendezvous {
        CMsgSteamDatagramP2PRendezvous::new()
    }

    fn clear(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connect_request.clear();
        self.connect_ok.clear();
        self.connection_closed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRendezvous {
        static instance: CMsgSteamDatagramP2PRendezvous = CMsgSteamDatagramP2PRendezvous {
            to_connection_id: ::std::option::Option::None,
            routes: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ack_peer_routes_revision: ::std::option::Option::None,
            connect_request: ::steam_vent_proto_common::protobuf::MessageField::none(),
            connect_ok: ::steam_vent_proto_common::protobuf::MessageField::none(),
            connection_closed: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsP2PClientToRouter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.c2r)
    pub c2r: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.c2s)
    pub c2s: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.ack_e2e)
    pub ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.forward_target_relay_routing_id)
    pub forward_target_relay_routing_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.forward_target_revision)
    pub forward_target_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.routes)
    pub routes: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramP2PRoutes>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.ack_peer_routes_revision)
    pub ack_peer_routes_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.seq_num_c2r)
    pub seq_num_c2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.seq_num_c2s)
    pub seq_num_c2s: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsP2PClientToRouter.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        <CMsgSteamDatagramConnectionStatsP2PClientToRouter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 forward_target_relay_routing_id = 6;

    pub fn forward_target_relay_routing_id(&self) -> u64 {
        self.forward_target_relay_routing_id.unwrap_or(0)
    }

    pub fn clear_forward_target_relay_routing_id(&mut self) {
        self.forward_target_relay_routing_id = ::std::option::Option::None;
    }

    pub fn has_forward_target_relay_routing_id(&self) -> bool {
        self.forward_target_relay_routing_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_relay_routing_id(&mut self, v: u64) {
        self.forward_target_relay_routing_id = ::std::option::Option::Some(v);
    }

    // optional uint32 forward_target_revision = 7;

    pub fn forward_target_revision(&self) -> u32 {
        self.forward_target_revision.unwrap_or(0)
    }

    pub fn clear_forward_target_revision(&mut self) {
        self.forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_forward_target_revision(&self) -> bool {
        self.forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_revision(&mut self, v: u32) {
        self.forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_peer_routes_revision = 9;

    pub fn ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }

    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 10;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 11;

    pub fn seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }

    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 12;

    pub fn seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }

    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsP2PClientToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.c2r)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.c2s)?;
                },
                26 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                29 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_e2e)?;
                },
                37 => {
                    self.ack_e2e.push(is.read_fixed32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                49 => {
                    self.forward_target_relay_routing_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                56 => {
                    self.forward_target_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.routes)?;
                },
                72 => {
                    self.ack_peer_routes_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                88 => {
                    self.seq_num_c2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.seq_num_c2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.c2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.forward_target_relay_routing_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.forward_target_revision {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.c2r.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.c2s.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(3, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(4, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.forward_target_relay_routing_id {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.forward_target_revision {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.routes.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        CMsgSteamDatagramConnectionStatsP2PClientToRouter::new()
    }

    fn clear(&mut self) {
        self.c2r.clear();
        self.c2s.clear();
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.forward_target_relay_routing_id = ::std::option::Option::None;
        self.forward_target_revision = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        static instance: CMsgSteamDatagramConnectionStatsP2PClientToRouter = CMsgSteamDatagramConnectionStatsP2PClientToRouter {
            c2r: ::steam_vent_proto_common::protobuf::MessageField::none(),
            c2s: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ack_relay: ::std::vec::Vec::new(),
            ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            forward_target_relay_routing_id: ::std::option::Option::None,
            forward_target_revision: ::std::option::Option::None,
            routes: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ack_peer_routes_revision: ::std::option::Option::None,
            connection_id: ::std::option::Option::None,
            seq_num_c2r: ::std::option::Option::None,
            seq_num_c2s: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsP2PClientToRouter`
pub mod cmsg_steam_datagram_connection_stats_p2pclient_to_router {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsP2PRouterToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.r2c)
    pub r2c: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.p2c)
    pub p2c: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.migrate_request_ip)
    pub migrate_request_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.migrate_request_port)
    pub migrate_request_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.scoring_penalty_relay_cluster)
    pub scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.ack_relay)
    pub ack_relay: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.ack_e2e)
    pub ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.ack_forward_target_revision)
    pub ack_forward_target_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.routes)
    pub routes: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramP2PRoutes>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.ack_peer_routes_revision)
    pub ack_peer_routes_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.seq_num_p2c)
    pub seq_num_p2c: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsP2PRouterToClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        <CMsgSteamDatagramConnectionStatsP2PRouterToClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        ::std::default::Default::default()
    }

    // optional uint32 seconds_until_shutdown = 3;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 4;

    pub fn migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }

    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 5;

    pub fn migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }

    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 6;

    pub fn scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }

    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 9;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_forward_target_revision = 10;

    pub fn ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }

    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_peer_routes_revision = 12;

    pub fn ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }

    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 13;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 14;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_p2c = 15;

    pub fn seq_num_p2c(&self) -> u32 {
        self.seq_num_p2c.unwrap_or(0)
    }

    pub fn clear_seq_num_p2c(&mut self) {
        self.seq_num_p2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_p2c(&self) -> bool {
        self.seq_num_p2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_p2c(&mut self, v: u32) {
        self.seq_num_p2c = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsP2PRouterToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.r2c)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.p2c)?;
                },
                24 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.migrate_request_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.migrate_request_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_relay)?;
                },
                61 => {
                    self.ack_relay.push(is.read_fixed32()?);
                },
                66 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_e2e)?;
                },
                69 => {
                    self.ack_e2e.push(is.read_fixed32()?);
                },
                72 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ack_forward_target_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.routes)?;
                },
                96 => {
                    self.ack_peer_routes_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                112 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.seq_num_p2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.p2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += 5 * self.ack_relay.len() as u64;
        my_size += 5 * self.ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.routes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.seq_num_p2c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.r2c.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.p2c.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(6, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(7, *v)?;
        };
        for v in &self.ack_e2e {
            os.write_fixed32(8, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.routes.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.seq_num_p2c {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        CMsgSteamDatagramConnectionStatsP2PRouterToClient::new()
    }

    fn clear(&mut self) {
        self.r2c.clear();
        self.p2c.clear();
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_p2c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        static instance: CMsgSteamDatagramConnectionStatsP2PRouterToClient = CMsgSteamDatagramConnectionStatsP2PRouterToClient {
            r2c: ::steam_vent_proto_common::protobuf::MessageField::none(),
            p2c: ::steam_vent_proto_common::protobuf::MessageField::none(),
            seconds_until_shutdown: ::std::option::Option::None,
            migrate_request_ip: ::std::option::Option::None,
            migrate_request_port: ::std::option::Option::None,
            scoring_penalty_relay_cluster: ::std::option::Option::None,
            ack_relay: ::std::vec::Vec::new(),
            ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            ack_forward_target_revision: ::std::option::Option::None,
            routes: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ack_peer_routes_revision: ::std::option::Option::None,
            connection_id: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            seq_num_p2c: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamDatagramConnectionStatsP2PRouterToClient`
pub mod cmsg_steam_datagram_connection_stats_p2prouter_to_client {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags.ACK_REQUEST_RELAY)
        ACK_REQUEST_RELAY = 1,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                1 => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_RELAY" => ::std::option::Option::Some(Flags::ACK_REQUEST_RELAY),
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_RELAY,
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_RELAY
        }
    }

}

// @@protoc_insertion_point(message:CMsgSteamSockets_UDP_ChallengeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamSockets_UDP_ChallengeRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ChallengeRequest.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ChallengeRequest.my_timestamp)
    pub my_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ChallengeRequest.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamSockets_UDP_ChallengeRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ChallengeRequest {
    fn default() -> &'a CMsgSteamSockets_UDP_ChallengeRequest {
        <CMsgSteamSockets_UDP_ChallengeRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ChallengeRequest {
    pub fn new() -> CMsgSteamSockets_UDP_ChallengeRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 3;

    pub fn my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }

    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 4;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamSockets_UDP_ChallengeRequest {
    const NAME: &'static str = "CMsgSteamSockets_UDP_ChallengeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.my_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamSockets_UDP_ChallengeRequest {
        CMsgSteamSockets_UDP_ChallengeRequest::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ChallengeRequest {
        static instance: CMsgSteamSockets_UDP_ChallengeRequest = CMsgSteamSockets_UDP_ChallengeRequest {
            connection_id: ::std::option::Option::None,
            my_timestamp: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamSockets_UDP_ChallengeReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamSockets_UDP_ChallengeReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ChallengeReply.connection_id)
    pub connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ChallengeReply.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ChallengeReply.your_timestamp)
    pub your_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ChallengeReply.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamSockets_UDP_ChallengeReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ChallengeReply {
    fn default() -> &'a CMsgSteamSockets_UDP_ChallengeReply {
        <CMsgSteamSockets_UDP_ChallengeReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ChallengeReply {
    pub fn new() -> CMsgSteamSockets_UDP_ChallengeReply {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;

    pub fn connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }

    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;

    pub fn your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }

    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 4;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamSockets_UDP_ChallengeReply {
    const NAME: &'static str = "CMsgSteamSockets_UDP_ChallengeReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.your_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamSockets_UDP_ChallengeReply {
        CMsgSteamSockets_UDP_ChallengeReply::new()
    }

    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ChallengeReply {
        static instance: CMsgSteamSockets_UDP_ChallengeReply = CMsgSteamSockets_UDP_ChallengeReply {
            connection_id: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            your_timestamp: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamSockets_UDP_ConnectRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamSockets_UDP_ConnectRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.my_timestamp)
    pub my_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.ping_est_ms)
    pub ping_est_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.crypt)
    pub crypt: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramSessionCryptInfoSigned>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.cert)
    pub cert: ::steam_vent_proto_common::protobuf::MessageField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectRequest.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamSockets_UDP_ConnectRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ConnectRequest {
    fn default() -> &'a CMsgSteamSockets_UDP_ConnectRequest {
        <CMsgSteamSockets_UDP_ConnectRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ConnectRequest {
    pub fn new() -> CMsgSteamSockets_UDP_ConnectRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 3;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 5;

    pub fn my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }

    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_est_ms = 6;

    pub fn ping_est_ms(&self) -> u32 {
        self.ping_est_ms.unwrap_or(0)
    }

    pub fn clear_ping_est_ms(&mut self) {
        self.ping_est_ms = ::std::option::Option::None;
    }

    pub fn has_ping_est_ms(&self) -> bool {
        self.ping_est_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_est_ms(&mut self, v: u32) {
        self.ping_est_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamSockets_UDP_ConnectRequest {
    const NAME: &'static str = "CMsgSteamSockets_UDP_ConnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.my_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.ping_est_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                64 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ping_est_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.ping_est_ms {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.crypt.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.cert.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamSockets_UDP_ConnectRequest {
        CMsgSteamSockets_UDP_ConnectRequest::new()
    }

    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.ping_est_ms = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ConnectRequest {
        static instance: CMsgSteamSockets_UDP_ConnectRequest = CMsgSteamSockets_UDP_ConnectRequest {
            client_connection_id: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            my_timestamp: ::std::option::Option::None,
            ping_est_ms: ::std::option::Option::None,
            crypt: ::steam_vent_proto_common::protobuf::MessageField::none(),
            cert: ::steam_vent_proto_common::protobuf::MessageField::none(),
            protocol_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamSockets_UDP_ConnectOK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamSockets_UDP_ConnectOK {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.client_connection_id)
    pub client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.server_connection_id)
    pub server_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.your_timestamp)
    pub your_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.delay_time_usec)
    pub delay_time_usec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.crypt)
    pub crypt: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramSessionCryptInfoSigned>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.cert)
    pub cert: ::steam_vent_proto_common::protobuf::MessageField<super::steamdatagram_auth_messages::CMsgSteamDatagramCertificateSigned>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectOK.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamSockets_UDP_ConnectOK.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ConnectOK {
    fn default() -> &'a CMsgSteamSockets_UDP_ConnectOK {
        <CMsgSteamSockets_UDP_ConnectOK as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ConnectOK {
    pub fn new() -> CMsgSteamSockets_UDP_ConnectOK {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;

    pub fn client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }

    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 5;

    pub fn server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }

    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_steam_id = 2;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;

    pub fn your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }

    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_time_usec = 4;

    pub fn delay_time_usec(&self) -> u32 {
        self.delay_time_usec.unwrap_or(0)
    }

    pub fn clear_delay_time_usec(&mut self) {
        self.delay_time_usec = ::std::option::Option::None;
    }

    pub fn has_delay_time_usec(&self) -> bool {
        self.delay_time_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_time_usec(&mut self, v: u32) {
        self.delay_time_usec = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 9;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamSockets_UDP_ConnectOK {
    const NAME: &'static str = "CMsgSteamSockets_UDP_ConnectOK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.server_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.your_timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.delay_time_usec = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                },
                72 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 1 + 8;
        }
        if let Some(v) = self.delay_time_usec {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.delay_time_usec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.crypt.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.cert.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamSockets_UDP_ConnectOK {
        CMsgSteamSockets_UDP_ConnectOK::new()
    }

    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.delay_time_usec = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.protocol_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ConnectOK {
        static instance: CMsgSteamSockets_UDP_ConnectOK = CMsgSteamSockets_UDP_ConnectOK {
            client_connection_id: ::std::option::Option::None,
            server_connection_id: ::std::option::Option::None,
            server_steam_id: ::std::option::Option::None,
            your_timestamp: ::std::option::Option::None,
            delay_time_usec: ::std::option::Option::None,
            crypt: ::steam_vent_proto_common::protobuf::MessageField::none(),
            cert: ::steam_vent_proto_common::protobuf::MessageField::none(),
            protocol_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamSockets_UDP_ConnectionClosed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamSockets_UDP_ConnectionClosed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectionClosed.legacy_client_connection_id)
    pub legacy_client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectionClosed.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectionClosed.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectionClosed.debug)
    pub debug: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_ConnectionClosed.reason_code)
    pub reason_code: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamSockets_UDP_ConnectionClosed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_ConnectionClosed {
    fn default() -> &'a CMsgSteamSockets_UDP_ConnectionClosed {
        <CMsgSteamSockets_UDP_ConnectionClosed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_ConnectionClosed {
    pub fn new() -> CMsgSteamSockets_UDP_ConnectionClosed {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;

    pub fn legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }

    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 4;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 5;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional string debug = 2;

    pub fn debug(&self) -> &str {
        match self.debug.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug(&mut self) {
        self.debug = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::std::string::String) {
        self.debug = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug(&mut self) -> &mut ::std::string::String {
        if self.debug.is_none() {
            self.debug = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug(&mut self) -> ::std::string::String {
        self.debug.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reason_code = 3;

    pub fn reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }

    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamSockets_UDP_ConnectionClosed {
    const NAME: &'static str = "CMsgSteamSockets_UDP_ConnectionClosed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.legacy_client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.debug = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.reason_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.debug.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reason_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.debug.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamSockets_UDP_ConnectionClosed {
        CMsgSteamSockets_UDP_ConnectionClosed::new()
    }

    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.debug = ::std::option::Option::None;
        self.reason_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_ConnectionClosed {
        static instance: CMsgSteamSockets_UDP_ConnectionClosed = CMsgSteamSockets_UDP_ConnectionClosed {
            legacy_client_connection_id: ::std::option::Option::None,
            to_connection_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            debug: ::std::option::Option::None,
            reason_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamSockets_UDP_NoConnection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamSockets_UDP_NoConnection {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_NoConnection.legacy_client_connection_id)
    pub legacy_client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_NoConnection.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_NoConnection.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamSockets_UDP_NoConnection.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_NoConnection {
    fn default() -> &'a CMsgSteamSockets_UDP_NoConnection {
        <CMsgSteamSockets_UDP_NoConnection as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_NoConnection {
    pub fn new() -> CMsgSteamSockets_UDP_NoConnection {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_client_connection_id = 1;

    pub fn legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }

    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 2;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 3;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamSockets_UDP_NoConnection {
    const NAME: &'static str = "CMsgSteamSockets_UDP_NoConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.legacy_client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamSockets_UDP_NoConnection {
        CMsgSteamSockets_UDP_NoConnection::new()
    }

    fn clear(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_NoConnection {
        static instance: CMsgSteamSockets_UDP_NoConnection = CMsgSteamSockets_UDP_NoConnection {
            legacy_client_connection_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            to_connection_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamSockets_UDP_Stats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamSockets_UDP_Stats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_Stats.stats)
    pub stats: ::steam_vent_proto_common::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_Stats.ack_e2e)
    pub ack_e2e: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_Stats.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_Stats.legacy_client_connection_id)
    pub legacy_client_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_Stats.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_Stats.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamSockets_UDP_Stats.seq_num)
    pub seq_num: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamSockets_UDP_Stats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamSockets_UDP_Stats {
    fn default() -> &'a CMsgSteamSockets_UDP_Stats {
        <CMsgSteamSockets_UDP_Stats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamSockets_UDP_Stats {
    pub fn new() -> CMsgSteamSockets_UDP_Stats {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 3;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_client_connection_id = 8;

    pub fn legacy_client_connection_id(&self) -> u32 {
        self.legacy_client_connection_id.unwrap_or(0)
    }

    pub fn clear_legacy_client_connection_id(&mut self) {
        self.legacy_client_connection_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_connection_id(&self) -> bool {
        self.legacy_client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_connection_id(&mut self, v: u32) {
        self.legacy_client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 9;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 10;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num = 4;

    pub fn seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamSockets_UDP_Stats {
    const NAME: &'static str = "CMsgSteamSockets_UDP_Stats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                18 => {
                    is.read_repeated_packed_fixed32_into(&mut self.ack_e2e)?;
                },
                21 => {
                    self.ack_e2e.push(is.read_fixed32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.legacy_client_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                77 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                85 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.seq_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.ack_e2e.len() as u64;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.legacy_client_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ack_e2e {
            os.write_fixed32(2, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.legacy_client_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamSockets_UDP_Stats {
        CMsgSteamSockets_UDP_Stats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.legacy_client_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.seq_num = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamSockets_UDP_Stats {
        static instance: CMsgSteamSockets_UDP_Stats = CMsgSteamSockets_UDP_Stats {
            stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ack_e2e: ::std::vec::Vec::new(),
            flags: ::std::option::Option::None,
            legacy_client_connection_id: ::std::option::Option::None,
            to_connection_id: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            seq_num: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamSockets_UDP_Stats`
pub mod cmsg_steam_sockets_udp_stats {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamSockets_UDP_Stats.Flags)
    pub enum Flags {
        // @@protoc_insertion_point(enum_value:CMsgSteamSockets_UDP_Stats.Flags.ACK_REQUEST_E2E)
        ACK_REQUEST_E2E = 2,
        // @@protoc_insertion_point(enum_value:CMsgSteamSockets_UDP_Stats.Flags.ACK_REQUEST_IMMEDIATE)
        ACK_REQUEST_IMMEDIATE = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Flags {
        const NAME: &'static str = "Flags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flags> {
            match value {
                2 => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                4 => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Flags> {
            match str {
                "ACK_REQUEST_E2E" => ::std::option::Option::Some(Flags::ACK_REQUEST_E2E),
                "ACK_REQUEST_IMMEDIATE" => ::std::option::Option::Some(Flags::ACK_REQUEST_IMMEDIATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flags] = &[
            Flags::ACK_REQUEST_E2E,
            Flags::ACK_REQUEST_IMMEDIATE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Flags {
        fn default() -> Self {
            Flags::ACK_REQUEST_E2E
        }
    }

}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDatagramMsgID)
pub enum ESteamDatagramMsgID {
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Invalid)
    k_ESteamDatagramMsg_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RouterPingRequest)
    k_ESteamDatagramMsg_RouterPingRequest = 1,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RouterPingReply)
    k_ESteamDatagramMsg_RouterPingReply = 2,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverPingRequest)
    k_ESteamDatagramMsg_GameserverPingRequest = 3,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverPingReply)
    k_ESteamDatagramMsg_GameserverPingReply = 4,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverSessionRequest)
    k_ESteamDatagramMsg_GameserverSessionRequest = 5,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverSessionEstablished)
    k_ESteamDatagramMsg_GameserverSessionEstablished = 6,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_NoSession)
    k_ESteamDatagramMsg_NoSession = 7,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Diagnostic)
    k_ESteamDatagramMsg_Diagnostic = 8,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataClientToRouter)
    k_ESteamDatagramMsg_DataClientToRouter = 9,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataRouterToServer)
    k_ESteamDatagramMsg_DataRouterToServer = 10,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataServerToRouter)
    k_ESteamDatagramMsg_DataServerToRouter = 11,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataRouterToClient)
    k_ESteamDatagramMsg_DataRouterToClient = 12,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Stats)
    k_ESteamDatagramMsg_Stats = 13,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientPingSampleRequest)
    k_ESteamDatagramMsg_ClientPingSampleRequest = 14,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientPingSampleReply)
    k_ESteamDatagramMsg_ClientPingSampleReply = 15,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary)
    k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RelayHealth)
    k_ESteamDatagramMsg_RelayHealth = 17,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ConnectRequest)
    k_ESteamDatagramMsg_ConnectRequest = 18,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ConnectOK)
    k_ESteamDatagramMsg_ConnectOK = 19,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ConnectionClosed)
    k_ESteamDatagramMsg_ConnectionClosed = 20,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_NoConnection)
    k_ESteamDatagramMsg_NoConnection = 21,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RelayToRelayPingRequest)
    k_ESteamDatagramMsg_RelayToRelayPingRequest = 22,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RelayToRelayPingReply)
    k_ESteamDatagramMsg_RelayToRelayPingReply = 23,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_P2PSessionRequest)
    k_ESteamDatagramMsg_P2PSessionRequest = 24,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_P2PSessionEstablished)
    k_ESteamDatagramMsg_P2PSessionEstablished = 25,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESteamDatagramMsgID {
    const NAME: &'static str = "ESteamDatagramMsgID";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDatagramMsgID> {
        match value {
            0 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid),
            1 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest),
            2 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply),
            3 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest),
            4 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply),
            5 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest),
            6 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished),
            7 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession),
            8 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic),
            9 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter),
            10 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer),
            11 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter),
            12 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient),
            13 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats),
            14 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest),
            15 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply),
            16 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary),
            17 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth),
            18 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest),
            19 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK),
            20 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed),
            21 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection),
            22 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest),
            23 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply),
            24 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest),
            25 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDatagramMsgID> {
        match str {
            "k_ESteamDatagramMsg_Invalid" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid),
            "k_ESteamDatagramMsg_RouterPingRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest),
            "k_ESteamDatagramMsg_RouterPingReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply),
            "k_ESteamDatagramMsg_GameserverPingRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest),
            "k_ESteamDatagramMsg_GameserverPingReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply),
            "k_ESteamDatagramMsg_GameserverSessionRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest),
            "k_ESteamDatagramMsg_GameserverSessionEstablished" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished),
            "k_ESteamDatagramMsg_NoSession" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession),
            "k_ESteamDatagramMsg_Diagnostic" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic),
            "k_ESteamDatagramMsg_DataClientToRouter" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter),
            "k_ESteamDatagramMsg_DataRouterToServer" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer),
            "k_ESteamDatagramMsg_DataServerToRouter" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter),
            "k_ESteamDatagramMsg_DataRouterToClient" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient),
            "k_ESteamDatagramMsg_Stats" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats),
            "k_ESteamDatagramMsg_ClientPingSampleRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest),
            "k_ESteamDatagramMsg_ClientPingSampleReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply),
            "k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary),
            "k_ESteamDatagramMsg_RelayHealth" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth),
            "k_ESteamDatagramMsg_ConnectRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest),
            "k_ESteamDatagramMsg_ConnectOK" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK),
            "k_ESteamDatagramMsg_ConnectionClosed" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed),
            "k_ESteamDatagramMsg_NoConnection" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection),
            "k_ESteamDatagramMsg_RelayToRelayPingRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest),
            "k_ESteamDatagramMsg_RelayToRelayPingReply" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply),
            "k_ESteamDatagramMsg_P2PSessionRequest" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest),
            "k_ESteamDatagramMsg_P2PSessionEstablished" => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDatagramMsgID] = &[
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished,
    ];
}

impl ::std::default::Default for ESteamDatagramMsgID {
    fn default() -> Self {
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamNetworkingUDPMsgID)
pub enum ESteamNetworkingUDPMsgID {
    // @@protoc_insertion_point(enum_value:ESteamNetworkingUDPMsgID.k_ESteamNetworkingUDPMsg_ChallengeRequest)
    k_ESteamNetworkingUDPMsg_ChallengeRequest = 32,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingUDPMsgID.k_ESteamNetworkingUDPMsg_ChallengeReply)
    k_ESteamNetworkingUDPMsg_ChallengeReply = 33,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingUDPMsgID.k_ESteamNetworkingUDPMsg_ConnectRequest)
    k_ESteamNetworkingUDPMsg_ConnectRequest = 34,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingUDPMsgID.k_ESteamNetworkingUDPMsg_ConnectOK)
    k_ESteamNetworkingUDPMsg_ConnectOK = 35,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingUDPMsgID.k_ESteamNetworkingUDPMsg_ConnectionClosed)
    k_ESteamNetworkingUDPMsg_ConnectionClosed = 36,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingUDPMsgID.k_ESteamNetworkingUDPMsg_NoConnection)
    k_ESteamNetworkingUDPMsg_NoConnection = 37,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingUDPMsgID.k_ESteamNetworkingUDPMsg_Stats)
    k_ESteamNetworkingUDPMsg_Stats = 38,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESteamNetworkingUDPMsgID {
    const NAME: &'static str = "ESteamNetworkingUDPMsgID";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamNetworkingUDPMsgID> {
        match value {
            32 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeRequest),
            33 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeReply),
            34 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectRequest),
            35 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectOK),
            36 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectionClosed),
            37 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_NoConnection),
            38 => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_Stats),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamNetworkingUDPMsgID> {
        match str {
            "k_ESteamNetworkingUDPMsg_ChallengeRequest" => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeRequest),
            "k_ESteamNetworkingUDPMsg_ChallengeReply" => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeReply),
            "k_ESteamNetworkingUDPMsg_ConnectRequest" => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectRequest),
            "k_ESteamNetworkingUDPMsg_ConnectOK" => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectOK),
            "k_ESteamNetworkingUDPMsg_ConnectionClosed" => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectionClosed),
            "k_ESteamNetworkingUDPMsg_NoConnection" => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_NoConnection),
            "k_ESteamNetworkingUDPMsg_Stats" => ::std::option::Option::Some(ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_Stats),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamNetworkingUDPMsgID] = &[
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeRequest,
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeReply,
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectRequest,
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectOK,
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ConnectionClosed,
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_NoConnection,
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_Stats,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESteamNetworkingUDPMsgID {
    fn default() -> Self {
        ESteamNetworkingUDPMsgID::k_ESteamNetworkingUDPMsg_ChallengeRequest
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steamdatagram_auth_messages::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramRouterPingReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramGameserverPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramRelayToRelayPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramSessionCryptInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramSessionCryptInfoSigned {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramGameserverSessionRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramGameserverSessionEstablished {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramNoSessionRelayToClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramNoSessionRelayToServer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramDiagnostic {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramDataCenterState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramLinkInstantaneousStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramLinkLifetimeStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramConnectionQuality {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramClientPingSampleRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramClientPingSampleReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramClientSwitchedPrimary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramRouterHealth {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramConnectRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramConnectOK {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramConnectionClosed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramNoConnection {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramP2PSessionRequestBody {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramP2PSessionRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramP2PSessionEstablished {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramP2PRoutes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamDatagramP2PRendezvous {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamSockets_UDP_ChallengeRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamSockets_UDP_ChallengeReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamSockets_UDP_ConnectRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamSockets_UDP_ConnectOK {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamSockets_UDP_ConnectionClosed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamSockets_UDP_NoConnection {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamSockets_UDP_Stats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
