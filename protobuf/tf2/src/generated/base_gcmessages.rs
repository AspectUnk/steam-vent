// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `base_gcmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CGCStorePurchaseInit_LineItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCStorePurchaseInit_LineItem {
    // message fields
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.cost_in_local_currency)
    pub cost_in_local_currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.purchase_type)
    pub purchase_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCStorePurchaseInit_LineItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCStorePurchaseInit_LineItem {
    fn default() -> &'a CGCStorePurchaseInit_LineItem {
        <CGCStorePurchaseInit_LineItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCStorePurchaseInit_LineItem {
    pub fn new() -> CGCStorePurchaseInit_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 cost_in_local_currency = 3;

    pub fn cost_in_local_currency(&self) -> u32 {
        self.cost_in_local_currency.unwrap_or(0)
    }

    pub fn clear_cost_in_local_currency(&mut self) {
        self.cost_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_cost_in_local_currency(&self) -> bool {
        self.cost_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_in_local_currency(&mut self, v: u32) {
        self.cost_in_local_currency = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_type = 4;

    pub fn purchase_type(&self) -> u32 {
        self.purchase_type.unwrap_or(0)
    }

    pub fn clear_purchase_type(&mut self) {
        self.purchase_type = ::std::option::Option::None;
    }

    pub fn has_purchase_type(&self) -> bool {
        self.purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_type(&mut self, v: u32) {
        self.purchase_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCStorePurchaseInit_LineItem {
    const NAME: &'static str = "CGCStorePurchaseInit_LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cost_in_local_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.purchase_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cost_in_local_currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.purchase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cost_in_local_currency {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.purchase_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCStorePurchaseInit_LineItem {
        CGCStorePurchaseInit_LineItem::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.cost_in_local_currency = ::std::option::Option::None;
        self.purchase_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCStorePurchaseInit_LineItem {
        static instance: CGCStorePurchaseInit_LineItem = CGCStorePurchaseInit_LineItem {
            item_def_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            cost_in_local_currency: ::std::option::Option::None,
            purchase_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseInit {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.line_items)
    pub line_items: ::std::vec::Vec<CGCStorePurchaseInit_LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInit {
    fn default() -> &'a CMsgGCStorePurchaseInit {
        <CMsgGCStorePurchaseInit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInit {
    pub fn new() -> CMsgGCStorePurchaseInit {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseInit {
    const NAME: &'static str = "CMsgGCStorePurchaseInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        for v in &self.line_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInit {
        CMsgGCStorePurchaseInit::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInit {
        static instance: CMsgGCStorePurchaseInit = CMsgGCStorePurchaseInit {
            country: ::std::option::Option::None,
            language: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseInitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseInitResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInitResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInitResponse {
    fn default() -> &'a CMsgGCStorePurchaseInitResponse {
        <CMsgGCStorePurchaseInitResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInitResponse {
    pub fn new() -> CMsgGCStorePurchaseInitResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_id = 2;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseInitResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseInitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.txn_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInitResponse {
        CMsgGCStorePurchaseInitResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInitResponse {
        static instance: CMsgGCStorePurchaseInitResponse = CMsgGCStorePurchaseInitResponse {
            result: ::std::option::Option::None,
            txn_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSystemBroadcast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSystemBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemBroadcast.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemBroadcast.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemBroadcast {
    fn default() -> &'a CMsgSystemBroadcast {
        <CMsgSystemBroadcast as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemBroadcast {
    pub fn new() -> CMsgSystemBroadcast {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSystemBroadcast {
    const NAME: &'static str = "CMsgSystemBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemBroadcast {
        CMsgSystemBroadcast::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemBroadcast {
        static instance: CMsgSystemBroadcast = CMsgSystemBroadcast {
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientHello.version)
    pub version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientHello.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHello {
    fn default() -> &'a CMsgClientHello {
        <CMsgClientHello as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHello {
    pub fn new() -> CMsgClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientHello {
    const NAME: &'static str = "CMsgClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHello {
        CMsgClientHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHello {
        static instance: CMsgClientHello = CMsgClientHello {
            version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerHello.version)
    pub version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerHello.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerHello {
    fn default() -> &'a CMsgServerHello {
        <CMsgServerHello as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerHello {
    pub fn new() -> CMsgServerHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerHello {
    const NAME: &'static str = "CMsgServerHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerHello {
        CMsgServerHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerHello {
        static instance: CMsgServerHello = CMsgServerHello {
            version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWelcome.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data)
    pub game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.txn_country_code)
    pub txn_country_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWelcome.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWelcome {
    fn default() -> &'a CMsgClientWelcome {
        <CMsgClientWelcome as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWelcome {
    pub fn new() -> CMsgClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;

    pub fn game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string txn_country_code = 3;

    pub fn txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code = ::std::option::Option::None;
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientWelcome {
    const NAME: &'static str = "CMsgClientWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.txn_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWelcome {
        CMsgClientWelcome::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.txn_country_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWelcome {
        static instance: CMsgClientWelcome = CMsgClientWelcome {
            version: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            txn_country_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerWelcome.min_allowed_version)
    pub min_allowed_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerWelcome.active_version)
    pub active_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerWelcome.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerWelcome {
    fn default() -> &'a CMsgServerWelcome {
        <CMsgServerWelcome as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerWelcome {
    pub fn new() -> CMsgServerWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 min_allowed_version = 1;

    pub fn min_allowed_version(&self) -> u32 {
        self.min_allowed_version.unwrap_or(0)
    }

    pub fn clear_min_allowed_version(&mut self) {
        self.min_allowed_version = ::std::option::Option::None;
    }

    pub fn has_min_allowed_version(&self) -> bool {
        self.min_allowed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_allowed_version(&mut self, v: u32) {
        self.min_allowed_version = ::std::option::Option::Some(v);
    }

    // optional uint32 active_version = 2;

    pub fn active_version(&self) -> u32 {
        self.active_version.unwrap_or(0)
    }

    pub fn clear_active_version(&mut self) {
        self.active_version = ::std::option::Option::None;
    }

    pub fn has_active_version(&self) -> bool {
        self.active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_version(&mut self, v: u32) {
        self.active_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerWelcome {
    const NAME: &'static str = "CMsgServerWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.min_allowed_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.active_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.min_allowed_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.active_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.min_allowed_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.active_version {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerWelcome {
        CMsgServerWelcome::new()
    }

    fn clear(&mut self) {
        self.min_allowed_version = ::std::option::Option::None;
        self.active_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerWelcome {
        static instance: CMsgServerWelcome = CMsgServerWelcome {
            min_allowed_version: ::std::option::Option::None,
            active_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientGoodbye)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientGoodbye {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGoodbye.reason)
    pub reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<GCGoodbyeReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGoodbye.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGoodbye {
    fn default() -> &'a CMsgClientGoodbye {
        <CMsgClientGoodbye as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGoodbye {
    pub fn new() -> CMsgClientGoodbye {
        ::std::default::Default::default()
    }

    // optional .GCGoodbyeReason reason = 1;

    pub fn reason(&self) -> GCGoodbyeReason {
        match self.reason {
            Some(e) => e.enum_value_or(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            None => GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: GCGoodbyeReason) {
        self.reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientGoodbye {
    const NAME: &'static str = "CMsgClientGoodbye";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGoodbye {
        CMsgClientGoodbye::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGoodbye {
        static instance: CMsgClientGoodbye = CMsgClientGoodbye {
            reason: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerGoodbye)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerGoodbye {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerGoodbye.reason)
    pub reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<GCGoodbyeReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerGoodbye.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerGoodbye {
    fn default() -> &'a CMsgServerGoodbye {
        <CMsgServerGoodbye as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerGoodbye {
    pub fn new() -> CMsgServerGoodbye {
        ::std::default::Default::default()
    }

    // optional .GCGoodbyeReason reason = 1;

    pub fn reason(&self) -> GCGoodbyeReason {
        match self.reason {
            Some(e) => e.enum_value_or(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            None => GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: GCGoodbyeReason) {
        self.reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerGoodbye {
    const NAME: &'static str = "CMsgServerGoodbye";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerGoodbye {
        CMsgServerGoodbye::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerGoodbye {
        static instance: CMsgServerGoodbye = CMsgServerGoodbye {
            reason: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerAvailable {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerAvailable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerAvailable {
    fn default() -> &'a CMsgServerAvailable {
        <CMsgServerAvailable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerAvailable {
    pub fn new() -> CMsgServerAvailable {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerAvailable {
    const NAME: &'static str = "CMsgServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerAvailable {
        CMsgServerAvailable::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerAvailable {
        static instance: CMsgServerAvailable = CMsgServerAvailable {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLANServerAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLANServerAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgLANServerAvailable.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLANServerAvailable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLANServerAvailable {
    fn default() -> &'a CMsgLANServerAvailable {
        <CMsgLANServerAvailable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLANServerAvailable {
    pub fn new() -> CMsgLANServerAvailable {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLANServerAvailable {
    const NAME: &'static str = "CMsgLANServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLANServerAvailable {
        CMsgLANServerAvailable::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLANServerAvailable {
        static instance: CMsgLANServerAvailable = CMsgLANServerAvailable {
            lobby_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconGameAccountClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconGameAccountClient {
    // message fields
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.additional_backpack_slots)
    pub additional_backpack_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.trial_account)
    pub trial_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.need_to_choose_most_helpful_friend)
    pub need_to_choose_most_helpful_friend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.in_coaches_list)
    pub in_coaches_list: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.trade_ban_expiration)
    pub trade_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.duel_ban_expiration)
    pub duel_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.preview_item_def)
    pub preview_item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.phone_verified)
    pub phone_verified: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.skill_rating_6v6)
    pub skill_rating_6v6: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.skill_rating_9v9)
    pub skill_rating_9v9: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.competitive_access)
    pub competitive_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_ban_expiration)
    pub matchmaking_ranked_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_low_priority_expiration)
    pub matchmaking_ranked_low_priority_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_ban_last_duration)
    pub matchmaking_ranked_ban_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_low_priority_last_duration)
    pub matchmaking_ranked_low_priority_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_ban_expiration)
    pub matchmaking_casual_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_low_priority_expiration)
    pub matchmaking_casual_low_priority_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_ban_last_duration)
    pub matchmaking_casual_ban_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_low_priority_last_duration)
    pub matchmaking_casual_low_priority_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.phone_identifying)
    pub phone_identifying: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.disable_party_quest_progress)
    pub disable_party_quest_progress: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.quest_reward_credits)
    pub quest_reward_credits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_last_casual_excessive_reports_auto_ban_time)
    pub matchmaking_last_casual_excessive_reports_auto_ban_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_last_comp_excessive_reports_auto_ban_time)
    pub matchmaking_last_comp_excessive_reports_auto_ban_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconGameAccountClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountClient {
    fn default() -> &'a CSOEconGameAccountClient {
        <CSOEconGameAccountClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountClient {
    pub fn new() -> CSOEconGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 additional_backpack_slots = 1;

    pub fn additional_backpack_slots(&self) -> u32 {
        self.additional_backpack_slots.unwrap_or(0u32)
    }

    pub fn clear_additional_backpack_slots(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
    }

    pub fn has_additional_backpack_slots(&self) -> bool {
        self.additional_backpack_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_backpack_slots(&mut self, v: u32) {
        self.additional_backpack_slots = ::std::option::Option::Some(v);
    }

    // optional bool trial_account = 2;

    pub fn trial_account(&self) -> bool {
        self.trial_account.unwrap_or(false)
    }

    pub fn clear_trial_account(&mut self) {
        self.trial_account = ::std::option::Option::None;
    }

    pub fn has_trial_account(&self) -> bool {
        self.trial_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trial_account(&mut self, v: bool) {
        self.trial_account = ::std::option::Option::Some(v);
    }

    // optional bool need_to_choose_most_helpful_friend = 4;

    pub fn need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.unwrap_or(false)
    }

    pub fn clear_need_to_choose_most_helpful_friend(&mut self) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
    }

    pub fn has_need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_to_choose_most_helpful_friend(&mut self, v: bool) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(v);
    }

    // optional bool in_coaches_list = 5;

    pub fn in_coaches_list(&self) -> bool {
        self.in_coaches_list.unwrap_or(false)
    }

    pub fn clear_in_coaches_list(&mut self) {
        self.in_coaches_list = ::std::option::Option::None;
    }

    pub fn has_in_coaches_list(&self) -> bool {
        self.in_coaches_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_coaches_list(&mut self, v: bool) {
        self.in_coaches_list = ::std::option::Option::Some(v);
    }

    // optional fixed32 trade_ban_expiration = 6;

    pub fn trade_ban_expiration(&self) -> u32 {
        self.trade_ban_expiration.unwrap_or(0)
    }

    pub fn clear_trade_ban_expiration(&mut self) {
        self.trade_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_trade_ban_expiration(&self) -> bool {
        self.trade_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_ban_expiration(&mut self, v: u32) {
        self.trade_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional fixed32 duel_ban_expiration = 7;

    pub fn duel_ban_expiration(&self) -> u32 {
        self.duel_ban_expiration.unwrap_or(0)
    }

    pub fn clear_duel_ban_expiration(&mut self) {
        self.duel_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_duel_ban_expiration(&self) -> bool {
        self.duel_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_ban_expiration(&mut self, v: u32) {
        self.duel_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 preview_item_def = 8;

    pub fn preview_item_def(&self) -> u32 {
        self.preview_item_def.unwrap_or(0u32)
    }

    pub fn clear_preview_item_def(&mut self) {
        self.preview_item_def = ::std::option::Option::None;
    }

    pub fn has_preview_item_def(&self) -> bool {
        self.preview_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_item_def(&mut self, v: u32) {
        self.preview_item_def = ::std::option::Option::Some(v);
    }

    // optional bool phone_verified = 19;

    pub fn phone_verified(&self) -> bool {
        self.phone_verified.unwrap_or(false)
    }

    pub fn clear_phone_verified(&mut self) {
        self.phone_verified = ::std::option::Option::None;
    }

    pub fn has_phone_verified(&self) -> bool {
        self.phone_verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone_verified(&mut self, v: bool) {
        self.phone_verified = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_rating_6v6 = 20;

    pub fn skill_rating_6v6(&self) -> u32 {
        self.skill_rating_6v6.unwrap_or(0)
    }

    pub fn clear_skill_rating_6v6(&mut self) {
        self.skill_rating_6v6 = ::std::option::Option::None;
    }

    pub fn has_skill_rating_6v6(&self) -> bool {
        self.skill_rating_6v6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_rating_6v6(&mut self, v: u32) {
        self.skill_rating_6v6 = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_rating_9v9 = 21;

    pub fn skill_rating_9v9(&self) -> u32 {
        self.skill_rating_9v9.unwrap_or(0)
    }

    pub fn clear_skill_rating_9v9(&mut self) {
        self.skill_rating_9v9 = ::std::option::Option::None;
    }

    pub fn has_skill_rating_9v9(&self) -> bool {
        self.skill_rating_9v9.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_rating_9v9(&mut self, v: u32) {
        self.skill_rating_9v9 = ::std::option::Option::Some(v);
    }

    // optional bool competitive_access = 23;

    pub fn competitive_access(&self) -> bool {
        self.competitive_access.unwrap_or(false)
    }

    pub fn clear_competitive_access(&mut self) {
        self.competitive_access = ::std::option::Option::None;
    }

    pub fn has_competitive_access(&self) -> bool {
        self.competitive_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_access(&mut self, v: bool) {
        self.competitive_access = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_ban_expiration = 18;

    pub fn matchmaking_ranked_ban_expiration(&self) -> u32 {
        self.matchmaking_ranked_ban_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_ban_expiration(&mut self) {
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_ban_expiration(&self) -> bool {
        self.matchmaking_ranked_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_ban_expiration(&mut self, v: u32) {
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_low_priority_expiration = 24;

    pub fn matchmaking_ranked_low_priority_expiration(&self) -> u32 {
        self.matchmaking_ranked_low_priority_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_low_priority_expiration(&mut self) {
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_low_priority_expiration(&self) -> bool {
        self.matchmaking_ranked_low_priority_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_low_priority_expiration(&mut self, v: u32) {
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_ban_last_duration = 25;

    pub fn matchmaking_ranked_ban_last_duration(&self) -> u32 {
        self.matchmaking_ranked_ban_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_ban_last_duration(&mut self) {
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_ban_last_duration(&self) -> bool {
        self.matchmaking_ranked_ban_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_ban_last_duration(&mut self, v: u32) {
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_low_priority_last_duration = 26;

    pub fn matchmaking_ranked_low_priority_last_duration(&self) -> u32 {
        self.matchmaking_ranked_low_priority_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_low_priority_last_duration(&mut self) {
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_low_priority_last_duration(&self) -> bool {
        self.matchmaking_ranked_low_priority_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_low_priority_last_duration(&mut self, v: u32) {
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_ban_expiration = 27;

    pub fn matchmaking_casual_ban_expiration(&self) -> u32 {
        self.matchmaking_casual_ban_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_ban_expiration(&mut self) {
        self.matchmaking_casual_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_ban_expiration(&self) -> bool {
        self.matchmaking_casual_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_ban_expiration(&mut self, v: u32) {
        self.matchmaking_casual_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_low_priority_expiration = 28;

    pub fn matchmaking_casual_low_priority_expiration(&self) -> u32 {
        self.matchmaking_casual_low_priority_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_low_priority_expiration(&mut self) {
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_low_priority_expiration(&self) -> bool {
        self.matchmaking_casual_low_priority_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_low_priority_expiration(&mut self, v: u32) {
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_ban_last_duration = 29;

    pub fn matchmaking_casual_ban_last_duration(&self) -> u32 {
        self.matchmaking_casual_ban_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_ban_last_duration(&mut self) {
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_ban_last_duration(&self) -> bool {
        self.matchmaking_casual_ban_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_ban_last_duration(&mut self, v: u32) {
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_low_priority_last_duration = 30;

    pub fn matchmaking_casual_low_priority_last_duration(&self) -> u32 {
        self.matchmaking_casual_low_priority_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_low_priority_last_duration(&mut self) {
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_low_priority_last_duration(&self) -> bool {
        self.matchmaking_casual_low_priority_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_low_priority_last_duration(&mut self, v: u32) {
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::Some(v);
    }

    // optional bool phone_identifying = 31;

    pub fn phone_identifying(&self) -> bool {
        self.phone_identifying.unwrap_or(false)
    }

    pub fn clear_phone_identifying(&mut self) {
        self.phone_identifying = ::std::option::Option::None;
    }

    pub fn has_phone_identifying(&self) -> bool {
        self.phone_identifying.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone_identifying(&mut self, v: bool) {
        self.phone_identifying = ::std::option::Option::Some(v);
    }

    // optional bool disable_party_quest_progress = 32;

    pub fn disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.unwrap_or(false)
    }

    pub fn clear_disable_party_quest_progress(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
    }

    pub fn has_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_party_quest_progress(&mut self, v: bool) {
        self.disable_party_quest_progress = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_reward_credits = 33;

    pub fn quest_reward_credits(&self) -> u32 {
        self.quest_reward_credits.unwrap_or(0)
    }

    pub fn clear_quest_reward_credits(&mut self) {
        self.quest_reward_credits = ::std::option::Option::None;
    }

    pub fn has_quest_reward_credits(&self) -> bool {
        self.quest_reward_credits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_reward_credits(&mut self, v: u32) {
        self.quest_reward_credits = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_last_casual_excessive_reports_auto_ban_time = 34;

    pub fn matchmaking_last_casual_excessive_reports_auto_ban_time(&self) -> u32 {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time.unwrap_or(0)
    }

    pub fn clear_matchmaking_last_casual_excessive_reports_auto_ban_time(&mut self) {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::None;
    }

    pub fn has_matchmaking_last_casual_excessive_reports_auto_ban_time(&self) -> bool {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_last_casual_excessive_reports_auto_ban_time(&mut self, v: u32) {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_last_comp_excessive_reports_auto_ban_time = 35;

    pub fn matchmaking_last_comp_excessive_reports_auto_ban_time(&self) -> u32 {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time.unwrap_or(0)
    }

    pub fn clear_matchmaking_last_comp_excessive_reports_auto_ban_time(&mut self) {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::None;
    }

    pub fn has_matchmaking_last_comp_excessive_reports_auto_ban_time(&self) -> bool {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_last_comp_excessive_reports_auto_ban_time(&mut self, v: u32) {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconGameAccountClient {
    const NAME: &'static str = "CSOEconGameAccountClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_backpack_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trial_account = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.in_coaches_list = ::std::option::Option::Some(is.read_bool()?);
                },
                53 => {
                    self.trade_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.duel_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                64 => {
                    self.preview_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.phone_verified = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.skill_rating_6v6 = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.skill_rating_9v9 = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.competitive_access = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.matchmaking_ranked_ban_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.matchmaking_ranked_ban_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.matchmaking_casual_ban_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.matchmaking_casual_low_priority_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.matchmaking_casual_ban_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.phone_identifying = ::std::option::Option::Some(is.read_bool()?);
                },
                256 => {
                    self.disable_party_quest_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                264 => {
                    self.quest_reward_credits = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_backpack_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trial_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.in_coaches_list {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trade_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duel_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.preview_item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.phone_verified {
            my_size += 2 + 1;
        }
        if let Some(v) = self.skill_rating_6v6 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.skill_rating_9v9 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.competitive_access {
            my_size += 2 + 1;
        }
        if let Some(v) = self.matchmaking_ranked_ban_expiration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_expiration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.matchmaking_ranked_ban_last_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_last_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.matchmaking_casual_ban_expiration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.matchmaking_casual_low_priority_expiration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.matchmaking_casual_ban_last_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.matchmaking_casual_low_priority_last_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.phone_identifying {
            my_size += 2 + 1;
        }
        if let Some(v) = self.disable_party_quest_progress {
            my_size += 2 + 1;
        }
        if let Some(v) = self.quest_reward_credits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.matchmaking_last_casual_excessive_reports_auto_ban_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.matchmaking_last_comp_excessive_reports_auto_ban_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.additional_backpack_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trial_account {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.in_coaches_list {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.trade_ban_expiration {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.duel_ban_expiration {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.preview_item_def {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.phone_verified {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.skill_rating_6v6 {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.skill_rating_9v9 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.competitive_access {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_ban_expiration {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_expiration {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_ban_last_duration {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_last_duration {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.matchmaking_casual_ban_expiration {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.matchmaking_casual_low_priority_expiration {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.matchmaking_casual_ban_last_duration {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.matchmaking_casual_low_priority_last_duration {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.phone_identifying {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.disable_party_quest_progress {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.quest_reward_credits {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.matchmaking_last_casual_excessive_reports_auto_ban_time {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.matchmaking_last_comp_excessive_reports_auto_ban_time {
            os.write_uint32(35, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconGameAccountClient {
        CSOEconGameAccountClient::new()
    }

    fn clear(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
        self.trial_account = ::std::option::Option::None;
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
        self.in_coaches_list = ::std::option::Option::None;
        self.trade_ban_expiration = ::std::option::Option::None;
        self.duel_ban_expiration = ::std::option::Option::None;
        self.preview_item_def = ::std::option::Option::None;
        self.phone_verified = ::std::option::Option::None;
        self.skill_rating_6v6 = ::std::option::Option::None;
        self.skill_rating_9v9 = ::std::option::Option::None;
        self.competitive_access = ::std::option::Option::None;
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::None;
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::None;
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::None;
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::None;
        self.matchmaking_casual_ban_expiration = ::std::option::Option::None;
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::None;
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::None;
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::None;
        self.phone_identifying = ::std::option::Option::None;
        self.disable_party_quest_progress = ::std::option::Option::None;
        self.quest_reward_credits = ::std::option::Option::None;
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::None;
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconGameAccountClient {
        static instance: CSOEconGameAccountClient = CSOEconGameAccountClient {
            additional_backpack_slots: ::std::option::Option::None,
            trial_account: ::std::option::Option::None,
            need_to_choose_most_helpful_friend: ::std::option::Option::None,
            in_coaches_list: ::std::option::Option::None,
            trade_ban_expiration: ::std::option::Option::None,
            duel_ban_expiration: ::std::option::Option::None,
            preview_item_def: ::std::option::Option::None,
            phone_verified: ::std::option::Option::None,
            skill_rating_6v6: ::std::option::Option::None,
            skill_rating_9v9: ::std::option::Option::None,
            competitive_access: ::std::option::Option::None,
            matchmaking_ranked_ban_expiration: ::std::option::Option::None,
            matchmaking_ranked_low_priority_expiration: ::std::option::Option::None,
            matchmaking_ranked_ban_last_duration: ::std::option::Option::None,
            matchmaking_ranked_low_priority_last_duration: ::std::option::Option::None,
            matchmaking_casual_ban_expiration: ::std::option::Option::None,
            matchmaking_casual_low_priority_expiration: ::std::option::Option::None,
            matchmaking_casual_ban_last_duration: ::std::option::Option::None,
            matchmaking_casual_low_priority_last_duration: ::std::option::Option::None,
            phone_identifying: ::std::option::Option::None,
            disable_party_quest_progress: ::std::option::Option::None,
            quest_reward_credits: ::std::option::Option::None,
            matchmaking_last_casual_excessive_reports_auto_ban_time: ::std::option::Option::None,
            matchmaking_last_comp_excessive_reports_auto_ban_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOItemCriteriaCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOItemCriteriaCondition {
    // message fields
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.op)
    pub op: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.field)
    pub field: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.required)
    pub required: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.float_value)
    pub float_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemCriteriaCondition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteriaCondition {
    fn default() -> &'a CSOItemCriteriaCondition {
        <CSOItemCriteriaCondition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteriaCondition {
    pub fn new() -> CSOItemCriteriaCondition {
        ::std::default::Default::default()
    }

    // optional int32 op = 1;

    pub fn op(&self) -> i32 {
        self.op.unwrap_or(0)
    }

    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: i32) {
        self.op = ::std::option::Option::Some(v);
    }

    // optional string field = 2;

    pub fn field(&self) -> &str {
        match self.field.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_field(&mut self) {
        self.field = ::std::option::Option::None;
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        if self.field.is_none() {
            self.field = ::std::option::Option::Some(::std::string::String::new());
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        self.field.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool required = 3;

    pub fn required(&self) -> bool {
        self.required.unwrap_or(false)
    }

    pub fn clear_required(&mut self) {
        self.required = ::std::option::Option::None;
    }

    pub fn has_required(&self) -> bool {
        self.required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: bool) {
        self.required = ::std::option::Option::Some(v);
    }

    // optional float float_value = 4;

    pub fn float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }

    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOItemCriteriaCondition {
    const NAME: &'static str = "CSOItemCriteriaCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.op = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.field = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.required = ::std::option::Option::Some(is.read_bool()?);
                },
                37 => {
                    self.float_value = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.field.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.required {
            my_size += 1 + 1;
        }
        if let Some(v) = self.float_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.op {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.field.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemCriteriaCondition {
        CSOItemCriteriaCondition::new()
    }

    fn clear(&mut self) {
        self.op = ::std::option::Option::None;
        self.field = ::std::option::Option::None;
        self.required = ::std::option::Option::None;
        self.float_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemCriteriaCondition {
        static instance: CSOItemCriteriaCondition = CSOItemCriteriaCondition {
            op: ::std::option::Option::None,
            field: ::std::option::Option::None,
            required: ::std::option::Option::None,
            float_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOItemCriteria)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOItemCriteria {
    // message fields
    // @@protoc_insertion_point(field:CSOItemCriteria.item_level)
    pub item_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_quality)
    pub item_quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_level_set)
    pub item_level_set: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_quality_set)
    pub item_quality_set: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.initial_inventory)
    pub initial_inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.initial_quantity)
    pub initial_quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.ignore_enabled_flag)
    pub ignore_enabled_flag: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.conditions)
    pub conditions: ::std::vec::Vec<CSOItemCriteriaCondition>,
    // @@protoc_insertion_point(field:CSOItemCriteria.recent_only)
    pub recent_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.tags)
    pub tags: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemCriteria.equip_regions)
    pub equip_regions: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemCriteria.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteria {
    fn default() -> &'a CSOItemCriteria {
        <CSOItemCriteria as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteria {
    pub fn new() -> CSOItemCriteria {
        ::std::default::Default::default()
    }

    // optional uint32 item_level = 1;

    pub fn item_level(&self) -> u32 {
        self.item_level.unwrap_or(0)
    }

    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: u32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 item_quality = 2;

    pub fn item_quality(&self) -> i32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: i32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional bool item_level_set = 3;

    pub fn item_level_set(&self) -> bool {
        self.item_level_set.unwrap_or(false)
    }

    pub fn clear_item_level_set(&mut self) {
        self.item_level_set = ::std::option::Option::None;
    }

    pub fn has_item_level_set(&self) -> bool {
        self.item_level_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level_set(&mut self, v: bool) {
        self.item_level_set = ::std::option::Option::Some(v);
    }

    // optional bool item_quality_set = 4;

    pub fn item_quality_set(&self) -> bool {
        self.item_quality_set.unwrap_or(false)
    }

    pub fn clear_item_quality_set(&mut self) {
        self.item_quality_set = ::std::option::Option::None;
    }

    pub fn has_item_quality_set(&self) -> bool {
        self.item_quality_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality_set(&mut self, v: bool) {
        self.item_quality_set = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_inventory = 5;

    pub fn initial_inventory(&self) -> u32 {
        self.initial_inventory.unwrap_or(0)
    }

    pub fn clear_initial_inventory(&mut self) {
        self.initial_inventory = ::std::option::Option::None;
    }

    pub fn has_initial_inventory(&self) -> bool {
        self.initial_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_inventory(&mut self, v: u32) {
        self.initial_inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_quantity = 6;

    pub fn initial_quantity(&self) -> u32 {
        self.initial_quantity.unwrap_or(0)
    }

    pub fn clear_initial_quantity(&mut self) {
        self.initial_quantity = ::std::option::Option::None;
    }

    pub fn has_initial_quantity(&self) -> bool {
        self.initial_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_quantity(&mut self, v: u32) {
        self.initial_quantity = ::std::option::Option::Some(v);
    }

    // optional bool ignore_enabled_flag = 8;

    pub fn ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.unwrap_or(false)
    }

    pub fn clear_ignore_enabled_flag(&mut self) {
        self.ignore_enabled_flag = ::std::option::Option::None;
    }

    pub fn has_ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_enabled_flag(&mut self, v: bool) {
        self.ignore_enabled_flag = ::std::option::Option::Some(v);
    }

    // optional bool recent_only = 10;

    pub fn recent_only(&self) -> bool {
        self.recent_only.unwrap_or(false)
    }

    pub fn clear_recent_only(&mut self) {
        self.recent_only = ::std::option::Option::None;
    }

    pub fn has_recent_only(&self) -> bool {
        self.recent_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_only(&mut self, v: bool) {
        self.recent_only = ::std::option::Option::Some(v);
    }

    // optional string tags = 11;

    pub fn tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tags(&mut self) {
        self.tags = ::std::option::Option::None;
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string equip_regions = 12;

    pub fn equip_regions(&self) -> &str {
        match self.equip_regions.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_equip_regions(&mut self) {
        self.equip_regions = ::std::option::Option::None;
    }

    pub fn has_equip_regions(&self) -> bool {
        self.equip_regions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equip_regions(&mut self, v: ::std::string::String) {
        self.equip_regions = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_equip_regions(&mut self) -> &mut ::std::string::String {
        if self.equip_regions.is_none() {
            self.equip_regions = ::std::option::Option::Some(::std::string::String::new());
        }
        self.equip_regions.as_mut().unwrap()
    }

    // Take field
    pub fn take_equip_regions(&mut self) -> ::std::string::String {
        self.equip_regions.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOItemCriteria {
    const NAME: &'static str = "CSOItemCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_level_set = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.item_quality_set = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.initial_inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.initial_quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.ignore_enabled_flag = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.conditions.push(is.read_message()?);
                },
                80 => {
                    self.recent_only = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.tags = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.equip_regions = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_level_set {
            my_size += 1 + 1;
        }
        if let Some(v) = self.item_quality_set {
            my_size += 1 + 1;
        }
        if let Some(v) = self.initial_inventory {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.initial_quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ignore_enabled_flag {
            my_size += 1 + 1;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.recent_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tags.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.equip_regions.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(12, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_level {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_level_set {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.item_quality_set {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.initial_inventory {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.initial_quantity {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ignore_enabled_flag {
            os.write_bool(8, v)?;
        }
        for v in &self.conditions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.recent_only {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.tags.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.equip_regions.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemCriteria {
        CSOItemCriteria::new()
    }

    fn clear(&mut self) {
        self.item_level = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_level_set = ::std::option::Option::None;
        self.item_quality_set = ::std::option::Option::None;
        self.initial_inventory = ::std::option::Option::None;
        self.initial_quantity = ::std::option::Option::None;
        self.ignore_enabled_flag = ::std::option::Option::None;
        self.conditions.clear();
        self.recent_only = ::std::option::Option::None;
        self.tags = ::std::option::Option::None;
        self.equip_regions = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemCriteria {
        static instance: CSOItemCriteria = CSOItemCriteria {
            item_level: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            item_level_set: ::std::option::Option::None,
            item_quality_set: ::std::option::Option::None,
            initial_inventory: ::std::option::Option::None,
            initial_quantity: ::std::option::Option::None,
            ignore_enabled_flag: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            recent_only: ::std::option::Option::None,
            tags: ::std::option::Option::None,
            equip_regions: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOItemRecipe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOItemRecipe {
    // message fields
    // @@protoc_insertion_point(field:CSOItemRecipe.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.n_a)
    pub n_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.desc_inputs)
    pub desc_inputs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.desc_outputs)
    pub desc_outputs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_a)
    pub di_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_b)
    pub di_b: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_c)
    pub di_c: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_a)
    pub do_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_b)
    pub do_b: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_c)
    pub do_c: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.requires_all_same_class)
    pub requires_all_same_class: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemRecipe.requires_all_same_slot)
    pub requires_all_same_slot: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemRecipe.class_usage_for_output)
    pub class_usage_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.slot_usage_for_output)
    pub slot_usage_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.set_for_output)
    pub set_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.input_items_criteria)
    pub input_items_criteria: ::std::vec::Vec<CSOItemCriteria>,
    // @@protoc_insertion_point(field:CSOItemRecipe.output_items_criteria)
    pub output_items_criteria: ::std::vec::Vec<CSOItemCriteria>,
    // @@protoc_insertion_point(field:CSOItemRecipe.input_item_dupe_counts)
    pub input_item_dupe_counts: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemRecipe.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemRecipe {
    fn default() -> &'a CSOItemRecipe {
        <CSOItemRecipe as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOItemRecipe {
    pub fn new() -> CSOItemRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string n_a = 3;

    pub fn n_a(&self) -> &str {
        match self.n_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_n_a(&mut self) {
        self.n_a = ::std::option::Option::None;
    }

    pub fn has_n_a(&self) -> bool {
        self.n_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_a(&mut self, v: ::std::string::String) {
        self.n_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_n_a(&mut self) -> &mut ::std::string::String {
        if self.n_a.is_none() {
            self.n_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.n_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_n_a(&mut self) -> ::std::string::String {
        self.n_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_inputs = 4;

    pub fn desc_inputs(&self) -> &str {
        match self.desc_inputs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_inputs(&mut self) {
        self.desc_inputs = ::std::option::Option::None;
    }

    pub fn has_desc_inputs(&self) -> bool {
        self.desc_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_inputs(&mut self, v: ::std::string::String) {
        self.desc_inputs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_inputs(&mut self) -> &mut ::std::string::String {
        if self.desc_inputs.is_none() {
            self.desc_inputs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_inputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_inputs(&mut self) -> ::std::string::String {
        self.desc_inputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_outputs = 5;

    pub fn desc_outputs(&self) -> &str {
        match self.desc_outputs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_outputs(&mut self) {
        self.desc_outputs = ::std::option::Option::None;
    }

    pub fn has_desc_outputs(&self) -> bool {
        self.desc_outputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_outputs(&mut self, v: ::std::string::String) {
        self.desc_outputs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_outputs(&mut self) -> &mut ::std::string::String {
        if self.desc_outputs.is_none() {
            self.desc_outputs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_outputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_outputs(&mut self) -> ::std::string::String {
        self.desc_outputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_a = 6;

    pub fn di_a(&self) -> &str {
        match self.di_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_a(&mut self) {
        self.di_a = ::std::option::Option::None;
    }

    pub fn has_di_a(&self) -> bool {
        self.di_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_a(&mut self, v: ::std::string::String) {
        self.di_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_a(&mut self) -> &mut ::std::string::String {
        if self.di_a.is_none() {
            self.di_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_a(&mut self) -> ::std::string::String {
        self.di_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_b = 7;

    pub fn di_b(&self) -> &str {
        match self.di_b.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_b(&mut self) {
        self.di_b = ::std::option::Option::None;
    }

    pub fn has_di_b(&self) -> bool {
        self.di_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_b(&mut self, v: ::std::string::String) {
        self.di_b = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_b(&mut self) -> &mut ::std::string::String {
        if self.di_b.is_none() {
            self.di_b = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_b(&mut self) -> ::std::string::String {
        self.di_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_c = 8;

    pub fn di_c(&self) -> &str {
        match self.di_c.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_c(&mut self) {
        self.di_c = ::std::option::Option::None;
    }

    pub fn has_di_c(&self) -> bool {
        self.di_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_c(&mut self, v: ::std::string::String) {
        self.di_c = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_c(&mut self) -> &mut ::std::string::String {
        if self.di_c.is_none() {
            self.di_c = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_c(&mut self) -> ::std::string::String {
        self.di_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_a = 9;

    pub fn do_a(&self) -> &str {
        match self.do_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_a(&mut self) {
        self.do_a = ::std::option::Option::None;
    }

    pub fn has_do_a(&self) -> bool {
        self.do_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_a(&mut self, v: ::std::string::String) {
        self.do_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_a(&mut self) -> &mut ::std::string::String {
        if self.do_a.is_none() {
            self.do_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_a(&mut self) -> ::std::string::String {
        self.do_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_b = 10;

    pub fn do_b(&self) -> &str {
        match self.do_b.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_b(&mut self) {
        self.do_b = ::std::option::Option::None;
    }

    pub fn has_do_b(&self) -> bool {
        self.do_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_b(&mut self, v: ::std::string::String) {
        self.do_b = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_b(&mut self) -> &mut ::std::string::String {
        if self.do_b.is_none() {
            self.do_b = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_b(&mut self) -> ::std::string::String {
        self.do_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_c = 11;

    pub fn do_c(&self) -> &str {
        match self.do_c.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_c(&mut self) {
        self.do_c = ::std::option::Option::None;
    }

    pub fn has_do_c(&self) -> bool {
        self.do_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_c(&mut self, v: ::std::string::String) {
        self.do_c = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_c(&mut self) -> &mut ::std::string::String {
        if self.do_c.is_none() {
            self.do_c = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_c(&mut self) -> ::std::string::String {
        self.do_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool requires_all_same_class = 12;

    pub fn requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.unwrap_or(false)
    }

    pub fn clear_requires_all_same_class(&mut self) {
        self.requires_all_same_class = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_class(&mut self, v: bool) {
        self.requires_all_same_class = ::std::option::Option::Some(v);
    }

    // optional bool requires_all_same_slot = 13;

    pub fn requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.unwrap_or(false)
    }

    pub fn clear_requires_all_same_slot(&mut self) {
        self.requires_all_same_slot = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_slot(&mut self, v: bool) {
        self.requires_all_same_slot = ::std::option::Option::Some(v);
    }

    // optional int32 class_usage_for_output = 14;

    pub fn class_usage_for_output(&self) -> i32 {
        self.class_usage_for_output.unwrap_or(0)
    }

    pub fn clear_class_usage_for_output(&mut self) {
        self.class_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_class_usage_for_output(&self) -> bool {
        self.class_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_usage_for_output(&mut self, v: i32) {
        self.class_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 slot_usage_for_output = 15;

    pub fn slot_usage_for_output(&self) -> i32 {
        self.slot_usage_for_output.unwrap_or(0)
    }

    pub fn clear_slot_usage_for_output(&mut self) {
        self.slot_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_slot_usage_for_output(&self) -> bool {
        self.slot_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_usage_for_output(&mut self, v: i32) {
        self.slot_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 set_for_output = 16;

    pub fn set_for_output(&self) -> i32 {
        self.set_for_output.unwrap_or(0)
    }

    pub fn clear_set_for_output(&mut self) {
        self.set_for_output = ::std::option::Option::None;
    }

    pub fn has_set_for_output(&self) -> bool {
        self.set_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_for_output(&mut self, v: i32) {
        self.set_for_output = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOItemRecipe {
    const NAME: &'static str = "CSOItemRecipe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.n_a = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.desc_inputs = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.desc_outputs = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.di_a = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.di_b = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.di_c = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.do_a = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.do_b = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.do_c = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.requires_all_same_class = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.requires_all_same_slot = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.class_usage_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.slot_usage_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.set_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                162 => {
                    self.input_items_criteria.push(is.read_message()?);
                },
                170 => {
                    self.output_items_criteria.push(is.read_message()?);
                },
                178 => {
                    is.read_repeated_packed_uint32_into(&mut self.input_item_dupe_counts)?;
                },
                176 => {
                    self.input_item_dupe_counts.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.n_a.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.desc_inputs.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.desc_outputs.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.di_a.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.di_b.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.di_c.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.do_a.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.do_b.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.do_c.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.requires_all_same_class {
            my_size += 1 + 1;
        }
        if let Some(v) = self.requires_all_same_slot {
            my_size += 1 + 1;
        }
        if let Some(v) = self.class_usage_for_output {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.slot_usage_for_output {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.set_for_output {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, v);
        }
        for value in &self.input_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.output_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.input_item_dupe_counts {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.n_a.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.desc_inputs.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.desc_outputs.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.di_a.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.di_b.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.di_c.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.do_a.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.do_b.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.do_c.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.requires_all_same_class {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.requires_all_same_slot {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.class_usage_for_output {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.slot_usage_for_output {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.set_for_output {
            os.write_int32(16, v)?;
        }
        for v in &self.input_items_criteria {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.output_items_criteria {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        for v in &self.input_item_dupe_counts {
            os.write_uint32(22, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemRecipe {
        CSOItemRecipe::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.n_a = ::std::option::Option::None;
        self.desc_inputs = ::std::option::Option::None;
        self.desc_outputs = ::std::option::Option::None;
        self.di_a = ::std::option::Option::None;
        self.di_b = ::std::option::Option::None;
        self.di_c = ::std::option::Option::None;
        self.do_a = ::std::option::Option::None;
        self.do_b = ::std::option::Option::None;
        self.do_c = ::std::option::Option::None;
        self.requires_all_same_class = ::std::option::Option::None;
        self.requires_all_same_slot = ::std::option::Option::None;
        self.class_usage_for_output = ::std::option::Option::None;
        self.slot_usage_for_output = ::std::option::Option::None;
        self.set_for_output = ::std::option::Option::None;
        self.input_items_criteria.clear();
        self.output_items_criteria.clear();
        self.input_item_dupe_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemRecipe {
        static instance: CSOItemRecipe = CSOItemRecipe {
            def_index: ::std::option::Option::None,
            name: ::std::option::Option::None,
            n_a: ::std::option::Option::None,
            desc_inputs: ::std::option::Option::None,
            desc_outputs: ::std::option::Option::None,
            di_a: ::std::option::Option::None,
            di_b: ::std::option::Option::None,
            di_c: ::std::option::Option::None,
            do_a: ::std::option::Option::None,
            do_b: ::std::option::Option::None,
            do_c: ::std::option::Option::None,
            requires_all_same_class: ::std::option::Option::None,
            requires_all_same_slot: ::std::option::Option::None,
            class_usage_for_output: ::std::option::Option::None,
            slot_usage_for_output: ::std::option::Option::None,
            set_for_output: ::std::option::Option::None,
            input_items_criteria: ::std::vec::Vec::new(),
            output_items_criteria: ::std::vec::Vec::new(),
            input_item_dupe_counts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevNewItemRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevNewItemRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.receiver)
    pub receiver: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.criteria)
    pub criteria: ::steam_vent_proto_common::protobuf::MessageField<CSOItemCriteria>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevNewItemRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequest {
    fn default() -> &'a CMsgDevNewItemRequest {
        <CMsgDevNewItemRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;

    pub fn receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }

    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevNewItemRequest {
    const NAME: &'static str = "CMsgDevNewItemRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.receiver = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.criteria)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 1 + 8;
        }
        if let Some(v) = self.criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.criteria.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.criteria.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevNewItemRequest {
        static instance: CMsgDevNewItemRequest = CMsgDevNewItemRequest {
            receiver: ::std::option::Option::None,
            criteria: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevDebugRollLootRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevDebugRollLootRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevDebugRollLootRequest.receiver)
    pub receiver: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDevDebugRollLootRequest.loot_list_name)
    pub loot_list_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevDebugRollLootRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevDebugRollLootRequest {
    fn default() -> &'a CMsgDevDebugRollLootRequest {
        <CMsgDevDebugRollLootRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevDebugRollLootRequest {
    pub fn new() -> CMsgDevDebugRollLootRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;

    pub fn receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }

    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional string loot_list_name = 2;

    pub fn loot_list_name(&self) -> &str {
        match self.loot_list_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loot_list_name(&mut self) {
        self.loot_list_name = ::std::option::Option::None;
    }

    pub fn has_loot_list_name(&self) -> bool {
        self.loot_list_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list_name(&mut self, v: ::std::string::String) {
        self.loot_list_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list_name(&mut self) -> &mut ::std::string::String {
        if self.loot_list_name.is_none() {
            self.loot_list_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loot_list_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list_name(&mut self) -> ::std::string::String {
        self.loot_list_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevDebugRollLootRequest {
    const NAME: &'static str = "CMsgDevDebugRollLootRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.receiver = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.loot_list_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 1 + 8;
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevDebugRollLootRequest {
        CMsgDevDebugRollLootRequest::new()
    }

    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.loot_list_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevDebugRollLootRequest {
        static instance: CMsgDevDebugRollLootRequest = CMsgDevDebugRollLootRequest {
            receiver: ::std::option::Option::None,
            loot_list_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgIncrementKillCountAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIncrementKillCountAttribute {
    // message fields
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.killer_steam_id)
    pub killer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.victim_steam_id)
    pub victim_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.increment_value)
    pub increment_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIncrementKillCountAttribute.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute {
    fn default() -> &'a CMsgIncrementKillCountAttribute {
        <CMsgIncrementKillCountAttribute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute {
    pub fn new() -> CMsgIncrementKillCountAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 killer_steam_id = 1;

    pub fn killer_steam_id(&self) -> u64 {
        self.killer_steam_id.unwrap_or(0)
    }

    pub fn clear_killer_steam_id(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
    }

    pub fn has_killer_steam_id(&self) -> bool {
        self.killer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_steam_id(&mut self, v: u64) {
        self.killer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 victim_steam_id = 2;

    pub fn victim_steam_id(&self) -> u64 {
        self.victim_steam_id.unwrap_or(0)
    }

    pub fn clear_victim_steam_id(&mut self) {
        self.victim_steam_id = ::std::option::Option::None;
    }

    pub fn has_victim_steam_id(&self) -> bool {
        self.victim_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_steam_id(&mut self, v: u64) {
        self.victim_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 increment_value = 5;

    pub fn increment_value(&self) -> u32 {
        self.increment_value.unwrap_or(0)
    }

    pub fn clear_increment_value(&mut self) {
        self.increment_value = ::std::option::Option::None;
    }

    pub fn has_increment_value(&self) -> bool {
        self.increment_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_increment_value(&mut self, v: u32) {
        self.increment_value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgIncrementKillCountAttribute {
    const NAME: &'static str = "CMsgIncrementKillCountAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.killer_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.victim_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.increment_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.victim_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.increment_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.killer_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.victim_steam_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.increment_value {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIncrementKillCountAttribute {
        CMsgIncrementKillCountAttribute::new()
    }

    fn clear(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
        self.victim_steam_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.increment_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute {
        static instance: CMsgIncrementKillCountAttribute = CMsgIncrementKillCountAttribute {
            killer_steam_id: ::std::option::Option::None,
            victim_steam_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            increment_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgIncrementKillCountAttribute_Multiple)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIncrementKillCountAttribute_Multiple {
    // message fields
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute_Multiple.msgs)
    pub msgs: ::std::vec::Vec<CMsgIncrementKillCountAttribute>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIncrementKillCountAttribute_Multiple.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute_Multiple {
    fn default() -> &'a CMsgIncrementKillCountAttribute_Multiple {
        <CMsgIncrementKillCountAttribute_Multiple as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute_Multiple {
    pub fn new() -> CMsgIncrementKillCountAttribute_Multiple {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgIncrementKillCountAttribute_Multiple {
    const NAME: &'static str = "CMsgIncrementKillCountAttribute_Multiple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.msgs.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.msgs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIncrementKillCountAttribute_Multiple {
        CMsgIncrementKillCountAttribute_Multiple::new()
    }

    fn clear(&mut self) {
        self.msgs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute_Multiple {
        static instance: CMsgIncrementKillCountAttribute_Multiple = CMsgIncrementKillCountAttribute_Multiple {
            msgs: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTrackUniquePlayerPairEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrackUniquePlayerPairEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.killer_steam_id)
    pub killer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.victim_steam_id)
    pub victim_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrackUniquePlayerPairEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrackUniquePlayerPairEvent {
    fn default() -> &'a CMsgTrackUniquePlayerPairEvent {
        <CMsgTrackUniquePlayerPairEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTrackUniquePlayerPairEvent {
    pub fn new() -> CMsgTrackUniquePlayerPairEvent {
        ::std::default::Default::default()
    }

    // optional uint64 killer_steam_id = 1;

    pub fn killer_steam_id(&self) -> u64 {
        self.killer_steam_id.unwrap_or(0)
    }

    pub fn clear_killer_steam_id(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
    }

    pub fn has_killer_steam_id(&self) -> bool {
        self.killer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_steam_id(&mut self, v: u64) {
        self.killer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 victim_steam_id = 2;

    pub fn victim_steam_id(&self) -> u64 {
        self.victim_steam_id.unwrap_or(0)
    }

    pub fn clear_victim_steam_id(&mut self) {
        self.victim_steam_id = ::std::option::Option::None;
    }

    pub fn has_victim_steam_id(&self) -> bool {
        self.victim_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_steam_id(&mut self, v: u64) {
        self.victim_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTrackUniquePlayerPairEvent {
    const NAME: &'static str = "CMsgTrackUniquePlayerPairEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.killer_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.victim_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.victim_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.killer_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.victim_steam_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrackUniquePlayerPairEvent {
        CMsgTrackUniquePlayerPairEvent::new()
    }

    fn clear(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
        self.victim_steam_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrackUniquePlayerPairEvent {
        static instance: CMsgTrackUniquePlayerPairEvent = CMsgTrackUniquePlayerPairEvent {
            killer_steam_id: ::std::option::Option::None,
            victim_steam_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyStrangeCountTransfer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyStrangeCountTransfer {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangeCountTransfer.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeCountTransfer.item_src_item_id)
    pub item_src_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeCountTransfer.item_dest_item_id)
    pub item_dest_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangeCountTransfer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangeCountTransfer {
    fn default() -> &'a CMsgApplyStrangeCountTransfer {
        <CMsgApplyStrangeCountTransfer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangeCountTransfer {
    pub fn new() -> CMsgApplyStrangeCountTransfer {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_src_item_id = 2;

    pub fn item_src_item_id(&self) -> u64 {
        self.item_src_item_id.unwrap_or(0)
    }

    pub fn clear_item_src_item_id(&mut self) {
        self.item_src_item_id = ::std::option::Option::None;
    }

    pub fn has_item_src_item_id(&self) -> bool {
        self.item_src_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_src_item_id(&mut self, v: u64) {
        self.item_src_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_dest_item_id = 3;

    pub fn item_dest_item_id(&self) -> u64 {
        self.item_dest_item_id.unwrap_or(0)
    }

    pub fn clear_item_dest_item_id(&mut self) {
        self.item_dest_item_id = ::std::option::Option::None;
    }

    pub fn has_item_dest_item_id(&self) -> bool {
        self.item_dest_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_dest_item_id(&mut self, v: u64) {
        self.item_dest_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyStrangeCountTransfer {
    const NAME: &'static str = "CMsgApplyStrangeCountTransfer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_src_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_dest_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_src_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_dest_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_src_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_dest_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangeCountTransfer {
        CMsgApplyStrangeCountTransfer::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_src_item_id = ::std::option::Option::None;
        self.item_dest_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangeCountTransfer {
        static instance: CMsgApplyStrangeCountTransfer = CMsgApplyStrangeCountTransfer {
            tool_item_id: ::std::option::Option::None,
            item_src_item_id: ::std::option::Option::None,
            item_dest_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyStrangePart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyStrangePart {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.strange_part_item_id)
    pub strange_part_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangePart.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangePart {
    fn default() -> &'a CMsgApplyStrangePart {
        <CMsgApplyStrangePart as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangePart {
    pub fn new() -> CMsgApplyStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;

    pub fn strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }

    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyStrangePart {
    const NAME: &'static str = "CMsgApplyStrangePart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strange_part_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangePart {
        CMsgApplyStrangePart::new()
    }

    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangePart {
        static instance: CMsgApplyStrangePart = CMsgApplyStrangePart {
            strange_part_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyStrangeRestriction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyStrangeRestriction {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangeRestriction.strange_part_item_id)
    pub strange_part_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeRestriction.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeRestriction.strange_attr_index)
    pub strange_attr_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangeRestriction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangeRestriction {
    fn default() -> &'a CMsgApplyStrangeRestriction {
        <CMsgApplyStrangeRestriction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangeRestriction {
    pub fn new() -> CMsgApplyStrangeRestriction {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;

    pub fn strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }

    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_attr_index = 3;

    pub fn strange_attr_index(&self) -> u32 {
        self.strange_attr_index.unwrap_or(0)
    }

    pub fn clear_strange_attr_index(&mut self) {
        self.strange_attr_index = ::std::option::Option::None;
    }

    pub fn has_strange_attr_index(&self) -> bool {
        self.strange_attr_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_attr_index(&mut self, v: u32) {
        self.strange_attr_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyStrangeRestriction {
    const NAME: &'static str = "CMsgApplyStrangeRestriction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strange_part_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.strange_attr_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.strange_attr_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.strange_attr_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangeRestriction {
        CMsgApplyStrangeRestriction::new()
    }

    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.strange_attr_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangeRestriction {
        static instance: CMsgApplyStrangeRestriction = CMsgApplyStrangeRestriction {
            strange_part_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            strange_attr_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyUpgradeCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyUpgradeCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyUpgradeCard.upgrade_card_item_id)
    pub upgrade_card_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyUpgradeCard.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyUpgradeCard.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyUpgradeCard {
    fn default() -> &'a CMsgApplyUpgradeCard {
        <CMsgApplyUpgradeCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyUpgradeCard {
    pub fn new() -> CMsgApplyUpgradeCard {
        ::std::default::Default::default()
    }

    // optional uint64 upgrade_card_item_id = 1;

    pub fn upgrade_card_item_id(&self) -> u64 {
        self.upgrade_card_item_id.unwrap_or(0)
    }

    pub fn clear_upgrade_card_item_id(&mut self) {
        self.upgrade_card_item_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_card_item_id(&self) -> bool {
        self.upgrade_card_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_card_item_id(&mut self, v: u64) {
        self.upgrade_card_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyUpgradeCard {
    const NAME: &'static str = "CMsgApplyUpgradeCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upgrade_card_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_card_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.upgrade_card_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyUpgradeCard {
        CMsgApplyUpgradeCard::new()
    }

    fn clear(&mut self) {
        self.upgrade_card_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyUpgradeCard {
        static instance: CMsgApplyUpgradeCard = CMsgApplyUpgradeCard {
            upgrade_card_item_id: ::std::option::Option::None,
            subject_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItemAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemAttribute.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value_bytes)
    pub value_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemAttribute.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemAttribute {
    fn default() -> &'a CSOEconItemAttribute {
        <CSOEconItemAttribute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemAttribute {
    pub fn new() -> CSOEconItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional bytes value_bytes = 3;

    pub fn value_bytes(&self) -> &[u8] {
        match self.value_bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value_bytes(&mut self) {
        self.value_bytes = ::std::option::Option::None;
    }

    pub fn has_value_bytes(&self) -> bool {
        self.value_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value_bytes.is_none() {
            self.value_bytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.value_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItemAttribute {
    const NAME: &'static str = "CSOEconItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.value_bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value_bytes.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value_bytes.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemAttribute {
        CSOEconItemAttribute::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value_bytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemAttribute {
        static instance: CSOEconItemAttribute = CSOEconItemAttribute {
            def_index: ::std::option::Option::None,
            value: ::std::option::Option::None,
            value_bytes: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItemEquipped)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemEquipped {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemEquipped.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEquipped {
    fn default() -> &'a CSOEconItemEquipped {
        <CSOEconItemEquipped as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEquipped {
    pub fn new() -> CSOEconItemEquipped {
        ::std::default::Default::default()
    }

    // optional uint32 new_class = 1;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 2;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItemEquipped {
    const NAME: &'static str = "CSOEconItemEquipped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_class {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.new_class {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemEquipped {
        CSOEconItemEquipped::new()
    }

    fn clear(&mut self) {
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemEquipped {
        static instance: CSOEconItemEquipped = CSOEconItemEquipped {
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItem {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItem.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.custom_name)
    pub custom_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOEconItem.custom_desc)
    pub custom_desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOEconItem.attribute)
    pub attribute: ::std::vec::Vec<CSOEconItemAttribute>,
    // @@protoc_insertion_point(field:CSOEconItem.interior_item)
    pub interior_item: ::steam_vent_proto_common::protobuf::MessageField<CSOEconItem>,
    // @@protoc_insertion_point(field:CSOEconItem.in_use)
    pub in_use: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconItem.style)
    pub style: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.original_id)
    pub original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.contains_equipped_state)
    pub contains_equipped_state: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconItem.equipped_state)
    pub equipped_state: ::std::vec::Vec<CSOEconItemEquipped>,
    // @@protoc_insertion_point(field:CSOEconItem.contains_equipped_state_v2)
    pub contains_equipped_state_v2: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItem {
    fn default() -> &'a CSOEconItem {
        <CSOEconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItem {
    pub fn new() -> CSOEconItem {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 3;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 4;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 5;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 6;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 7;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 8;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0u32)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 9;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional string custom_name = 10;

    pub fn custom_name(&self) -> &str {
        match self.custom_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_name(&mut self) {
        self.custom_name = ::std::option::Option::None;
    }

    pub fn has_custom_name(&self) -> bool {
        self.custom_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_name(&mut self, v: ::std::string::String) {
        self.custom_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_name(&mut self) -> &mut ::std::string::String {
        if self.custom_name.is_none() {
            self.custom_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_name(&mut self) -> ::std::string::String {
        self.custom_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_desc = 11;

    pub fn custom_desc(&self) -> &str {
        match self.custom_desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_desc(&mut self) {
        self.custom_desc = ::std::option::Option::None;
    }

    pub fn has_custom_desc(&self) -> bool {
        self.custom_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_desc(&mut self, v: ::std::string::String) {
        self.custom_desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_desc(&mut self) -> &mut ::std::string::String {
        if self.custom_desc.is_none() {
            self.custom_desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_desc(&mut self) -> ::std::string::String {
        self.custom_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_use = 14;

    pub fn in_use(&self) -> bool {
        self.in_use.unwrap_or(false)
    }

    pub fn clear_in_use(&mut self) {
        self.in_use = ::std::option::Option::None;
    }

    pub fn has_in_use(&self) -> bool {
        self.in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_use(&mut self, v: bool) {
        self.in_use = ::std::option::Option::Some(v);
    }

    // optional uint32 style = 15;

    pub fn style(&self) -> u32 {
        self.style.unwrap_or(0u32)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: u32) {
        self.style = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 16;

    pub fn original_id(&self) -> u64 {
        self.original_id.unwrap_or(0u64)
    }

    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }

    // optional bool contains_equipped_state = 17;

    pub fn contains_equipped_state(&self) -> bool {
        self.contains_equipped_state.unwrap_or(false)
    }

    pub fn clear_contains_equipped_state(&mut self) {
        self.contains_equipped_state = ::std::option::Option::None;
    }

    pub fn has_contains_equipped_state(&self) -> bool {
        self.contains_equipped_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contains_equipped_state(&mut self, v: bool) {
        self.contains_equipped_state = ::std::option::Option::Some(v);
    }

    // optional bool contains_equipped_state_v2 = 19;

    pub fn contains_equipped_state_v2(&self) -> bool {
        self.contains_equipped_state_v2.unwrap_or(false)
    }

    pub fn clear_contains_equipped_state_v2(&mut self) {
        self.contains_equipped_state_v2 = ::std::option::Option::None;
    }

    pub fn has_contains_equipped_state_v2(&self) -> bool {
        self.contains_equipped_state_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contains_equipped_state_v2(&mut self, v: bool) {
        self.contains_equipped_state_v2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItem {
    const NAME: &'static str = "CSOEconItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.custom_name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.custom_desc = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.attribute.push(is.read_message()?);
                },
                106 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.interior_item)?;
                },
                112 => {
                    self.in_use = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.style = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                136 => {
                    self.contains_equipped_state = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    self.equipped_state.push(is.read_message()?);
                },
                152 => {
                    self.contains_equipped_state_v2 = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.origin {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.custom_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.custom_desc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.interior_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.in_use {
            my_size += 1 + 1;
        }
        if let Some(v) = self.style {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.original_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(16, v);
        }
        if let Some(v) = self.contains_equipped_state {
            my_size += 2 + 1;
        }
        for value in &self.equipped_state {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.contains_equipped_state_v2 {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.custom_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.custom_desc.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.attribute {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.interior_item.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.in_use {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.style {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.contains_equipped_state {
            os.write_bool(17, v)?;
        }
        for v in &self.equipped_state {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.contains_equipped_state_v2 {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItem {
        CSOEconItem::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.custom_name = ::std::option::Option::None;
        self.custom_desc = ::std::option::Option::None;
        self.attribute.clear();
        self.interior_item.clear();
        self.in_use = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.contains_equipped_state = ::std::option::Option::None;
        self.equipped_state.clear();
        self.contains_equipped_state_v2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItem {
        static instance: CSOEconItem = CSOEconItem {
            id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            level: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            custom_name: ::std::option::Option::None,
            custom_desc: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            interior_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
            in_use: ::std::option::Option::None,
            style: ::std::option::Option::None,
            original_id: ::std::option::Option::None,
            contains_equipped_state: ::std::option::Option::None,
            equipped_state: ::std::vec::Vec::new(),
            contains_equipped_state_v2: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAdjustItemEquippedState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAdjustItemEquippedState {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdjustItemEquippedState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedState {
    fn default() -> &'a CMsgAdjustItemEquippedState {
        <CMsgAdjustItemEquippedState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_class = 2;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 3;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAdjustItemEquippedState {
    const NAME: &'static str = "CMsgAdjustItemEquippedState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.new_class {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static instance: CMsgAdjustItemEquippedState = CMsgAdjustItemEquippedState {
            item_id: ::std::option::Option::None,
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSortItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSortItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgSortItems.sort_type)
    pub sort_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSortItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSortItems {
    fn default() -> &'a CMsgSortItems {
        <CMsgSortItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSortItems {
    pub fn new() -> CMsgSortItems {
        ::std::default::Default::default()
    }

    // optional uint32 sort_type = 1;

    pub fn sort_type(&self) -> u32 {
        self.sort_type.unwrap_or(0)
    }

    pub fn clear_sort_type(&mut self) {
        self.sort_type = ::std::option::Option::None;
    }

    pub fn has_sort_type(&self) -> bool {
        self.sort_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: u32) {
        self.sort_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSortItems {
    const NAME: &'static str = "CMsgSortItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sort_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sort_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.sort_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSortItems {
        CMsgSortItems::new()
    }

    fn clear(&mut self) {
        self.sort_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSortItems {
        static instance: CMsgSortItems = CMsgSortItems {
            sort_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconClaimCode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconClaimCode {
    // message fields
    // @@protoc_insertion_point(field:CSOEconClaimCode.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.code_type)
    pub code_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.time_acquired)
    pub time_acquired: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.code)
    pub code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconClaimCode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconClaimCode {
    fn default() -> &'a CSOEconClaimCode {
        <CSOEconClaimCode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconClaimCode {
    pub fn new() -> CSOEconClaimCode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 code_type = 2;

    pub fn code_type(&self) -> u32 {
        self.code_type.unwrap_or(0)
    }

    pub fn clear_code_type(&mut self) {
        self.code_type = ::std::option::Option::None;
    }

    pub fn has_code_type(&self) -> bool {
        self.code_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_type(&mut self, v: u32) {
        self.code_type = ::std::option::Option::Some(v);
    }

    // optional uint32 time_acquired = 3;

    pub fn time_acquired(&self) -> u32 {
        self.time_acquired.unwrap_or(0)
    }

    pub fn clear_time_acquired(&mut self) {
        self.time_acquired = ::std::option::Option::None;
    }

    pub fn has_time_acquired(&self) -> bool {
        self.time_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_acquired(&mut self, v: u32) {
        self.time_acquired = ::std::option::Option::Some(v);
    }

    // optional string code = 4;

    pub fn code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconClaimCode {
    const NAME: &'static str = "CSOEconClaimCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.code_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_acquired = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.code_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_acquired {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.code_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_acquired {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconClaimCode {
        CSOEconClaimCode::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.code_type = ::std::option::Option::None;
        self.time_acquired = ::std::option::Option::None;
        self.code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconClaimCode {
        static instance: CSOEconClaimCode = CSOEconClaimCode {
            account_id: ::std::option::Option::None,
            code_type: ::std::option::Option::None,
            time_acquired: ::std::option::Option::None,
            code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStoreGetUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStoreGetUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgStoreGetUserData.price_sheet_version)
    pub price_sheet_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStoreGetUserData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserData {
    fn default() -> &'a CMsgStoreGetUserData {
        <CMsgStoreGetUserData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserData {
    pub fn new() -> CMsgStoreGetUserData {
        ::std::default::Default::default()
    }

    // optional fixed32 price_sheet_version = 1;

    pub fn price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }

    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStoreGetUserData {
    const NAME: &'static str = "CMsgStoreGetUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.price_sheet_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.price_sheet_version {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStoreGetUserData {
        CMsgStoreGetUserData::new()
    }

    fn clear(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStoreGetUserData {
        static instance: CMsgStoreGetUserData = CMsgStoreGetUserData {
            price_sheet_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStoreGetUserDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStoreGetUserDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.price_sheet_version)
    pub price_sheet_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.experiment_data)
    pub experiment_data: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.featured_item_idx)
    pub featured_item_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.show_hat_descriptions)
    pub show_hat_descriptions: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.price_sheet)
    pub price_sheet: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.default_item_sort)
    pub default_item_sort: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.popular_items)
    pub popular_items: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStoreGetUserDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserDataResponse {
    fn default() -> &'a CMsgStoreGetUserDataResponse {
        <CMsgStoreGetUserDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserDataResponse {
    pub fn new() -> CMsgStoreGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 2;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional string country = 3;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 price_sheet_version = 4;

    pub fn price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }

    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    // optional uint64 experiment_data = 5;

    pub fn experiment_data(&self) -> u64 {
        self.experiment_data.unwrap_or(0u64)
    }

    pub fn clear_experiment_data(&mut self) {
        self.experiment_data = ::std::option::Option::None;
    }

    pub fn has_experiment_data(&self) -> bool {
        self.experiment_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experiment_data(&mut self, v: u64) {
        self.experiment_data = ::std::option::Option::Some(v);
    }

    // optional int32 featured_item_idx = 6;

    pub fn featured_item_idx(&self) -> i32 {
        self.featured_item_idx.unwrap_or(0)
    }

    pub fn clear_featured_item_idx(&mut self) {
        self.featured_item_idx = ::std::option::Option::None;
    }

    pub fn has_featured_item_idx(&self) -> bool {
        self.featured_item_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_item_idx(&mut self, v: i32) {
        self.featured_item_idx = ::std::option::Option::Some(v);
    }

    // optional bool show_hat_descriptions = 7;

    pub fn show_hat_descriptions(&self) -> bool {
        self.show_hat_descriptions.unwrap_or(true)
    }

    pub fn clear_show_hat_descriptions(&mut self) {
        self.show_hat_descriptions = ::std::option::Option::None;
    }

    pub fn has_show_hat_descriptions(&self) -> bool {
        self.show_hat_descriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_hat_descriptions(&mut self, v: bool) {
        self.show_hat_descriptions = ::std::option::Option::Some(v);
    }

    // optional bytes price_sheet = 8;

    pub fn price_sheet(&self) -> &[u8] {
        match self.price_sheet.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_price_sheet(&mut self) {
        self.price_sheet = ::std::option::Option::None;
    }

    pub fn has_price_sheet(&self) -> bool {
        self.price_sheet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet(&mut self, v: ::std::vec::Vec<u8>) {
        self.price_sheet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_sheet(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.price_sheet.is_none() {
            self.price_sheet = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.price_sheet.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_sheet(&mut self) -> ::std::vec::Vec<u8> {
        self.price_sheet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 default_item_sort = 9;

    pub fn default_item_sort(&self) -> i32 {
        self.default_item_sort.unwrap_or(0i32)
    }

    pub fn clear_default_item_sort(&mut self) {
        self.default_item_sort = ::std::option::Option::None;
    }

    pub fn has_default_item_sort(&self) -> bool {
        self.default_item_sort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_item_sort(&mut self, v: i32) {
        self.default_item_sort = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStoreGetUserDataResponse {
    const NAME: &'static str = "CMsgStoreGetUserDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.price_sheet_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.experiment_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.featured_item_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.show_hat_descriptions = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.price_sheet = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.default_item_sort = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.popular_items)?;
                },
                80 => {
                    self.popular_items.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.price_sheet_version {
            my_size += 1 + 4;
        }
        if let Some(v) = self.experiment_data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.featured_item_idx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.show_hat_descriptions {
            my_size += 1 + 1;
        }
        if let Some(v) = self.price_sheet.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.default_item_sort {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
        }
        for value in &self.popular_items {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.experiment_data {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.featured_item_idx {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.show_hat_descriptions {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.price_sheet.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.default_item_sort {
            os.write_int32(9, v)?;
        }
        for v in &self.popular_items {
            os.write_uint32(10, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStoreGetUserDataResponse {
        CMsgStoreGetUserDataResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.country = ::std::option::Option::None;
        self.price_sheet_version = ::std::option::Option::None;
        self.experiment_data = ::std::option::Option::None;
        self.featured_item_idx = ::std::option::Option::None;
        self.show_hat_descriptions = ::std::option::Option::None;
        self.price_sheet = ::std::option::Option::None;
        self.default_item_sort = ::std::option::Option::None;
        self.popular_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStoreGetUserDataResponse {
        static instance: CMsgStoreGetUserDataResponse = CMsgStoreGetUserDataResponse {
            result: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            country: ::std::option::Option::None,
            price_sheet_version: ::std::option::Option::None,
            experiment_data: ::std::option::Option::None,
            featured_item_idx: ::std::option::Option::None,
            show_hat_descriptions: ::std::option::Option::None,
            price_sheet: ::std::option::Option::None,
            default_item_sort: ::std::option::Option::None,
            popular_items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUpdateItemSchema)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpdateItemSchema {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.items_game)
    pub items_game: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.item_schema_version)
    pub item_schema_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.items_game_url)
    pub items_game_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateItemSchema.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateItemSchema {
    fn default() -> &'a CMsgUpdateItemSchema {
        <CMsgUpdateItemSchema as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateItemSchema {
    pub fn new() -> CMsgUpdateItemSchema {
        ::std::default::Default::default()
    }

    // optional bytes items_game = 1;

    pub fn items_game(&self) -> &[u8] {
        match self.items_game.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_items_game(&mut self) {
        self.items_game = ::std::option::Option::None;
    }

    pub fn has_items_game(&self) -> bool {
        self.items_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game(&mut self, v: ::std::vec::Vec<u8>) {
        self.items_game = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.items_game.is_none() {
            self.items_game = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.items_game.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game(&mut self) -> ::std::vec::Vec<u8> {
        self.items_game.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 item_schema_version = 2;

    pub fn item_schema_version(&self) -> u32 {
        self.item_schema_version.unwrap_or(0)
    }

    pub fn clear_item_schema_version(&mut self) {
        self.item_schema_version = ::std::option::Option::None;
    }

    pub fn has_item_schema_version(&self) -> bool {
        self.item_schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_schema_version(&mut self, v: u32) {
        self.item_schema_version = ::std::option::Option::Some(v);
    }

    // optional string items_game_url = 3;

    pub fn items_game_url(&self) -> &str {
        match self.items_game_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_items_game_url(&mut self) {
        self.items_game_url = ::std::option::Option::None;
    }

    pub fn has_items_game_url(&self) -> bool {
        self.items_game_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game_url(&mut self, v: ::std::string::String) {
        self.items_game_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game_url(&mut self) -> &mut ::std::string::String {
        if self.items_game_url.is_none() {
            self.items_game_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.items_game_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game_url(&mut self) -> ::std::string::String {
        self.items_game_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes signature = 4;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUpdateItemSchema {
    const NAME: &'static str = "CMsgUpdateItemSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items_game = ::std::option::Option::Some(is.read_bytes()?);
                },
                21 => {
                    self.item_schema_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.items_game_url = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.items_game.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.item_schema_version {
            my_size += 1 + 4;
        }
        if let Some(v) = self.items_game_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.items_game.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.item_schema_version {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.items_game_url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateItemSchema {
        CMsgUpdateItemSchema::new()
    }

    fn clear(&mut self) {
        self.items_game = ::std::option::Option::None;
        self.item_schema_version = ::std::option::Option::None;
        self.items_game_url = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateItemSchema {
        static instance: CMsgUpdateItemSchema = CMsgUpdateItemSchema {
            items_game: ::std::option::Option::None,
            item_schema_version: ::std::option::Option::None,
            items_game_url: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCError {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCError.error_text)
    pub error_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCError.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCError {
    fn default() -> &'a CMsgGCError {
        <CMsgGCError as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCError {
    pub fn new() -> CMsgGCError {
        ::std::default::Default::default()
    }

    // optional string error_text = 1;

    pub fn error_text(&self) -> &str {
        match self.error_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_text(&mut self) {
        self.error_text = ::std::option::Option::None;
    }

    pub fn has_error_text(&self) -> bool {
        self.error_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_text(&mut self, v: ::std::string::String) {
        self.error_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_text(&mut self) -> &mut ::std::string::String {
        if self.error_text.is_none() {
            self.error_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_text(&mut self) -> ::std::string::String {
        self.error_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCError {
    const NAME: &'static str = "CMsgGCError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error_text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.error_text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCError {
        CMsgGCError::new()
    }

    fn clear(&mut self) {
        self.error_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCError {
        static instance: CMsgGCError = CMsgGCError {
            error_text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestInventoryRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestInventoryRefresh {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestInventoryRefresh.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestInventoryRefresh {
    fn default() -> &'a CMsgRequestInventoryRefresh {
        <CMsgRequestInventoryRefresh as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestInventoryRefresh {
    pub fn new() -> CMsgRequestInventoryRefresh {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestInventoryRefresh {
    const NAME: &'static str = "CMsgRequestInventoryRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestInventoryRefresh {
        CMsgRequestInventoryRefresh::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestInventoryRefresh {
        static instance: CMsgRequestInventoryRefresh = CMsgRequestInventoryRefresh {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgConVarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConVarValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgConVarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgConVarValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConVarValue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConVarValue {
    fn default() -> &'a CMsgConVarValue {
        <CMsgConVarValue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConVarValue {
    pub fn new() -> CMsgConVarValue {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConVarValue {
    const NAME: &'static str = "CMsgConVarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConVarValue {
        CMsgConVarValue::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConVarValue {
        static instance: CMsgConVarValue = CMsgConVarValue {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgReplicateConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReplicateConVars {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplicateConVars.convars)
    pub convars: ::std::vec::Vec<CMsgConVarValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplicateConVars.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplicateConVars {
    fn default() -> &'a CMsgReplicateConVars {
        <CMsgReplicateConVars as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgReplicateConVars {
    pub fn new() -> CMsgReplicateConVars {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgReplicateConVars {
    const NAME: &'static str = "CMsgReplicateConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.convars.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.convars {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.convars {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplicateConVars {
        CMsgReplicateConVars::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplicateConVars {
        static instance: CMsgReplicateConVars = CMsgReplicateConVars {
            convars: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgUseItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.gift__potential_targets)
    pub gift__potential_targets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.duel__class_lock)
    pub duel__class_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.initiator_steam_id)
    pub initiator_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.itempack__ack_immediately)
    pub itempack__ack_immediately: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUseItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUseItem {
    fn default() -> &'a CMsgUseItem {
        <CMsgUseItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 2;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel__class_lock = 4;

    pub fn duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }

    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 5;

    pub fn initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool itempack__ack_immediately = 6;

    pub fn itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.unwrap_or(false)
    }

    pub fn clear_itempack__ack_immediately(&mut self) {
        self.itempack__ack_immediately = ::std::option::Option::None;
    }

    pub fn has_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itempack__ack_immediately(&mut self, v: bool) {
        self.itempack__ack_immediately = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUseItem {
    const NAME: &'static str = "CMsgUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.gift__potential_targets)?;
                },
                24 => {
                    self.gift__potential_targets.push(is.read_uint32()?);
                },
                32 => {
                    self.duel__class_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.initiator_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.itempack__ack_immediately = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        for value in &self.gift__potential_targets {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.itempack__ack_immediately {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.itempack__ack_immediately {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.gift__potential_targets.clear();
        self.duel__class_lock = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.itempack__ack_immediately = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUseItem {
        static instance: CMsgUseItem = CMsgUseItem {
            item_id: ::std::option::Option::None,
            target_steam_id: ::std::option::Option::None,
            gift__potential_targets: ::std::vec::Vec::new(),
            duel__class_lock: ::std::option::Option::None,
            initiator_steam_id: ::std::option::Option::None,
            itempack__ack_immediately: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgReplayUploadedToYouTube)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReplayUploadedToYouTube {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.youtube_url)
    pub youtube_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.youtube_account_name)
    pub youtube_account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.session_id)
    pub session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplayUploadedToYouTube.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplayUploadedToYouTube {
    fn default() -> &'a CMsgReplayUploadedToYouTube {
        <CMsgReplayUploadedToYouTube as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgReplayUploadedToYouTube {
    pub fn new() -> CMsgReplayUploadedToYouTube {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;

    pub fn youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_url(&mut self) {
        self.youtube_url = ::std::option::Option::None;
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_account_name = 2;

    pub fn youtube_account_name(&self) -> &str {
        match self.youtube_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_account_name(&mut self) {
        self.youtube_account_name = ::std::option::Option::None;
    }

    pub fn has_youtube_account_name(&self) -> bool {
        self.youtube_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_account_name(&mut self, v: ::std::string::String) {
        self.youtube_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_account_name(&mut self) -> &mut ::std::string::String {
        if self.youtube_account_name.is_none() {
            self.youtube_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_account_name(&mut self) -> ::std::string::String {
        self.youtube_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 session_id = 3;

    pub fn session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgReplayUploadedToYouTube {
    const NAME: &'static str = "CMsgReplayUploadedToYouTube";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.youtube_url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.youtube_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.youtube_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.youtube_account_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.session_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.youtube_url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.youtube_account_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplayUploadedToYouTube {
        CMsgReplayUploadedToYouTube::new()
    }

    fn clear(&mut self) {
        self.youtube_url = ::std::option::Option::None;
        self.youtube_account_name = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplayUploadedToYouTube {
        static instance: CMsgReplayUploadedToYouTube = CMsgReplayUploadedToYouTube {
            youtube_url: ::std::option::Option::None,
            youtube_account_name: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgConsumableExhausted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConsumableExhausted {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumableExhausted.item_def_id)
    pub item_def_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumableExhausted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumableExhausted {
    fn default() -> &'a CMsgConsumableExhausted {
        <CMsgConsumableExhausted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumableExhausted {
    pub fn new() -> CMsgConsumableExhausted {
        ::std::default::Default::default()
    }

    // optional int32 item_def_id = 1;

    pub fn item_def_id(&self) -> i32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: i32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConsumableExhausted {
    const NAME: &'static str = "CMsgConsumableExhausted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumableExhausted {
        CMsgConsumableExhausted::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumableExhausted {
        static instance: CMsgConsumableExhausted = CMsgConsumableExhausted {
            item_def_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgItemAcknowledged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemAcknowledged {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.rarity)
    pub rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.is_strange)
    pub is_strange: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.is_unusual)
    pub is_unusual: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.wear)
    pub wear: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemAcknowledged.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged {
    fn default() -> &'a CMsgItemAcknowledged {
        <CMsgItemAcknowledged as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 2;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 3;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 4;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 is_strange = 7;

    pub fn is_strange(&self) -> u32 {
        self.is_strange.unwrap_or(0)
    }

    pub fn clear_is_strange(&mut self) {
        self.is_strange = ::std::option::Option::None;
    }

    pub fn has_is_strange(&self) -> bool {
        self.is_strange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_strange(&mut self, v: u32) {
        self.is_strange = ::std::option::Option::Some(v);
    }

    // optional uint32 is_unusual = 8;

    pub fn is_unusual(&self) -> u32 {
        self.is_unusual.unwrap_or(0)
    }

    pub fn clear_is_unusual(&mut self) {
        self.is_unusual = ::std::option::Option::None;
    }

    pub fn has_is_unusual(&self) -> bool {
        self.is_unusual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unusual(&mut self, v: u32) {
        self.is_unusual = ::std::option::Option::Some(v);
    }

    // optional float wear = 9;

    pub fn wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }

    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgItemAcknowledged {
    const NAME: &'static str = "CMsgItemAcknowledged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.is_strange = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.is_unusual = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.wear = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.origin {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.is_strange {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.is_unusual {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.wear {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_strange {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.is_unusual {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.is_strange = ::std::option::Option::None;
        self.is_unusual = ::std::option::Option::None;
        self.wear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAcknowledged {
        static instance: CMsgItemAcknowledged = CMsgItemAcknowledged {
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            is_strange: ::std::option::Option::None,
            is_unusual: ::std::option::Option::None,
            wear: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetPresetItemPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetPresetItemPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.preset_id)
    pub preset_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetPresetItemPosition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetPresetItemPosition {
    fn default() -> &'a CMsgSetPresetItemPosition {
        <CMsgSetPresetItemPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetPresetItemPosition {
    pub fn new() -> CMsgSetPresetItemPosition {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 1;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 2;

    pub fn preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }

    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 4;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetPresetItemPosition {
    const NAME: &'static str = "CMsgSetPresetItemPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.preset_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetPresetItemPosition {
        CMsgSetPresetItemPosition::new()
    }

    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetPresetItemPosition {
        static instance: CMsgSetPresetItemPosition = CMsgSetPresetItemPosition {
            class_id: ::std::option::Option::None,
            preset_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetItemPositions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetItemPositions {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemPositions.item_positions)
    pub item_positions: ::std::vec::Vec<cmsg_set_item_positions::ItemPosition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemPositions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions {
    fn default() -> &'a CMsgSetItemPositions {
        <CMsgSetItemPositions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions {
    pub fn new() -> CMsgSetItemPositions {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetItemPositions {
    const NAME: &'static str = "CMsgSetItemPositions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item_positions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_positions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_positions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemPositions {
        CMsgSetItemPositions::new()
    }

    fn clear(&mut self) {
        self.item_positions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemPositions {
        static instance: CMsgSetItemPositions = CMsgSetItemPositions {
            item_positions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSetItemPositions`
pub mod cmsg_set_item_positions {
    // @@protoc_insertion_point(message:CMsgSetItemPositions.ItemPosition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemPosition {
        // message fields
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.position)
        pub position: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSetItemPositions.ItemPosition.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemPosition {
        fn default() -> &'a ItemPosition {
            <ItemPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemPosition {
        pub fn new() -> ItemPosition {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 position = 2;

        pub fn position(&self) -> u32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: u32) {
            self.position = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemPosition {
        const NAME: &'static str = "ItemPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.position {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.position {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemPosition {
            ItemPosition::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemPosition {
            static instance: ItemPosition = ItemPosition {
                item_id: ::std::option::Option::None,
                position: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSOEconItemPresetInstance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemPresetInstance {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.preset_id)
    pub preset_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemPresetInstance.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemPresetInstance {
    fn default() -> &'a CSOEconItemPresetInstance {
        <CSOEconItemPresetInstance as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemPresetInstance {
    pub fn new() -> CSOEconItemPresetInstance {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 2;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 3;

    pub fn preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }

    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 4;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 5;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItemPresetInstance {
    const NAME: &'static str = "CSOEconItemPresetInstance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.preset_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemPresetInstance {
        CSOEconItemPresetInstance::new()
    }

    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemPresetInstance {
        static instance: CSOEconItemPresetInstance = CSOEconItemPresetInstance {
            class_id: ::std::option::Option::None,
            preset_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSelectPresetForClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSelectPresetForClass {
    // message fields
    // @@protoc_insertion_point(field:CMsgSelectPresetForClass.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSelectPresetForClass.preset_id)
    pub preset_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSelectPresetForClass.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSelectPresetForClass {
    fn default() -> &'a CMsgSelectPresetForClass {
        <CMsgSelectPresetForClass as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSelectPresetForClass {
    pub fn new() -> CMsgSelectPresetForClass {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 1;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 2;

    pub fn preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }

    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSelectPresetForClass {
    const NAME: &'static str = "CMsgSelectPresetForClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.preset_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSelectPresetForClass {
        CMsgSelectPresetForClass::new()
    }

    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSelectPresetForClass {
        static instance: CMsgSelectPresetForClass = CMsgSelectPresetForClass {
            class_id: ::std::option::Option::None,
            preset_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOClassPresetClientData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOClassPresetClientData {
    // message fields
    // @@protoc_insertion_point(field:CSOClassPresetClientData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOClassPresetClientData.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOClassPresetClientData.active_preset_id)
    pub active_preset_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOClassPresetClientData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOClassPresetClientData {
    fn default() -> &'a CSOClassPresetClientData {
        <CSOClassPresetClientData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOClassPresetClientData {
    pub fn new() -> CSOClassPresetClientData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 class_id = 2;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 active_preset_id = 3;

    pub fn active_preset_id(&self) -> u32 {
        self.active_preset_id.unwrap_or(0)
    }

    pub fn clear_active_preset_id(&mut self) {
        self.active_preset_id = ::std::option::Option::None;
    }

    pub fn has_active_preset_id(&self) -> bool {
        self.active_preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_preset_id(&mut self, v: u32) {
        self.active_preset_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOClassPresetClientData {
    const NAME: &'static str = "CSOClassPresetClientData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.active_preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.class_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.active_preset_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.active_preset_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOClassPresetClientData {
        CSOClassPresetClientData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.active_preset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOClassPresetClientData {
        static instance: CSOClassPresetClientData = CSOClassPresetClientData {
            account_id: ::std::option::Option::None,
            class_id: ::std::option::Option::None,
            active_preset_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCReportAbuse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCReportAbuse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.abuse_type)
    pub abuse_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.content_type)
    pub content_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_game_server_ip)
    pub target_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_game_server_port)
    pub target_game_server_port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCReportAbuse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuse {
    fn default() -> &'a CMsgGCReportAbuse {
        <CMsgGCReportAbuse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuse {
    pub fn new() -> CMsgGCReportAbuse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gid = 5;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 abuse_type = 2;

    pub fn abuse_type(&self) -> u32 {
        self.abuse_type.unwrap_or(0)
    }

    pub fn clear_abuse_type(&mut self) {
        self.abuse_type = ::std::option::Option::None;
    }

    pub fn has_abuse_type(&self) -> bool {
        self.abuse_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abuse_type(&mut self, v: u32) {
        self.abuse_type = ::std::option::Option::Some(v);
    }

    // optional uint32 content_type = 3;

    pub fn content_type(&self) -> u32 {
        self.content_type.unwrap_or(0)
    }

    pub fn clear_content_type(&mut self) {
        self.content_type = ::std::option::Option::None;
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: u32) {
        self.content_type = ::std::option::Option::Some(v);
    }

    // optional fixed32 target_game_server_ip = 6;

    pub fn target_game_server_ip(&self) -> u32 {
        self.target_game_server_ip.unwrap_or(0)
    }

    pub fn clear_target_game_server_ip(&mut self) {
        self.target_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_target_game_server_ip(&self) -> bool {
        self.target_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_ip(&mut self, v: u32) {
        self.target_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 target_game_server_port = 7;

    pub fn target_game_server_port(&self) -> u32 {
        self.target_game_server_port.unwrap_or(0)
    }

    pub fn clear_target_game_server_port(&mut self) {
        self.target_game_server_port = ::std::option::Option::None;
    }

    pub fn has_target_game_server_port(&self) -> bool {
        self.target_game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_port(&mut self, v: u32) {
        self.target_game_server_port = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCReportAbuse {
    const NAME: &'static str = "CMsgGCReportAbuse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.abuse_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.content_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.target_game_server_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.target_game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.abuse_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.content_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.target_game_server_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.target_game_server_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.gid {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.abuse_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.content_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.target_game_server_ip {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.target_game_server_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCReportAbuse {
        CMsgGCReportAbuse::new()
    }

    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.gid = ::std::option::Option::None;
        self.abuse_type = ::std::option::Option::None;
        self.content_type = ::std::option::Option::None;
        self.target_game_server_ip = ::std::option::Option::None;
        self.target_game_server_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCReportAbuse {
        static instance: CMsgGCReportAbuse = CMsgGCReportAbuse {
            target_steam_id: ::std::option::Option::None,
            description: ::std::option::Option::None,
            gid: ::std::option::Option::None,
            abuse_type: ::std::option::Option::None,
            content_type: ::std::option::Option::None,
            target_game_server_ip: ::std::option::Option::None,
            target_game_server_port: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCReportAbuseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCReportAbuseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCReportAbuseResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuseResponse {
    fn default() -> &'a CMsgGCReportAbuseResponse {
        <CMsgGCReportAbuseResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuseResponse {
    pub fn new() -> CMsgGCReportAbuseResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 2;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCReportAbuseResponse {
    const NAME: &'static str = "CMsgGCReportAbuseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCReportAbuseResponse {
        CMsgGCReportAbuseResponse::new()
    }

    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCReportAbuseResponse {
        static instance: CMsgGCReportAbuseResponse = CMsgGCReportAbuseResponse {
            target_steam_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCNameItemNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNameItemNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.player_steamid)
    pub player_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.item_name_custom)
    pub item_name_custom: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNameItemNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNameItemNotification {
    fn default() -> &'a CMsgGCNameItemNotification {
        <CMsgGCNameItemNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNameItemNotification {
    pub fn new() -> CMsgGCNameItemNotification {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;

    pub fn player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }

    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_index = 2;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional string item_name_custom = 3;

    pub fn item_name_custom(&self) -> &str {
        match self.item_name_custom.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_name_custom(&mut self) {
        self.item_name_custom = ::std::option::Option::None;
    }

    pub fn has_item_name_custom(&self) -> bool {
        self.item_name_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name_custom(&mut self, v: ::std::string::String) {
        self.item_name_custom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name_custom(&mut self) -> &mut ::std::string::String {
        if self.item_name_custom.is_none() {
            self.item_name_custom = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_name_custom.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name_custom(&mut self) -> ::std::string::String {
        self.item_name_custom.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNameItemNotification {
    const NAME: &'static str = "CMsgGCNameItemNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.player_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.item_name_custom = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_name_custom.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_name_custom.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNameItemNotification {
        CMsgGCNameItemNotification::new()
    }

    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.item_def_index = ::std::option::Option::None;
        self.item_name_custom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNameItemNotification {
        static instance: CMsgGCNameItemNotification = CMsgGCNameItemNotification {
            player_steamid: ::std::option::Option::None,
            item_def_index: ::std::option::Option::None,
            item_name_custom: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCClientDisplayNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientDisplayNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.notification_title_localization_key)
    pub notification_title_localization_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.notification_body_localization_key)
    pub notification_body_localization_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.body_substring_keys)
    pub body_substring_keys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.body_substring_values)
    pub body_substring_values: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientDisplayNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientDisplayNotification {
    fn default() -> &'a CMsgGCClientDisplayNotification {
        <CMsgGCClientDisplayNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientDisplayNotification {
    pub fn new() -> CMsgGCClientDisplayNotification {
        ::std::default::Default::default()
    }

    // optional string notification_title_localization_key = 1;

    pub fn notification_title_localization_key(&self) -> &str {
        match self.notification_title_localization_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_title_localization_key(&mut self) {
        self.notification_title_localization_key = ::std::option::Option::None;
    }

    pub fn has_notification_title_localization_key(&self) -> bool {
        self.notification_title_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_title_localization_key(&mut self, v: ::std::string::String) {
        self.notification_title_localization_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_title_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_title_localization_key.is_none() {
            self.notification_title_localization_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_title_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_title_localization_key(&mut self) -> ::std::string::String {
        self.notification_title_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string notification_body_localization_key = 2;

    pub fn notification_body_localization_key(&self) -> &str {
        match self.notification_body_localization_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_body_localization_key(&mut self) {
        self.notification_body_localization_key = ::std::option::Option::None;
    }

    pub fn has_notification_body_localization_key(&self) -> bool {
        self.notification_body_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_body_localization_key(&mut self, v: ::std::string::String) {
        self.notification_body_localization_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_body_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_body_localization_key.is_none() {
            self.notification_body_localization_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_body_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_body_localization_key(&mut self) -> ::std::string::String {
        self.notification_body_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCClientDisplayNotification {
    const NAME: &'static str = "CMsgGCClientDisplayNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notification_title_localization_key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.notification_body_localization_key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.body_substring_keys.push(is.read_string()?);
                },
                34 => {
                    self.body_substring_values.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification_title_localization_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.notification_body_localization_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        for value in &self.body_substring_keys {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &value);
        };
        for value in &self.body_substring_values {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.notification_title_localization_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.notification_body_localization_key.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.body_substring_keys {
            os.write_string(3, &v)?;
        };
        for v in &self.body_substring_values {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientDisplayNotification {
        CMsgGCClientDisplayNotification::new()
    }

    fn clear(&mut self) {
        self.notification_title_localization_key = ::std::option::Option::None;
        self.notification_body_localization_key = ::std::option::Option::None;
        self.body_substring_keys.clear();
        self.body_substring_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientDisplayNotification {
        static instance: CMsgGCClientDisplayNotification = CMsgGCClientDisplayNotification {
            notification_title_localization_key: ::std::option::Option::None,
            notification_body_localization_key: ::std::option::Option::None,
            body_substring_keys: ::std::vec::Vec::new(),
            body_substring_values: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCShowItemsPickedUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCShowItemsPickedUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCShowItemsPickedUp.player_steamid)
    pub player_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCShowItemsPickedUp.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCShowItemsPickedUp {
    fn default() -> &'a CMsgGCShowItemsPickedUp {
        <CMsgGCShowItemsPickedUp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShowItemsPickedUp {
    pub fn new() -> CMsgGCShowItemsPickedUp {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;

    pub fn player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }

    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCShowItemsPickedUp {
    const NAME: &'static str = "CMsgGCShowItemsPickedUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.player_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCShowItemsPickedUp {
        CMsgGCShowItemsPickedUp::new()
    }

    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCShowItemsPickedUp {
        static instance: CMsgGCShowItemsPickedUp = CMsgGCShowItemsPickedUp {
            player_steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUpdatePeriodicEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpdatePeriodicEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdatePeriodicEvent.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdatePeriodicEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdatePeriodicEvent.amount)
    pub amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdatePeriodicEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdatePeriodicEvent {
    fn default() -> &'a CMsgUpdatePeriodicEvent {
        <CMsgUpdatePeriodicEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdatePeriodicEvent {
    pub fn new() -> CMsgUpdatePeriodicEvent {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 2;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 amount = 3;

    pub fn amount(&self) -> u32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u32) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUpdatePeriodicEvent {
    const NAME: &'static str = "CMsgUpdatePeriodicEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdatePeriodicEvent {
        CMsgUpdatePeriodicEvent::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdatePeriodicEvent {
        static instance: CMsgUpdatePeriodicEvent = CMsgUpdatePeriodicEvent {
            account_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCIncrementKillCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCIncrementKillCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.killer_account_id)
    pub killer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.num_kills)
    pub num_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.level_type)
    pub level_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCIncrementKillCountResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCIncrementKillCountResponse {
    fn default() -> &'a CMsgGCIncrementKillCountResponse {
        <CMsgGCIncrementKillCountResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCIncrementKillCountResponse {
    pub fn new() -> CMsgGCIncrementKillCountResponse {
        ::std::default::Default::default()
    }

    // optional uint32 killer_account_id = 1;

    pub fn killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }

    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_kills = 2;

    pub fn num_kills(&self) -> u32 {
        self.num_kills.unwrap_or(0)
    }

    pub fn clear_num_kills(&mut self) {
        self.num_kills = ::std::option::Option::None;
    }

    pub fn has_num_kills(&self) -> bool {
        self.num_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_kills(&mut self, v: u32) {
        self.num_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 3;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 level_type = 4;

    pub fn level_type(&self) -> u32 {
        self.level_type.unwrap_or(0)
    }

    pub fn clear_level_type(&mut self) {
        self.level_type = ::std::option::Option::None;
    }

    pub fn has_level_type(&self) -> bool {
        self.level_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_type(&mut self, v: u32) {
        self.level_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCIncrementKillCountResponse {
    const NAME: &'static str = "CMsgGCIncrementKillCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.killer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.level_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.level_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.killer_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.level_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCIncrementKillCountResponse {
        CMsgGCIncrementKillCountResponse::new()
    }

    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.num_kills = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.level_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCIncrementKillCountResponse {
        static instance: CMsgGCIncrementKillCountResponse = CMsgGCIncrementKillCountResponse {
            killer_account_id: ::std::option::Option::None,
            num_kills: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            level_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRemoveStrangePart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRemoveStrangePart {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRemoveStrangePart.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCRemoveStrangePart.strange_part_score_type)
    pub strange_part_score_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRemoveStrangePart.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveStrangePart {
    fn default() -> &'a CMsgGCRemoveStrangePart {
        <CMsgGCRemoveStrangePart as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveStrangePart {
    pub fn new() -> CMsgGCRemoveStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_part_score_type = 2;

    pub fn strange_part_score_type(&self) -> u32 {
        self.strange_part_score_type.unwrap_or(0)
    }

    pub fn clear_strange_part_score_type(&mut self) {
        self.strange_part_score_type = ::std::option::Option::None;
    }

    pub fn has_strange_part_score_type(&self) -> bool {
        self.strange_part_score_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_score_type(&mut self, v: u32) {
        self.strange_part_score_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRemoveStrangePart {
    const NAME: &'static str = "CMsgGCRemoveStrangePart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.strange_part_score_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.strange_part_score_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.strange_part_score_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRemoveStrangePart {
        CMsgGCRemoveStrangePart::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.strange_part_score_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRemoveStrangePart {
        static instance: CMsgGCRemoveStrangePart = CMsgGCRemoveStrangePart {
            item_id: ::std::option::Option::None,
            strange_part_score_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRemoveUpgradeCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRemoveUpgradeCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRemoveUpgradeCard.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCRemoveUpgradeCard.attribute_index)
    pub attribute_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRemoveUpgradeCard.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveUpgradeCard {
    fn default() -> &'a CMsgGCRemoveUpgradeCard {
        <CMsgGCRemoveUpgradeCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveUpgradeCard {
    pub fn new() -> CMsgGCRemoveUpgradeCard {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attribute_index = 2;

    pub fn attribute_index(&self) -> u32 {
        self.attribute_index.unwrap_or(0)
    }

    pub fn clear_attribute_index(&mut self) {
        self.attribute_index = ::std::option::Option::None;
    }

    pub fn has_attribute_index(&self) -> bool {
        self.attribute_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_index(&mut self, v: u32) {
        self.attribute_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRemoveUpgradeCard {
    const NAME: &'static str = "CMsgGCRemoveUpgradeCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.attribute_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.attribute_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attribute_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRemoveUpgradeCard {
        CMsgGCRemoveUpgradeCard::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.attribute_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRemoveUpgradeCard {
        static instance: CMsgGCRemoveUpgradeCard = CMsgGCRemoveUpgradeCard {
            item_id: ::std::option::Option::None,
            attribute_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRemoveCustomizationAttributeSimple)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRemoveCustomizationAttributeSimple {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRemoveCustomizationAttributeSimple.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRemoveCustomizationAttributeSimple.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveCustomizationAttributeSimple {
    fn default() -> &'a CMsgGCRemoveCustomizationAttributeSimple {
        <CMsgGCRemoveCustomizationAttributeSimple as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveCustomizationAttributeSimple {
    pub fn new() -> CMsgGCRemoveCustomizationAttributeSimple {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRemoveCustomizationAttributeSimple {
    const NAME: &'static str = "CMsgGCRemoveCustomizationAttributeSimple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRemoveCustomizationAttributeSimple {
        CMsgGCRemoveCustomizationAttributeSimple::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRemoveCustomizationAttributeSimple {
        static instance: CMsgGCRemoveCustomizationAttributeSimple = CMsgGCRemoveCustomizationAttributeSimple {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCResetStrangeScores)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCResetStrangeScores {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCResetStrangeScores.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCResetStrangeScores.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCResetStrangeScores {
    fn default() -> &'a CMsgGCResetStrangeScores {
        <CMsgGCResetStrangeScores as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCResetStrangeScores {
    pub fn new() -> CMsgGCResetStrangeScores {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCResetStrangeScores {
    const NAME: &'static str = "CMsgGCResetStrangeScores";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCResetStrangeScores {
        CMsgGCResetStrangeScores::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCResetStrangeScores {
        static instance: CMsgGCResetStrangeScores = CMsgGCResetStrangeScores {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCItemPreviewItemBoughtNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemPreviewItemBoughtNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemPreviewItemBoughtNotification.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemPreviewItemBoughtNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemPreviewItemBoughtNotification {
    fn default() -> &'a CMsgGCItemPreviewItemBoughtNotification {
        <CMsgGCItemPreviewItemBoughtNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemPreviewItemBoughtNotification {
    pub fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemPreviewItemBoughtNotification {
    const NAME: &'static str = "CMsgGCItemPreviewItemBoughtNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        CMsgGCItemPreviewItemBoughtNotification::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemPreviewItemBoughtNotification {
        static instance: CMsgGCItemPreviewItemBoughtNotification = CMsgGCItemPreviewItemBoughtNotification {
            item_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseCancel {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancel.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancel {
    fn default() -> &'a CMsgGCStorePurchaseCancel {
        <CMsgGCStorePurchaseCancel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancel {
    pub fn new() -> CMsgGCStorePurchaseCancel {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseCancel {
    const NAME: &'static str = "CMsgGCStorePurchaseCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancel {
        CMsgGCStorePurchaseCancel::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancel {
        static instance: CMsgGCStorePurchaseCancel = CMsgGCStorePurchaseCancel {
            txn_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseCancelResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancelResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancelResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancelResponse {
    fn default() -> &'a CMsgGCStorePurchaseCancelResponse {
        <CMsgGCStorePurchaseCancelResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancelResponse {
    pub fn new() -> CMsgGCStorePurchaseCancelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseCancelResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseCancelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancelResponse {
        CMsgGCStorePurchaseCancelResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancelResponse {
        static instance: CMsgGCStorePurchaseCancelResponse = CMsgGCStorePurchaseCancelResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseFinalize {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalize.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalize.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalize {
    fn default() -> &'a CMsgGCStorePurchaseFinalize {
        <CMsgGCStorePurchaseFinalize as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalize {
    pub fn new() -> CMsgGCStorePurchaseFinalize {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseFinalize {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalize {
        CMsgGCStorePurchaseFinalize::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalize {
        static instance: CMsgGCStorePurchaseFinalize = CMsgGCStorePurchaseFinalize {
            txn_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseFinalizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalizeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalizeResponse {
    fn default() -> &'a CMsgGCStorePurchaseFinalizeResponse {
        <CMsgGCStorePurchaseFinalizeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalizeResponse {
    pub fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseFinalizeResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        CMsgGCStorePurchaseFinalizeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalizeResponse {
        static instance: CMsgGCStorePurchaseFinalizeResponse = CMsgGCStorePurchaseFinalizeResponse {
            result: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCBannedWordListRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCBannedWordListRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCBannedWordListRequest.ban_list_group_id)
    pub ban_list_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCBannedWordListRequest.word_id)
    pub word_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCBannedWordListRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWordListRequest {
    fn default() -> &'a CMsgGCBannedWordListRequest {
        <CMsgGCBannedWordListRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWordListRequest {
    pub fn new() -> CMsgGCBannedWordListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 ban_list_group_id = 1;

    pub fn ban_list_group_id(&self) -> u32 {
        self.ban_list_group_id.unwrap_or(0)
    }

    pub fn clear_ban_list_group_id(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
    }

    pub fn has_ban_list_group_id(&self) -> bool {
        self.ban_list_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_list_group_id(&mut self, v: u32) {
        self.ban_list_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 word_id = 2;

    pub fn word_id(&self) -> u32 {
        self.word_id.unwrap_or(0)
    }

    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: u32) {
        self.word_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCBannedWordListRequest {
    const NAME: &'static str = "CMsgGCBannedWordListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ban_list_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.word_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ban_list_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.word_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ban_list_group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.word_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBannedWordListRequest {
        CMsgGCBannedWordListRequest::new()
    }

    fn clear(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
        self.word_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBannedWordListRequest {
        static instance: CMsgGCBannedWordListRequest = CMsgGCBannedWordListRequest {
            ban_list_group_id: ::std::option::Option::None,
            word_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGiftedItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGiftedItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGiftedItems.gifter_steam_id)
    pub gifter_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCGiftedItems.was_random_person)
    pub was_random_person: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCGiftedItems.recipient_account_ids)
    pub recipient_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGiftedItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGiftedItems {
    fn default() -> &'a CMsgGCGiftedItems {
        <CMsgGCGiftedItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGiftedItems {
    pub fn new() -> CMsgGCGiftedItems {
        ::std::default::Default::default()
    }

    // optional uint64 gifter_steam_id = 1;

    pub fn gifter_steam_id(&self) -> u64 {
        self.gifter_steam_id.unwrap_or(0)
    }

    pub fn clear_gifter_steam_id(&mut self) {
        self.gifter_steam_id = ::std::option::Option::None;
    }

    pub fn has_gifter_steam_id(&self) -> bool {
        self.gifter_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifter_steam_id(&mut self, v: u64) {
        self.gifter_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool was_random_person = 2;

    pub fn was_random_person(&self) -> bool {
        self.was_random_person.unwrap_or(false)
    }

    pub fn clear_was_random_person(&mut self) {
        self.was_random_person = ::std::option::Option::None;
    }

    pub fn has_was_random_person(&self) -> bool {
        self.was_random_person.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_random_person(&mut self, v: bool) {
        self.was_random_person = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGiftedItems {
    const NAME: &'static str = "CMsgGCGiftedItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gifter_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.was_random_person = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.recipient_account_ids)?;
                },
                24 => {
                    self.recipient_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gifter_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.was_random_person {
            my_size += 1 + 1;
        }
        for value in &self.recipient_account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gifter_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.was_random_person {
            os.write_bool(2, v)?;
        }
        for v in &self.recipient_account_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGiftedItems {
        CMsgGCGiftedItems::new()
    }

    fn clear(&mut self) {
        self.gifter_steam_id = ::std::option::Option::None;
        self.was_random_person = ::std::option::Option::None;
        self.recipient_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGiftedItems {
        static instance: CMsgGCGiftedItems = CMsgGCGiftedItems {
            gifter_steam_id: ::std::option::Option::None,
            was_random_person: ::std::option::Option::None,
            recipient_account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCCollectItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCollectItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCollectItem.collection_item_id)
    pub collection_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCollectItem.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCollectItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCollectItem {
    fn default() -> &'a CMsgGCCollectItem {
        <CMsgGCCollectItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCollectItem {
    pub fn new() -> CMsgGCCollectItem {
        ::std::default::Default::default()
    }

    // optional uint64 collection_item_id = 1;

    pub fn collection_item_id(&self) -> u64 {
        self.collection_item_id.unwrap_or(0)
    }

    pub fn clear_collection_item_id(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
    }

    pub fn has_collection_item_id(&self) -> bool {
        self.collection_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collection_item_id(&mut self, v: u64) {
        self.collection_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCCollectItem {
    const NAME: &'static str = "CMsgGCCollectItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.collection_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.collection_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.collection_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCollectItem {
        CMsgGCCollectItem::new()
    }

    fn clear(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCollectItem {
        static instance: CMsgGCCollectItem = CMsgGCCollectItem {
            collection_item_id: ::std::option::Option::None,
            subject_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCClientMarketDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientMarketDataRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataRequest.user_currency)
    pub user_currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientMarketDataRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketDataRequest {
    fn default() -> &'a CMsgGCClientMarketDataRequest {
        <CMsgGCClientMarketDataRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketDataRequest {
    pub fn new() -> CMsgGCClientMarketDataRequest {
        ::std::default::Default::default()
    }

    // optional uint32 user_currency = 1;

    pub fn user_currency(&self) -> u32 {
        self.user_currency.unwrap_or(0)
    }

    pub fn clear_user_currency(&mut self) {
        self.user_currency = ::std::option::Option::None;
    }

    pub fn has_user_currency(&self) -> bool {
        self.user_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_currency(&mut self, v: u32) {
        self.user_currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCClientMarketDataRequest {
    const NAME: &'static str = "CMsgGCClientMarketDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.user_currency {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientMarketDataRequest {
        CMsgGCClientMarketDataRequest::new()
    }

    fn clear(&mut self) {
        self.user_currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientMarketDataRequest {
        static instance: CMsgGCClientMarketDataRequest = CMsgGCClientMarketDataRequest {
            user_currency: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCClientMarketDataEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientMarketDataEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.item_sell_listings)
    pub item_sell_listings: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.price_in_local_currency)
    pub price_in_local_currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientMarketDataEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketDataEntry {
    fn default() -> &'a CMsgGCClientMarketDataEntry {
        <CMsgGCClientMarketDataEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketDataEntry {
    pub fn new() -> CMsgGCClientMarketDataEntry {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 item_sell_listings = 3;

    pub fn item_sell_listings(&self) -> u32 {
        self.item_sell_listings.unwrap_or(0)
    }

    pub fn clear_item_sell_listings(&mut self) {
        self.item_sell_listings = ::std::option::Option::None;
    }

    pub fn has_item_sell_listings(&self) -> bool {
        self.item_sell_listings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_sell_listings(&mut self, v: u32) {
        self.item_sell_listings = ::std::option::Option::Some(v);
    }

    // optional uint32 price_in_local_currency = 4;

    pub fn price_in_local_currency(&self) -> u32 {
        self.price_in_local_currency.unwrap_or(0)
    }

    pub fn clear_price_in_local_currency(&mut self) {
        self.price_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_price_in_local_currency(&self) -> bool {
        self.price_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_in_local_currency(&mut self, v: u32) {
        self.price_in_local_currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCClientMarketDataEntry {
    const NAME: &'static str = "CMsgGCClientMarketDataEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_sell_listings = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.price_in_local_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_sell_listings {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.price_in_local_currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_sell_listings {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.price_in_local_currency {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientMarketDataEntry {
        CMsgGCClientMarketDataEntry::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_sell_listings = ::std::option::Option::None;
        self.price_in_local_currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientMarketDataEntry {
        static instance: CMsgGCClientMarketDataEntry = CMsgGCClientMarketDataEntry {
            item_def_index: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            item_sell_listings: ::std::option::Option::None,
            price_in_local_currency: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCClientMarketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientMarketData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientMarketData.entries)
    pub entries: ::std::vec::Vec<CMsgGCClientMarketDataEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientMarketData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketData {
    fn default() -> &'a CMsgGCClientMarketData {
        <CMsgGCClientMarketData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketData {
    pub fn new() -> CMsgGCClientMarketData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCClientMarketData {
    const NAME: &'static str = "CMsgGCClientMarketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientMarketData {
        CMsgGCClientMarketData::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientMarketData {
        static instance: CMsgGCClientMarketData = CMsgGCClientMarketData {
            entries: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyToolToItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyToolToItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyToolToItem.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyToolToItem.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyToolToItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyToolToItem {
    fn default() -> &'a CMsgApplyToolToItem {
        <CMsgApplyToolToItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyToolToItem {
    pub fn new() -> CMsgApplyToolToItem {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyToolToItem {
    const NAME: &'static str = "CMsgApplyToolToItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyToolToItem {
        CMsgApplyToolToItem::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyToolToItem {
        static instance: CMsgApplyToolToItem = CMsgApplyToolToItem {
            tool_item_id: ::std::option::Option::None,
            subject_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyToolToBaseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyToolToBaseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyToolToBaseItem.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyToolToBaseItem.baseitem_def_index)
    pub baseitem_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyToolToBaseItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyToolToBaseItem {
    fn default() -> &'a CMsgApplyToolToBaseItem {
        <CMsgApplyToolToBaseItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyToolToBaseItem {
    pub fn new() -> CMsgApplyToolToBaseItem {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 baseitem_def_index = 2;

    pub fn baseitem_def_index(&self) -> u32 {
        self.baseitem_def_index.unwrap_or(0)
    }

    pub fn clear_baseitem_def_index(&mut self) {
        self.baseitem_def_index = ::std::option::Option::None;
    }

    pub fn has_baseitem_def_index(&self) -> bool {
        self.baseitem_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseitem_def_index(&mut self, v: u32) {
        self.baseitem_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyToolToBaseItem {
    const NAME: &'static str = "CMsgApplyToolToBaseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.baseitem_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.baseitem_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.baseitem_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyToolToBaseItem {
        CMsgApplyToolToBaseItem::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.baseitem_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyToolToBaseItem {
        static instance: CMsgApplyToolToBaseItem = CMsgApplyToolToBaseItem {
            tool_item_id: ::std::option::Option::None,
            baseitem_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRecipeComponent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:CMsgRecipeComponent.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRecipeComponent.attribute_index)
    pub attribute_index: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRecipeComponent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRecipeComponent {
    fn default() -> &'a CMsgRecipeComponent {
        <CMsgRecipeComponent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRecipeComponent {
    pub fn new() -> CMsgRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint64 subject_item_id = 1;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 attribute_index = 2;

    pub fn attribute_index(&self) -> u64 {
        self.attribute_index.unwrap_or(0)
    }

    pub fn clear_attribute_index(&mut self) {
        self.attribute_index = ::std::option::Option::None;
    }

    pub fn has_attribute_index(&self) -> bool {
        self.attribute_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_index(&mut self, v: u64) {
        self.attribute_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRecipeComponent {
    const NAME: &'static str = "CMsgRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.attribute_index = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subject_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.attribute_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.subject_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attribute_index {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRecipeComponent {
        CMsgRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
        self.attribute_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRecipeComponent {
        static instance: CMsgRecipeComponent = CMsgRecipeComponent {
            subject_item_id: ::std::option::Option::None,
            attribute_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFulfillDynamicRecipeComponent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFulfillDynamicRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:CMsgFulfillDynamicRecipeComponent.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgFulfillDynamicRecipeComponent.consumption_components)
    pub consumption_components: ::std::vec::Vec<CMsgRecipeComponent>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFulfillDynamicRecipeComponent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFulfillDynamicRecipeComponent {
    fn default() -> &'a CMsgFulfillDynamicRecipeComponent {
        <CMsgFulfillDynamicRecipeComponent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFulfillDynamicRecipeComponent {
    pub fn new() -> CMsgFulfillDynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFulfillDynamicRecipeComponent {
    const NAME: &'static str = "CMsgFulfillDynamicRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.consumption_components.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.consumption_components {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.consumption_components {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFulfillDynamicRecipeComponent {
        CMsgFulfillDynamicRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.consumption_components.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFulfillDynamicRecipeComponent {
        static instance: CMsgFulfillDynamicRecipeComponent = CMsgFulfillDynamicRecipeComponent {
            tool_item_id: ::std::option::Option::None,
            consumption_components: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetItemEffectVerticalOffset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetItemEffectVerticalOffset {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemEffectVerticalOffset.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetItemEffectVerticalOffset.offset)
    pub offset: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemEffectVerticalOffset.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemEffectVerticalOffset {
    fn default() -> &'a CMsgSetItemEffectVerticalOffset {
        <CMsgSetItemEffectVerticalOffset as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemEffectVerticalOffset {
    pub fn new() -> CMsgSetItemEffectVerticalOffset {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional float offset = 2;

    pub fn offset(&self) -> f32 {
        self.offset.unwrap_or(0.)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: f32) {
        self.offset = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetItemEffectVerticalOffset {
    const NAME: &'static str = "CMsgSetItemEffectVerticalOffset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.offset = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemEffectVerticalOffset {
        CMsgSetItemEffectVerticalOffset::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemEffectVerticalOffset {
        static instance: CMsgSetItemEffectVerticalOffset = CMsgSetItemEffectVerticalOffset {
            item_id: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetHatEffectUseHeadOrigin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetHatEffectUseHeadOrigin {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHatEffectUseHeadOrigin.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetHatEffectUseHeadOrigin.use_head)
    pub use_head: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHatEffectUseHeadOrigin.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHatEffectUseHeadOrigin {
    fn default() -> &'a CMsgSetHatEffectUseHeadOrigin {
        <CMsgSetHatEffectUseHeadOrigin as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHatEffectUseHeadOrigin {
    pub fn new() -> CMsgSetHatEffectUseHeadOrigin {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional bool use_head = 2;

    pub fn use_head(&self) -> bool {
        self.use_head.unwrap_or(false)
    }

    pub fn clear_use_head(&mut self) {
        self.use_head = ::std::option::Option::None;
    }

    pub fn has_use_head(&self) -> bool {
        self.use_head.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_head(&mut self, v: bool) {
        self.use_head = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetHatEffectUseHeadOrigin {
    const NAME: &'static str = "CMsgSetHatEffectUseHeadOrigin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.use_head = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.use_head {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.use_head {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHatEffectUseHeadOrigin {
        CMsgSetHatEffectUseHeadOrigin::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.use_head = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHatEffectUseHeadOrigin {
        static instance: CMsgSetHatEffectUseHeadOrigin = CMsgSetHatEffectUseHeadOrigin {
            item_id: ::std::option::Option::None,
            use_head: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDeliverGiftResponseGiver)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDeliverGiftResponseGiver {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeliverGiftResponseGiver.response_code)
    pub response_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDeliverGiftResponseGiver.receiver_account_name)
    pub receiver_account_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeliverGiftResponseGiver.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeliverGiftResponseGiver {
    fn default() -> &'a CMsgDeliverGiftResponseGiver {
        <CMsgDeliverGiftResponseGiver as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDeliverGiftResponseGiver {
    pub fn new() -> CMsgDeliverGiftResponseGiver {
        ::std::default::Default::default()
    }

    // optional uint32 response_code = 1;

    pub fn response_code(&self) -> u32 {
        self.response_code.unwrap_or(0)
    }

    pub fn clear_response_code(&mut self) {
        self.response_code = ::std::option::Option::None;
    }

    pub fn has_response_code(&self) -> bool {
        self.response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: u32) {
        self.response_code = ::std::option::Option::Some(v);
    }

    // optional string receiver_account_name = 2;

    pub fn receiver_account_name(&self) -> &str {
        match self.receiver_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_receiver_account_name(&mut self) {
        self.receiver_account_name = ::std::option::Option::None;
    }

    pub fn has_receiver_account_name(&self) -> bool {
        self.receiver_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_account_name(&mut self, v: ::std::string::String) {
        self.receiver_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver_account_name(&mut self) -> &mut ::std::string::String {
        if self.receiver_account_name.is_none() {
            self.receiver_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.receiver_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_receiver_account_name(&mut self) -> ::std::string::String {
        self.receiver_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDeliverGiftResponseGiver {
    const NAME: &'static str = "CMsgDeliverGiftResponseGiver";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.receiver_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.receiver_account_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response_code {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.receiver_account_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeliverGiftResponseGiver {
        CMsgDeliverGiftResponseGiver::new()
    }

    fn clear(&mut self) {
        self.response_code = ::std::option::Option::None;
        self.receiver_account_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeliverGiftResponseGiver {
        static instance: CMsgDeliverGiftResponseGiver = CMsgDeliverGiftResponseGiver {
            response_code: ::std::option::Option::None,
            receiver_account_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconGameAccountForGameServers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconGameAccountForGameServers {
    // message fields
    // @@protoc_insertion_point(field:CSOEconGameAccountForGameServers.disable_party_quest_progress)
    pub disable_party_quest_progress: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconGameAccountForGameServers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountForGameServers {
    fn default() -> &'a CSOEconGameAccountForGameServers {
        <CSOEconGameAccountForGameServers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountForGameServers {
    pub fn new() -> CSOEconGameAccountForGameServers {
        ::std::default::Default::default()
    }

    // optional bool disable_party_quest_progress = 6;

    pub fn disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.unwrap_or(false)
    }

    pub fn clear_disable_party_quest_progress(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
    }

    pub fn has_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_party_quest_progress(&mut self, v: bool) {
        self.disable_party_quest_progress = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconGameAccountForGameServers {
    const NAME: &'static str = "CSOEconGameAccountForGameServers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.disable_party_quest_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.disable_party_quest_progress {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.disable_party_quest_progress {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconGameAccountForGameServers {
        CSOEconGameAccountForGameServers::new()
    }

    fn clear(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconGameAccountForGameServers {
        static instance: CSOEconGameAccountForGameServers = CSOEconGameAccountForGameServers {
            disable_party_quest_progress: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_PopulateItemDescriptions_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.languages)
    pub languages: ::std::vec::Vec<cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request {
        <CWorkshop_PopulateItemDescriptions_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request {
    const NAME: &'static str = "CWorkshop_PopulateItemDescriptions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        CWorkshop_PopulateItemDescriptions_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request {
        static instance: CWorkshop_PopulateItemDescriptions_Request = CWorkshop_PopulateItemDescriptions_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_PopulateItemDescriptions_Request`
pub mod cworkshop_populate_item_descriptions_request {
    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleItemDescription {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.gameitemid)
        pub gameitemid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description)
        pub item_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleItemDescription {
        fn default() -> &'a SingleItemDescription {
            <SingleItemDescription as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleItemDescription {
        pub fn new() -> SingleItemDescription {
            ::std::default::Default::default()
        }

        // optional uint32 gameitemid = 1;

        pub fn gameitemid(&self) -> u32 {
            self.gameitemid.unwrap_or(0)
        }

        pub fn clear_gameitemid(&mut self) {
            self.gameitemid = ::std::option::Option::None;
        }

        pub fn has_gameitemid(&self) -> bool {
            self.gameitemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameitemid(&mut self, v: u32) {
            self.gameitemid = ::std::option::Option::Some(v);
        }

        // optional string item_description = 2;

        pub fn item_description(&self) -> &str {
            match self.item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_item_description(&mut self) {
            self.item_description = ::std::option::Option::None;
        }

        pub fn has_item_description(&self) -> bool {
            self.item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_description(&mut self, v: ::std::string::String) {
            self.item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
            if self.item_description.is_none() {
                self.item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_description(&mut self) -> ::std::string::String {
            self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleItemDescription {
        const NAME: &'static str = "SingleItemDescription";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gameitemid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.gameitemid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleItemDescription {
            SingleItemDescription::new()
        }

        fn clear(&mut self) {
            self.gameitemid = ::std::option::Option::None;
            self.item_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleItemDescription {
            static instance: SingleItemDescription = SingleItemDescription {
                gameitemid: ::std::option::Option::None,
                item_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDescriptionsLanguageBlock {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.descriptions)
        pub descriptions: ::std::vec::Vec<SingleItemDescription>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDescriptionsLanguageBlock {
        fn default() -> &'a ItemDescriptionsLanguageBlock {
            <ItemDescriptionsLanguageBlock as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemDescriptionsLanguageBlock {
        pub fn new() -> ItemDescriptionsLanguageBlock {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemDescriptionsLanguageBlock {
        const NAME: &'static str = "ItemDescriptionsLanguageBlock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.descriptions.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            for value in &self.descriptions {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.descriptions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDescriptionsLanguageBlock {
            ItemDescriptionsLanguageBlock::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.descriptions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDescriptionsLanguageBlock {
            static instance: ItemDescriptionsLanguageBlock = ItemDescriptionsLanguageBlock {
                language: ::std::option::Option::None,
                descriptions: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Request {
    fn default() -> &'a CWorkshop_GetContributors_Request {
        <CWorkshop_GetContributors_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Request {
    pub fn new() -> CWorkshop_GetContributors_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetContributors_Request {
    const NAME: &'static str = "CWorkshop_GetContributors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Request {
        CWorkshop_GetContributors_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Request {
        static instance: CWorkshop_GetContributors_Request = CWorkshop_GetContributors_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Response.contributors)
    pub contributors: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Response {
    fn default() -> &'a CWorkshop_GetContributors_Response {
        <CWorkshop_GetContributors_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Response {
    pub fn new() -> CWorkshop_GetContributors_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetContributors_Response {
    const NAME: &'static str = "CWorkshop_GetContributors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.contributors)?;
                },
                9 => {
                    self.contributors.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.contributors.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.contributors {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Response {
        CWorkshop_GetContributors_Response::new()
    }

    fn clear(&mut self) {
        self.contributors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Response {
        static instance: CWorkshop_GetContributors_Response = CWorkshop_GetContributors_Response {
            contributors: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_files)
    pub associated_workshop_files: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.partner_accounts)
    pub partner_accounts: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request {
        <CWorkshop_SetItemPaymentRules_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_SetItemPaymentRules_Request {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.associated_workshop_files.push(is.read_message()?);
                },
                34 => {
                    self.partner_accounts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.associated_workshop_files {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.partner_accounts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        for v in &self.associated_workshop_files {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.partner_accounts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request {
        CWorkshop_SetItemPaymentRules_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.associated_workshop_files.clear();
        self.partner_accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request {
        static instance: CWorkshop_SetItemPaymentRules_Request = CWorkshop_SetItemPaymentRules_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            associated_workshop_files: ::std::vec::Vec::new(),
            partner_accounts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_SetItemPaymentRules_Request`
pub mod cworkshop_set_item_payment_rules_request {
    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemPaymentRule {
        fn default() -> &'a WorkshopItemPaymentRule {
            <WorkshopItemPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemPaymentRule {
        pub fn new() -> WorkshopItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WorkshopItemPaymentRule {
        const NAME: &'static str = "WorkshopItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemPaymentRule {
            WorkshopItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemPaymentRule {
            static instance: WorkshopItemPaymentRule = WorkshopItemPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartnerItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerItemPaymentRule {
        fn default() -> &'a PartnerItemPaymentRule {
            <PartnerItemPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PartnerItemPaymentRule {
        pub fn new() -> PartnerItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PartnerItemPaymentRule {
        const NAME: &'static str = "PartnerItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerItemPaymentRule {
            PartnerItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerItemPaymentRule {
            static instance: PartnerItemPaymentRule = PartnerItemPaymentRule {
                account_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Response {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Response {
        <CWorkshop_SetItemPaymentRules_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Response {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_SetItemPaymentRules_Response {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Response {
        CWorkshop_SetItemPaymentRules_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Response {
        static instance: CWorkshop_SetItemPaymentRules_Response = CWorkshop_SetItemPaymentRules_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCBaseMsg)
pub enum EGCBaseMsg {
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCSystemMessage)
    k_EMsgGCSystemMessage = 4001,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCReplicateConVars)
    k_EMsgGCReplicateConVars = 4002,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCConVarUpdated)
    k_EMsgGCConVarUpdated = 4003,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCServerAvailable)
    k_EMsgGCServerAvailable = 4506,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCClientConnectToServer)
    k_EMsgGCClientConnectToServer = 4507,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCGameServerInfo)
    k_EMsgGCGameServerInfo = 4508,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCError)
    k_EMsgGCError = 4509,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCReplay_UploadedToYouTube)
    k_EMsgGCReplay_UploadedToYouTube = 4510,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCLANServerAvailable)
    k_EMsgGCLANServerAvailable = 4511,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGCBaseMsg {
    const NAME: &'static str = "EGCBaseMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseMsg> {
        match value {
            4001 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCSystemMessage),
            4002 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            4003 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            4506 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            4507 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            4508 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            4509 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCError),
            4510 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube),
            4511 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCBaseMsg> {
        match str {
            "k_EMsgGCSystemMessage" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCSystemMessage),
            "k_EMsgGCReplicateConVars" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            "k_EMsgGCConVarUpdated" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            "k_EMsgGCServerAvailable" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            "k_EMsgGCClientConnectToServer" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            "k_EMsgGCGameServerInfo" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            "k_EMsgGCError" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCError),
            "k_EMsgGCReplay_UploadedToYouTube" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube),
            "k_EMsgGCLANServerAvailable" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseMsg] = &[
        EGCBaseMsg::k_EMsgGCSystemMessage,
        EGCBaseMsg::k_EMsgGCReplicateConVars,
        EGCBaseMsg::k_EMsgGCConVarUpdated,
        EGCBaseMsg::k_EMsgGCServerAvailable,
        EGCBaseMsg::k_EMsgGCClientConnectToServer,
        EGCBaseMsg::k_EMsgGCGameServerInfo,
        EGCBaseMsg::k_EMsgGCError,
        EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube,
        EGCBaseMsg::k_EMsgGCLANServerAvailable,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseMsg {
    fn default() -> Self {
        EGCBaseMsg::k_EMsgGCSystemMessage
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCBaseProtoObjectTypes)
pub enum EGCBaseProtoObjectTypes {
    // @@protoc_insertion_point(enum_value:EGCBaseProtoObjectTypes.k_EProtoObjectPartyInvite)
    k_EProtoObjectPartyInvite = 1001,
    // @@protoc_insertion_point(enum_value:EGCBaseProtoObjectTypes.k_EProtoObjectLobbyInvite)
    k_EProtoObjectLobbyInvite = 1002,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGCBaseProtoObjectTypes {
    const NAME: &'static str = "EGCBaseProtoObjectTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseProtoObjectTypes> {
        match value {
            1001 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite),
            1002 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCBaseProtoObjectTypes> {
        match str {
            "k_EProtoObjectPartyInvite" => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite),
            "k_EProtoObjectLobbyInvite" => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseProtoObjectTypes] = &[
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite,
        EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseProtoObjectTypes {
    fn default() -> Self {
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCGoodbyeReason)
pub enum GCGoodbyeReason {
    // @@protoc_insertion_point(enum_value:GCGoodbyeReason.GCGoodbyeReason_GC_GOING_DOWN)
    GCGoodbyeReason_GC_GOING_DOWN = 1,
    // @@protoc_insertion_point(enum_value:GCGoodbyeReason.GCGoodbyeReason_NO_SESSION)
    GCGoodbyeReason_NO_SESSION = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for GCGoodbyeReason {
    const NAME: &'static str = "GCGoodbyeReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCGoodbyeReason> {
        match value {
            1 => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_NO_SESSION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCGoodbyeReason> {
        match str {
            "GCGoodbyeReason_GC_GOING_DOWN" => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            "GCGoodbyeReason_NO_SESSION" => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_NO_SESSION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCGoodbyeReason] = &[
        GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN,
        GCGoodbyeReason::GCGoodbyeReason_NO_SESSION,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GCGoodbyeReason {
    fn default() -> Self {
        GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
impl ::steam_vent_proto_common::RpcMessage for CGCStorePurchaseInit_LineItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseInit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseInitResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSystemBroadcast {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientHello {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientHello {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCClientHello;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerHello {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerHello {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCServerHello;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientWelcome {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientWelcome {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCClientWelcome;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerWelcome {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerWelcome {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCServerWelcome;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientGoodbye {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientGoodbye {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCClientGoodbye;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerGoodbye {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerGoodbye {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCServerGoodbye;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerAvailable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerAvailable {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCServerAvailable;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLANServerAvailable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgLANServerAvailable {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCLANServerAvailable;
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconGameAccountClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOItemCriteriaCondition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOItemCriteria {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOItemRecipe {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevNewItemRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevDebugRollLootRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgIncrementKillCountAttribute {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgIncrementKillCountAttribute_Multiple {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTrackUniquePlayerPairEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyStrangeCountTransfer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyStrangeCountTransfer {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyStrangePart {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyStrangePart {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyStrangePart;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyStrangeRestriction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyStrangeRestriction {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyStrangeRestriction;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyUpgradeCard {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyUpgradeCard {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyUpgradeCard;
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItemAttribute {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItemEquipped {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAdjustItemEquippedState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgAdjustItemEquippedState {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCAdjustItemEquippedState;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSortItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSortItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSortItems;
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconClaimCode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStoreGetUserData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgStoreGetUserData {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStoreGetUserData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStoreGetUserDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgStoreGetUserDataResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStoreGetUserDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUpdateItemSchema {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgUpdateItemSchema {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCUpdateItemSchema;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCError {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRequestInventoryRefresh {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgRequestInventoryRefresh {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestInventoryRefresh;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConVarValue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgReplicateConVars {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgReplicateConVars {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCReplicateConVars;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUseItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgReplayUploadedToYouTube {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConsumableExhausted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgItemAcknowledged {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgItemAcknowledged {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCItemAcknowledged;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetPresetItemPosition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetItemPositions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSetItemPositions {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSetItemPositions;
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItemPresetInstance {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSelectPresetForClass {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOClassPresetClientData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCReportAbuse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCReportAbuseResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNameItemNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCClientDisplayNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCShowItemsPickedUp {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUpdatePeriodicEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCIncrementKillCountResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRemoveStrangePart {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRemoveUpgradeCard {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRemoveCustomizationAttributeSimple {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCResetStrangeScores {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCItemPreviewItemBoughtNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseCancel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseCancelResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseFinalize {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseFinalizeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCBannedWordListRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGiftedItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCCollectItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCClientMarketDataRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCClientMarketDataEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCClientMarketData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyToolToItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyToolToBaseItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRecipeComponent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgFulfillDynamicRecipeComponent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgFulfillDynamicRecipeComponent {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetItemEffectVerticalOffset {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSetItemEffectVerticalOffset {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetHatEffectUseHeadOrigin {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSetHatEffectUseHeadOrigin {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDeliverGiftResponseGiver {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDeliverGiftResponseGiver {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver;
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconGameAccountForGameServers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CWorkshop_PopulateItemDescriptions_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetContributors_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetContributors_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_SetItemPaymentRules_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_SetItemPaymentRules_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::MsgKindEnum for EGCBaseMsg {}
