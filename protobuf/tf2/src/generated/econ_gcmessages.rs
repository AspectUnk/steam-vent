// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `econ_gcmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgApplyAutograph)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyAutograph {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyAutograph.autograph_item_id)
    pub autograph_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyAutograph.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyAutograph.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyAutograph {
    fn default() -> &'a CMsgApplyAutograph {
        <CMsgApplyAutograph as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyAutograph {
    pub fn new() -> CMsgApplyAutograph {
        ::std::default::Default::default()
    }

    // optional uint64 autograph_item_id = 1;

    pub fn autograph_item_id(&self) -> u64 {
        self.autograph_item_id.unwrap_or(0)
    }

    pub fn clear_autograph_item_id(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
    }

    pub fn has_autograph_item_id(&self) -> bool {
        self.autograph_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_item_id(&mut self, v: u64) {
        self.autograph_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyAutograph {
    const NAME: &'static str = "CMsgApplyAutograph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.autograph_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.autograph_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.autograph_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyAutograph {
        CMsgApplyAutograph::new()
    }

    fn clear(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyAutograph {
        static instance: CMsgApplyAutograph = CMsgApplyAutograph {
            autograph_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEconPlayerStrangeCountAdjustment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEconPlayerStrangeCountAdjustment {
    // message fields
    // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.strange_count_adjustments)
    pub strange_count_adjustments: ::std::vec::Vec<cmsg_econ_player_strange_count_adjustment::CStrangeCountAdjustment>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEconPlayerStrangeCountAdjustment.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEconPlayerStrangeCountAdjustment {
    fn default() -> &'a CMsgEconPlayerStrangeCountAdjustment {
        <CMsgEconPlayerStrangeCountAdjustment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgEconPlayerStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment {
    const NAME: &'static str = "CMsgEconPlayerStrangeCountAdjustment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.strange_count_adjustments.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.strange_count_adjustments {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.strange_count_adjustments {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.strange_count_adjustments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment {
        static instance: CMsgEconPlayerStrangeCountAdjustment = CMsgEconPlayerStrangeCountAdjustment {
            account_id: ::std::option::Option::None,
            strange_count_adjustments: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgEconPlayerStrangeCountAdjustment`
pub mod cmsg_econ_player_strange_count_adjustment {
    // @@protoc_insertion_point(message:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CStrangeCountAdjustment {
        // message fields
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.event_type)
        pub event_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.adjustment)
        pub adjustment: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CStrangeCountAdjustment {
        fn default() -> &'a CStrangeCountAdjustment {
            <CStrangeCountAdjustment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CStrangeCountAdjustment {
        pub fn new() -> CStrangeCountAdjustment {
            ::std::default::Default::default()
        }

        // optional uint32 event_type = 1;

        pub fn event_type(&self) -> u32 {
            self.event_type.unwrap_or(0)
        }

        pub fn clear_event_type(&mut self) {
            self.event_type = ::std::option::Option::None;
        }

        pub fn has_event_type(&self) -> bool {
            self.event_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_type(&mut self, v: u32) {
            self.event_type = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 2;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 adjustment = 3;

        pub fn adjustment(&self) -> u32 {
            self.adjustment.unwrap_or(0)
        }

        pub fn clear_adjustment(&mut self) {
            self.adjustment = ::std::option::Option::None;
        }

        pub fn has_adjustment(&self) -> bool {
            self.adjustment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_adjustment(&mut self, v: u32) {
            self.adjustment = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CStrangeCountAdjustment {
        const NAME: &'static str = "CStrangeCountAdjustment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.adjustment = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.adjustment {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.adjustment {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CStrangeCountAdjustment {
            CStrangeCountAdjustment::new()
        }

        fn clear(&mut self) {
            self.event_type = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.adjustment = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CStrangeCountAdjustment {
            static instance: CStrangeCountAdjustment = CStrangeCountAdjustment {
                event_type: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                adjustment: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_FinalizePurchase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestItemPurgatory_FinalizePurchase {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_FinalizePurchase.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_FinalizePurchase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_FinalizePurchase {
    fn default() -> &'a CMsgRequestItemPurgatory_FinalizePurchase {
        <CMsgRequestItemPurgatory_FinalizePurchase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_FinalizePurchase {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchase {
    const NAME: &'static str = "CMsgRequestItemPurgatory_FinalizePurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        CMsgRequestItemPurgatory_FinalizePurchase::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchase {
        static instance: CMsgRequestItemPurgatory_FinalizePurchase = CMsgRequestItemPurgatory_FinalizePurchase {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_FinalizePurchaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_FinalizePurchaseResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_FinalizePurchaseResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn default() -> &'a CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        <CMsgRequestItemPurgatory_FinalizePurchaseResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    const NAME: &'static str = "CMsgRequestItemPurgatory_FinalizePurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        CMsgRequestItemPurgatory_FinalizePurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        static instance: CMsgRequestItemPurgatory_FinalizePurchaseResponse = CMsgRequestItemPurgatory_FinalizePurchaseResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_RefundPurchase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestItemPurgatory_RefundPurchase {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_RefundPurchase.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_RefundPurchase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_RefundPurchase {
    fn default() -> &'a CMsgRequestItemPurgatory_RefundPurchase {
        <CMsgRequestItemPurgatory_RefundPurchase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_RefundPurchase {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchase {
    const NAME: &'static str = "CMsgRequestItemPurgatory_RefundPurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        CMsgRequestItemPurgatory_RefundPurchase::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchase {
        static instance: CMsgRequestItemPurgatory_RefundPurchase = CMsgRequestItemPurgatory_RefundPurchase {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_RefundPurchaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestItemPurgatory_RefundPurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_RefundPurchaseResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_RefundPurchaseResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn default() -> &'a CMsgRequestItemPurgatory_RefundPurchaseResponse {
        <CMsgRequestItemPurgatory_RefundPurchaseResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_RefundPurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    const NAME: &'static str = "CMsgRequestItemPurgatory_RefundPurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        CMsgRequestItemPurgatory_RefundPurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchaseResponse {
        static instance: CMsgRequestItemPurgatory_RefundPurchaseResponse = CMsgRequestItemPurgatory_RefundPurchaseResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCraftingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftingResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftingResponse {
    fn default() -> &'a CMsgCraftingResponse {
        <CMsgCraftingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftingResponse {
    pub fn new() -> CMsgCraftingResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCraftingResponse {
    const NAME: &'static str = "CMsgCraftingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftingResponse {
        CMsgCraftingResponse::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftingResponse {
        static instance: CMsgCraftingResponse = CMsgCraftingResponse {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesData.currency)
    pub currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesData {
    fn default() -> &'a CMsgGCRequestStoreSalesData {
        <CMsgGCRequestStoreSalesData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesData {
    pub fn new() -> CMsgGCRequestStoreSalesData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 2;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestStoreSalesData {
    const NAME: &'static str = "CMsgGCRequestStoreSalesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesData {
        CMsgGCRequestStoreSalesData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesData {
        static instance: CMsgGCRequestStoreSalesData = CMsgGCRequestStoreSalesData {
            version: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.sale_price)
    pub sale_price: ::std::vec::Vec<cmsg_gcrequest_store_sales_data_response::Price>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataResponse {
        <CMsgGCRequestStoreSalesDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 2;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestStoreSalesDataResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sale_price.push(is.read_message()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sale_price {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.sale_price {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataResponse {
        CMsgGCRequestStoreSalesDataResponse::new()
    }

    fn clear(&mut self) {
        self.sale_price.clear();
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse {
        static instance: CMsgGCRequestStoreSalesDataResponse = CMsgGCRequestStoreSalesDataResponse {
            sale_price: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCRequestStoreSalesDataResponse`
pub mod cmsg_gcrequest_store_sales_data_response {
    // @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataResponse.Price)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Price {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.Price.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.Price.price)
        pub price: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataResponse.Price.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Price {
        fn default() -> &'a Price {
            <Price as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Price {
        pub fn new() -> Price {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 price = 2;

        pub fn price(&self) -> u32 {
            self.price.unwrap_or(0)
        }

        pub fn clear_price(&mut self) {
            self.price = ::std::option::Option::None;
        }

        pub fn has_price(&self) -> bool {
            self.price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price(&mut self, v: u32) {
            self.price = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Price {
        const NAME: &'static str = "Price";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.price = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.price {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.price {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Price {
            Price::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.price = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Price {
            static instance: Price = Price {
                item_def: ::std::option::Option::None,
                price: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataUpToDateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesDataUpToDateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataUpToDateResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataUpToDateResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataUpToDateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
        <CMsgGCRequestStoreSalesDataUpToDateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataUpToDateResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 2;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestStoreSalesDataUpToDateResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataUpToDateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        CMsgGCRequestStoreSalesDataUpToDateResponse::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataUpToDateResponse {
        static instance: CMsgGCRequestStoreSalesDataUpToDateResponse = CMsgGCRequestStoreSalesDataUpToDateResponse {
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPingRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingRequest {
    fn default() -> &'a CMsgGCToGCPingRequest {
        <CMsgGCToGCPingRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingRequest {
    pub fn new() -> CMsgGCToGCPingRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCPingRequest {
    const NAME: &'static str = "CMsgGCToGCPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingRequest {
        CMsgGCToGCPingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingRequest {
        static instance: CMsgGCToGCPingRequest = CMsgGCToGCPingRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCPingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPingResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingResponse {
    fn default() -> &'a CMsgGCToGCPingResponse {
        <CMsgGCToGCPingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingResponse {
    pub fn new() -> CMsgGCToGCPingResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCPingResponse {
    const NAME: &'static str = "CMsgGCToGCPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingResponse {
        CMsgGCToGCPingResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingResponse {
        static instance: CMsgGCToGCPingResponse = CMsgGCToGCPingResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserSessionServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserSessionServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserSessionServer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserSessionServer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServer {
    fn default() -> &'a CMsgGCToGCGetUserSessionServer {
        <CMsgGCToGCGetUserSessionServer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServer {
    pub fn new() -> CMsgGCToGCGetUserSessionServer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserSessionServer {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServer {
        CMsgGCToGCGetUserSessionServer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServer {
        static instance: CMsgGCToGCGetUserSessionServer = CMsgGCToGCGetUserSessionServer {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserSessionServerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserSessionServerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserSessionServerResponse.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserSessionServerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServerResponse {
    fn default() -> &'a CMsgGCToGCGetUserSessionServerResponse {
        <CMsgGCToGCGetUserSessionServerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServerResponse {
    pub fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 server_steam_id = 1;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserSessionServerResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        CMsgGCToGCGetUserSessionServerResponse::new()
    }

    fn clear(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServerResponse {
        static instance: CMsgGCToGCGetUserSessionServerResponse = CMsgGCToGCGetUserSessionServerResponse {
            server_steam_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserServerMembers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserServerMembers {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembers.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembers.max_spectators)
    pub max_spectators: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserServerMembers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembers {
    fn default() -> &'a CMsgGCToGCGetUserServerMembers {
        <CMsgGCToGCGetUserServerMembers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembers {
    pub fn new() -> CMsgGCToGCGetUserServerMembers {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spectators = 2;

    pub fn max_spectators(&self) -> u32 {
        self.max_spectators.unwrap_or(0)
    }

    pub fn clear_max_spectators(&mut self) {
        self.max_spectators = ::std::option::Option::None;
    }

    pub fn has_max_spectators(&self) -> bool {
        self.max_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spectators(&mut self, v: u32) {
        self.max_spectators = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserServerMembers {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_spectators {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_spectators {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembers {
        CMsgGCToGCGetUserServerMembers::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.max_spectators = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembers {
        static instance: CMsgGCToGCGetUserServerMembers = CMsgGCToGCGetUserServerMembers {
            account_id: ::std::option::Option::None,
            max_spectators: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserServerMembersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserServerMembersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembersResponse.member_account_id)
    pub member_account_id: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserServerMembersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembersResponse {
    fn default() -> &'a CMsgGCToGCGetUserServerMembersResponse {
        <CMsgGCToGCGetUserServerMembersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembersResponse {
    pub fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserServerMembersResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.member_account_id)?;
                },
                8 => {
                    self.member_account_id.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.member_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.member_account_id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        CMsgGCToGCGetUserServerMembersResponse::new()
    }

    fn clear(&mut self) {
        self.member_account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembersResponse {
        static instance: CMsgGCToGCGetUserServerMembersResponse = CMsgGCToGCGetUserServerMembersResponse {
            member_account_id: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLookupMultipleAccountNames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLookupMultipleAccountNames {
    // message fields
    // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNames.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNames.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNames {
    fn default() -> &'a CMsgLookupMultipleAccountNames {
        <CMsgLookupMultipleAccountNames as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNames {
    pub fn new() -> CMsgLookupMultipleAccountNames {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLookupMultipleAccountNames {
    const NAME: &'static str = "CMsgLookupMultipleAccountNames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                8 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(1, &self.accountids);
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_repeated_packed_uint32(1, &self.accountids)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNames {
        CMsgLookupMultipleAccountNames::new()
    }

    fn clear(&mut self) {
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNames {
        static instance: CMsgLookupMultipleAccountNames = CMsgLookupMultipleAccountNames {
            accountids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLookupMultipleAccountNamesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLookupMultipleAccountNamesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.accounts)
    pub accounts: ::std::vec::Vec<cmsg_lookup_multiple_account_names_response::Account>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNamesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNamesResponse {
    fn default() -> &'a CMsgLookupMultipleAccountNamesResponse {
        <CMsgLookupMultipleAccountNamesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNamesResponse {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLookupMultipleAccountNamesResponse {
    const NAME: &'static str = "CMsgLookupMultipleAccountNamesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.accounts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNamesResponse {
        CMsgLookupMultipleAccountNamesResponse::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse {
        static instance: CMsgLookupMultipleAccountNamesResponse = CMsgLookupMultipleAccountNamesResponse {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgLookupMultipleAccountNamesResponse`
pub mod cmsg_lookup_multiple_account_names_response {
    // @@protoc_insertion_point(message:CMsgLookupMultipleAccountNamesResponse.Account)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Account {
        // message fields
        // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.Account.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.Account.persona)
        pub persona: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNamesResponse.Account.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Account {
        fn default() -> &'a Account {
            <Account as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Account {
        pub fn new() -> Account {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional string persona = 2;

        pub fn persona(&self) -> &str {
            match self.persona.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona(&mut self) {
            self.persona = ::std::option::Option::None;
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: ::std::string::String) {
            self.persona = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut ::std::string::String {
            if self.persona.is_none() {
                self.persona = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona(&mut self) -> ::std::string::String {
            self.persona.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Account {
        const NAME: &'static str = "Account";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.persona = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.persona.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Account {
            Account::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.persona = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Account {
            static instance: Account = Account {
                accountid: ::std::option::Option::None,
                persona: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGrantSelfMadeItemToAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGrantSelfMadeItemToAccount {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGrantSelfMadeItemToAccount.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGrantSelfMadeItemToAccount.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGrantSelfMadeItemToAccount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGrantSelfMadeItemToAccount {
    fn default() -> &'a CMsgGCToGCGrantSelfMadeItemToAccount {
        <CMsgGCToGCGrantSelfMadeItemToAccount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGrantSelfMadeItemToAccount {
    pub fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGrantSelfMadeItemToAccount {
    const NAME: &'static str = "CMsgGCToGCGrantSelfMadeItemToAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        CMsgGCToGCGrantSelfMadeItemToAccount::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGrantSelfMadeItemToAccount {
        static instance: CMsgGCToGCGrantSelfMadeItemToAccount = CMsgGCToGCGrantSelfMadeItemToAccount {
            item_def_index: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCThankedByNewUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCThankedByNewUser {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCThankedByNewUser.new_user_accountid)
    pub new_user_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCThankedByNewUser.thanked_user_accountid)
    pub thanked_user_accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCThankedByNewUser.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCThankedByNewUser {
    fn default() -> &'a CMsgGCToGCThankedByNewUser {
        <CMsgGCToGCThankedByNewUser as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCThankedByNewUser {
    pub fn new() -> CMsgGCToGCThankedByNewUser {
        ::std::default::Default::default()
    }

    // optional uint32 new_user_accountid = 1;

    pub fn new_user_accountid(&self) -> u32 {
        self.new_user_accountid.unwrap_or(0)
    }

    pub fn clear_new_user_accountid(&mut self) {
        self.new_user_accountid = ::std::option::Option::None;
    }

    pub fn has_new_user_accountid(&self) -> bool {
        self.new_user_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_user_accountid(&mut self, v: u32) {
        self.new_user_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 thanked_user_accountid = 2;

    pub fn thanked_user_accountid(&self) -> u32 {
        self.thanked_user_accountid.unwrap_or(0)
    }

    pub fn clear_thanked_user_accountid(&mut self) {
        self.thanked_user_accountid = ::std::option::Option::None;
    }

    pub fn has_thanked_user_accountid(&self) -> bool {
        self.thanked_user_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thanked_user_accountid(&mut self, v: u32) {
        self.thanked_user_accountid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCThankedByNewUser {
    const NAME: &'static str = "CMsgGCToGCThankedByNewUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_user_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.thanked_user_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_user_accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.thanked_user_accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.new_user_accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.thanked_user_accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCThankedByNewUser {
        CMsgGCToGCThankedByNewUser::new()
    }

    fn clear(&mut self) {
        self.new_user_accountid = ::std::option::Option::None;
        self.thanked_user_accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCThankedByNewUser {
        static instance: CMsgGCToGCThankedByNewUser = CMsgGCToGCThankedByNewUser {
            new_user_accountid: ::std::option::Option::None,
            thanked_user_accountid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCShuffleCrateContents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCShuffleCrateContents {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCShuffleCrateContents.crate_item_id)
    pub crate_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCShuffleCrateContents.user_code_string)
    pub user_code_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCShuffleCrateContents.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCShuffleCrateContents {
    fn default() -> &'a CMsgGCShuffleCrateContents {
        <CMsgGCShuffleCrateContents as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShuffleCrateContents {
    pub fn new() -> CMsgGCShuffleCrateContents {
        ::std::default::Default::default()
    }

    // optional uint64 crate_item_id = 1;

    pub fn crate_item_id(&self) -> u64 {
        self.crate_item_id.unwrap_or(0)
    }

    pub fn clear_crate_item_id(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
    }

    pub fn has_crate_item_id(&self) -> bool {
        self.crate_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_id(&mut self, v: u64) {
        self.crate_item_id = ::std::option::Option::Some(v);
    }

    // optional string user_code_string = 2;

    pub fn user_code_string(&self) -> &str {
        match self.user_code_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_code_string(&mut self) {
        self.user_code_string = ::std::option::Option::None;
    }

    pub fn has_user_code_string(&self) -> bool {
        self.user_code_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_code_string(&mut self, v: ::std::string::String) {
        self.user_code_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_code_string(&mut self) -> &mut ::std::string::String {
        if self.user_code_string.is_none() {
            self.user_code_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_code_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_code_string(&mut self) -> ::std::string::String {
        self.user_code_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCShuffleCrateContents {
    const NAME: &'static str = "CMsgGCShuffleCrateContents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.user_code_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.user_code_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.crate_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.user_code_string.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCShuffleCrateContents {
        CMsgGCShuffleCrateContents::new()
    }

    fn clear(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
        self.user_code_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCShuffleCrateContents {
        static instance: CMsgGCShuffleCrateContents = CMsgGCShuffleCrateContents {
            crate_item_id: ::std::option::Option::None,
            user_code_string: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestObjective_Progress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestObjective_Progress {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.quest_attrib_index)
    pub quest_attrib_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.delta)
    pub delta: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.owner_steamid)
    pub owner_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_Progress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_Progress {
    fn default() -> &'a CMsgGCQuestObjective_Progress {
        <CMsgGCQuestObjective_Progress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_Progress {
    pub fn new() -> CMsgGCQuestObjective_Progress {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_attrib_index = 2;

    pub fn quest_attrib_index(&self) -> u32 {
        self.quest_attrib_index.unwrap_or(0)
    }

    pub fn clear_quest_attrib_index(&mut self) {
        self.quest_attrib_index = ::std::option::Option::None;
    }

    pub fn has_quest_attrib_index(&self) -> bool {
        self.quest_attrib_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_attrib_index(&mut self, v: u32) {
        self.quest_attrib_index = ::std::option::Option::Some(v);
    }

    // optional uint32 delta = 3;

    pub fn delta(&self) -> u32 {
        self.delta.unwrap_or(0)
    }

    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: u32) {
        self.delta = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steamid = 4;

    pub fn owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }

    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestObjective_Progress {
    const NAME: &'static str = "CMsgGCQuestObjective_Progress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.quest_attrib_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.quest_attrib_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.delta {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.quest_attrib_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.delta {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_Progress {
        CMsgGCQuestObjective_Progress::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.quest_attrib_index = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_Progress {
        static instance: CMsgGCQuestObjective_Progress = CMsgGCQuestObjective_Progress {
            quest_id: ::std::option::Option::None,
            quest_attrib_index: ::std::option::Option::None,
            delta: ::std::option::Option::None,
            owner_steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestObjective_PointsChange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestObjective_PointsChange {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.owner_steamid)
    pub owner_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.update_base_points)
    pub update_base_points: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.points_0)
    pub points_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.points_1)
    pub points_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.points_2)
    pub points_2: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_PointsChange.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_PointsChange {
    fn default() -> &'a CMsgGCQuestObjective_PointsChange {
        <CMsgGCQuestObjective_PointsChange as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_PointsChange {
    pub fn new() -> CMsgGCQuestObjective_PointsChange {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steamid = 4;

    pub fn owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }

    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }

    // optional bool update_base_points = 5;

    pub fn update_base_points(&self) -> bool {
        self.update_base_points.unwrap_or(false)
    }

    pub fn clear_update_base_points(&mut self) {
        self.update_base_points = ::std::option::Option::None;
    }

    pub fn has_update_base_points(&self) -> bool {
        self.update_base_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_base_points(&mut self, v: bool) {
        self.update_base_points = ::std::option::Option::Some(v);
    }

    // optional uint32 points_0 = 6;

    pub fn points_0(&self) -> u32 {
        self.points_0.unwrap_or(0)
    }

    pub fn clear_points_0(&mut self) {
        self.points_0 = ::std::option::Option::None;
    }

    pub fn has_points_0(&self) -> bool {
        self.points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_0(&mut self, v: u32) {
        self.points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_1 = 7;

    pub fn points_1(&self) -> u32 {
        self.points_1.unwrap_or(0)
    }

    pub fn clear_points_1(&mut self) {
        self.points_1 = ::std::option::Option::None;
    }

    pub fn has_points_1(&self) -> bool {
        self.points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_1(&mut self, v: u32) {
        self.points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_2 = 8;

    pub fn points_2(&self) -> u32 {
        self.points_2.unwrap_or(0)
    }

    pub fn clear_points_2(&mut self) {
        self.points_2 = ::std::option::Option::None;
    }

    pub fn has_points_2(&self) -> bool {
        self.points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_2(&mut self, v: u32) {
        self.points_2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestObjective_PointsChange {
    const NAME: &'static str = "CMsgGCQuestObjective_PointsChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.update_base_points = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.points_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.points_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.points_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.update_base_points {
            my_size += 1 + 1;
        }
        if let Some(v) = self.points_0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.points_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.points_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.update_base_points {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.points_0 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.points_1 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.points_2 {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_PointsChange {
        CMsgGCQuestObjective_PointsChange::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.update_base_points = ::std::option::Option::None;
        self.points_0 = ::std::option::Option::None;
        self.points_1 = ::std::option::Option::None;
        self.points_2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_PointsChange {
        static instance: CMsgGCQuestObjective_PointsChange = CMsgGCQuestObjective_PointsChange {
            quest_id: ::std::option::Option::None,
            owner_steamid: ::std::option::Option::None,
            update_base_points: ::std::option::Option::None,
            points_0: ::std::option::Option::None,
            points_1: ::std::option::Option::None,
            points_2: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestComplete_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestComplete_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestComplete_Request.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestComplete_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestComplete_Request {
    fn default() -> &'a CMsgGCQuestComplete_Request {
        <CMsgGCQuestComplete_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestComplete_Request {
    pub fn new() -> CMsgGCQuestComplete_Request {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestComplete_Request {
    const NAME: &'static str = "CMsgGCQuestComplete_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestComplete_Request {
        CMsgGCQuestComplete_Request::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestComplete_Request {
        static instance: CMsgGCQuestComplete_Request = CMsgGCQuestComplete_Request {
            quest_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestCompleted {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestCompleted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestCompleted {
    fn default() -> &'a CMsgGCQuestCompleted {
        <CMsgGCQuestCompleted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestCompleted {
    pub fn new() -> CMsgGCQuestCompleted {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestCompleted {
    const NAME: &'static str = "CMsgGCQuestCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestCompleted {
        CMsgGCQuestCompleted::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestCompleted {
        static instance: CMsgGCQuestCompleted = CMsgGCQuestCompleted {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestObjective_RequestLoanerItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestObjective_RequestLoanerItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_RequestLoanerItems.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_RequestLoanerItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_RequestLoanerItems {
    fn default() -> &'a CMsgGCQuestObjective_RequestLoanerItems {
        <CMsgGCQuestObjective_RequestLoanerItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_RequestLoanerItems {
    pub fn new() -> CMsgGCQuestObjective_RequestLoanerItems {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestObjective_RequestLoanerItems {
    const NAME: &'static str = "CMsgGCQuestObjective_RequestLoanerItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_RequestLoanerItems {
        CMsgGCQuestObjective_RequestLoanerItems::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_RequestLoanerItems {
        static instance: CMsgGCQuestObjective_RequestLoanerItems = CMsgGCQuestObjective_RequestLoanerItems {
            quest_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestObjective_RequestLoanerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestObjective_RequestLoanerResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_RequestLoanerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_RequestLoanerResponse {
    fn default() -> &'a CMsgGCQuestObjective_RequestLoanerResponse {
        <CMsgGCQuestObjective_RequestLoanerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_RequestLoanerResponse {
    pub fn new() -> CMsgGCQuestObjective_RequestLoanerResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestObjective_RequestLoanerResponse {
    const NAME: &'static str = "CMsgGCQuestObjective_RequestLoanerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_RequestLoanerResponse {
        CMsgGCQuestObjective_RequestLoanerResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_RequestLoanerResponse {
        static instance: CMsgGCQuestObjective_RequestLoanerResponse = CMsgGCQuestObjective_RequestLoanerResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCraftCollectionUpgrade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftCollectionUpgrade {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftCollectionUpgrade.item_id)
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftCollectionUpgrade.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftCollectionUpgrade {
    fn default() -> &'a CMsgCraftCollectionUpgrade {
        <CMsgCraftCollectionUpgrade as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftCollectionUpgrade {
    pub fn new() -> CMsgCraftCollectionUpgrade {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCraftCollectionUpgrade {
    const NAME: &'static str = "CMsgCraftCollectionUpgrade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_id)?;
                },
                8 => {
                    self.item_id.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_id {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftCollectionUpgrade {
        CMsgCraftCollectionUpgrade::new()
    }

    fn clear(&mut self) {
        self.item_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftCollectionUpgrade {
        static instance: CMsgCraftCollectionUpgrade = CMsgCraftCollectionUpgrade {
            item_id: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCraftHalloweenOffering)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftHalloweenOffering {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftHalloweenOffering.tool_id)
    pub tool_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCraftHalloweenOffering.item_id)
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftHalloweenOffering.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftHalloweenOffering {
    fn default() -> &'a CMsgCraftHalloweenOffering {
        <CMsgCraftHalloweenOffering as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftHalloweenOffering {
    pub fn new() -> CMsgCraftHalloweenOffering {
        ::std::default::Default::default()
    }

    // optional uint64 tool_id = 1;

    pub fn tool_id(&self) -> u64 {
        self.tool_id.unwrap_or(0)
    }

    pub fn clear_tool_id(&mut self) {
        self.tool_id = ::std::option::Option::None;
    }

    pub fn has_tool_id(&self) -> bool {
        self.tool_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_id(&mut self, v: u64) {
        self.tool_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCraftHalloweenOffering {
    const NAME: &'static str = "CMsgCraftHalloweenOffering";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_id)?;
                },
                16 => {
                    self.item_id.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_id {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftHalloweenOffering {
        CMsgCraftHalloweenOffering::new()
    }

    fn clear(&mut self) {
        self.tool_id = ::std::option::Option::None;
        self.item_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftHalloweenOffering {
        static instance: CMsgCraftHalloweenOffering = CMsgCraftHalloweenOffering {
            tool_id: ::std::option::Option::None,
            item_id: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCraftCommonStatClock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftCommonStatClock {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftCommonStatClock.tool_id)
    pub tool_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCraftCommonStatClock.item_id)
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftCommonStatClock.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftCommonStatClock {
    fn default() -> &'a CMsgCraftCommonStatClock {
        <CMsgCraftCommonStatClock as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftCommonStatClock {
    pub fn new() -> CMsgCraftCommonStatClock {
        ::std::default::Default::default()
    }

    // optional uint64 tool_id = 1;

    pub fn tool_id(&self) -> u64 {
        self.tool_id.unwrap_or(0)
    }

    pub fn clear_tool_id(&mut self) {
        self.tool_id = ::std::option::Option::None;
    }

    pub fn has_tool_id(&self) -> bool {
        self.tool_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_id(&mut self, v: u64) {
        self.tool_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCraftCommonStatClock {
    const NAME: &'static str = "CMsgCraftCommonStatClock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_id)?;
                },
                16 => {
                    self.item_id.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_id {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftCommonStatClock {
        CMsgCraftCommonStatClock::new()
    }

    fn clear(&mut self) {
        self.tool_id = ::std::option::Option::None;
        self.item_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftCommonStatClock {
        static instance: CMsgCraftCommonStatClock = CMsgCraftCommonStatClock {
            tool_id: ::std::option::Option::None,
            item_id: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestDiscard_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestDiscard_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestDiscard_Request.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestDiscard_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestDiscard_Request {
    fn default() -> &'a CMsgGCQuestDiscard_Request {
        <CMsgGCQuestDiscard_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestDiscard_Request {
    pub fn new() -> CMsgGCQuestDiscard_Request {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestDiscard_Request {
    const NAME: &'static str = "CMsgGCQuestDiscard_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestDiscard_Request {
        CMsgGCQuestDiscard_Request::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestDiscard_Request {
        static instance: CMsgGCQuestDiscard_Request = CMsgGCQuestDiscard_Request {
            quest_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCItemMsg)
pub enum EGCItemMsg {
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCBase)
    k_EMsgGCBase = 1000,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetSingleItemPosition)
    k_EMsgGCSetSingleItemPosition = 1001,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraft)
    k_EMsgGCCraft = 1002,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftResponse)
    k_EMsgGCCraftResponse = 1003,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDelete)
    k_EMsgGCDelete = 1004,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCVerifyCacheSubscription)
    k_EMsgGCVerifyCacheSubscription = 1005,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameItem)
    k_EMsgGCNameItem = 1006,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnlockCrate)
    k_EMsgGCUnlockCrate = 1007,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnlockCrateResponse)
    k_EMsgGCUnlockCrateResponse = 1008,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPaintItem)
    k_EMsgGCPaintItem = 1009,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPaintItemResponse)
    k_EMsgGCPaintItemResponse = 1010,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGoldenWrenchBroadcast)
    k_EMsgGCGoldenWrenchBroadcast = 1011,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCMOTDRequest)
    k_EMsgGCMOTDRequest = 1012,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCMOTDRequestResponse)
    k_EMsgGCMOTDRequestResponse = 1013,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameBaseItem)
    k_EMsgGCNameBaseItem = 1019,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameBaseItemResponse)
    k_EMsgGCNameBaseItemResponse = 1020,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveSocketItem_DEPRECATED)
    k_EMsgGCRemoveSocketItem_DEPRECATED = 1021,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveSocketItemResponse_DEPRECATED)
    k_EMsgGCRemoveSocketItemResponse_DEPRECATED = 1022,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCustomizeItemTexture)
    k_EMsgGCCustomizeItemTexture = 1023,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCustomizeItemTextureResponse)
    k_EMsgGCCustomizeItemTextureResponse = 1024,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUseItemRequest)
    k_EMsgGCUseItemRequest = 1025,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUseItemResponse)
    k_EMsgGCUseItemResponse = 1026,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRespawnPostLoadoutChange)
    k_EMsgGCRespawnPostLoadoutChange = 1029,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveItemName)
    k_EMsgGCRemoveItemName = 1030,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveItemPaint)
    k_EMsgGCRemoveItemPaint = 1031,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGiftWrapItem)
    k_EMsgGCGiftWrapItem = 1032,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGiftWrapItemResponse)
    k_EMsgGCGiftWrapItemResponse = 1033,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDeliverGift)
    k_EMsgGCDeliverGift = 1034,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDeliverGiftResponseReceiver)
    k_EMsgGCDeliverGiftResponseReceiver = 1036,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnwrapGiftRequest)
    k_EMsgGCUnwrapGiftRequest = 1037,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnwrapGiftResponse)
    k_EMsgGCUnwrapGiftResponse = 1038,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemStyle)
    k_EMsgGCSetItemStyle = 1039,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUsedClaimCodeItem)
    k_EMsgGCUsedClaimCodeItem = 1040,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSortItems)
    k_EMsgGCSortItems = 1041,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_RevolvingLootList_DEPRECATED)
    k_EMsgGC_RevolvingLootList_DEPRECATED = 1042,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccount)
    k_EMsgGCLookupAccount = 1043,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccountResponse)
    k_EMsgGCLookupAccountResponse = 1044,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccountName)
    k_EMsgGCLookupAccountName = 1045,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccountNameResponse)
    k_EMsgGCLookupAccountNameResponse = 1046,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUpdateItemSchema)
    k_EMsgGCUpdateItemSchema = 1049,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestInventoryRefresh)
    k_EMsgGCRequestInventoryRefresh = 1050,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveCustomTexture)
    k_EMsgGCRemoveCustomTexture = 1051,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveCustomTextureResponse)
    k_EMsgGCRemoveCustomTextureResponse = 1052,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveMakersMark)
    k_EMsgGCRemoveMakersMark = 1053,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveMakersMarkResponse)
    k_EMsgGCRemoveMakersMarkResponse = 1054,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveUniqueCraftIndex)
    k_EMsgGCRemoveUniqueCraftIndex = 1055,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveUniqueCraftIndexResponse)
    k_EMsgGCRemoveUniqueCraftIndexResponse = 1056,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSaxxyBroadcast)
    k_EMsgGCSaxxyBroadcast = 1057,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCBackpackSortFinished)
    k_EMsgGCBackpackSortFinished = 1058,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAdjustItemEquippedState)
    k_EMsgGCAdjustItemEquippedState = 1059,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCollectItem)
    k_EMsgGCCollectItem = 1061,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemAcknowledged)
    k_EMsgGCItemAcknowledged = 1062,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPresets_SelectPresetForClass)
    k_EMsgGCPresets_SelectPresetForClass = 1063,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPresets_SetItemPosition)
    k_EMsgGCPresets_SetItemPosition = 1064,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_ReportAbuse)
    k_EMsgGC_ReportAbuse = 1065,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_ReportAbuseResponse)
    k_EMsgGC_ReportAbuseResponse = 1066,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPresets_SelectPresetForClassReply)
    k_EMsgGCPresets_SelectPresetForClassReply = 1067,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameItemNotification)
    k_EMsgGCNameItemNotification = 1068,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientDisplayNotification)
    k_EMsgGCClientDisplayNotification = 1069,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyStrangePart)
    k_EMsgGCApplyStrangePart = 1070,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_IncrementKillCountAttribute)
    k_EMsgGC_IncrementKillCountAttribute = 1071,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_IncrementKillCountResponse)
    k_EMsgGC_IncrementKillCountResponse = 1072,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveStrangePart)
    k_EMsgGCRemoveStrangePart = 1073,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCResetStrangeScores)
    k_EMsgGCResetStrangeScores = 1074,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGiftedItems)
    k_EMsgGCGiftedItems = 1075,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyUpgradeCard)
    k_EMsgGCApplyUpgradeCard = 1077,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveUpgradeCard)
    k_EMsgGCRemoveUpgradeCard = 1078,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyStrangeRestriction)
    k_EMsgGCApplyStrangeRestriction = 1079,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientRequestMarketData)
    k_EMsgGCClientRequestMarketData = 1080,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientRequestMarketDataResponse)
    k_EMsgGCClientRequestMarketDataResponse = 1081,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyXifier)
    k_EMsgGCApplyXifier = 1082,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyXifierResponse)
    k_EMsgGCApplyXifierResponse = 1083,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_TrackUniquePlayerPairEvent)
    k_EMsgGC_TrackUniquePlayerPairEvent = 1084,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCFulfillDynamicRecipeComponent)
    k_EMsgGCFulfillDynamicRecipeComponent = 1085,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCFulfillDynamicRecipeComponentResponse)
    k_EMsgGCFulfillDynamicRecipeComponentResponse = 1086,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemEffectVerticalOffset)
    k_EMsgGCSetItemEffectVerticalOffset = 1087,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetHatEffectUseHeadOrigin)
    k_EMsgGCSetHatEffectUseHeadOrigin = 1088,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemEaterRecharger)
    k_EMsgGCItemEaterRecharger = 1089,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemEaterRechargerResponse)
    k_EMsgGCItemEaterRechargerResponse = 1090,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyBaseItemXifier)
    k_EMsgGCApplyBaseItemXifier = 1091,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyClassTransmogrifier)
    k_EMsgGCApplyClassTransmogrifier = 1092,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyHalloweenSpellbookPage)
    k_EMsgGCApplyHalloweenSpellbookPage = 1093,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveKillStreak)
    k_EMsgGCRemoveKillStreak = 1094,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveKillStreakResponse)
    k_EMsgGCRemoveKillStreakResponse = 1095,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTFSpecificItemBroadcast)
    k_EMsgGCTFSpecificItemBroadcast = 1096,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_IncrementKillCountAttribute_Multiple)
    k_EMsgGC_IncrementKillCountAttribute_Multiple = 1097,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDeliverGiftResponseGiver)
    k_EMsgGCDeliverGiftResponseGiver = 1098,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemPositions)
    k_EMsgGCSetItemPositions = 1100,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupMultipleAccountNames)
    k_EMsgGCLookupMultipleAccountNames = 1101,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupMultipleAccountNamesResponse)
    k_EMsgGCLookupMultipleAccountNamesResponse = 1102,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTradingBase)
    k_EMsgGCTradingBase = 1500,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_InitiateTradeRequest)
    k_EMsgGCTrading_InitiateTradeRequest = 1501,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_InitiateTradeResponse)
    k_EMsgGCTrading_InitiateTradeResponse = 1502,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_StartSession)
    k_EMsgGCTrading_StartSession = 1503,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_SessionClosed)
    k_EMsgGCTrading_SessionClosed = 1509,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_CancelSession)
    k_EMsgGCTrading_CancelSession = 1510,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_InitiateTradeRequestResponse)
    k_EMsgGCTrading_InitiateTradeRequestResponse = 1514,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerBrowser_FavoriteServer)
    k_EMsgGCServerBrowser_FavoriteServer = 1601,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerBrowser_BlacklistServer)
    k_EMsgGCServerBrowser_BlacklistServer = 1602,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerRentalsBase)
    k_EMsgGCServerRentalsBase = 1700,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewCheckStatus)
    k_EMsgGCItemPreviewCheckStatus = 1701,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewStatusResponse)
    k_EMsgGCItemPreviewStatusResponse = 1702,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewRequest)
    k_EMsgGCItemPreviewRequest = 1703,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewRequestResponse)
    k_EMsgGCItemPreviewRequestResponse = 1704,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewExpire)
    k_EMsgGCItemPreviewExpire = 1705,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewExpireNotification)
    k_EMsgGCItemPreviewExpireNotification = 1706,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewItemBoughtNotification)
    k_EMsgGCItemPreviewItemBoughtNotification = 1708,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_NewItemRequest)
    k_EMsgGCDev_NewItemRequest = 2001,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_NewItemRequestResponse)
    k_EMsgGCDev_NewItemRequestResponse = 2002,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_DebugRollLootRequest)
    k_EMsgGCDev_DebugRollLootRequest = 2003,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStoreGetUserData)
    k_EMsgGCStoreGetUserData = 2500,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStoreGetUserDataResponse)
    k_EMsgGCStoreGetUserDataResponse = 2501,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInit_DEPRECATED)
    k_EMsgGCStorePurchaseInit_DEPRECATED = 2502,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInitResponse_DEPRECATED)
    k_EMsgGCStorePurchaseInitResponse_DEPRECATED = 2503,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseFinalize)
    k_EMsgGCStorePurchaseFinalize = 2512,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseFinalizeResponse)
    k_EMsgGCStorePurchaseFinalizeResponse = 2513,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseCancel)
    k_EMsgGCStorePurchaseCancel = 2514,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseCancelResponse)
    k_EMsgGCStorePurchaseCancelResponse = 2515,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseQueryTxn)
    k_EMsgGCStorePurchaseQueryTxn = 2508,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseQueryTxnResponse)
    k_EMsgGCStorePurchaseQueryTxnResponse = 2509,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInit)
    k_EMsgGCStorePurchaseInit = 2510,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInitResponse)
    k_EMsgGCStorePurchaseInitResponse = 2511,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCDirtySDOCache)
    k_EMsgGCToGCDirtySDOCache = 2516,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCDirtyMultipleSDOCache)
    k_EMsgGCToGCDirtyMultipleSDOCache = 2517,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCUpdateSQLKeyValue)
    k_EMsgGCToGCUpdateSQLKeyValue = 2518,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCBroadcastConsoleCommand)
    k_EMsgGCToGCBroadcastConsoleCommand = 2521,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerVersionUpdated)
    k_EMsgGCServerVersionUpdated = 2522,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyAutograph)
    k_EMsgGCApplyAutograph = 2523,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCWebAPIAccountChanged)
    k_EMsgGCToGCWebAPIAccountChanged = 2524,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestAnnouncements)
    k_EMsgGCRequestAnnouncements = 2525,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestAnnouncementsResponse)
    k_EMsgGCRequestAnnouncementsResponse = 2526,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestPassportItemGrant)
    k_EMsgGCRequestPassportItemGrant = 2527,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientVersionUpdated)
    k_EMsgGCClientVersionUpdated = 2528,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_FinalizePurchase)
    k_EMsgGCItemPurgatory_FinalizePurchase = 2531,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_FinalizePurchaseResponse)
    k_EMsgGCItemPurgatory_FinalizePurchaseResponse = 2532,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_RefundPurchase)
    k_EMsgGCItemPurgatory_RefundPurchase = 2533,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_RefundPurchaseResponse)
    k_EMsgGCItemPurgatory_RefundPurchaseResponse = 2534,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPlayerStrangeCountAdjustments)
    k_EMsgGCToGCPlayerStrangeCountAdjustments = 2535,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesData)
    k_EMsgGCRequestStoreSalesData = 2536,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesDataResponse)
    k_EMsgGCRequestStoreSalesDataResponse = 2537,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesDataUpToDateResponse)
    k_EMsgGCRequestStoreSalesDataUpToDateResponse = 2538,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPingRequest)
    k_EMsgGCToGCPingRequest = 2539,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPingResponse)
    k_EMsgGCToGCPingResponse = 2540,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserSessionServer)
    k_EMsgGCToGCGetUserSessionServer = 2541,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserSessionServerResponse)
    k_EMsgGCToGCGetUserSessionServerResponse = 2542,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserServerMembers)
    k_EMsgGCToGCGetUserServerMembers = 2543,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserServerMembersResponse)
    k_EMsgGCToGCGetUserServerMembersResponse = 2544,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGrantSelfMadeItemToAccount)
    k_EMsgGCToGCGrantSelfMadeItemToAccount = 2555,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCThankedByNewUser)
    k_EMsgGCToGCThankedByNewUser = 2556,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCShuffleCrateContents)
    k_EMsgGCShuffleCrateContents = 2557,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_Progress)
    k_EMsgGCQuestObjective_Progress = 2558,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestCompleted)
    k_EMsgGCQuestCompleted = 2559,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyDuckToken)
    k_EMsgGCApplyDuckToken = 2560,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_PointsChange)
    k_EMsgGCQuestObjective_PointsChange = 2562,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_RequestLoanerItems)
    k_EMsgGCQuestObjective_RequestLoanerItems = 2564,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_RequestLoanerResponse)
    k_EMsgGCQuestObjective_RequestLoanerResponse = 2565,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyStrangeCountTransfer)
    k_EMsgGCApplyStrangeCountTransfer = 2566,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftCollectionUpgrade)
    k_EMsgGCCraftCollectionUpgrade = 2567,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftHalloweenOffering)
    k_EMsgGCCraftHalloweenOffering = 2568,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestDiscard_Request)
    k_EMsgGCQuestDiscard_Request = 2569,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveGiftedBy)
    k_EMsgGCRemoveGiftedBy = 2570,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveGiftedByResponse)
    k_EMsgGCRemoveGiftedByResponse = 2571,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveFestivizer)
    k_EMsgGCRemoveFestivizer = 2572,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveFestivizerResponse)
    k_EMsgGCRemoveFestivizerResponse = 2573,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftCommonStatClock)
    k_EMsgGCCraftCommonStatClock = 2574,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGCItemMsg {
    const NAME: &'static str = "EGCItemMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCItemMsg> {
        match value {
            1000 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            1001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetSingleItemPosition),
            1002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraft),
            1003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftResponse),
            1004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            1005 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            1006 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItem),
            1007 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrate),
            1008 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrateResponse),
            1009 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            1010 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            1011 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast),
            1012 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequest),
            1013 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequestResponse),
            1019 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            1020 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            1021 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED),
            1022 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED),
            1023 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTexture),
            1024 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse),
            1025 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            1026 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            1029 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange),
            1030 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemName),
            1031 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemPaint),
            1032 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItem),
            1033 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItemResponse),
            1034 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGift),
            1036 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver),
            1037 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            1038 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            1039 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemStyle),
            1040 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUsedClaimCodeItem),
            1041 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            1042 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED),
            1043 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccount),
            1044 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountResponse),
            1045 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountName),
            1046 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountNameResponse),
            1049 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUpdateItemSchema),
            1050 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestInventoryRefresh),
            1051 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTexture),
            1052 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse),
            1053 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMark),
            1054 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse),
            1055 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex),
            1056 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse),
            1057 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSaxxyBroadcast),
            1058 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            1059 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            1061 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCollectItem),
            1062 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            1063 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass),
            1064 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SetItemPosition),
            1065 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuse),
            1066 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuseResponse),
            1067 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply),
            1068 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItemNotification),
            1069 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientDisplayNotification),
            1070 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            1071 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute),
            1072 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountResponse),
            1073 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveStrangePart),
            1074 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeScores),
            1075 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            1077 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyUpgradeCard),
            1078 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUpgradeCard),
            1079 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeRestriction),
            1080 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketData),
            1081 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse),
            1082 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifier),
            1083 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifierResponse),
            1084 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent),
            1085 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent),
            1086 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse),
            1087 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset),
            1088 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin),
            1089 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRecharger),
            1090 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRechargerResponse),
            1091 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyBaseItemXifier),
            1092 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyClassTransmogrifier),
            1093 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage),
            1094 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreak),
            1095 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreakResponse),
            1096 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast),
            1097 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple),
            1098 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver),
            1100 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            1101 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNames),
            1102 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse),
            1500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTradingBase),
            1501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest),
            1502 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse),
            1503 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_StartSession),
            1509 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_SessionClosed),
            1510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_CancelSession),
            1514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse),
            1601 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer),
            1602 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer),
            1700 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerRentalsBase),
            1701 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewCheckStatus),
            1702 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewStatusResponse),
            1703 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequest),
            1704 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequestResponse),
            1705 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpire),
            1706 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpireNotification),
            1708 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification),
            2001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            2002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            2003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest),
            2500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserData),
            2501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserDataResponse),
            2502 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED),
            2503 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED),
            2512 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            2513 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            2514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            2515 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            2508 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn),
            2509 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse),
            2510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            2511 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            2516 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            2517 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache),
            2518 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            2521 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            2522 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            2523 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            2524 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            2525 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncements),
            2526 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse),
            2527 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestPassportItemGrant),
            2528 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            2531 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase),
            2532 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse),
            2533 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase),
            2534 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse),
            2535 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            2536 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            2537 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            2538 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            2539 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            2540 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            2541 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            2542 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            2543 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            2544 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            2555 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            2556 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCThankedByNewUser),
            2557 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCShuffleCrateContents),
            2558 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_Progress),
            2559 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestCompleted),
            2560 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyDuckToken),
            2562 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_PointsChange),
            2564 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems),
            2565 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse),
            2566 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer),
            2567 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCollectionUpgrade),
            2568 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftHalloweenOffering),
            2569 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestDiscard_Request),
            2570 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedBy),
            2571 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedByResponse),
            2572 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizer),
            2573 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizerResponse),
            2574 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCommonStatClock),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCItemMsg> {
        match str {
            "k_EMsgGCBase" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            "k_EMsgGCSetSingleItemPosition" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetSingleItemPosition),
            "k_EMsgGCCraft" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraft),
            "k_EMsgGCCraftResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftResponse),
            "k_EMsgGCDelete" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            "k_EMsgGCVerifyCacheSubscription" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            "k_EMsgGCNameItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItem),
            "k_EMsgGCUnlockCrate" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrate),
            "k_EMsgGCUnlockCrateResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrateResponse),
            "k_EMsgGCPaintItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            "k_EMsgGCPaintItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            "k_EMsgGCGoldenWrenchBroadcast" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast),
            "k_EMsgGCMOTDRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequest),
            "k_EMsgGCMOTDRequestResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequestResponse),
            "k_EMsgGCNameBaseItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            "k_EMsgGCNameBaseItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            "k_EMsgGCRemoveSocketItem_DEPRECATED" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED),
            "k_EMsgGCRemoveSocketItemResponse_DEPRECATED" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED),
            "k_EMsgGCCustomizeItemTexture" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTexture),
            "k_EMsgGCCustomizeItemTextureResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse),
            "k_EMsgGCUseItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            "k_EMsgGCUseItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            "k_EMsgGCRespawnPostLoadoutChange" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange),
            "k_EMsgGCRemoveItemName" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemName),
            "k_EMsgGCRemoveItemPaint" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemPaint),
            "k_EMsgGCGiftWrapItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItem),
            "k_EMsgGCGiftWrapItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItemResponse),
            "k_EMsgGCDeliverGift" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGift),
            "k_EMsgGCDeliverGiftResponseReceiver" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver),
            "k_EMsgGCUnwrapGiftRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            "k_EMsgGCUnwrapGiftResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            "k_EMsgGCSetItemStyle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemStyle),
            "k_EMsgGCUsedClaimCodeItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUsedClaimCodeItem),
            "k_EMsgGCSortItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            "k_EMsgGC_RevolvingLootList_DEPRECATED" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED),
            "k_EMsgGCLookupAccount" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccount),
            "k_EMsgGCLookupAccountResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountResponse),
            "k_EMsgGCLookupAccountName" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountName),
            "k_EMsgGCLookupAccountNameResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountNameResponse),
            "k_EMsgGCUpdateItemSchema" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUpdateItemSchema),
            "k_EMsgGCRequestInventoryRefresh" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestInventoryRefresh),
            "k_EMsgGCRemoveCustomTexture" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTexture),
            "k_EMsgGCRemoveCustomTextureResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse),
            "k_EMsgGCRemoveMakersMark" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMark),
            "k_EMsgGCRemoveMakersMarkResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse),
            "k_EMsgGCRemoveUniqueCraftIndex" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex),
            "k_EMsgGCRemoveUniqueCraftIndexResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse),
            "k_EMsgGCSaxxyBroadcast" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSaxxyBroadcast),
            "k_EMsgGCBackpackSortFinished" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            "k_EMsgGCAdjustItemEquippedState" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            "k_EMsgGCCollectItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCollectItem),
            "k_EMsgGCItemAcknowledged" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            "k_EMsgGCPresets_SelectPresetForClass" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass),
            "k_EMsgGCPresets_SetItemPosition" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SetItemPosition),
            "k_EMsgGC_ReportAbuse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuse),
            "k_EMsgGC_ReportAbuseResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuseResponse),
            "k_EMsgGCPresets_SelectPresetForClassReply" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply),
            "k_EMsgGCNameItemNotification" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItemNotification),
            "k_EMsgGCClientDisplayNotification" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientDisplayNotification),
            "k_EMsgGCApplyStrangePart" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            "k_EMsgGC_IncrementKillCountAttribute" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute),
            "k_EMsgGC_IncrementKillCountResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountResponse),
            "k_EMsgGCRemoveStrangePart" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveStrangePart),
            "k_EMsgGCResetStrangeScores" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeScores),
            "k_EMsgGCGiftedItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            "k_EMsgGCApplyUpgradeCard" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyUpgradeCard),
            "k_EMsgGCRemoveUpgradeCard" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUpgradeCard),
            "k_EMsgGCApplyStrangeRestriction" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeRestriction),
            "k_EMsgGCClientRequestMarketData" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketData),
            "k_EMsgGCClientRequestMarketDataResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse),
            "k_EMsgGCApplyXifier" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifier),
            "k_EMsgGCApplyXifierResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifierResponse),
            "k_EMsgGC_TrackUniquePlayerPairEvent" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent),
            "k_EMsgGCFulfillDynamicRecipeComponent" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent),
            "k_EMsgGCFulfillDynamicRecipeComponentResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse),
            "k_EMsgGCSetItemEffectVerticalOffset" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset),
            "k_EMsgGCSetHatEffectUseHeadOrigin" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin),
            "k_EMsgGCItemEaterRecharger" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRecharger),
            "k_EMsgGCItemEaterRechargerResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRechargerResponse),
            "k_EMsgGCApplyBaseItemXifier" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyBaseItemXifier),
            "k_EMsgGCApplyClassTransmogrifier" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyClassTransmogrifier),
            "k_EMsgGCApplyHalloweenSpellbookPage" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage),
            "k_EMsgGCRemoveKillStreak" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreak),
            "k_EMsgGCRemoveKillStreakResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreakResponse),
            "k_EMsgGCTFSpecificItemBroadcast" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast),
            "k_EMsgGC_IncrementKillCountAttribute_Multiple" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple),
            "k_EMsgGCDeliverGiftResponseGiver" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver),
            "k_EMsgGCSetItemPositions" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            "k_EMsgGCLookupMultipleAccountNames" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNames),
            "k_EMsgGCLookupMultipleAccountNamesResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse),
            "k_EMsgGCTradingBase" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTradingBase),
            "k_EMsgGCTrading_InitiateTradeRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest),
            "k_EMsgGCTrading_InitiateTradeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse),
            "k_EMsgGCTrading_StartSession" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_StartSession),
            "k_EMsgGCTrading_SessionClosed" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_SessionClosed),
            "k_EMsgGCTrading_CancelSession" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_CancelSession),
            "k_EMsgGCTrading_InitiateTradeRequestResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse),
            "k_EMsgGCServerBrowser_FavoriteServer" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer),
            "k_EMsgGCServerBrowser_BlacklistServer" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer),
            "k_EMsgGCServerRentalsBase" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerRentalsBase),
            "k_EMsgGCItemPreviewCheckStatus" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewCheckStatus),
            "k_EMsgGCItemPreviewStatusResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewStatusResponse),
            "k_EMsgGCItemPreviewRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequest),
            "k_EMsgGCItemPreviewRequestResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequestResponse),
            "k_EMsgGCItemPreviewExpire" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpire),
            "k_EMsgGCItemPreviewExpireNotification" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpireNotification),
            "k_EMsgGCItemPreviewItemBoughtNotification" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification),
            "k_EMsgGCDev_NewItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            "k_EMsgGCDev_NewItemRequestResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            "k_EMsgGCDev_DebugRollLootRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest),
            "k_EMsgGCStoreGetUserData" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserData),
            "k_EMsgGCStoreGetUserDataResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserDataResponse),
            "k_EMsgGCStorePurchaseInit_DEPRECATED" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED),
            "k_EMsgGCStorePurchaseInitResponse_DEPRECATED" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED),
            "k_EMsgGCStorePurchaseFinalize" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            "k_EMsgGCStorePurchaseFinalizeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            "k_EMsgGCStorePurchaseCancel" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            "k_EMsgGCStorePurchaseCancelResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            "k_EMsgGCStorePurchaseQueryTxn" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn),
            "k_EMsgGCStorePurchaseQueryTxnResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse),
            "k_EMsgGCStorePurchaseInit" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            "k_EMsgGCStorePurchaseInitResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            "k_EMsgGCToGCDirtySDOCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            "k_EMsgGCToGCDirtyMultipleSDOCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache),
            "k_EMsgGCToGCUpdateSQLKeyValue" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            "k_EMsgGCToGCBroadcastConsoleCommand" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            "k_EMsgGCServerVersionUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            "k_EMsgGCApplyAutograph" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            "k_EMsgGCToGCWebAPIAccountChanged" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            "k_EMsgGCRequestAnnouncements" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncements),
            "k_EMsgGCRequestAnnouncementsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse),
            "k_EMsgGCRequestPassportItemGrant" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestPassportItemGrant),
            "k_EMsgGCClientVersionUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            "k_EMsgGCItemPurgatory_FinalizePurchase" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase),
            "k_EMsgGCItemPurgatory_FinalizePurchaseResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse),
            "k_EMsgGCItemPurgatory_RefundPurchase" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase),
            "k_EMsgGCItemPurgatory_RefundPurchaseResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse),
            "k_EMsgGCToGCPlayerStrangeCountAdjustments" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            "k_EMsgGCRequestStoreSalesData" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            "k_EMsgGCRequestStoreSalesDataResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            "k_EMsgGCRequestStoreSalesDataUpToDateResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            "k_EMsgGCToGCPingRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            "k_EMsgGCToGCPingResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            "k_EMsgGCToGCGetUserSessionServer" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            "k_EMsgGCToGCGetUserSessionServerResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            "k_EMsgGCToGCGetUserServerMembers" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            "k_EMsgGCToGCGetUserServerMembersResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            "k_EMsgGCToGCGrantSelfMadeItemToAccount" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            "k_EMsgGCToGCThankedByNewUser" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCThankedByNewUser),
            "k_EMsgGCShuffleCrateContents" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCShuffleCrateContents),
            "k_EMsgGCQuestObjective_Progress" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_Progress),
            "k_EMsgGCQuestCompleted" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestCompleted),
            "k_EMsgGCApplyDuckToken" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyDuckToken),
            "k_EMsgGCQuestObjective_PointsChange" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_PointsChange),
            "k_EMsgGCQuestObjective_RequestLoanerItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems),
            "k_EMsgGCQuestObjective_RequestLoanerResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse),
            "k_EMsgGCApplyStrangeCountTransfer" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer),
            "k_EMsgGCCraftCollectionUpgrade" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCollectionUpgrade),
            "k_EMsgGCCraftHalloweenOffering" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftHalloweenOffering),
            "k_EMsgGCQuestDiscard_Request" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestDiscard_Request),
            "k_EMsgGCRemoveGiftedBy" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedBy),
            "k_EMsgGCRemoveGiftedByResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedByResponse),
            "k_EMsgGCRemoveFestivizer" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizer),
            "k_EMsgGCRemoveFestivizerResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizerResponse),
            "k_EMsgGCCraftCommonStatClock" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCommonStatClock),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCItemMsg] = &[
        EGCItemMsg::k_EMsgGCBase,
        EGCItemMsg::k_EMsgGCSetSingleItemPosition,
        EGCItemMsg::k_EMsgGCCraft,
        EGCItemMsg::k_EMsgGCCraftResponse,
        EGCItemMsg::k_EMsgGCDelete,
        EGCItemMsg::k_EMsgGCVerifyCacheSubscription,
        EGCItemMsg::k_EMsgGCNameItem,
        EGCItemMsg::k_EMsgGCUnlockCrate,
        EGCItemMsg::k_EMsgGCUnlockCrateResponse,
        EGCItemMsg::k_EMsgGCPaintItem,
        EGCItemMsg::k_EMsgGCPaintItemResponse,
        EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast,
        EGCItemMsg::k_EMsgGCMOTDRequest,
        EGCItemMsg::k_EMsgGCMOTDRequestResponse,
        EGCItemMsg::k_EMsgGCNameBaseItem,
        EGCItemMsg::k_EMsgGCNameBaseItemResponse,
        EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED,
        EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED,
        EGCItemMsg::k_EMsgGCCustomizeItemTexture,
        EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse,
        EGCItemMsg::k_EMsgGCUseItemRequest,
        EGCItemMsg::k_EMsgGCUseItemResponse,
        EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange,
        EGCItemMsg::k_EMsgGCRemoveItemName,
        EGCItemMsg::k_EMsgGCRemoveItemPaint,
        EGCItemMsg::k_EMsgGCGiftWrapItem,
        EGCItemMsg::k_EMsgGCGiftWrapItemResponse,
        EGCItemMsg::k_EMsgGCDeliverGift,
        EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver,
        EGCItemMsg::k_EMsgGCUnwrapGiftRequest,
        EGCItemMsg::k_EMsgGCUnwrapGiftResponse,
        EGCItemMsg::k_EMsgGCSetItemStyle,
        EGCItemMsg::k_EMsgGCUsedClaimCodeItem,
        EGCItemMsg::k_EMsgGCSortItems,
        EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED,
        EGCItemMsg::k_EMsgGCLookupAccount,
        EGCItemMsg::k_EMsgGCLookupAccountResponse,
        EGCItemMsg::k_EMsgGCLookupAccountName,
        EGCItemMsg::k_EMsgGCLookupAccountNameResponse,
        EGCItemMsg::k_EMsgGCUpdateItemSchema,
        EGCItemMsg::k_EMsgGCRequestInventoryRefresh,
        EGCItemMsg::k_EMsgGCRemoveCustomTexture,
        EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse,
        EGCItemMsg::k_EMsgGCRemoveMakersMark,
        EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse,
        EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex,
        EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse,
        EGCItemMsg::k_EMsgGCSaxxyBroadcast,
        EGCItemMsg::k_EMsgGCBackpackSortFinished,
        EGCItemMsg::k_EMsgGCAdjustItemEquippedState,
        EGCItemMsg::k_EMsgGCCollectItem,
        EGCItemMsg::k_EMsgGCItemAcknowledged,
        EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass,
        EGCItemMsg::k_EMsgGCPresets_SetItemPosition,
        EGCItemMsg::k_EMsgGC_ReportAbuse,
        EGCItemMsg::k_EMsgGC_ReportAbuseResponse,
        EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply,
        EGCItemMsg::k_EMsgGCNameItemNotification,
        EGCItemMsg::k_EMsgGCClientDisplayNotification,
        EGCItemMsg::k_EMsgGCApplyStrangePart,
        EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute,
        EGCItemMsg::k_EMsgGC_IncrementKillCountResponse,
        EGCItemMsg::k_EMsgGCRemoveStrangePart,
        EGCItemMsg::k_EMsgGCResetStrangeScores,
        EGCItemMsg::k_EMsgGCGiftedItems,
        EGCItemMsg::k_EMsgGCApplyUpgradeCard,
        EGCItemMsg::k_EMsgGCRemoveUpgradeCard,
        EGCItemMsg::k_EMsgGCApplyStrangeRestriction,
        EGCItemMsg::k_EMsgGCClientRequestMarketData,
        EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse,
        EGCItemMsg::k_EMsgGCApplyXifier,
        EGCItemMsg::k_EMsgGCApplyXifierResponse,
        EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent,
        EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent,
        EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse,
        EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset,
        EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin,
        EGCItemMsg::k_EMsgGCItemEaterRecharger,
        EGCItemMsg::k_EMsgGCItemEaterRechargerResponse,
        EGCItemMsg::k_EMsgGCApplyBaseItemXifier,
        EGCItemMsg::k_EMsgGCApplyClassTransmogrifier,
        EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage,
        EGCItemMsg::k_EMsgGCRemoveKillStreak,
        EGCItemMsg::k_EMsgGCRemoveKillStreakResponse,
        EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast,
        EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple,
        EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver,
        EGCItemMsg::k_EMsgGCSetItemPositions,
        EGCItemMsg::k_EMsgGCLookupMultipleAccountNames,
        EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse,
        EGCItemMsg::k_EMsgGCTradingBase,
        EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest,
        EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse,
        EGCItemMsg::k_EMsgGCTrading_StartSession,
        EGCItemMsg::k_EMsgGCTrading_SessionClosed,
        EGCItemMsg::k_EMsgGCTrading_CancelSession,
        EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse,
        EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer,
        EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer,
        EGCItemMsg::k_EMsgGCServerRentalsBase,
        EGCItemMsg::k_EMsgGCItemPreviewCheckStatus,
        EGCItemMsg::k_EMsgGCItemPreviewStatusResponse,
        EGCItemMsg::k_EMsgGCItemPreviewRequest,
        EGCItemMsg::k_EMsgGCItemPreviewRequestResponse,
        EGCItemMsg::k_EMsgGCItemPreviewExpire,
        EGCItemMsg::k_EMsgGCItemPreviewExpireNotification,
        EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification,
        EGCItemMsg::k_EMsgGCDev_NewItemRequest,
        EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse,
        EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest,
        EGCItemMsg::k_EMsgGCStoreGetUserData,
        EGCItemMsg::k_EMsgGCStoreGetUserDataResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED,
        EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalize,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseCancel,
        EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn,
        EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseInit,
        EGCItemMsg::k_EMsgGCStorePurchaseInitResponse,
        EGCItemMsg::k_EMsgGCToGCDirtySDOCache,
        EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache,
        EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue,
        EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand,
        EGCItemMsg::k_EMsgGCServerVersionUpdated,
        EGCItemMsg::k_EMsgGCApplyAutograph,
        EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged,
        EGCItemMsg::k_EMsgGCRequestAnnouncements,
        EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse,
        EGCItemMsg::k_EMsgGCRequestPassportItemGrant,
        EGCItemMsg::k_EMsgGCClientVersionUpdated,
        EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase,
        EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse,
        EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase,
        EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse,
        EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments,
        EGCItemMsg::k_EMsgGCRequestStoreSalesData,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse,
        EGCItemMsg::k_EMsgGCToGCPingRequest,
        EGCItemMsg::k_EMsgGCToGCPingResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServer,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembers,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse,
        EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount,
        EGCItemMsg::k_EMsgGCToGCThankedByNewUser,
        EGCItemMsg::k_EMsgGCShuffleCrateContents,
        EGCItemMsg::k_EMsgGCQuestObjective_Progress,
        EGCItemMsg::k_EMsgGCQuestCompleted,
        EGCItemMsg::k_EMsgGCApplyDuckToken,
        EGCItemMsg::k_EMsgGCQuestObjective_PointsChange,
        EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems,
        EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse,
        EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer,
        EGCItemMsg::k_EMsgGCCraftCollectionUpgrade,
        EGCItemMsg::k_EMsgGCCraftHalloweenOffering,
        EGCItemMsg::k_EMsgGCQuestDiscard_Request,
        EGCItemMsg::k_EMsgGCRemoveGiftedBy,
        EGCItemMsg::k_EMsgGCRemoveGiftedByResponse,
        EGCItemMsg::k_EMsgGCRemoveFestivizer,
        EGCItemMsg::k_EMsgGCRemoveFestivizerResponse,
        EGCItemMsg::k_EMsgGCCraftCommonStatClock,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCItemMsg {
    fn default() -> Self {
        EGCItemMsg::k_EMsgGCBase
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCMsgResponse)
pub enum EGCMsgResponse {
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseOK)
    k_EGCMsgResponseOK = 0,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseDenied)
    k_EGCMsgResponseDenied = 1,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseServerError)
    k_EGCMsgResponseServerError = 2,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseTimeout)
    k_EGCMsgResponseTimeout = 3,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseInvalid)
    k_EGCMsgResponseInvalid = 4,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseNoMatch)
    k_EGCMsgResponseNoMatch = 5,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseUnknownError)
    k_EGCMsgResponseUnknownError = 6,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseNotLoggedOn)
    k_EGCMsgResponseNotLoggedOn = 7,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgFailedToCreate)
    k_EGCMsgFailedToCreate = 8,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGCMsgResponse {
    const NAME: &'static str = "EGCMsgResponse";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCMsgResponse> {
        match value {
            0 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseOK),
            1 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseDenied),
            2 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseServerError),
            3 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseTimeout),
            4 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseInvalid),
            5 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNoMatch),
            6 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseUnknownError),
            7 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNotLoggedOn),
            8 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgFailedToCreate),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCMsgResponse> {
        match str {
            "k_EGCMsgResponseOK" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseOK),
            "k_EGCMsgResponseDenied" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseDenied),
            "k_EGCMsgResponseServerError" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseServerError),
            "k_EGCMsgResponseTimeout" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseTimeout),
            "k_EGCMsgResponseInvalid" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseInvalid),
            "k_EGCMsgResponseNoMatch" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNoMatch),
            "k_EGCMsgResponseUnknownError" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseUnknownError),
            "k_EGCMsgResponseNotLoggedOn" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNotLoggedOn),
            "k_EGCMsgFailedToCreate" => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgFailedToCreate),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCMsgResponse] = &[
        EGCMsgResponse::k_EGCMsgResponseOK,
        EGCMsgResponse::k_EGCMsgResponseDenied,
        EGCMsgResponse::k_EGCMsgResponseServerError,
        EGCMsgResponse::k_EGCMsgResponseTimeout,
        EGCMsgResponse::k_EGCMsgResponseInvalid,
        EGCMsgResponse::k_EGCMsgResponseNoMatch,
        EGCMsgResponse::k_EGCMsgResponseUnknownError,
        EGCMsgResponse::k_EGCMsgResponseNotLoggedOn,
        EGCMsgResponse::k_EGCMsgFailedToCreate,
    ];
}

impl ::std::default::Default for EGCMsgResponse {
    fn default() -> Self {
        EGCMsgResponse::k_EGCMsgResponseOK
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUnlockStyle)
pub enum EUnlockStyle {
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Succeeded)
    k_UnlockStyle_Succeeded = 0,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_PreReq)
    k_UnlockStyle_Failed_PreReq = 1,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantAfford)
    k_UnlockStyle_Failed_CantAfford = 2,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantCommit)
    k_UnlockStyle_Failed_CantCommit = 3,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantLockCache)
    k_UnlockStyle_Failed_CantLockCache = 4,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantAffordAttrib)
    k_UnlockStyle_Failed_CantAffordAttrib = 5,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantAffordGem)
    k_UnlockStyle_Failed_CantAffordGem = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for EUnlockStyle {
    const NAME: &'static str = "EUnlockStyle";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUnlockStyle> {
        match value {
            0 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
            1 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
            2 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
            3 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
            4 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
            5 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
            6 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUnlockStyle> {
        match str {
            "k_UnlockStyle_Succeeded" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
            "k_UnlockStyle_Failed_PreReq" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
            "k_UnlockStyle_Failed_CantAfford" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
            "k_UnlockStyle_Failed_CantCommit" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
            "k_UnlockStyle_Failed_CantLockCache" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
            "k_UnlockStyle_Failed_CantAffordAttrib" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
            "k_UnlockStyle_Failed_CantAffordGem" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUnlockStyle] = &[
        EUnlockStyle::k_UnlockStyle_Succeeded,
        EUnlockStyle::k_UnlockStyle_Failed_PreReq,
        EUnlockStyle::k_UnlockStyle_Failed_CantAfford,
        EUnlockStyle::k_UnlockStyle_Failed_CantCommit,
        EUnlockStyle::k_UnlockStyle_Failed_CantLockCache,
        EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib,
        EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem,
    ];
}

impl ::std::default::Default for EUnlockStyle {
    fn default() -> Self {
        EUnlockStyle::k_UnlockStyle_Succeeded
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EItemPurgatoryResponse_Finalize)
pub enum EItemPurgatoryResponse_Finalize {
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Succeeded)
    k_ItemPurgatoryResponse_Finalize_Succeeded = 0,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_Incomplete)
    k_ItemPurgatoryResponse_Finalize_Failed_Incomplete = 1,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory)
    k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory = 2,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems)
    k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems = 3,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache)
    k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache = 4,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_BackpackFull)
    k_ItemPurgatoryResponse_Finalize_BackpackFull = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EItemPurgatoryResponse_Finalize {
    const NAME: &'static str = "EItemPurgatoryResponse_Finalize";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Finalize> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EItemPurgatoryResponse_Finalize> {
        match str {
            "k_ItemPurgatoryResponse_Finalize_Succeeded" => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded),
            "k_ItemPurgatoryResponse_Finalize_Failed_Incomplete" => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete),
            "k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory" => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory),
            "k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems" => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems),
            "k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache" => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache),
            "k_ItemPurgatoryResponse_Finalize_BackpackFull" => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EItemPurgatoryResponse_Finalize] = &[
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull,
    ];
}

impl ::std::default::Default for EItemPurgatoryResponse_Finalize {
    fn default() -> Self {
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EItemPurgatoryResponse_Refund)
pub enum EItemPurgatoryResponse_Refund {
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Succeeded)
    k_ItemPurgatoryResponse_Refund_Succeeded = 0,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory)
    k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory = 1,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem)
    k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem = 2,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_NoSOCache)
    k_ItemPurgatoryResponse_Refund_Failed_NoSOCache = 3,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_NoDetail)
    k_ItemPurgatoryResponse_Refund_Failed_NoDetail = 4,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI)
    k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EItemPurgatoryResponse_Refund {
    const NAME: &'static str = "EItemPurgatoryResponse_Refund";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Refund> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EItemPurgatoryResponse_Refund> {
        match str {
            "k_ItemPurgatoryResponse_Refund_Succeeded" => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded),
            "k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory" => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory),
            "k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem" => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem),
            "k_ItemPurgatoryResponse_Refund_Failed_NoSOCache" => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache),
            "k_ItemPurgatoryResponse_Refund_Failed_NoDetail" => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail),
            "k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI" => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EItemPurgatoryResponse_Refund] = &[
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI,
    ];
}

impl ::std::default::Default for EItemPurgatoryResponse_Refund {
    fn default() -> Self {
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyAutograph {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgEconPlayerStrangeCountAdjustment {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgRequestItemPurgatory_FinalizePurchase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRequestItemPurgatory_RefundPurchase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCraftingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestStoreSalesData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestStoreSalesDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCPingRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCPingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserSessionServer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserSessionServerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserServerMembers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserServerMembersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLookupMultipleAccountNames {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLookupMultipleAccountNamesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCThankedByNewUser {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCShuffleCrateContents {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestObjective_Progress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestObjective_PointsChange {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestComplete_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestObjective_RequestLoanerItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCQuestObjective_RequestLoanerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCraftCollectionUpgrade {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCraftHalloweenOffering {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCraftCommonStatClock {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestDiscard_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
