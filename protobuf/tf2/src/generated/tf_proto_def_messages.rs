// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tf_proto_def_messages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgFieldID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFieldID {
    // message fields
    // @@protoc_insertion_point(field:CMsgFieldID.field)
    pub field: ::std::vec::Vec<cmsg_field_id::CMsgField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFieldID.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFieldID {
    fn default() -> &'a CMsgFieldID {
        <CMsgFieldID as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFieldID {
    pub fn new() -> CMsgFieldID {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFieldID {
    const NAME: &'static str = "CMsgFieldID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.field.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.field {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFieldID {
        CMsgFieldID::new()
    }

    fn clear(&mut self) {
        self.field.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFieldID {
        static instance: CMsgFieldID = CMsgFieldID {
            field: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgFieldID`
pub mod cmsg_field_id {
    // @@protoc_insertion_point(message:CMsgFieldID.CMsgField)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgField {
        // message fields
        // @@protoc_insertion_point(field:CMsgFieldID.CMsgField.field_number)
        pub field_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgFieldID.CMsgField.repeated_index)
        pub repeated_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgFieldID.CMsgField.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgField {
        fn default() -> &'a CMsgField {
            <CMsgField as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CMsgField {
        pub fn new() -> CMsgField {
            ::std::default::Default::default()
        }

        // optional uint32 field_number = 1;

        pub fn field_number(&self) -> u32 {
            self.field_number.unwrap_or(0)
        }

        pub fn clear_field_number(&mut self) {
            self.field_number = ::std::option::Option::None;
        }

        pub fn has_field_number(&self) -> bool {
            self.field_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_field_number(&mut self, v: u32) {
            self.field_number = ::std::option::Option::Some(v);
        }

        // optional uint32 repeated_index = 2;

        pub fn repeated_index(&self) -> u32 {
            self.repeated_index.unwrap_or(0)
        }

        pub fn clear_repeated_index(&mut self) {
            self.repeated_index = ::std::option::Option::None;
        }

        pub fn has_repeated_index(&self) -> bool {
            self.repeated_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_repeated_index(&mut self, v: u32) {
            self.repeated_index = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CMsgField {
        const NAME: &'static str = "CMsgField";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.field_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.repeated_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.field_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.repeated_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.field_number {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.repeated_index {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgField {
            CMsgField::new()
        }

        fn clear(&mut self) {
            self.field_number = ::std::option::Option::None;
            self.repeated_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgField {
            static instance: CMsgField = CMsgField {
                field_number: ::std::option::Option::None,
                repeated_index: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgUniversalFieldID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUniversalFieldID {
    // message fields
    // @@protoc_insertion_point(field:CMsgUniversalFieldID.source_type)
    pub source_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EValueDefinitionSource>>,
    // @@protoc_insertion_point(field:CMsgUniversalFieldID.defining_obj_id)
    pub defining_obj_id: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgUniversalFieldID.field_id)
    pub field_id: ::steam_vent_proto_common::protobuf::MessageField<CMsgFieldID>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUniversalFieldID.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUniversalFieldID {
    fn default() -> &'a CMsgUniversalFieldID {
        <CMsgUniversalFieldID as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUniversalFieldID {
    pub fn new() -> CMsgUniversalFieldID {
        ::std::default::Default::default()
    }

    // optional .EValueDefinitionSource source_type = 1;

    pub fn source_type(&self) -> EValueDefinitionSource {
        match self.source_type {
            Some(e) => e.enum_value_or(EValueDefinitionSource::REFERENCE_DEFINES),
            None => EValueDefinitionSource::REFERENCE_DEFINES,
        }
    }

    pub fn clear_source_type(&mut self) {
        self.source_type = ::std::option::Option::None;
    }

    pub fn has_source_type(&self) -> bool {
        self.source_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: EValueDefinitionSource) {
        self.source_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUniversalFieldID {
    const NAME: &'static str = "CMsgUniversalFieldID";

    fn is_initialized(&self) -> bool {
        for v in &self.defining_obj_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.defining_obj_id)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.field_id)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.defining_obj_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.field_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.defining_obj_id.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.field_id.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUniversalFieldID {
        CMsgUniversalFieldID::new()
    }

    fn clear(&mut self) {
        self.source_type = ::std::option::Option::None;
        self.defining_obj_id.clear();
        self.field_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUniversalFieldID {
        static instance: CMsgUniversalFieldID = CMsgUniversalFieldID {
            source_type: ::std::option::Option::None,
            defining_obj_id: ::steam_vent_proto_common::protobuf::MessageField::none(),
            field_id: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgVariableDefinition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVariableDefinition {
    // message fields
    // @@protoc_insertion_point(field:CMsgVariableDefinition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgVariableDefinition.inherit)
    pub inherit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgVariableDefinition.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVariableDefinition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVariableDefinition {
    fn default() -> &'a CMsgVariableDefinition {
        <CMsgVariableDefinition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgVariableDefinition {
    pub fn new() -> CMsgVariableDefinition {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool inherit = 2;

    pub fn inherit(&self) -> bool {
        self.inherit.unwrap_or(true)
    }

    pub fn clear_inherit(&mut self) {
        self.inherit = ::std::option::Option::None;
    }

    pub fn has_inherit(&self) -> bool {
        self.inherit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit(&mut self, v: bool) {
        self.inherit = ::std::option::Option::Some(v);
    }

    // optional string value = 3;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgVariableDefinition {
    const NAME: &'static str = "CMsgVariableDefinition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.inherit = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inherit {
            my_size += 1 + 1;
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.inherit {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVariableDefinition {
        CMsgVariableDefinition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.inherit = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVariableDefinition {
        static instance: CMsgVariableDefinition = CMsgVariableDefinition {
            name: ::std::option::Option::None,
            inherit: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgProtoDefHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtoDefHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.prefabs)
    pub prefabs: ::std::vec::Vec<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.prefab_only)
    pub prefab_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoDefHeader.variables)
    pub variables: ::std::vec::Vec<CMsgVariableDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtoDefHeader.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtoDefHeader {
    fn default() -> &'a CMsgProtoDefHeader {
        <CMsgProtoDefHeader as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProtoDefHeader {
    pub fn new() -> CMsgProtoDefHeader {
        ::std::default::Default::default()
    }

    // required uint32 defindex = 1;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool prefab_only = 5;

    pub fn prefab_only(&self) -> bool {
        self.prefab_only.unwrap_or(false)
    }

    pub fn clear_prefab_only(&mut self) {
        self.prefab_only = ::std::option::Option::None;
    }

    pub fn has_prefab_only(&self) -> bool {
        self.prefab_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefab_only(&mut self, v: bool) {
        self.prefab_only = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProtoDefHeader {
    const NAME: &'static str = "CMsgProtoDefHeader";

    fn is_initialized(&self) -> bool {
        if self.defindex.is_none() {
            return false;
        }
        for v in &self.prefabs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.prefabs.push(is.read_message()?);
                },
                34 => {
                    self.tags.push(is.read_string()?);
                },
                40 => {
                    self.prefab_only = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.variables.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        for value in &self.prefabs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tags {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.prefab_only {
            my_size += 1 + 1;
        }
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.prefabs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.prefab_only {
            os.write_bool(5, v)?;
        }
        for v in &self.variables {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtoDefHeader {
        CMsgProtoDefHeader::new()
    }

    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.prefabs.clear();
        self.tags.clear();
        self.prefab_only = ::std::option::Option::None;
        self.variables.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtoDefHeader {
        static instance: CMsgProtoDefHeader = CMsgProtoDefHeader {
            defindex: ::std::option::Option::None,
            name: ::std::option::Option::None,
            prefabs: ::std::vec::Vec::new(),
            tags: ::std::vec::Vec::new(),
            prefab_only: ::std::option::Option::None,
            variables: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgValidTypes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgValidTypes {
    // message fields
    // @@protoc_insertion_point(field:CMsgValidTypes.types)
    pub types: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<ProtoDefTypes>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgValidTypes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgValidTypes {
    fn default() -> &'a CMsgValidTypes {
        <CMsgValidTypes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgValidTypes {
    pub fn new() -> CMsgValidTypes {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgValidTypes {
    const NAME: &'static str = "CMsgValidTypes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.types {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.types {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgValidTypes {
        CMsgValidTypes::new()
    }

    fn clear(&mut self) {
        self.types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgValidTypes {
        static instance: CMsgValidTypes = CMsgValidTypes {
            types: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgProtoDefID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtoDefID {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtoDefID.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoDefID.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ProtoDefTypes>>,
    // message oneof groups
    pub instance: ::std::option::Option<cmsg_proto_def_id::Instance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtoDefID.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtoDefID {
    fn default() -> &'a CMsgProtoDefID {
        <CMsgProtoDefID as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProtoDefID {
    pub fn new() -> CMsgProtoDefID {
        ::std::default::Default::default()
    }

    // optional uint32 defindex = 1;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional .ProtoDefTypes type = 2;

    pub fn type_(&self) -> ProtoDefTypes {
        match self.type_ {
            Some(e) => e.enum_value_or(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE),
            None => ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ProtoDefTypes) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgQuestMapNodeDef instance_def_type_quest_map_node = 3;

    pub fn instance_def_type_quest_map_node(&self) -> &CMsgQuestMapNodeDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v)) => v,
            _ => <CMsgQuestMapNodeDef as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_map_node(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_map_node(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_map_node(&mut self, v: CMsgQuestMapNodeDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_map_node(&mut self) -> &mut CMsgQuestMapNodeDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(CMsgQuestMapNodeDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_map_node(&mut self) -> CMsgQuestMapNodeDef {
        if self.has_instance_def_type_quest_map_node() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeDef::new()
        }
    }

    // optional .CMsgQuestTheme instance_def_type_quest_theme = 5;

    pub fn instance_def_type_quest_theme(&self) -> &CMsgQuestTheme {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v)) => v,
            _ => <CMsgQuestTheme as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_theme(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_theme(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_theme(&mut self, v: CMsgQuestTheme) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_theme(&mut self) -> &mut CMsgQuestTheme {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(CMsgQuestTheme::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_theme(&mut self) -> CMsgQuestTheme {
        if self.has_instance_def_type_quest_theme() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestTheme::new()
        }
    }

    // optional .CMsgQuestMapRegionDef instance_def_type_quest_map_region = 6;

    pub fn instance_def_type_quest_map_region(&self) -> &CMsgQuestMapRegionDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v)) => v,
            _ => <CMsgQuestMapRegionDef as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_map_region(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_map_region(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_map_region(&mut self, v: CMsgQuestMapRegionDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_map_region(&mut self) -> &mut CMsgQuestMapRegionDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(CMsgQuestMapRegionDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_map_region(&mut self) -> CMsgQuestMapRegionDef {
        if self.has_instance_def_type_quest_map_region() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapRegionDef::new()
        }
    }

    // optional .CMsgQuestDef instance_def_type_quest = 7;

    pub fn instance_def_type_quest(&self) -> &CMsgQuestDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v)) => v,
            _ => <CMsgQuestDef as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest(&mut self, v: CMsgQuestDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest(&mut self) -> &mut CMsgQuestDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(CMsgQuestDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest(&mut self) -> CMsgQuestDef {
        if self.has_instance_def_type_quest() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestDef::new()
        }
    }

    // optional .CMsgQuestObjectiveDef instance_def_type_quest_objective = 8;

    pub fn instance_def_type_quest_objective(&self) -> &CMsgQuestObjectiveDef {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v)) => v,
            _ => <CMsgQuestObjectiveDef as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_quest_objective(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_objective(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_objective(&mut self, v: CMsgQuestObjectiveDef) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_objective(&mut self) -> &mut CMsgQuestObjectiveDef {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(CMsgQuestObjectiveDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_objective(&mut self) -> CMsgQuestObjectiveDef {
        if self.has_instance_def_type_quest_objective() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestObjectiveDef::new()
        }
    }

    // optional .CMsgPaintKit_Variables instance_def_type_paintkit_variables = 9;

    pub fn instance_def_type_paintkit_variables(&self) -> &CMsgPaintKit_Variables {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v)) => v,
            _ => <CMsgPaintKit_Variables as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_variables(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_variables(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_variables(&mut self, v: CMsgPaintKit_Variables) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_variables(&mut self) -> &mut CMsgPaintKit_Variables {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(CMsgPaintKit_Variables::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_variables(&mut self) -> CMsgPaintKit_Variables {
        if self.has_instance_def_type_paintkit_variables() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Variables::new()
        }
    }

    // optional .CMsgPaintKit_Operation instance_def_type_paintkit_operation = 10;

    pub fn instance_def_type_paintkit_operation(&self) -> &CMsgPaintKit_Operation {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v)) => v,
            _ => <CMsgPaintKit_Operation as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_operation(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_operation(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_operation(&mut self, v: CMsgPaintKit_Operation) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_operation(&mut self) -> &mut CMsgPaintKit_Operation {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(CMsgPaintKit_Operation::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_operation(&mut self) -> CMsgPaintKit_Operation {
        if self.has_instance_def_type_paintkit_operation() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation::new()
        }
    }

    // optional .CMsgPaintKit_ItemDefinition instance_def_type_paintkit_item_definition = 11;

    pub fn instance_def_type_paintkit_item_definition(&self) -> &CMsgPaintKit_ItemDefinition {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v)) => v,
            _ => <CMsgPaintKit_ItemDefinition as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_item_definition(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_item_definition(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_item_definition(&mut self, v: CMsgPaintKit_ItemDefinition) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_item_definition(&mut self) -> &mut CMsgPaintKit_ItemDefinition {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(CMsgPaintKit_ItemDefinition::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_item_definition(&mut self) -> CMsgPaintKit_ItemDefinition {
        if self.has_instance_def_type_paintkit_item_definition() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_ItemDefinition::new()
        }
    }

    // optional .CMsgPaintKit_Definition instance_def_type_paintkit_definition = 12;

    pub fn instance_def_type_paintkit_definition(&self) -> &CMsgPaintKit_Definition {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v)) => v,
            _ => <CMsgPaintKit_Definition as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_paintkit_definition(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_definition(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_definition(&mut self, v: CMsgPaintKit_Definition) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_definition(&mut self) -> &mut CMsgPaintKit_Definition {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(CMsgPaintKit_Definition::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_definition(&mut self) -> CMsgPaintKit_Definition {
        if self.has_instance_def_type_paintkit_definition() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Definition::new()
        }
    }

    // optional .CMsgHeaderOnly instance_def_type_header_only = 13;

    pub fn instance_def_type_header_only(&self) -> &CMsgHeaderOnly {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v)) => v,
            _ => <CMsgHeaderOnly as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_def_type_header_only(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_header_only(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_header_only(&mut self, v: CMsgHeaderOnly) {
        self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_header_only(&mut self) -> &mut CMsgHeaderOnly {
        if let ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(CMsgHeaderOnly::new()));
        }
        match self.instance {
            ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_header_only(&mut self) -> CMsgHeaderOnly {
        if self.has_instance_def_type_header_only() {
            match self.instance.take() {
                ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgHeaderOnly::new()
        }
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProtoDefID {
    const NAME: &'static str = "CMsgProtoDefID";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(is.read_message()?));
                },
                42 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(is.read_message()?));
                },
                50 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(is.read_message()?));
                },
                58 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuest(is.read_message()?));
                },
                66 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(is.read_message()?));
                },
                74 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(is.read_message()?));
                },
                82 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(is.read_message()?));
                },
                90 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(is.read_message()?));
                },
                98 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(is.read_message()?));
                },
                106 => {
                    self.instance = ::std::option::Option::Some(cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(is.read_message()?));
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.instance {
            match v {
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.instance {
            match v {
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapNode(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestTheme(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestMapRegion(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuest(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeQuestObjective(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitVariables(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitOperation(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitItemDefinition(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypePaintkitDefinition(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &cmsg_proto_def_id::Instance::InstanceDefTypeHeaderOnly(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtoDefID {
        CMsgProtoDefID::new()
    }

    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtoDefID {
        static instance: CMsgProtoDefID = CMsgProtoDefID {
            defindex: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            instance: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgProtoDefID`
pub mod cmsg_proto_def_id {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgProtoDefID.instance)
    pub enum Instance {
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_map_node)
        InstanceDefTypeQuestMapNode(super::CMsgQuestMapNodeDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_theme)
        InstanceDefTypeQuestTheme(super::CMsgQuestTheme),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_map_region)
        InstanceDefTypeQuestMapRegion(super::CMsgQuestMapRegionDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest)
        InstanceDefTypeQuest(super::CMsgQuestDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_quest_objective)
        InstanceDefTypeQuestObjective(super::CMsgQuestObjectiveDef),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_variables)
        InstanceDefTypePaintkitVariables(super::CMsgPaintKit_Variables),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_operation)
        InstanceDefTypePaintkitOperation(super::CMsgPaintKit_Operation),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_item_definition)
        InstanceDefTypePaintkitItemDefinition(super::CMsgPaintKit_ItemDefinition),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_paintkit_definition)
        InstanceDefTypePaintkitDefinition(super::CMsgPaintKit_Definition),
        // @@protoc_insertion_point(oneof_field:CMsgProtoDefID.instance_def_type_header_only)
        InstanceDefTypeHeaderOnly(super::CMsgHeaderOnly),
    }

    impl ::steam_vent_proto_common::protobuf::Oneof for Instance {
    }

    impl Instance {
    }
}

// @@protoc_insertion_point(message:CMsgQuestObjectiveDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestObjectiveDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.loc_desctoken)
    pub loc_desctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.points)
    pub points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.conditions_defindex)
    pub conditions_defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.map)
    pub map: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.game_mode)
    pub game_mode: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_quest_objective_def::ETF2GameModes>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.team)
    pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_quest_objective_def::ETF2Team>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.condition_vars)
    pub condition_vars: ::std::vec::Vec<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.classes_vars)
    pub classes_vars: ::std::vec::Vec<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.conditions)
    pub conditions: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_quest_objective_def::ETF2Conditions>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.condition_logic)
    pub condition_logic: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<LogicalOperation>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.item_name)
    pub item_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.item_logic)
    pub item_logic: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<LogicalOperation>>,
    // @@protoc_insertion_point(field:CMsgQuestObjectiveDef.jump_state)
    pub jump_state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestObjectiveDef.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestObjectiveDef {
    fn default() -> &'a CMsgQuestObjectiveDef {
        <CMsgQuestObjectiveDef as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestObjectiveDef {
    pub fn new() -> CMsgQuestObjectiveDef {
        ::std::default::Default::default()
    }

    // optional string loc_desctoken = 2;

    pub fn loc_desctoken(&self) -> &str {
        match self.loc_desctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc_desctoken(&mut self) {
        self.loc_desctoken = ::std::option::Option::None;
    }

    pub fn has_loc_desctoken(&self) -> bool {
        self.loc_desctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_desctoken(&mut self, v: ::std::string::String) {
        self.loc_desctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_desctoken(&mut self) -> &mut ::std::string::String {
        if self.loc_desctoken.is_none() {
            self.loc_desctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc_desctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_desctoken(&mut self) -> ::std::string::String {
        self.loc_desctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 points = 3;

    pub fn points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    // optional uint32 conditions_defindex = 5;

    pub fn conditions_defindex(&self) -> u32 {
        self.conditions_defindex.unwrap_or(0)
    }

    pub fn clear_conditions_defindex(&mut self) {
        self.conditions_defindex = ::std::option::Option::None;
    }

    pub fn has_conditions_defindex(&self) -> bool {
        self.conditions_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditions_defindex(&mut self, v: u32) {
        self.conditions_defindex = ::std::option::Option::Some(v);
    }

    // optional .CMsgQuestObjectiveDef.ETF2Team team = 10;

    pub fn team(&self) -> cmsg_quest_objective_def::ETF2Team {
        match self.team {
            Some(e) => e.enum_value_or(cmsg_quest_objective_def::ETF2Team::TF_TEAM_RED),
            None => cmsg_quest_objective_def::ETF2Team::TF_TEAM_RED,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: cmsg_quest_objective_def::ETF2Team) {
        self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .LogicalOperation condition_logic = 14;

    pub fn condition_logic(&self) -> LogicalOperation {
        match self.condition_logic {
            Some(e) => e.enum_value_or(LogicalOperation::AND),
            None => LogicalOperation::AND,
        }
    }

    pub fn clear_condition_logic(&mut self) {
        self.condition_logic = ::std::option::Option::None;
    }

    pub fn has_condition_logic(&self) -> bool {
        self.condition_logic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition_logic(&mut self, v: LogicalOperation) {
        self.condition_logic = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .LogicalOperation item_logic = 16;

    pub fn item_logic(&self) -> LogicalOperation {
        match self.item_logic {
            Some(e) => e.enum_value_or(LogicalOperation::AND),
            None => LogicalOperation::AND,
        }
    }

    pub fn clear_item_logic(&mut self) {
        self.item_logic = ::std::option::Option::None;
    }

    pub fn has_item_logic(&self) -> bool {
        self.item_logic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_logic(&mut self, v: LogicalOperation) {
        self.item_logic = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 jump_state = 17;

    pub fn jump_state(&self) -> u32 {
        self.jump_state.unwrap_or(0)
    }

    pub fn clear_jump_state(&mut self) {
        self.jump_state = ::std::option::Option::None;
    }

    pub fn has_jump_state(&self) -> bool {
        self.jump_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jump_state(&mut self, v: u32) {
        self.jump_state = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestObjectiveDef {
    const NAME: &'static str = "CMsgQuestObjectiveDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition_vars {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.classes_vars {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.loc_desctoken = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.points = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.conditions_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.map.push(is.read_string()?);
                },
                72 => {
                    self.game_mode.push(is.read_enum_or_unknown()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.game_mode)?
                },
                80 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.condition_vars.push(is.read_message()?);
                },
                98 => {
                    self.classes_vars.push(is.read_message()?);
                },
                104 => {
                    self.conditions.push(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.conditions)?
                },
                112 => {
                    self.condition_logic = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                122 => {
                    self.item_name.push(is.read_string()?);
                },
                128 => {
                    self.item_logic = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.jump_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.conditions_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.map {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &value);
        };
        for value in &self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, value.value());
        };
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
        }
        for value in &self.condition_vars {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.classes_vars {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.conditions {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, value.value());
        };
        if let Some(v) = self.condition_logic {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v.value());
        }
        for value in &self.item_name {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.item_logic {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.jump_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.conditions_defindex {
            os.write_uint32(5, v)?;
        }
        for v in &self.map {
            os.write_string(8, &v)?;
        };
        for v in &self.game_mode {
            os.write_enum(9, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.team {
            os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.condition_vars {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.classes_vars {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.conditions {
            os.write_enum(13, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.condition_logic {
            os.write_enum(14, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.item_name {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.item_logic {
            os.write_enum(16, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.jump_state {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestObjectiveDef {
        CMsgQuestObjectiveDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.loc_desctoken = ::std::option::Option::None;
        self.points = ::std::option::Option::None;
        self.conditions_defindex = ::std::option::Option::None;
        self.map.clear();
        self.game_mode.clear();
        self.team = ::std::option::Option::None;
        self.condition_vars.clear();
        self.classes_vars.clear();
        self.conditions.clear();
        self.condition_logic = ::std::option::Option::None;
        self.item_name.clear();
        self.item_logic = ::std::option::Option::None;
        self.jump_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestObjectiveDef {
        static instance: CMsgQuestObjectiveDef = CMsgQuestObjectiveDef {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            loc_desctoken: ::std::option::Option::None,
            points: ::std::option::Option::None,
            conditions_defindex: ::std::option::Option::None,
            map: ::std::vec::Vec::new(),
            game_mode: ::std::vec::Vec::new(),
            team: ::std::option::Option::None,
            condition_vars: ::std::vec::Vec::new(),
            classes_vars: ::std::vec::Vec::new(),
            conditions: ::std::vec::Vec::new(),
            condition_logic: ::std::option::Option::None,
            item_name: ::std::vec::Vec::new(),
            item_logic: ::std::option::Option::None,
            jump_state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgQuestObjectiveDef`
pub mod cmsg_quest_objective_def {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgQuestObjectiveDef.ETF2GameModes)
    pub enum ETF2GameModes {
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Escort)
        kGameCategory_Escort = 0,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_CTF)
        kGameCategory_CTF = 1,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_AttackDefense)
        kGameCategory_AttackDefense = 2,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Koth)
        kGameCategory_Koth = 3,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_CP)
        kGameCategory_CP = 4,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_EscortRace)
        kGameCategory_EscortRace = 5,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_EventMix)
        kGameCategory_EventMix = 6,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_SD)
        kGameCategory_SD = 7,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Quickplay)
        kGameCategory_Quickplay = 8,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Event247)
        kGameCategory_Event247 = 9,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Arena)
        kGameCategory_Arena = 10,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_RobotDestruction)
        kGameCategory_RobotDestruction = 11,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Powerup)
        kGameCategory_Powerup = 12,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Featured)
        kGameCategory_Featured = 13,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Passtime)
        kGameCategory_Passtime = 14,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Community_Update)
        kGameCategory_Community_Update = 15,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Misc)
        kGameCategory_Misc = 16,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Competitive_6v6)
        kGameCategory_Competitive_6v6 = 17,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Other)
        kGameCategory_Other = 18,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2GameModes.kGameCategory_Halloween)
        kGameCategory_Halloween = 19,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ETF2GameModes {
        const NAME: &'static str = "ETF2GameModes";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETF2GameModes> {
            match value {
                0 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Escort),
                1 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CTF),
                2 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_AttackDefense),
                3 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Koth),
                4 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CP),
                5 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EscortRace),
                6 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EventMix),
                7 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_SD),
                8 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Quickplay),
                9 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Event247),
                10 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Arena),
                11 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_RobotDestruction),
                12 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Powerup),
                13 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Featured),
                14 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Passtime),
                15 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Community_Update),
                16 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Misc),
                17 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Competitive_6v6),
                18 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Other),
                19 => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Halloween),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETF2GameModes> {
            match str {
                "kGameCategory_Escort" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Escort),
                "kGameCategory_CTF" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CTF),
                "kGameCategory_AttackDefense" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_AttackDefense),
                "kGameCategory_Koth" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Koth),
                "kGameCategory_CP" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_CP),
                "kGameCategory_EscortRace" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EscortRace),
                "kGameCategory_EventMix" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_EventMix),
                "kGameCategory_SD" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_SD),
                "kGameCategory_Quickplay" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Quickplay),
                "kGameCategory_Event247" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Event247),
                "kGameCategory_Arena" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Arena),
                "kGameCategory_RobotDestruction" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_RobotDestruction),
                "kGameCategory_Powerup" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Powerup),
                "kGameCategory_Featured" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Featured),
                "kGameCategory_Passtime" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Passtime),
                "kGameCategory_Community_Update" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Community_Update),
                "kGameCategory_Misc" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Misc),
                "kGameCategory_Competitive_6v6" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Competitive_6v6),
                "kGameCategory_Other" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Other),
                "kGameCategory_Halloween" => ::std::option::Option::Some(ETF2GameModes::kGameCategory_Halloween),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETF2GameModes] = &[
            ETF2GameModes::kGameCategory_Escort,
            ETF2GameModes::kGameCategory_CTF,
            ETF2GameModes::kGameCategory_AttackDefense,
            ETF2GameModes::kGameCategory_Koth,
            ETF2GameModes::kGameCategory_CP,
            ETF2GameModes::kGameCategory_EscortRace,
            ETF2GameModes::kGameCategory_EventMix,
            ETF2GameModes::kGameCategory_SD,
            ETF2GameModes::kGameCategory_Quickplay,
            ETF2GameModes::kGameCategory_Event247,
            ETF2GameModes::kGameCategory_Arena,
            ETF2GameModes::kGameCategory_RobotDestruction,
            ETF2GameModes::kGameCategory_Powerup,
            ETF2GameModes::kGameCategory_Featured,
            ETF2GameModes::kGameCategory_Passtime,
            ETF2GameModes::kGameCategory_Community_Update,
            ETF2GameModes::kGameCategory_Misc,
            ETF2GameModes::kGameCategory_Competitive_6v6,
            ETF2GameModes::kGameCategory_Other,
            ETF2GameModes::kGameCategory_Halloween,
        ];
    }

    impl ::std::default::Default for ETF2GameModes {
        fn default() -> Self {
            ETF2GameModes::kGameCategory_Escort
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgQuestObjectiveDef.ETF2Conditions)
    pub enum ETF2Conditions {
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_AIMING)
        TF_COND_AIMING = 0,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ZOOMED)
        TF_COND_ZOOMED = 1,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISING)
        TF_COND_DISGUISING = 2,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISED)
        TF_COND_DISGUISED = 3,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED)
        TF_COND_STEALTHED = 4,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE)
        TF_COND_INVULNERABLE = 5,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TELEPORTED)
        TF_COND_TELEPORTED = 6,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TAUNTING)
        TF_COND_TAUNTING = 7,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_WEARINGOFF)
        TF_COND_INVULNERABLE_WEARINGOFF = 8,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_BLINK)
        TF_COND_STEALTHED_BLINK = 9,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SELECTED_TO_TELEPORT)
        TF_COND_SELECTED_TO_TELEPORT = 10,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED)
        TF_COND_CRITBOOSTED = 11,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TMPDAMAGEBONUS)
        TF_COND_TMPDAMAGEBONUS = 12,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_FEIGN_DEATH)
        TF_COND_FEIGN_DEATH = 13,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PHASE)
        TF_COND_PHASE = 14,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STUNNED)
        TF_COND_STUNNED = 15,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_OFFENSEBUFF)
        TF_COND_OFFENSEBUFF = 16,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SHIELD_CHARGE)
        TF_COND_SHIELD_CHARGE = 17,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEMO_BUFF)
        TF_COND_DEMO_BUFF = 18,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ENERGY_BUFF)
        TF_COND_ENERGY_BUFF = 19,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RADIUSHEAL)
        TF_COND_RADIUSHEAL = 20,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HEALTH_BUFF)
        TF_COND_HEALTH_BUFF = 21,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BURNING)
        TF_COND_BURNING = 22,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HEALTH_OVERHEALED)
        TF_COND_HEALTH_OVERHEALED = 23,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_URINE)
        TF_COND_URINE = 24,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BLEEDING)
        TF_COND_BLEEDING = 25,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEFENSEBUFF)
        TF_COND_DEFENSEBUFF = 26,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MAD_MILK)
        TF_COND_MAD_MILK = 27,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEGAHEAL)
        TF_COND_MEGAHEAL = 28,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_REGENONDAMAGEBUFF)
        TF_COND_REGENONDAMAGEBUFF = 29,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MARKEDFORDEATH)
        TF_COND_MARKEDFORDEATH = 30,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_NOHEALINGDAMAGEBUFF)
        TF_COND_NOHEALINGDAMAGEBUFF = 31,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SPEED_BOOST)
        TF_COND_SPEED_BOOST = 32,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_PUMPKIN)
        TF_COND_CRITBOOSTED_PUMPKIN = 33,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_USER_BUFF)
        TF_COND_CRITBOOSTED_USER_BUFF = 34,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_DEMO_CHARGE)
        TF_COND_CRITBOOSTED_DEMO_CHARGE = 35,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SODAPOPPER_HYPE)
        TF_COND_SODAPOPPER_HYPE = 36,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_FIRST_BLOOD)
        TF_COND_CRITBOOSTED_FIRST_BLOOD = 37,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_BONUS_TIME)
        TF_COND_CRITBOOSTED_BONUS_TIME = 38,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_CTF_CAPTURE)
        TF_COND_CRITBOOSTED_CTF_CAPTURE = 39,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_ON_KILL)
        TF_COND_CRITBOOSTED_ON_KILL = 40,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CANNOT_SWITCH_FROM_MELEE)
        TF_COND_CANNOT_SWITCH_FROM_MELEE = 41,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK)
        TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK = 42,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_REPROGRAMMED)
        TF_COND_REPROGRAMMED = 43,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_RAGE_BUFF)
        TF_COND_CRITBOOSTED_RAGE_BUFF = 44,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DEFENSEBUFF_HIGH)
        TF_COND_DEFENSEBUFF_HIGH = 45,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SNIPERCHARGE_RAGE_BUFF)
        TF_COND_SNIPERCHARGE_RAGE_BUFF = 46,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISE_WEARINGOFF)
        TF_COND_DISGUISE_WEARINGOFF = 47,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MARKEDFORDEATH_SILENT)
        TF_COND_MARKEDFORDEATH_SILENT = 48,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DISGUISED_AS_DISPENSER)
        TF_COND_DISGUISED_AS_DISPENSER = 49,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SAPPED)
        TF_COND_SAPPED = 50,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED)
        TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED = 51,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_USER_BUFF)
        TF_COND_INVULNERABLE_USER_BUFF = 52,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_BOMB_HEAD)
        TF_COND_HALLOWEEN_BOMB_HEAD = 53,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_THRILLER)
        TF_COND_HALLOWEEN_THRILLER = 54,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RADIUSHEAL_ON_DAMAGE)
        TF_COND_RADIUSHEAL_ON_DAMAGE = 55,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_CARD_EFFECT)
        TF_COND_CRITBOOSTED_CARD_EFFECT = 56,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_INVULNERABLE_CARD_EFFECT)
        TF_COND_INVULNERABLE_CARD_EFFECT = 57,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_UBER_BULLET_RESIST)
        TF_COND_MEDIGUN_UBER_BULLET_RESIST = 58,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_UBER_BLAST_RESIST)
        TF_COND_MEDIGUN_UBER_BLAST_RESIST = 59,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_UBER_FIRE_RESIST)
        TF_COND_MEDIGUN_UBER_FIRE_RESIST = 60,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_SMALL_BULLET_RESIST)
        TF_COND_MEDIGUN_SMALL_BULLET_RESIST = 61,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_SMALL_BLAST_RESIST)
        TF_COND_MEDIGUN_SMALL_BLAST_RESIST = 62,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_SMALL_FIRE_RESIST)
        TF_COND_MEDIGUN_SMALL_FIRE_RESIST = 63,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_USER_BUFF)
        TF_COND_STEALTHED_USER_BUFF = 64,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MEDIGUN_DEBUFF)
        TF_COND_MEDIGUN_DEBUFF = 65,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_USER_BUFF_FADING)
        TF_COND_STEALTHED_USER_BUFF_FADING = 66,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BULLET_IMMUNE)
        TF_COND_BULLET_IMMUNE = 67,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BLAST_IMMUNE)
        TF_COND_BLAST_IMMUNE = 68,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_FIRE_IMMUNE)
        TF_COND_FIRE_IMMUNE = 69,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PREVENT_DEATH)
        TF_COND_PREVENT_DEATH = 70,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MVM_BOT_STUN_RADIOWAVE)
        TF_COND_MVM_BOT_STUN_RADIOWAVE = 71,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_SPEED_BOOST)
        TF_COND_HALLOWEEN_SPEED_BOOST = 72,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_QUICK_HEAL)
        TF_COND_HALLOWEEN_QUICK_HEAL = 73,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_GIANT)
        TF_COND_HALLOWEEN_GIANT = 74,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_TINY)
        TF_COND_HALLOWEEN_TINY = 75,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_IN_HELL)
        TF_COND_HALLOWEEN_IN_HELL = 76,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_GHOST_MODE)
        TF_COND_HALLOWEEN_GHOST_MODE = 77,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MINICRITBOOSTED_ON_KILL)
        TF_COND_MINICRITBOOSTED_ON_KILL = 78,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_OBSCURED_SMOKE)
        TF_COND_OBSCURED_SMOKE = 79,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PARACHUTE_ACTIVE)
        TF_COND_PARACHUTE_ACTIVE = 80,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BLASTJUMPING)
        TF_COND_BLASTJUMPING = 81,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_KART)
        TF_COND_HALLOWEEN_KART = 82,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_KART_DASH)
        TF_COND_HALLOWEEN_KART_DASH = 83,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_BALLOON_HEAD)
        TF_COND_BALLOON_HEAD = 84,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_MELEE_ONLY)
        TF_COND_MELEE_ONLY = 85,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SWIMMING_CURSE)
        TF_COND_SWIMMING_CURSE = 86,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_FREEZE_INPUT)
        TF_COND_FREEZE_INPUT = 87,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HALLOWEEN_KART_CAGE)
        TF_COND_HALLOWEEN_KART_CAGE = 88,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_DONOTUSE_0)
        TF_COND_DONOTUSE_0 = 89,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_STRENGTH)
        TF_COND_RUNE_STRENGTH = 90,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_HASTE)
        TF_COND_RUNE_HASTE = 91,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_REGEN)
        TF_COND_RUNE_REGEN = 92,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_RESIST)
        TF_COND_RUNE_RESIST = 93,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_VAMPIRE)
        TF_COND_RUNE_VAMPIRE = 94,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_REFLECT)
        TF_COND_RUNE_REFLECT = 95,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_PRECISION)
        TF_COND_RUNE_PRECISION = 96,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_AGILITY)
        TF_COND_RUNE_AGILITY = 97,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK)
        TF_COND_GRAPPLINGHOOK = 98,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK_SAFEFALL)
        TF_COND_GRAPPLINGHOOK_SAFEFALL = 99,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK_LATCHED)
        TF_COND_GRAPPLINGHOOK_LATCHED = 100,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GRAPPLINGHOOK_BLEEDING)
        TF_COND_GRAPPLINGHOOK_BLEEDING = 101,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_AFTERBURN_IMMUNE)
        TF_COND_AFTERBURN_IMMUNE = 102,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_KNOCKOUT)
        TF_COND_RUNE_KNOCKOUT = 103,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_IMBALANCE)
        TF_COND_RUNE_IMBALANCE = 104,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CRITBOOSTED_RUNE_TEMP)
        TF_COND_CRITBOOSTED_RUNE_TEMP = 105,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PASSTIME_INTERCEPTION)
        TF_COND_PASSTIME_INTERCEPTION = 106,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SWIMMING_NO_EFFECTS)
        TF_COND_SWIMMING_NO_EFFECTS = 107,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PURGATORY)
        TF_COND_PURGATORY = 108,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_KING)
        TF_COND_RUNE_KING = 109,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_PLAGUE)
        TF_COND_RUNE_PLAGUE = 110,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_RUNE_SUPERNOVA)
        TF_COND_RUNE_SUPERNOVA = 111,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PLAGUE)
        TF_COND_PLAGUE = 112,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_KING_BUFFED)
        TF_COND_KING_BUFFED = 113,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TEAM_GLOWS)
        TF_COND_TEAM_GLOWS = 114,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_KNOCKED_INTO_AIR)
        TF_COND_KNOCKED_INTO_AIR = 115,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_COMPETITIVE_WINNER)
        TF_COND_COMPETITIVE_WINNER = 116,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_COMPETITIVE_LOSER)
        TF_COND_COMPETITIVE_LOSER = 117,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_HEALING_DEBUFF)
        TF_COND_HEALING_DEBUFF = 118,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PASSTIME_PENALTY_DEBUFF)
        TF_COND_PASSTIME_PENALTY_DEBUFF = 119,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_PARACHUTE_DEPLOYED)
        TF_COND_PARACHUTE_DEPLOYED = 120,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_NO_COMBAT_SPEED_BOOST)
        TF_COND_NO_COMBAT_SPEED_BOOST = 121,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TRANQ_SPY_BOOST)
        TF_COND_TRANQ_SPY_BOOST = 122,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_TRANQ_MARKED)
        TF_COND_TRANQ_MARKED = 123,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ROCKETPACK)
        TF_COND_ROCKETPACK = 126,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_ROCKETPACK_PASSENGER)
        TF_COND_ROCKETPACK_PASSENGER = 127,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_STEALTHED_PHASE)
        TF_COND_STEALTHED_PHASE = 128,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_CLIP_OVERLOAD)
        TF_COND_CLIP_OVERLOAD = 129,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_SPY_CLASS_STEAL)
        TF_COND_SPY_CLASS_STEAL = 130,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Conditions.TF_COND_GAS)
        TF_COND_GAS = 131,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ETF2Conditions {
        const NAME: &'static str = "ETF2Conditions";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETF2Conditions> {
            match value {
                0 => ::std::option::Option::Some(ETF2Conditions::TF_COND_AIMING),
                1 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ZOOMED),
                2 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISING),
                3 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED),
                4 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED),
                5 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE),
                6 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TELEPORTED),
                7 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TAUNTING),
                8 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF),
                9 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_BLINK),
                10 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT),
                11 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED),
                12 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TMPDAMAGEBONUS),
                13 => ::std::option::Option::Some(ETF2Conditions::TF_COND_FEIGN_DEATH),
                14 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PHASE),
                15 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STUNNED),
                16 => ::std::option::Option::Some(ETF2Conditions::TF_COND_OFFENSEBUFF),
                17 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SHIELD_CHARGE),
                18 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEMO_BUFF),
                19 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ENERGY_BUFF),
                20 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL),
                21 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_BUFF),
                22 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BURNING),
                23 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_OVERHEALED),
                24 => ::std::option::Option::Some(ETF2Conditions::TF_COND_URINE),
                25 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLEEDING),
                26 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF),
                27 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MAD_MILK),
                28 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEGAHEAL),
                29 => ::std::option::Option::Some(ETF2Conditions::TF_COND_REGENONDAMAGEBUFF),
                30 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH),
                31 => ::std::option::Option::Some(ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF),
                32 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPEED_BOOST),
                33 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN),
                34 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF),
                35 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE),
                36 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SODAPOPPER_HYPE),
                37 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD),
                38 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME),
                39 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE),
                40 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL),
                41 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE),
                42 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK),
                43 => ::std::option::Option::Some(ETF2Conditions::TF_COND_REPROGRAMMED),
                44 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF),
                45 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH),
                46 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF),
                47 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF),
                48 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT),
                49 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER),
                50 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SAPPED),
                51 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED),
                52 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF),
                53 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD),
                54 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_THRILLER),
                55 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE),
                56 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT),
                57 => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT),
                58 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST),
                59 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST),
                60 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST),
                61 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST),
                62 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST),
                63 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST),
                64 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF),
                65 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_DEBUFF),
                66 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING),
                67 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BULLET_IMMUNE),
                68 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLAST_IMMUNE),
                69 => ::std::option::Option::Some(ETF2Conditions::TF_COND_FIRE_IMMUNE),
                70 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PREVENT_DEATH),
                71 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE),
                72 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST),
                73 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL),
                74 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GIANT),
                75 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_TINY),
                76 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL),
                77 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE),
                78 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL),
                79 => ::std::option::Option::Some(ETF2Conditions::TF_COND_OBSCURED_SMOKE),
                80 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_ACTIVE),
                81 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLASTJUMPING),
                82 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART),
                83 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH),
                84 => ::std::option::Option::Some(ETF2Conditions::TF_COND_BALLOON_HEAD),
                85 => ::std::option::Option::Some(ETF2Conditions::TF_COND_MELEE_ONLY),
                86 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_CURSE),
                87 => ::std::option::Option::Some(ETF2Conditions::TF_COND_FREEZE_INPUT),
                88 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE),
                89 => ::std::option::Option::Some(ETF2Conditions::TF_COND_DONOTUSE_0),
                90 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_STRENGTH),
                91 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_HASTE),
                92 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REGEN),
                93 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_RESIST),
                94 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_VAMPIRE),
                95 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REFLECT),
                96 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PRECISION),
                97 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_AGILITY),
                98 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK),
                99 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL),
                100 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED),
                101 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING),
                102 => ::std::option::Option::Some(ETF2Conditions::TF_COND_AFTERBURN_IMMUNE),
                103 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KNOCKOUT),
                104 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_IMBALANCE),
                105 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP),
                106 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION),
                107 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS),
                108 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PURGATORY),
                109 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KING),
                110 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PLAGUE),
                111 => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_SUPERNOVA),
                112 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PLAGUE),
                113 => ::std::option::Option::Some(ETF2Conditions::TF_COND_KING_BUFFED),
                114 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TEAM_GLOWS),
                115 => ::std::option::Option::Some(ETF2Conditions::TF_COND_KNOCKED_INTO_AIR),
                116 => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_WINNER),
                117 => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_LOSER),
                118 => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALING_DEBUFF),
                119 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF),
                120 => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED),
                121 => ::std::option::Option::Some(ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST),
                122 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_SPY_BOOST),
                123 => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_MARKED),
                126 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK),
                127 => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER),
                128 => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_PHASE),
                129 => ::std::option::Option::Some(ETF2Conditions::TF_COND_CLIP_OVERLOAD),
                130 => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPY_CLASS_STEAL),
                131 => ::std::option::Option::Some(ETF2Conditions::TF_COND_GAS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETF2Conditions> {
            match str {
                "TF_COND_AIMING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_AIMING),
                "TF_COND_ZOOMED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ZOOMED),
                "TF_COND_DISGUISING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISING),
                "TF_COND_DISGUISED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED),
                "TF_COND_STEALTHED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED),
                "TF_COND_INVULNERABLE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE),
                "TF_COND_TELEPORTED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TELEPORTED),
                "TF_COND_TAUNTING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TAUNTING),
                "TF_COND_INVULNERABLE_WEARINGOFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF),
                "TF_COND_STEALTHED_BLINK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_BLINK),
                "TF_COND_SELECTED_TO_TELEPORT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT),
                "TF_COND_CRITBOOSTED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED),
                "TF_COND_TMPDAMAGEBONUS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TMPDAMAGEBONUS),
                "TF_COND_FEIGN_DEATH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_FEIGN_DEATH),
                "TF_COND_PHASE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PHASE),
                "TF_COND_STUNNED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STUNNED),
                "TF_COND_OFFENSEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_OFFENSEBUFF),
                "TF_COND_SHIELD_CHARGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SHIELD_CHARGE),
                "TF_COND_DEMO_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEMO_BUFF),
                "TF_COND_ENERGY_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ENERGY_BUFF),
                "TF_COND_RADIUSHEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL),
                "TF_COND_HEALTH_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_BUFF),
                "TF_COND_BURNING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BURNING),
                "TF_COND_HEALTH_OVERHEALED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALTH_OVERHEALED),
                "TF_COND_URINE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_URINE),
                "TF_COND_BLEEDING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLEEDING),
                "TF_COND_DEFENSEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF),
                "TF_COND_MAD_MILK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MAD_MILK),
                "TF_COND_MEGAHEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEGAHEAL),
                "TF_COND_REGENONDAMAGEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_REGENONDAMAGEBUFF),
                "TF_COND_MARKEDFORDEATH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH),
                "TF_COND_NOHEALINGDAMAGEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF),
                "TF_COND_SPEED_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPEED_BOOST),
                "TF_COND_CRITBOOSTED_PUMPKIN" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN),
                "TF_COND_CRITBOOSTED_USER_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF),
                "TF_COND_CRITBOOSTED_DEMO_CHARGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE),
                "TF_COND_SODAPOPPER_HYPE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SODAPOPPER_HYPE),
                "TF_COND_CRITBOOSTED_FIRST_BLOOD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD),
                "TF_COND_CRITBOOSTED_BONUS_TIME" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME),
                "TF_COND_CRITBOOSTED_CTF_CAPTURE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE),
                "TF_COND_CRITBOOSTED_ON_KILL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL),
                "TF_COND_CANNOT_SWITCH_FROM_MELEE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE),
                "TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK),
                "TF_COND_REPROGRAMMED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_REPROGRAMMED),
                "TF_COND_CRITBOOSTED_RAGE_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF),
                "TF_COND_DEFENSEBUFF_HIGH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH),
                "TF_COND_SNIPERCHARGE_RAGE_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF),
                "TF_COND_DISGUISE_WEARINGOFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF),
                "TF_COND_MARKEDFORDEATH_SILENT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT),
                "TF_COND_DISGUISED_AS_DISPENSER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER),
                "TF_COND_SAPPED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SAPPED),
                "TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED),
                "TF_COND_INVULNERABLE_USER_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF),
                "TF_COND_HALLOWEEN_BOMB_HEAD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD),
                "TF_COND_HALLOWEEN_THRILLER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_THRILLER),
                "TF_COND_RADIUSHEAL_ON_DAMAGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE),
                "TF_COND_CRITBOOSTED_CARD_EFFECT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT),
                "TF_COND_INVULNERABLE_CARD_EFFECT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT),
                "TF_COND_MEDIGUN_UBER_BULLET_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST),
                "TF_COND_MEDIGUN_UBER_BLAST_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST),
                "TF_COND_MEDIGUN_UBER_FIRE_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST),
                "TF_COND_MEDIGUN_SMALL_BULLET_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST),
                "TF_COND_MEDIGUN_SMALL_BLAST_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST),
                "TF_COND_MEDIGUN_SMALL_FIRE_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST),
                "TF_COND_STEALTHED_USER_BUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF),
                "TF_COND_MEDIGUN_DEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MEDIGUN_DEBUFF),
                "TF_COND_STEALTHED_USER_BUFF_FADING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING),
                "TF_COND_BULLET_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BULLET_IMMUNE),
                "TF_COND_BLAST_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLAST_IMMUNE),
                "TF_COND_FIRE_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_FIRE_IMMUNE),
                "TF_COND_PREVENT_DEATH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PREVENT_DEATH),
                "TF_COND_MVM_BOT_STUN_RADIOWAVE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE),
                "TF_COND_HALLOWEEN_SPEED_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST),
                "TF_COND_HALLOWEEN_QUICK_HEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL),
                "TF_COND_HALLOWEEN_GIANT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GIANT),
                "TF_COND_HALLOWEEN_TINY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_TINY),
                "TF_COND_HALLOWEEN_IN_HELL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL),
                "TF_COND_HALLOWEEN_GHOST_MODE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE),
                "TF_COND_MINICRITBOOSTED_ON_KILL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL),
                "TF_COND_OBSCURED_SMOKE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_OBSCURED_SMOKE),
                "TF_COND_PARACHUTE_ACTIVE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_ACTIVE),
                "TF_COND_BLASTJUMPING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BLASTJUMPING),
                "TF_COND_HALLOWEEN_KART" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART),
                "TF_COND_HALLOWEEN_KART_DASH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH),
                "TF_COND_BALLOON_HEAD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_BALLOON_HEAD),
                "TF_COND_MELEE_ONLY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_MELEE_ONLY),
                "TF_COND_SWIMMING_CURSE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_CURSE),
                "TF_COND_FREEZE_INPUT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_FREEZE_INPUT),
                "TF_COND_HALLOWEEN_KART_CAGE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE),
                "TF_COND_DONOTUSE_0" => ::std::option::Option::Some(ETF2Conditions::TF_COND_DONOTUSE_0),
                "TF_COND_RUNE_STRENGTH" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_STRENGTH),
                "TF_COND_RUNE_HASTE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_HASTE),
                "TF_COND_RUNE_REGEN" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REGEN),
                "TF_COND_RUNE_RESIST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_RESIST),
                "TF_COND_RUNE_VAMPIRE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_VAMPIRE),
                "TF_COND_RUNE_REFLECT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_REFLECT),
                "TF_COND_RUNE_PRECISION" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PRECISION),
                "TF_COND_RUNE_AGILITY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_AGILITY),
                "TF_COND_GRAPPLINGHOOK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK),
                "TF_COND_GRAPPLINGHOOK_SAFEFALL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL),
                "TF_COND_GRAPPLINGHOOK_LATCHED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED),
                "TF_COND_GRAPPLINGHOOK_BLEEDING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING),
                "TF_COND_AFTERBURN_IMMUNE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_AFTERBURN_IMMUNE),
                "TF_COND_RUNE_KNOCKOUT" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KNOCKOUT),
                "TF_COND_RUNE_IMBALANCE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_IMBALANCE),
                "TF_COND_CRITBOOSTED_RUNE_TEMP" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP),
                "TF_COND_PASSTIME_INTERCEPTION" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION),
                "TF_COND_SWIMMING_NO_EFFECTS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS),
                "TF_COND_PURGATORY" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PURGATORY),
                "TF_COND_RUNE_KING" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_KING),
                "TF_COND_RUNE_PLAGUE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_PLAGUE),
                "TF_COND_RUNE_SUPERNOVA" => ::std::option::Option::Some(ETF2Conditions::TF_COND_RUNE_SUPERNOVA),
                "TF_COND_PLAGUE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PLAGUE),
                "TF_COND_KING_BUFFED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_KING_BUFFED),
                "TF_COND_TEAM_GLOWS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TEAM_GLOWS),
                "TF_COND_KNOCKED_INTO_AIR" => ::std::option::Option::Some(ETF2Conditions::TF_COND_KNOCKED_INTO_AIR),
                "TF_COND_COMPETITIVE_WINNER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_WINNER),
                "TF_COND_COMPETITIVE_LOSER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_COMPETITIVE_LOSER),
                "TF_COND_HEALING_DEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_HEALING_DEBUFF),
                "TF_COND_PASSTIME_PENALTY_DEBUFF" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF),
                "TF_COND_PARACHUTE_DEPLOYED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED),
                "TF_COND_NO_COMBAT_SPEED_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST),
                "TF_COND_TRANQ_SPY_BOOST" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_SPY_BOOST),
                "TF_COND_TRANQ_MARKED" => ::std::option::Option::Some(ETF2Conditions::TF_COND_TRANQ_MARKED),
                "TF_COND_ROCKETPACK" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK),
                "TF_COND_ROCKETPACK_PASSENGER" => ::std::option::Option::Some(ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER),
                "TF_COND_STEALTHED_PHASE" => ::std::option::Option::Some(ETF2Conditions::TF_COND_STEALTHED_PHASE),
                "TF_COND_CLIP_OVERLOAD" => ::std::option::Option::Some(ETF2Conditions::TF_COND_CLIP_OVERLOAD),
                "TF_COND_SPY_CLASS_STEAL" => ::std::option::Option::Some(ETF2Conditions::TF_COND_SPY_CLASS_STEAL),
                "TF_COND_GAS" => ::std::option::Option::Some(ETF2Conditions::TF_COND_GAS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETF2Conditions] = &[
            ETF2Conditions::TF_COND_AIMING,
            ETF2Conditions::TF_COND_ZOOMED,
            ETF2Conditions::TF_COND_DISGUISING,
            ETF2Conditions::TF_COND_DISGUISED,
            ETF2Conditions::TF_COND_STEALTHED,
            ETF2Conditions::TF_COND_INVULNERABLE,
            ETF2Conditions::TF_COND_TELEPORTED,
            ETF2Conditions::TF_COND_TAUNTING,
            ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF,
            ETF2Conditions::TF_COND_STEALTHED_BLINK,
            ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT,
            ETF2Conditions::TF_COND_CRITBOOSTED,
            ETF2Conditions::TF_COND_TMPDAMAGEBONUS,
            ETF2Conditions::TF_COND_FEIGN_DEATH,
            ETF2Conditions::TF_COND_PHASE,
            ETF2Conditions::TF_COND_STUNNED,
            ETF2Conditions::TF_COND_OFFENSEBUFF,
            ETF2Conditions::TF_COND_SHIELD_CHARGE,
            ETF2Conditions::TF_COND_DEMO_BUFF,
            ETF2Conditions::TF_COND_ENERGY_BUFF,
            ETF2Conditions::TF_COND_RADIUSHEAL,
            ETF2Conditions::TF_COND_HEALTH_BUFF,
            ETF2Conditions::TF_COND_BURNING,
            ETF2Conditions::TF_COND_HEALTH_OVERHEALED,
            ETF2Conditions::TF_COND_URINE,
            ETF2Conditions::TF_COND_BLEEDING,
            ETF2Conditions::TF_COND_DEFENSEBUFF,
            ETF2Conditions::TF_COND_MAD_MILK,
            ETF2Conditions::TF_COND_MEGAHEAL,
            ETF2Conditions::TF_COND_REGENONDAMAGEBUFF,
            ETF2Conditions::TF_COND_MARKEDFORDEATH,
            ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF,
            ETF2Conditions::TF_COND_SPEED_BOOST,
            ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN,
            ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF,
            ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE,
            ETF2Conditions::TF_COND_SODAPOPPER_HYPE,
            ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD,
            ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME,
            ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE,
            ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL,
            ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE,
            ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK,
            ETF2Conditions::TF_COND_REPROGRAMMED,
            ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF,
            ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH,
            ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF,
            ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF,
            ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT,
            ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER,
            ETF2Conditions::TF_COND_SAPPED,
            ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED,
            ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF,
            ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD,
            ETF2Conditions::TF_COND_HALLOWEEN_THRILLER,
            ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE,
            ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT,
            ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT,
            ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST,
            ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST,
            ETF2Conditions::TF_COND_STEALTHED_USER_BUFF,
            ETF2Conditions::TF_COND_MEDIGUN_DEBUFF,
            ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING,
            ETF2Conditions::TF_COND_BULLET_IMMUNE,
            ETF2Conditions::TF_COND_BLAST_IMMUNE,
            ETF2Conditions::TF_COND_FIRE_IMMUNE,
            ETF2Conditions::TF_COND_PREVENT_DEATH,
            ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE,
            ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST,
            ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL,
            ETF2Conditions::TF_COND_HALLOWEEN_GIANT,
            ETF2Conditions::TF_COND_HALLOWEEN_TINY,
            ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL,
            ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE,
            ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL,
            ETF2Conditions::TF_COND_OBSCURED_SMOKE,
            ETF2Conditions::TF_COND_PARACHUTE_ACTIVE,
            ETF2Conditions::TF_COND_BLASTJUMPING,
            ETF2Conditions::TF_COND_HALLOWEEN_KART,
            ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH,
            ETF2Conditions::TF_COND_BALLOON_HEAD,
            ETF2Conditions::TF_COND_MELEE_ONLY,
            ETF2Conditions::TF_COND_SWIMMING_CURSE,
            ETF2Conditions::TF_COND_FREEZE_INPUT,
            ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE,
            ETF2Conditions::TF_COND_DONOTUSE_0,
            ETF2Conditions::TF_COND_RUNE_STRENGTH,
            ETF2Conditions::TF_COND_RUNE_HASTE,
            ETF2Conditions::TF_COND_RUNE_REGEN,
            ETF2Conditions::TF_COND_RUNE_RESIST,
            ETF2Conditions::TF_COND_RUNE_VAMPIRE,
            ETF2Conditions::TF_COND_RUNE_REFLECT,
            ETF2Conditions::TF_COND_RUNE_PRECISION,
            ETF2Conditions::TF_COND_RUNE_AGILITY,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED,
            ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING,
            ETF2Conditions::TF_COND_AFTERBURN_IMMUNE,
            ETF2Conditions::TF_COND_RUNE_KNOCKOUT,
            ETF2Conditions::TF_COND_RUNE_IMBALANCE,
            ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP,
            ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION,
            ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS,
            ETF2Conditions::TF_COND_PURGATORY,
            ETF2Conditions::TF_COND_RUNE_KING,
            ETF2Conditions::TF_COND_RUNE_PLAGUE,
            ETF2Conditions::TF_COND_RUNE_SUPERNOVA,
            ETF2Conditions::TF_COND_PLAGUE,
            ETF2Conditions::TF_COND_KING_BUFFED,
            ETF2Conditions::TF_COND_TEAM_GLOWS,
            ETF2Conditions::TF_COND_KNOCKED_INTO_AIR,
            ETF2Conditions::TF_COND_COMPETITIVE_WINNER,
            ETF2Conditions::TF_COND_COMPETITIVE_LOSER,
            ETF2Conditions::TF_COND_HEALING_DEBUFF,
            ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF,
            ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED,
            ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST,
            ETF2Conditions::TF_COND_TRANQ_SPY_BOOST,
            ETF2Conditions::TF_COND_TRANQ_MARKED,
            ETF2Conditions::TF_COND_ROCKETPACK,
            ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER,
            ETF2Conditions::TF_COND_STEALTHED_PHASE,
            ETF2Conditions::TF_COND_CLIP_OVERLOAD,
            ETF2Conditions::TF_COND_SPY_CLASS_STEAL,
            ETF2Conditions::TF_COND_GAS,
        ];
    }

    impl ::std::default::Default for ETF2Conditions {
        fn default() -> Self {
            ETF2Conditions::TF_COND_AIMING
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgQuestObjectiveDef.ETF2Team)
    pub enum ETF2Team {
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Team.TF_TEAM_RED)
        TF_TEAM_RED = 2,
        // @@protoc_insertion_point(enum_value:CMsgQuestObjectiveDef.ETF2Team.TF_TEAM_BLUE)
        TF_TEAM_BLUE = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ETF2Team {
        const NAME: &'static str = "ETF2Team";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ETF2Team> {
            match value {
                2 => ::std::option::Option::Some(ETF2Team::TF_TEAM_RED),
                3 => ::std::option::Option::Some(ETF2Team::TF_TEAM_BLUE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ETF2Team> {
            match str {
                "TF_TEAM_RED" => ::std::option::Option::Some(ETF2Team::TF_TEAM_RED),
                "TF_TEAM_BLUE" => ::std::option::Option::Some(ETF2Team::TF_TEAM_BLUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ETF2Team] = &[
            ETF2Team::TF_TEAM_RED,
            ETF2Team::TF_TEAM_BLUE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ETF2Team {
        fn default() -> Self {
            ETF2Team::TF_TEAM_RED
        }
    }

}

// @@protoc_insertion_point(message:CMsgQuestDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestDef.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestDef.max_points_0)
    pub max_points_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestDef.max_points_1)
    pub max_points_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestDef.max_points_2)
    pub max_points_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestDef.name_loctoken)
    pub name_loctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.operation)
    pub operation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.mm_criteria)
    pub mm_criteria: ::steam_vent_proto_common::protobuf::MessageField<cmsg_quest_def::MMCriteria>,
    // @@protoc_insertion_point(field:CMsgQuestDef.node_image)
    pub node_image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.icon_image)
    pub icon_image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.theme)
    pub theme: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestDef.loaner_names)
    pub loaner_names: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestDef.objectives)
    pub objectives: ::std::vec::Vec<cmsg_quest_def::ObjectiveInstance>,
    // @@protoc_insertion_point(field:CMsgQuestDef.map)
    pub map: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestDef.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestDef {
    fn default() -> &'a CMsgQuestDef {
        <CMsgQuestDef as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestDef {
    pub fn new() -> CMsgQuestDef {
        ::std::default::Default::default()
    }

    // optional uint32 max_points_0 = 2;

    pub fn max_points_0(&self) -> u32 {
        self.max_points_0.unwrap_or(0)
    }

    pub fn clear_max_points_0(&mut self) {
        self.max_points_0 = ::std::option::Option::None;
    }

    pub fn has_max_points_0(&self) -> bool {
        self.max_points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_0(&mut self, v: u32) {
        self.max_points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 max_points_1 = 3;

    pub fn max_points_1(&self) -> u32 {
        self.max_points_1.unwrap_or(0)
    }

    pub fn clear_max_points_1(&mut self) {
        self.max_points_1 = ::std::option::Option::None;
    }

    pub fn has_max_points_1(&self) -> bool {
        self.max_points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_1(&mut self, v: u32) {
        self.max_points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 max_points_2 = 4;

    pub fn max_points_2(&self) -> u32 {
        self.max_points_2.unwrap_or(0)
    }

    pub fn clear_max_points_2(&mut self) {
        self.max_points_2 = ::std::option::Option::None;
    }

    pub fn has_max_points_2(&self) -> bool {
        self.max_points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_2(&mut self, v: u32) {
        self.max_points_2 = ::std::option::Option::Some(v);
    }

    // optional string name_loctoken = 5;

    pub fn name_loctoken(&self) -> &str {
        match self.name_loctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loctoken(&mut self) {
        self.name_loctoken = ::std::option::Option::None;
    }

    pub fn has_name_loctoken(&self) -> bool {
        self.name_loctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loctoken(&mut self, v: ::std::string::String) {
        self.name_loctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loctoken(&mut self) -> &mut ::std::string::String {
        if self.name_loctoken.is_none() {
            self.name_loctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loctoken(&mut self) -> ::std::string::String {
        self.name_loctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operation = 7;

    pub fn operation(&self) -> &str {
        match self.operation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        if self.operation.is_none() {
            self.operation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        self.operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string node_image = 12;

    pub fn node_image(&self) -> &str {
        match self.node_image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_node_image(&mut self) {
        self.node_image = ::std::option::Option::None;
    }

    pub fn has_node_image(&self) -> bool {
        self.node_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_image(&mut self, v: ::std::string::String) {
        self.node_image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_image(&mut self) -> &mut ::std::string::String {
        if self.node_image.is_none() {
            self.node_image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.node_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_image(&mut self) -> ::std::string::String {
        self.node_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon_image = 13;

    pub fn icon_image(&self) -> &str {
        match self.icon_image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon_image(&mut self) {
        self.icon_image = ::std::option::Option::None;
    }

    pub fn has_icon_image(&self) -> bool {
        self.icon_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_image(&mut self, v: ::std::string::String) {
        self.icon_image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_image(&mut self) -> &mut ::std::string::String {
        if self.icon_image.is_none() {
            self.icon_image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_image(&mut self) -> ::std::string::String {
        self.icon_image.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestDef {
    const NAME: &'static str = "CMsgQuestDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mm_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.theme {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.objectives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.max_points_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.max_points_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.max_points_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.name_loctoken = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.operation = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.mm_criteria)?;
                },
                98 => {
                    self.node_image = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.icon_image = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.theme)?;
                },
                122 => {
                    self.loaner_names.push(is.read_string()?);
                },
                130 => {
                    self.objectives.push(is.read_message()?);
                },
                138 => {
                    self.map.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_points_0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.max_points_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.max_points_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.operation.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.mm_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.node_image.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.icon_image.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.theme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.loaner_names {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &value);
        };
        for value in &self.objectives {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.map {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(17, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.max_points_0 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.max_points_1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_points_2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.operation.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.mm_criteria.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.node_image.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.icon_image.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.theme.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.loaner_names {
            os.write_string(15, &v)?;
        };
        for v in &self.objectives {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.map {
            os.write_string(17, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestDef {
        CMsgQuestDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.max_points_0 = ::std::option::Option::None;
        self.max_points_1 = ::std::option::Option::None;
        self.max_points_2 = ::std::option::Option::None;
        self.name_loctoken = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.mm_criteria.clear();
        self.node_image = ::std::option::Option::None;
        self.icon_image = ::std::option::Option::None;
        self.theme.clear();
        self.loaner_names.clear();
        self.objectives.clear();
        self.map.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestDef {
        static instance: CMsgQuestDef = CMsgQuestDef {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            max_points_0: ::std::option::Option::None,
            max_points_1: ::std::option::Option::None,
            max_points_2: ::std::option::Option::None,
            name_loctoken: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            mm_criteria: ::steam_vent_proto_common::protobuf::MessageField::none(),
            node_image: ::std::option::Option::None,
            icon_image: ::std::option::Option::None,
            theme: ::steam_vent_proto_common::protobuf::MessageField::none(),
            loaner_names: ::std::vec::Vec::new(),
            objectives: ::std::vec::Vec::new(),
            map: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgQuestDef`
pub mod cmsg_quest_def {
    // @@protoc_insertion_point(message:CMsgQuestDef.MMCriteria)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MMCriteria {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestDef.MMCriteria.group_name)
        pub group_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgQuestDef.MMCriteria.category_name)
        pub category_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgQuestDef.MMCriteria.map_name)
        pub map_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestDef.MMCriteria.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MMCriteria {
        fn default() -> &'a MMCriteria {
            <MMCriteria as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MMCriteria {
        pub fn new() -> MMCriteria {
            ::std::default::Default::default()
        }

        // optional string group_name = 1;

        pub fn group_name(&self) -> &str {
            match self.group_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_group_name(&mut self) {
            self.group_name = ::std::option::Option::None;
        }

        pub fn has_group_name(&self) -> bool {
            self.group_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_name(&mut self, v: ::std::string::String) {
            self.group_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_group_name(&mut self) -> &mut ::std::string::String {
            if self.group_name.is_none() {
                self.group_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.group_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_group_name(&mut self) -> ::std::string::String {
            self.group_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string category_name = 2;

        pub fn category_name(&self) -> &str {
            match self.category_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category_name(&mut self) {
            self.category_name = ::std::option::Option::None;
        }

        pub fn has_category_name(&self) -> bool {
            self.category_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category_name(&mut self, v: ::std::string::String) {
            self.category_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category_name(&mut self) -> &mut ::std::string::String {
            if self.category_name.is_none() {
                self.category_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.category_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_category_name(&mut self) -> ::std::string::String {
            self.category_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string map_name = 3;

        pub fn map_name(&self) -> &str {
            match self.map_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_map_name(&mut self) {
            self.map_name = ::std::option::Option::None;
        }

        pub fn has_map_name(&self) -> bool {
            self.map_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_name(&mut self, v: ::std::string::String) {
            self.map_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
            if self.map_name.is_none() {
                self.map_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.map_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_map_name(&mut self) -> ::std::string::String {
            self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MMCriteria {
        const NAME: &'static str = "MMCriteria";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.group_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.category_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.map_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.group_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.category_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.map_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.group_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.category_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.map_name.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MMCriteria {
            MMCriteria::new()
        }

        fn clear(&mut self) {
            self.group_name = ::std::option::Option::None;
            self.category_name = ::std::option::Option::None;
            self.map_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MMCriteria {
            static instance: MMCriteria = MMCriteria {
                group_name: ::std::option::Option::None,
                category_name: ::std::option::Option::None,
                map_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgQuestDef.ObjectiveInstance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ObjectiveInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestDef.ObjectiveInstance.objective)
        pub objective: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgQuestDef.ObjectiveInstance.point_type)
        pub point_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::EQuestPoints>>,
        // @@protoc_insertion_point(field:CMsgQuestDef.ObjectiveInstance.point_value)
        pub point_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestDef.ObjectiveInstance.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ObjectiveInstance {
        fn default() -> &'a ObjectiveInstance {
            <ObjectiveInstance as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ObjectiveInstance {
        pub fn new() -> ObjectiveInstance {
            ::std::default::Default::default()
        }

        // optional .EQuestPoints point_type = 2;

        pub fn point_type(&self) -> super::EQuestPoints {
            match self.point_type {
                Some(e) => e.enum_value_or(super::EQuestPoints::QUEST_POINTS_NOVICE),
                None => super::EQuestPoints::QUEST_POINTS_NOVICE,
            }
        }

        pub fn clear_point_type(&mut self) {
            self.point_type = ::std::option::Option::None;
        }

        pub fn has_point_type(&self) -> bool {
            self.point_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_point_type(&mut self, v: super::EQuestPoints) {
            self.point_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 point_value = 3;

        pub fn point_value(&self) -> u32 {
            self.point_value.unwrap_or(0)
        }

        pub fn clear_point_value(&mut self) {
            self.point_value = ::std::option::Option::None;
        }

        pub fn has_point_value(&self) -> bool {
            self.point_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_point_value(&mut self, v: u32) {
            self.point_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ObjectiveInstance {
        const NAME: &'static str = "ObjectiveInstance";

        fn is_initialized(&self) -> bool {
            for v in &self.objective {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.objective)?;
                    },
                    16 => {
                        self.point_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.point_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.objective.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.point_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.point_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.objective.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.point_type {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.point_value {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ObjectiveInstance {
            ObjectiveInstance::new()
        }

        fn clear(&mut self) {
            self.objective.clear();
            self.point_type = ::std::option::Option::None;
            self.point_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ObjectiveInstance {
            static instance: ObjectiveInstance = ObjectiveInstance {
                objective: ::steam_vent_proto_common::protobuf::MessageField::none(),
                point_type: ::std::option::Option::None,
                point_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapStoreItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapStoreItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.item_name)
    pub item_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.reward_lootlist_name)
    pub reward_lootlist_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.price)
    pub price: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.purchase_limit)
    pub purchase_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestMapStoreItem.sort_group)
    pub sort_group: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapStoreItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapStoreItem {
    fn default() -> &'a CMsgQuestMapStoreItem {
        <CMsgQuestMapStoreItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapStoreItem {
    pub fn new() -> CMsgQuestMapStoreItem {
        ::std::default::Default::default()
    }

    // optional string item_name = 2;

    pub fn item_name(&self) -> &str {
        match self.item_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_name(&mut self) {
        self.item_name = ::std::option::Option::None;
    }

    pub fn has_item_name(&self) -> bool {
        self.item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name(&mut self, v: ::std::string::String) {
        self.item_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name(&mut self) -> &mut ::std::string::String {
        if self.item_name.is_none() {
            self.item_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name(&mut self) -> ::std::string::String {
        self.item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_lootlist_name = 6;

    pub fn reward_lootlist_name(&self) -> &str {
        match self.reward_lootlist_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_lootlist_name(&mut self) {
        self.reward_lootlist_name = ::std::option::Option::None;
    }

    pub fn has_reward_lootlist_name(&self) -> bool {
        self.reward_lootlist_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_lootlist_name(&mut self, v: ::std::string::String) {
        self.reward_lootlist_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_lootlist_name(&mut self) -> &mut ::std::string::String {
        if self.reward_lootlist_name.is_none() {
            self.reward_lootlist_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_lootlist_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_lootlist_name(&mut self) -> ::std::string::String {
        self.reward_lootlist_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 purchase_limit = 4;

    pub fn purchase_limit(&self) -> u32 {
        self.purchase_limit.unwrap_or(0)
    }

    pub fn clear_purchase_limit(&mut self) {
        self.purchase_limit = ::std::option::Option::None;
    }

    pub fn has_purchase_limit(&self) -> bool {
        self.purchase_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_limit(&mut self, v: u32) {
        self.purchase_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_group = 5;

    pub fn sort_group(&self) -> u32 {
        self.sort_group.unwrap_or(0)
    }

    pub fn clear_sort_group(&mut self) {
        self.sort_group = ::std::option::Option::None;
    }

    pub fn has_sort_group(&self) -> bool {
        self.sort_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_group(&mut self, v: u32) {
        self.sort_group = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestMapStoreItem {
    const NAME: &'static str = "CMsgQuestMapStoreItem";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.price {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.item_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.reward_lootlist_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.price)?;
                },
                32 => {
                    self.purchase_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.sort_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.purchase_limit {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sort_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.item_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.price.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.purchase_limit {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sort_group {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapStoreItem {
        CMsgQuestMapStoreItem::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.item_name = ::std::option::Option::None;
        self.reward_lootlist_name = ::std::option::Option::None;
        self.price.clear();
        self.purchase_limit = ::std::option::Option::None;
        self.sort_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapStoreItem {
        static instance: CMsgQuestMapStoreItem = CMsgQuestMapStoreItem {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            item_name: ::std::option::Option::None,
            reward_lootlist_name: ::std::option::Option::None,
            price: ::steam_vent_proto_common::protobuf::MessageField::none(),
            purchase_limit: ::std::option::Option::None,
            sort_group: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapRegionDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapRegionDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.resfile)
    pub resfile: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.links)
    pub links: ::std::vec::Vec<cmsg_quest_map_region_def::RegionLink>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.return_link)
    pub return_link: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.radio_freq)
    pub radio_freq: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.zoom_scale)
    pub zoom_scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.star_type)
    pub star_type: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapRegionDef.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapRegionDef {
    fn default() -> &'a CMsgQuestMapRegionDef {
        <CMsgQuestMapRegionDef as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapRegionDef {
    pub fn new() -> CMsgQuestMapRegionDef {
        ::std::default::Default::default()
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resfile = 3;

    pub fn resfile(&self) -> &str {
        match self.resfile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resfile(&mut self) {
        self.resfile = ::std::option::Option::None;
    }

    pub fn has_resfile(&self) -> bool {
        self.resfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resfile(&mut self, v: ::std::string::String) {
        self.resfile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resfile(&mut self) -> &mut ::std::string::String {
        if self.resfile.is_none() {
            self.resfile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_resfile(&mut self) -> ::std::string::String {
        self.resfile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float radio_freq = 6;

    pub fn radio_freq(&self) -> f32 {
        self.radio_freq.unwrap_or(0.)
    }

    pub fn clear_radio_freq(&mut self) {
        self.radio_freq = ::std::option::Option::None;
    }

    pub fn has_radio_freq(&self) -> bool {
        self.radio_freq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_freq(&mut self, v: f32) {
        self.radio_freq = ::std::option::Option::Some(v);
    }

    // optional float zoom_scale = 7;

    pub fn zoom_scale(&self) -> f32 {
        self.zoom_scale.unwrap_or(0.)
    }

    pub fn clear_zoom_scale(&mut self) {
        self.zoom_scale = ::std::option::Option::None;
    }

    pub fn has_zoom_scale(&self) -> bool {
        self.zoom_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom_scale(&mut self, v: f32) {
        self.zoom_scale = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestMapRegionDef {
    const NAME: &'static str = "CMsgQuestMapRegionDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_link {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.star_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.resfile = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.links.push(is.read_message()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.return_link)?;
                },
                53 => {
                    self.radio_freq = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.zoom_scale = ::std::option::Option::Some(is.read_float()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.star_type)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resfile.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.return_link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radio_freq {
            my_size += 1 + 4;
        }
        if let Some(v) = self.zoom_scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.star_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.resfile.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.links {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.return_link.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.radio_freq {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.zoom_scale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.star_type.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapRegionDef {
        CMsgQuestMapRegionDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.name = ::std::option::Option::None;
        self.resfile = ::std::option::Option::None;
        self.links.clear();
        self.return_link.clear();
        self.radio_freq = ::std::option::Option::None;
        self.zoom_scale = ::std::option::Option::None;
        self.star_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapRegionDef {
        static instance: CMsgQuestMapRegionDef = CMsgQuestMapRegionDef {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            resfile: ::std::option::Option::None,
            links: ::std::vec::Vec::new(),
            return_link: ::steam_vent_proto_common::protobuf::MessageField::none(),
            radio_freq: ::std::option::Option::None,
            zoom_scale: ::std::option::Option::None,
            star_type: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgQuestMapRegionDef`
pub mod cmsg_quest_map_region_def {
    // @@protoc_insertion_point(message:CMsgQuestMapRegionDef.RegionLink)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RegionLink {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.RegionLink.target_region_defid)
        pub target_region_defid: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.RegionLink.xpos)
        pub xpos: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgQuestMapRegionDef.RegionLink.ypos)
        pub ypos: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestMapRegionDef.RegionLink.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RegionLink {
        fn default() -> &'a RegionLink {
            <RegionLink as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RegionLink {
        pub fn new() -> RegionLink {
            ::std::default::Default::default()
        }

        // optional uint32 xpos = 2;

        pub fn xpos(&self) -> u32 {
            self.xpos.unwrap_or(0)
        }

        pub fn clear_xpos(&mut self) {
            self.xpos = ::std::option::Option::None;
        }

        pub fn has_xpos(&self) -> bool {
            self.xpos.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xpos(&mut self, v: u32) {
            self.xpos = ::std::option::Option::Some(v);
        }

        // optional uint32 ypos = 3;

        pub fn ypos(&self) -> u32 {
            self.ypos.unwrap_or(0)
        }

        pub fn clear_ypos(&mut self) {
            self.ypos = ::std::option::Option::None;
        }

        pub fn has_ypos(&self) -> bool {
            self.ypos.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ypos(&mut self, v: u32) {
            self.ypos = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RegionLink {
        const NAME: &'static str = "RegionLink";

        fn is_initialized(&self) -> bool {
            if self.target_region_defid.is_none() {
                return false;
            }
            for v in &self.target_region_defid {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.target_region_defid)?;
                    },
                    16 => {
                        self.xpos = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.ypos = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.target_region_defid.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.xpos {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.ypos {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.target_region_defid.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.xpos {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.ypos {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RegionLink {
            RegionLink::new()
        }

        fn clear(&mut self) {
            self.target_region_defid.clear();
            self.xpos = ::std::option::Option::None;
            self.ypos = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RegionLink {
            static instance: RegionLink = RegionLink {
                target_region_defid: ::steam_vent_proto_common::protobuf::MessageField::none(),
                xpos: ::std::option::Option::None,
                ypos: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgVarField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVarField {
    // message fields
    // @@protoc_insertion_point(field:CMsgVarField.variable)
    pub variable: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub value: ::std::option::Option<cmsg_var_field::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVarField.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVarField {
    fn default() -> &'a CMsgVarField {
        <CMsgVarField as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgVarField {
    pub fn new() -> CMsgVarField {
        ::std::default::Default::default()
    }

    // optional string variable = 1;

    pub fn variable(&self) -> &str {
        match self.variable.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_variable(&mut self) {
        self.variable = ::std::option::Option::None;
    }

    pub fn has_variable(&self) -> bool {
        self.variable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variable(&mut self, v: ::std::string::String) {
        self.variable = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_variable(&mut self) -> &mut ::std::string::String {
        if self.variable.is_none() {
            self.variable = ::std::option::Option::Some(::std::string::String::new());
        }
        self.variable.as_mut().unwrap()
    }

    // Take field
    pub fn take_variable(&mut self) -> ::std::string::String {
        self.variable.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float float = 2;

    pub fn float(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Float(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_float(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Float(v))
    }

    // optional double double = 3;

    pub fn double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Double(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Double(v))
    }

    // optional uint32 uint32 = 4;

    pub fn uint32(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_uint32(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_uint32(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint32(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint32(v))
    }

    // optional uint64 uint64 = 5;

    pub fn uint64(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_uint64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_uint64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Uint64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint64(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint64(v))
    }

    // optional sint32 sint32 = 6;

    pub fn sint32(&self) -> i32 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint32(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_sint32(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sint32(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint32(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint32(v))
    }

    // optional sint64 sint64 = 7;

    pub fn sint64(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_sint64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sint64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Sint64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint64(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint64(v))
    }

    // optional bool bool = 8;

    pub fn bool(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Bool(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::Bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::Bool(v))
    }

    // optional string string = 9;

    pub fn string(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::String(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::String(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(cmsg_var_field::Value::String(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(cmsg_var_field::Value::String(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(cmsg_var_field::Value::String(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(cmsg_var_field::Value::String(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.value.take() {
                ::std::option::Option::Some(cmsg_var_field::Value::String(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgVarField {
    const NAME: &'static str = "CMsgVarField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.variable = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Float(is.read_float()?));
                },
                25 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Double(is.read_double()?));
                },
                32 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint32(is.read_uint32()?));
                },
                40 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Uint64(is.read_uint64()?));
                },
                48 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint32(is.read_sint32()?));
                },
                56 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Sint64(is.read_sint64()?));
                },
                64 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::Bool(is.read_bool()?));
                },
                74 => {
                    self.value = ::std::option::Option::Some(cmsg_var_field::Value::String(is.read_string()?));
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.variable.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &cmsg_var_field::Value::Float(v) => {
                    my_size += 1 + 4;
                },
                &cmsg_var_field::Value::Double(v) => {
                    my_size += 1 + 8;
                },
                &cmsg_var_field::Value::Uint32(v) => {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                },
                &cmsg_var_field::Value::Uint64(v) => {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
                },
                &cmsg_var_field::Value::Sint32(v) => {
                    my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(6, v);
                },
                &cmsg_var_field::Value::Sint64(v) => {
                    my_size += ::steam_vent_proto_common::protobuf::rt::sint64_size(7, v);
                },
                &cmsg_var_field::Value::Bool(v) => {
                    my_size += 1 + 1;
                },
                &cmsg_var_field::Value::String(ref v) => {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
                },
            };
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.variable.as_ref() {
            os.write_string(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &cmsg_var_field::Value::Float(v) => {
                    os.write_float(2, v)?;
                },
                &cmsg_var_field::Value::Double(v) => {
                    os.write_double(3, v)?;
                },
                &cmsg_var_field::Value::Uint32(v) => {
                    os.write_uint32(4, v)?;
                },
                &cmsg_var_field::Value::Uint64(v) => {
                    os.write_uint64(5, v)?;
                },
                &cmsg_var_field::Value::Sint32(v) => {
                    os.write_sint32(6, v)?;
                },
                &cmsg_var_field::Value::Sint64(v) => {
                    os.write_sint64(7, v)?;
                },
                &cmsg_var_field::Value::Bool(v) => {
                    os.write_bool(8, v)?;
                },
                &cmsg_var_field::Value::String(ref v) => {
                    os.write_string(9, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVarField {
        CMsgVarField::new()
    }

    fn clear(&mut self) {
        self.variable = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVarField {
        static instance: CMsgVarField = CMsgVarField {
            variable: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgVarField`
pub mod cmsg_var_field {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgVarField.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:CMsgVarField.float)
        Float(f32),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.double)
        Double(f64),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.uint32)
        Uint32(u32),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.uint64)
        Uint64(u64),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.sint32)
        Sint32(i32),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.sint64)
        Sint64(i64),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.bool)
        Bool(bool),
        // @@protoc_insertion_point(oneof_field:CMsgVarField.string)
        String(::std::string::String),
    }

    impl ::steam_vent_proto_common::protobuf::Oneof for Value {
    }

    impl Value {
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapStarType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapStarType {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapStarType.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapStarType.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapStarType.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapStarType {
    fn default() -> &'a CMsgQuestMapStarType {
        <CMsgQuestMapStarType as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapStarType {
    pub fn new() -> CMsgQuestMapStarType {
        ::std::default::Default::default()
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestMapStarType {
    const NAME: &'static str = "CMsgQuestMapStarType";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapStarType {
        CMsgQuestMapStarType::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapStarType {
        static instance: CMsgQuestMapStarType = CMsgQuestMapStarType {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.name_loctoken)
    pub name_loctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.x_pos)
    pub x_pos: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.y_pos)
    pub y_pos: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.condition)
    pub condition: ::steam_vent_proto_common::protobuf::MessageField<CMsgQuestMapNodeCondition>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.owning_region)
    pub owning_region: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.quest_options)
    pub quest_options: ::std::vec::Vec<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.associated_operation)
    pub associated_operation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.reward_item_name)
    pub reward_item_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.reward_lootlist_name)
    pub reward_lootlist_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.cash_reward)
    pub cash_reward: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ENodeCashReward>>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.star_type)
    pub star_type: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeDef.stars_to_unlock)
    pub stars_to_unlock: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeDef.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeDef {
    fn default() -> &'a CMsgQuestMapNodeDef {
        <CMsgQuestMapNodeDef as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeDef {
    pub fn new() -> CMsgQuestMapNodeDef {
        ::std::default::Default::default()
    }

    // optional string name_loctoken = 4;

    pub fn name_loctoken(&self) -> &str {
        match self.name_loctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loctoken(&mut self) {
        self.name_loctoken = ::std::option::Option::None;
    }

    pub fn has_name_loctoken(&self) -> bool {
        self.name_loctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loctoken(&mut self, v: ::std::string::String) {
        self.name_loctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loctoken(&mut self) -> &mut ::std::string::String {
        if self.name_loctoken.is_none() {
            self.name_loctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loctoken(&mut self) -> ::std::string::String {
        self.name_loctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float x_pos = 6;

    pub fn x_pos(&self) -> f32 {
        self.x_pos.unwrap_or(0.)
    }

    pub fn clear_x_pos(&mut self) {
        self.x_pos = ::std::option::Option::None;
    }

    pub fn has_x_pos(&self) -> bool {
        self.x_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_pos(&mut self, v: f32) {
        self.x_pos = ::std::option::Option::Some(v);
    }

    // optional float y_pos = 7;

    pub fn y_pos(&self) -> f32 {
        self.y_pos.unwrap_or(0.)
    }

    pub fn clear_y_pos(&mut self) {
        self.y_pos = ::std::option::Option::None;
    }

    pub fn has_y_pos(&self) -> bool {
        self.y_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_pos(&mut self, v: f32) {
        self.y_pos = ::std::option::Option::Some(v);
    }

    // optional string associated_operation = 16;

    pub fn associated_operation(&self) -> &str {
        match self.associated_operation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_associated_operation(&mut self) {
        self.associated_operation = ::std::option::Option::None;
    }

    pub fn has_associated_operation(&self) -> bool {
        self.associated_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_operation(&mut self, v: ::std::string::String) {
        self.associated_operation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_operation(&mut self) -> &mut ::std::string::String {
        if self.associated_operation.is_none() {
            self.associated_operation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.associated_operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_associated_operation(&mut self) -> ::std::string::String {
        self.associated_operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_item_name = 18;

    pub fn reward_item_name(&self) -> &str {
        match self.reward_item_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_item_name(&mut self) {
        self.reward_item_name = ::std::option::Option::None;
    }

    pub fn has_reward_item_name(&self) -> bool {
        self.reward_item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_name(&mut self, v: ::std::string::String) {
        self.reward_item_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_item_name(&mut self) -> &mut ::std::string::String {
        if self.reward_item_name.is_none() {
            self.reward_item_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_item_name(&mut self) -> ::std::string::String {
        self.reward_item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_lootlist_name = 22;

    pub fn reward_lootlist_name(&self) -> &str {
        match self.reward_lootlist_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_lootlist_name(&mut self) {
        self.reward_lootlist_name = ::std::option::Option::None;
    }

    pub fn has_reward_lootlist_name(&self) -> bool {
        self.reward_lootlist_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_lootlist_name(&mut self, v: ::std::string::String) {
        self.reward_lootlist_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_lootlist_name(&mut self) -> &mut ::std::string::String {
        if self.reward_lootlist_name.is_none() {
            self.reward_lootlist_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_lootlist_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_lootlist_name(&mut self) -> ::std::string::String {
        self.reward_lootlist_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ENodeCashReward cash_reward = 19;

    pub fn cash_reward(&self) -> ENodeCashReward {
        match self.cash_reward {
            Some(e) => e.enum_value_or(ENodeCashReward::CASH_REWARD_NONE),
            None => ENodeCashReward::CASH_REWARD_NONE,
        }
    }

    pub fn clear_cash_reward(&mut self) {
        self.cash_reward = ::std::option::Option::None;
    }

    pub fn has_cash_reward(&self) -> bool {
        self.cash_reward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cash_reward(&mut self, v: ENodeCashReward) {
        self.cash_reward = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 stars_to_unlock = 21;

    pub fn stars_to_unlock(&self) -> u32 {
        self.stars_to_unlock.unwrap_or(1u32)
    }

    pub fn clear_stars_to_unlock(&mut self) {
        self.stars_to_unlock = ::std::option::Option::None;
    }

    pub fn has_stars_to_unlock(&self) -> bool {
        self.stars_to_unlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stars_to_unlock(&mut self, v: u32) {
        self.stars_to_unlock = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestMapNodeDef {
    const NAME: &'static str = "CMsgQuestMapNodeDef";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owning_region {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quest_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.star_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                34 => {
                    self.name_loctoken = ::std::option::Option::Some(is.read_string()?);
                },
                53 => {
                    self.x_pos = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.y_pos = ::std::option::Option::Some(is.read_float()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.condition)?;
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owning_region)?;
                },
                90 => {
                    self.quest_options.push(is.read_message()?);
                },
                130 => {
                    self.associated_operation = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.reward_item_name = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.reward_lootlist_name = ::std::option::Option::Some(is.read_string()?);
                },
                152 => {
                    self.cash_reward = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                162 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.star_type)?;
                },
                168 => {
                    self.stars_to_unlock = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.x_pos {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_pos {
            my_size += 1 + 4;
        }
        if let Some(v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.owning_region.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.quest_options {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.associated_operation.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.reward_item_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.cash_reward {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.star_type.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stars_to_unlock {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name_loctoken.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.x_pos {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.y_pos {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.condition.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.owning_region.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.quest_options {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.associated_operation.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.reward_item_name.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.reward_lootlist_name.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.cash_reward {
            os.write_enum(19, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.star_type.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.stars_to_unlock {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeDef {
        CMsgQuestMapNodeDef::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.name_loctoken = ::std::option::Option::None;
        self.x_pos = ::std::option::Option::None;
        self.y_pos = ::std::option::Option::None;
        self.condition.clear();
        self.owning_region.clear();
        self.quest_options.clear();
        self.associated_operation = ::std::option::Option::None;
        self.reward_item_name = ::std::option::Option::None;
        self.reward_lootlist_name = ::std::option::Option::None;
        self.cash_reward = ::std::option::Option::None;
        self.star_type.clear();
        self.stars_to_unlock = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeDef {
        static instance: CMsgQuestMapNodeDef = CMsgQuestMapNodeDef {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            name_loctoken: ::std::option::Option::None,
            x_pos: ::std::option::Option::None,
            y_pos: ::std::option::Option::None,
            condition: ::steam_vent_proto_common::protobuf::MessageField::none(),
            owning_region: ::steam_vent_proto_common::protobuf::MessageField::none(),
            quest_options: ::std::vec::Vec::new(),
            associated_operation: ::std::option::Option::None,
            reward_item_name: ::std::option::Option::None,
            reward_lootlist_name: ::std::option::Option::None,
            cash_reward: ::std::option::Option::None,
            star_type: ::steam_vent_proto_common::protobuf::MessageField::none(),
            stars_to_unlock: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Variables)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Variables {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Variables.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Variables.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Variables {
    fn default() -> &'a CMsgPaintKit_Variables {
        <CMsgPaintKit_Variables as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Variables {
    pub fn new() -> CMsgPaintKit_Variables {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Variables {
    const NAME: &'static str = "CMsgPaintKit_Variables";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Variables {
        CMsgPaintKit_Variables::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Variables {
        static instance: CMsgPaintKit_Variables = CMsgPaintKit_Variables {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_TextureStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_TextureStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.texture)
    pub texture: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.texture_red)
    pub texture_red: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.texture_blue)
    pub texture_blue: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.adjust_black)
    pub adjust_black: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.adjust_offset)
    pub adjust_offset: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.adjust_gamma)
    pub adjust_gamma: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.rotation)
    pub rotation: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.translate_u)
    pub translate_u: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.translate_v)
    pub translate_v: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.scale_uv)
    pub scale_uv: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.flip_u)
    pub flip_u: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_TextureStage.flip_v)
    pub flip_v: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_TextureStage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_TextureStage {
    fn default() -> &'a CMsgPaintKit_Operation_TextureStage {
        <CMsgPaintKit_Operation_TextureStage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_TextureStage {
    pub fn new() -> CMsgPaintKit_Operation_TextureStage {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Operation_TextureStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_TextureStage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.texture)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_red)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.texture_blue)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_black)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_offset)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_gamma)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rotation)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_u)?;
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_v)?;
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.scale_uv)?;
                },
                90 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_u)?;
                },
                98 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_v)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.texture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_red.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.texture_blue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.texture.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.texture_red.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.texture_blue.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.rotation.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.translate_u.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.translate_v.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.flip_u.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.flip_v.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_TextureStage {
        CMsgPaintKit_Operation_TextureStage::new()
    }

    fn clear(&mut self) {
        self.texture.clear();
        self.texture_red.clear();
        self.texture_blue.clear();
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.rotation.clear();
        self.translate_u.clear();
        self.translate_v.clear();
        self.scale_uv.clear();
        self.flip_u.clear();
        self.flip_v.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_TextureStage {
        static instance: CMsgPaintKit_Operation_TextureStage = CMsgPaintKit_Operation_TextureStage {
            texture: ::steam_vent_proto_common::protobuf::MessageField::none(),
            texture_red: ::steam_vent_proto_common::protobuf::MessageField::none(),
            texture_blue: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_black: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_offset: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_gamma: ::steam_vent_proto_common::protobuf::MessageField::none(),
            rotation: ::steam_vent_proto_common::protobuf::MessageField::none(),
            translate_u: ::steam_vent_proto_common::protobuf::MessageField::none(),
            translate_v: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scale_uv: ::steam_vent_proto_common::protobuf::MessageField::none(),
            flip_u: ::steam_vent_proto_common::protobuf::MessageField::none(),
            flip_v: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_CombineStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_CombineStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.adjust_black)
    pub adjust_black: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.adjust_offset)
    pub adjust_offset: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.adjust_gamma)
    pub adjust_gamma: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.rotation)
    pub rotation: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.translate_u)
    pub translate_u: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.translate_v)
    pub translate_v: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.scale_uv)
    pub scale_uv: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.flip_u)
    pub flip_u: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.flip_v)
    pub flip_v: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_CombineStage.operation_node)
    pub operation_node: ::std::vec::Vec<CMsgPaintKit_OperationNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_CombineStage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_CombineStage {
    fn default() -> &'a CMsgPaintKit_Operation_CombineStage {
        <CMsgPaintKit_Operation_CombineStage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_CombineStage {
    pub fn new() -> CMsgPaintKit_Operation_CombineStage {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Operation_CombineStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_CombineStage";

    fn is_initialized(&self) -> bool {
        for v in &self.adjust_black {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_v {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale_uv {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_v {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_black)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_offset)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_gamma)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rotation)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_u)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.translate_v)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.scale_uv)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_u)?;
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.flip_v)?;
                },
                90 => {
                    self.operation_node.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.translate_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flip_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.adjust_black.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.rotation.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.translate_u.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.translate_v.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.scale_uv.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.flip_u.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.flip_v.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.operation_node {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_CombineStage {
        CMsgPaintKit_Operation_CombineStage::new()
    }

    fn clear(&mut self) {
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.rotation.clear();
        self.translate_u.clear();
        self.translate_v.clear();
        self.scale_uv.clear();
        self.flip_u.clear();
        self.flip_v.clear();
        self.operation_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_CombineStage {
        static instance: CMsgPaintKit_Operation_CombineStage = CMsgPaintKit_Operation_CombineStage {
            adjust_black: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_offset: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_gamma: ::steam_vent_proto_common::protobuf::MessageField::none(),
            rotation: ::steam_vent_proto_common::protobuf::MessageField::none(),
            translate_u: ::steam_vent_proto_common::protobuf::MessageField::none(),
            translate_v: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scale_uv: ::steam_vent_proto_common::protobuf::MessageField::none(),
            flip_u: ::steam_vent_proto_common::protobuf::MessageField::none(),
            flip_v: ::steam_vent_proto_common::protobuf::MessageField::none(),
            operation_node: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_SelectStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_SelectStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_SelectStage.groups)
    pub groups: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_SelectStage.select)
    pub select: ::std::vec::Vec<CMsgVarField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_SelectStage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_SelectStage {
    fn default() -> &'a CMsgPaintKit_Operation_SelectStage {
        <CMsgPaintKit_Operation_SelectStage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_SelectStage {
    pub fn new() -> CMsgPaintKit_Operation_SelectStage {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Operation_SelectStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_SelectStage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.groups)?;
                },
                18 => {
                    self.select.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.select {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.groups.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.select {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_SelectStage {
        CMsgPaintKit_Operation_SelectStage::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.select.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_SelectStage {
        static instance: CMsgPaintKit_Operation_SelectStage = CMsgPaintKit_Operation_SelectStage {
            groups: ::steam_vent_proto_common::protobuf::MessageField::none(),
            select: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_Sticker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_Sticker {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_Sticker.base)
    pub base: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_Sticker.weight)
    pub weight: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_Sticker.spec)
    pub spec: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_Sticker.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_Sticker {
    fn default() -> &'a CMsgPaintKit_Operation_Sticker {
        <CMsgPaintKit_Operation_Sticker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_Sticker {
    pub fn new() -> CMsgPaintKit_Operation_Sticker {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Operation_Sticker {
    const NAME: &'static str = "CMsgPaintKit_Operation_Sticker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.weight)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.weight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.weight.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_Sticker {
        CMsgPaintKit_Operation_Sticker::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.weight.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_Sticker {
        static instance: CMsgPaintKit_Operation_Sticker = CMsgPaintKit_Operation_Sticker {
            base: ::steam_vent_proto_common::protobuf::MessageField::none(),
            weight: ::steam_vent_proto_common::protobuf::MessageField::none(),
            spec: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation_StickerStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation_StickerStage {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.sticker)
    pub sticker: ::std::vec::Vec<CMsgPaintKit_Operation_Sticker>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.dest_tl)
    pub dest_tl: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.dest_tr)
    pub dest_tr: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.dest_bl)
    pub dest_bl: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.adjust_black)
    pub adjust_black: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.adjust_offset)
    pub adjust_offset: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.adjust_gamma)
    pub adjust_gamma: ::steam_vent_proto_common::protobuf::MessageField<CMsgVarField>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation_StickerStage.operation_node)
    pub operation_node: ::std::vec::Vec<CMsgPaintKit_OperationNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation_StickerStage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_StickerStage {
    fn default() -> &'a CMsgPaintKit_Operation_StickerStage {
        <CMsgPaintKit_Operation_StickerStage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_StickerStage {
    pub fn new() -> CMsgPaintKit_Operation_StickerStage {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Operation_StickerStage {
    const NAME: &'static str = "CMsgPaintKit_Operation_StickerStage";

    fn is_initialized(&self) -> bool {
        for v in &self.sticker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_tl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_tr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_bl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_black {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sticker.push(is.read_message()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dest_tl)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dest_tr)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dest_bl)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_black)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_offset)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.adjust_gamma)?;
                },
                74 => {
                    self.operation_node.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sticker {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.dest_tl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dest_tr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dest_bl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.sticker {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.dest_tl.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.dest_tr.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.dest_bl.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.adjust_black.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.adjust_offset.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.adjust_gamma.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.operation_node {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation_StickerStage {
        CMsgPaintKit_Operation_StickerStage::new()
    }

    fn clear(&mut self) {
        self.sticker.clear();
        self.dest_tl.clear();
        self.dest_tr.clear();
        self.dest_bl.clear();
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.operation_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_StickerStage {
        static instance: CMsgPaintKit_Operation_StickerStage = CMsgPaintKit_Operation_StickerStage {
            sticker: ::std::vec::Vec::new(),
            dest_tl: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dest_tr: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dest_bl: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_black: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_offset: ::steam_vent_proto_common::protobuf::MessageField::none(),
            adjust_gamma: ::steam_vent_proto_common::protobuf::MessageField::none(),
            operation_node: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_OperationStage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_OperationStage {
    // message oneof groups
    pub stage: ::std::option::Option<cmsg_paint_kit_operation_stage::Stage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_OperationStage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_OperationStage {
    fn default() -> &'a CMsgPaintKit_OperationStage {
        <CMsgPaintKit_OperationStage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_OperationStage {
    pub fn new() -> CMsgPaintKit_OperationStage {
        ::std::default::Default::default()
    }

    // optional .CMsgPaintKit_Operation_TextureStage texture_lookup = 1;

    pub fn texture_lookup(&self) -> &CMsgPaintKit_Operation_TextureStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v)) => v,
            _ => <CMsgPaintKit_Operation_TextureStage as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_texture_lookup(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_texture_lookup(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_texture_lookup(&mut self, v: CMsgPaintKit_Operation_TextureStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_texture_lookup(&mut self) -> &mut CMsgPaintKit_Operation_TextureStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(CMsgPaintKit_Operation_TextureStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_texture_lookup(&mut self) -> CMsgPaintKit_Operation_TextureStage {
        if self.has_texture_lookup() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_TextureStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_add = 2;

    pub fn combine_add(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine_add(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_add(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_add(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_add(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_add(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_add() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_lerp = 3;

    pub fn combine_lerp(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine_lerp(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_lerp(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_lerp(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_lerp(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_lerp(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_lerp() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_multiply = 4;

    pub fn combine_multiply(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine_multiply(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_multiply(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_multiply(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_multiply(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_multiply(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_multiply() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_SelectStage select = 5;

    pub fn select(&self) -> &CMsgPaintKit_Operation_SelectStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(ref v)) => v,
            _ => <CMsgPaintKit_Operation_SelectStage as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_select(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_select(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select(&mut self, v: CMsgPaintKit_Operation_SelectStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select(&mut self) -> &mut CMsgPaintKit_Operation_SelectStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(CMsgPaintKit_Operation_SelectStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select(&mut self) -> CMsgPaintKit_Operation_SelectStage {
        if self.has_select() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_SelectStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_StickerStage apply_sticker = 6;

    pub fn apply_sticker(&self) -> &CMsgPaintKit_Operation_StickerStage {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v)) => v,
            _ => <CMsgPaintKit_Operation_StickerStage as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_apply_sticker(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_apply_sticker(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_sticker(&mut self, v: CMsgPaintKit_Operation_StickerStage) {
        self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_sticker(&mut self) -> &mut CMsgPaintKit_Operation_StickerStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(CMsgPaintKit_Operation_StickerStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_sticker(&mut self) -> CMsgPaintKit_Operation_StickerStage {
        if self.has_apply_sticker() {
            match self.stage.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_StickerStage::new()
        }
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_OperationStage {
    const NAME: &'static str = "CMsgPaintKit_OperationStage";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::Select(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::TextureLookup(is.read_message()?));
                },
                18 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineAdd(is.read_message()?));
                },
                26 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineLerp(is.read_message()?));
                },
                34 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::CombineMultiply(is.read_message()?));
                },
                42 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::Select(is.read_message()?));
                },
                50 => {
                    self.stage = ::std::option::Option::Some(cmsg_paint_kit_operation_stage::Stage::ApplySticker(is.read_message()?));
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.stage {
            match v {
                &cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::Select(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.stage {
            match v {
                &cmsg_paint_kit_operation_stage::Stage::TextureLookup(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineAdd(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineLerp(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::CombineMultiply(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::Select(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &cmsg_paint_kit_operation_stage::Stage::ApplySticker(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_OperationStage {
        CMsgPaintKit_OperationStage::new()
    }

    fn clear(&mut self) {
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_OperationStage {
        static instance: CMsgPaintKit_OperationStage = CMsgPaintKit_OperationStage {
            stage: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPaintKit_OperationStage`
pub mod cmsg_paint_kit_operation_stage {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgPaintKit_OperationStage.stage)
    pub enum Stage {
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.texture_lookup)
        TextureLookup(super::CMsgPaintKit_Operation_TextureStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.combine_add)
        CombineAdd(super::CMsgPaintKit_Operation_CombineStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.combine_lerp)
        CombineLerp(super::CMsgPaintKit_Operation_CombineStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.combine_multiply)
        CombineMultiply(super::CMsgPaintKit_Operation_CombineStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.select)
        Select(super::CMsgPaintKit_Operation_SelectStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationStage.apply_sticker)
        ApplySticker(super::CMsgPaintKit_Operation_StickerStage),
    }

    impl ::steam_vent_proto_common::protobuf::Oneof for Stage {
    }

    impl Stage {
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_OperationNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_OperationNode {
    // message oneof groups
    pub node: ::std::option::Option<cmsg_paint_kit_operation_node::Node>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_OperationNode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_OperationNode {
    fn default() -> &'a CMsgPaintKit_OperationNode {
        <CMsgPaintKit_OperationNode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_OperationNode {
    pub fn new() -> CMsgPaintKit_OperationNode {
        ::std::default::Default::default()
    }

    // optional .CMsgPaintKit_OperationStage stage = 1;

    pub fn stage(&self) -> &CMsgPaintKit_OperationStage {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(ref v)) => v,
            _ => <CMsgPaintKit_OperationStage as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stage(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: CMsgPaintKit_OperationStage) {
        self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stage(&mut self) -> &mut CMsgPaintKit_OperationStage {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(CMsgPaintKit_OperationStage::new()));
        }
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stage(&mut self) -> CMsgPaintKit_OperationStage {
        if self.has_stage() {
            match self.node.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_OperationStage::new()
        }
    }

    // optional .CMsgProtoDefID operation_template = 2;

    pub fn operation_template(&self) -> &CMsgProtoDefID {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v)) => v,
            _ => <CMsgProtoDefID as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_operation_template(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_operation_template(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_operation_template(&mut self, v: CMsgProtoDefID) {
        self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_operation_template(&mut self) -> &mut CMsgProtoDefID {
        if let ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(CMsgProtoDefID::new()));
        }
        match self.node {
            ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_operation_template(&mut self) -> CMsgProtoDefID {
        if self.has_operation_template() {
            match self.node.take() {
                ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgProtoDefID::new()
        }
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_OperationNode {
    const NAME: &'static str = "CMsgPaintKit_OperationNode";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_paint_kit_operation_node::Node::Stage(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::Stage(is.read_message()?));
                },
                18 => {
                    self.node = ::std::option::Option::Some(cmsg_paint_kit_operation_node::Node::OperationTemplate(is.read_message()?));
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &cmsg_paint_kit_operation_node::Node::Stage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &cmsg_paint_kit_operation_node::Node::Stage(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cmsg_paint_kit_operation_node::Node::OperationTemplate(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_OperationNode {
        CMsgPaintKit_OperationNode::new()
    }

    fn clear(&mut self) {
        self.node = ::std::option::Option::None;
        self.node = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_OperationNode {
        static instance: CMsgPaintKit_OperationNode = CMsgPaintKit_OperationNode {
            node: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPaintKit_OperationNode`
pub mod cmsg_paint_kit_operation_node {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgPaintKit_OperationNode.node)
    pub enum Node {
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationNode.stage)
        Stage(super::CMsgPaintKit_OperationStage),
        // @@protoc_insertion_point(oneof_field:CMsgPaintKit_OperationNode.operation_template)
        OperationTemplate(super::CMsgProtoDefID),
    }

    impl ::steam_vent_proto_common::protobuf::Oneof for Node {
    }

    impl Node {
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Operation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Operation {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Operation.operation_node)
    pub operation_node: ::std::vec::Vec<CMsgPaintKit_OperationNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Operation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation {
    fn default() -> &'a CMsgPaintKit_Operation {
        <CMsgPaintKit_Operation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation {
    pub fn new() -> CMsgPaintKit_Operation {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Operation {
    const NAME: &'static str = "CMsgPaintKit_Operation";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.operation_node.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.operation_node {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Operation {
        CMsgPaintKit_Operation::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.operation_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation {
        static instance: CMsgPaintKit_Operation = CMsgPaintKit_Operation {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            operation_node: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_ItemDefinition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_ItemDefinition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.item_definition_index)
    pub item_definition_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.variable_template)
    pub variable_template: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.definition)
    pub definition: ::std::vec::Vec<cmsg_paint_kit_item_definition::Definition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_ItemDefinition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_ItemDefinition {
    fn default() -> &'a CMsgPaintKit_ItemDefinition {
        <CMsgPaintKit_ItemDefinition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_ItemDefinition {
    pub fn new() -> CMsgPaintKit_ItemDefinition {
        ::std::default::Default::default()
    }

    // required uint32 item_definition_index = 2;

    pub fn item_definition_index(&self) -> u32 {
        self.item_definition_index.unwrap_or(0)
    }

    pub fn clear_item_definition_index(&mut self) {
        self.item_definition_index = ::std::option::Option::None;
    }

    pub fn has_item_definition_index(&self) -> bool {
        self.item_definition_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_definition_index(&mut self, v: u32) {
        self.item_definition_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_ItemDefinition {
    const NAME: &'static str = "CMsgPaintKit_ItemDefinition";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.item_definition_index.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variable_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.definition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.item_definition_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.variable_template)?;
                },
                34 => {
                    self.definition.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_definition_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.variable_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.definition {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.item_definition_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.variable_template.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.definition {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_ItemDefinition {
        CMsgPaintKit_ItemDefinition::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.item_definition_index = ::std::option::Option::None;
        self.variable_template.clear();
        self.definition.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_ItemDefinition {
        static instance: CMsgPaintKit_ItemDefinition = CMsgPaintKit_ItemDefinition {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            item_definition_index: ::std::option::Option::None,
            variable_template: ::steam_vent_proto_common::protobuf::MessageField::none(),
            definition: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPaintKit_ItemDefinition`
pub mod cmsg_paint_kit_item_definition {
    // @@protoc_insertion_point(message:CMsgPaintKit_ItemDefinition.Definition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Definition {
        // message fields
        // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.Definition.operation_template)
        pub operation_template: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgPaintKit_ItemDefinition.Definition.variable)
        pub variable: ::std::vec::Vec<super::CMsgVarField>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPaintKit_ItemDefinition.Definition.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Definition {
        fn default() -> &'a Definition {
            <Definition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Definition {
        pub fn new() -> Definition {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Definition {
        const NAME: &'static str = "Definition";

        fn is_initialized(&self) -> bool {
            for v in &self.operation_template {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.variable {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.operation_template)?;
                    },
                    18 => {
                        self.variable.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.operation_template.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.variable {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.operation_template.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.variable {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Definition {
            Definition::new()
        }

        fn clear(&mut self) {
            self.operation_template.clear();
            self.variable.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Definition {
            static instance: Definition = Definition {
                operation_template: ::steam_vent_proto_common::protobuf::MessageField::none(),
                variable: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPaintKit_Definition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPaintKit_Definition {
    // message fields
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.loc_desctoken)
    pub loc_desctoken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.operation_template)
    pub operation_template: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.has_team_textures)
    pub has_team_textures: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.item)
    pub item: ::std::vec::Vec<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.paintkit_tool)
    pub paintkit_tool: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.flamethrower)
    pub flamethrower: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.grenadelauncher)
    pub grenadelauncher: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.knife)
    pub knife: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.medigun)
    pub medigun: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.minigun)
    pub minigun: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.pistol)
    pub pistol: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.revolver)
    pub revolver: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.rocketlauncher)
    pub rocketlauncher: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.scattergun)
    pub scattergun: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.shotgun)
    pub shotgun: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.smg)
    pub smg: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.sniperrifle)
    pub sniperrifle: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.stickybomb_launcher)
    pub stickybomb_launcher: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.ubersaw)
    pub ubersaw: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.wrench)
    pub wrench: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.amputator)
    pub amputator: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.atom_launcher)
    pub atom_launcher: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.back_scratcher)
    pub back_scratcher: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.battleaxe)
    pub battleaxe: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.bazaar_sniper)
    pub bazaar_sniper: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.blackbox)
    pub blackbox: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.claidheamohmor)
    pub claidheamohmor: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.crusaders_crossbow)
    pub crusaders_crossbow: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.degreaser)
    pub degreaser: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.demo_cannon)
    pub demo_cannon: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.demo_sultan_sword)
    pub demo_sultan_sword: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.detonator)
    pub detonator: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.gatling_gun)
    pub gatling_gun: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.holymackerel)
    pub holymackerel: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.jag)
    pub jag: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.lochnload)
    pub lochnload: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.powerjack)
    pub powerjack: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.quadball)
    pub quadball: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.reserve_shooter)
    pub reserve_shooter: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.riding_crop)
    pub riding_crop: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.russian_riot)
    pub russian_riot: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.scimitar)
    pub scimitar: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.scorch_shot)
    pub scorch_shot: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.shortstop)
    pub shortstop: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.soda_popper)
    pub soda_popper: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.tele_shotgun)
    pub tele_shotgun: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.tomislav)
    pub tomislav: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.trenchgun)
    pub trenchgun: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // @@protoc_insertion_point(field:CMsgPaintKit_Definition.winger_pistol)
    pub winger_pistol: ::steam_vent_proto_common::protobuf::MessageField<cmsg_paint_kit_definition::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPaintKit_Definition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Definition {
    fn default() -> &'a CMsgPaintKit_Definition {
        <CMsgPaintKit_Definition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Definition {
    pub fn new() -> CMsgPaintKit_Definition {
        ::std::default::Default::default()
    }

    // optional string loc_desctoken = 2;

    pub fn loc_desctoken(&self) -> &str {
        match self.loc_desctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc_desctoken(&mut self) {
        self.loc_desctoken = ::std::option::Option::None;
    }

    pub fn has_loc_desctoken(&self) -> bool {
        self.loc_desctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_desctoken(&mut self, v: ::std::string::String) {
        self.loc_desctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_desctoken(&mut self) -> &mut ::std::string::String {
        if self.loc_desctoken.is_none() {
            self.loc_desctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc_desctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_desctoken(&mut self) -> ::std::string::String {
        self.loc_desctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_team_textures = 4;

    pub fn has_team_textures(&self) -> bool {
        self.has_team_textures.unwrap_or(false)
    }

    pub fn clear_has_team_textures(&mut self) {
        self.has_team_textures = ::std::option::Option::None;
    }

    pub fn has_has_team_textures(&self) -> bool {
        self.has_team_textures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_team_textures(&mut self, v: bool) {
        self.has_team_textures = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPaintKit_Definition {
    const NAME: &'static str = "CMsgPaintKit_Definition";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paintkit_tool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flamethrower {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grenadelauncher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.knife {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.medigun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.minigun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pistol {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revolver {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rocketlauncher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scattergun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shotgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.smg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sniperrifle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stickybomb_launcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ubersaw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wrench {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.amputator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.atom_launcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.back_scratcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.battleaxe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bazaar_sniper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blackbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.claidheamohmor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crusaders_crossbow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.degreaser {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.demo_cannon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.demo_sultan_sword {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.detonator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gatling_gun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.holymackerel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.jag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lochnload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.powerjack {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quadball {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserve_shooter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.riding_crop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.russian_riot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scimitar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scorch_shot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shortstop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.soda_popper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tele_shotgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tomislav {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trenchgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.winger_pistol {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.loc_desctoken = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.operation_template)?;
                },
                32 => {
                    self.has_team_textures = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.item.push(is.read_message()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.paintkit_tool)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.flamethrower)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.grenadelauncher)?;
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.knife)?;
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.medigun)?;
                },
                90 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.minigun)?;
                },
                98 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.pistol)?;
                },
                106 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.revolver)?;
                },
                114 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rocketlauncher)?;
                },
                122 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.scattergun)?;
                },
                130 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.shotgun)?;
                },
                138 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.smg)?;
                },
                146 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.sniperrifle)?;
                },
                154 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stickybomb_launcher)?;
                },
                162 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ubersaw)?;
                },
                170 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wrench)?;
                },
                178 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.amputator)?;
                },
                186 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.atom_launcher)?;
                },
                194 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.back_scratcher)?;
                },
                202 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.battleaxe)?;
                },
                210 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.bazaar_sniper)?;
                },
                218 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.blackbox)?;
                },
                226 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.claidheamohmor)?;
                },
                234 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.crusaders_crossbow)?;
                },
                242 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.degreaser)?;
                },
                250 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.demo_cannon)?;
                },
                258 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.demo_sultan_sword)?;
                },
                266 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.detonator)?;
                },
                274 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gatling_gun)?;
                },
                282 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.holymackerel)?;
                },
                290 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.jag)?;
                },
                298 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.lochnload)?;
                },
                306 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.powerjack)?;
                },
                314 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.quadball)?;
                },
                322 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.reserve_shooter)?;
                },
                330 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.riding_crop)?;
                },
                338 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.russian_riot)?;
                },
                346 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.scimitar)?;
                },
                354 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.scorch_shot)?;
                },
                362 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.shortstop)?;
                },
                370 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.soda_popper)?;
                },
                378 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tele_shotgun)?;
                },
                386 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tomislav)?;
                },
                394 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.trenchgun)?;
                },
                402 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.winger_pistol)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.operation_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.has_team_textures {
            my_size += 1 + 1;
        }
        for value in &self.item {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.paintkit_tool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flamethrower.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.grenadelauncher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.knife.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.medigun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minigun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pistol.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revolver.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rocketlauncher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scattergun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shotgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.smg.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sniperrifle.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickybomb_launcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ubersaw.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wrench.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.amputator.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.atom_launcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.back_scratcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.battleaxe.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bazaar_sniper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blackbox.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.claidheamohmor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.crusaders_crossbow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.degreaser.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.demo_cannon.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.demo_sultan_sword.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.detonator.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gatling_gun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.holymackerel.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.jag.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lochnload.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.powerjack.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quadball.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reserve_shooter.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.riding_crop.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.russian_riot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scimitar.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scorch_shot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shortstop.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.soda_popper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tele_shotgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tomislav.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trenchgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.winger_pistol.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.loc_desctoken.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.operation_template.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.has_team_textures {
            os.write_bool(4, v)?;
        }
        for v in &self.item {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.paintkit_tool.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.flamethrower.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.grenadelauncher.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.knife.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.medigun.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.minigun.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.pistol.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.revolver.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.rocketlauncher.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.scattergun.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.shotgun.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.smg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.sniperrifle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.stickybomb_launcher.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.ubersaw.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.wrench.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.amputator.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.atom_launcher.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.back_scratcher.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.battleaxe.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.bazaar_sniper.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.blackbox.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.claidheamohmor.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.crusaders_crossbow.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.degreaser.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.demo_cannon.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.demo_sultan_sword.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.detonator.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.gatling_gun.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.holymackerel.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.jag.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.lochnload.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.powerjack.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        if let Some(v) = self.quadball.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        if let Some(v) = self.reserve_shooter.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.riding_crop.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.russian_riot.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.scimitar.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.scorch_shot.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        if let Some(v) = self.shortstop.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        }
        if let Some(v) = self.soda_popper.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
        }
        if let Some(v) = self.tele_shotgun.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        }
        if let Some(v) = self.tomislav.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        }
        if let Some(v) = self.trenchgun.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        }
        if let Some(v) = self.winger_pistol.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPaintKit_Definition {
        CMsgPaintKit_Definition::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.loc_desctoken = ::std::option::Option::None;
        self.operation_template.clear();
        self.has_team_textures = ::std::option::Option::None;
        self.item.clear();
        self.paintkit_tool.clear();
        self.flamethrower.clear();
        self.grenadelauncher.clear();
        self.knife.clear();
        self.medigun.clear();
        self.minigun.clear();
        self.pistol.clear();
        self.revolver.clear();
        self.rocketlauncher.clear();
        self.scattergun.clear();
        self.shotgun.clear();
        self.smg.clear();
        self.sniperrifle.clear();
        self.stickybomb_launcher.clear();
        self.ubersaw.clear();
        self.wrench.clear();
        self.amputator.clear();
        self.atom_launcher.clear();
        self.back_scratcher.clear();
        self.battleaxe.clear();
        self.bazaar_sniper.clear();
        self.blackbox.clear();
        self.claidheamohmor.clear();
        self.crusaders_crossbow.clear();
        self.degreaser.clear();
        self.demo_cannon.clear();
        self.demo_sultan_sword.clear();
        self.detonator.clear();
        self.gatling_gun.clear();
        self.holymackerel.clear();
        self.jag.clear();
        self.lochnload.clear();
        self.powerjack.clear();
        self.quadball.clear();
        self.reserve_shooter.clear();
        self.riding_crop.clear();
        self.russian_riot.clear();
        self.scimitar.clear();
        self.scorch_shot.clear();
        self.shortstop.clear();
        self.soda_popper.clear();
        self.tele_shotgun.clear();
        self.tomislav.clear();
        self.trenchgun.clear();
        self.winger_pistol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPaintKit_Definition {
        static instance: CMsgPaintKit_Definition = CMsgPaintKit_Definition {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            loc_desctoken: ::std::option::Option::None,
            operation_template: ::steam_vent_proto_common::protobuf::MessageField::none(),
            has_team_textures: ::std::option::Option::None,
            item: ::std::vec::Vec::new(),
            paintkit_tool: ::steam_vent_proto_common::protobuf::MessageField::none(),
            flamethrower: ::steam_vent_proto_common::protobuf::MessageField::none(),
            grenadelauncher: ::steam_vent_proto_common::protobuf::MessageField::none(),
            knife: ::steam_vent_proto_common::protobuf::MessageField::none(),
            medigun: ::steam_vent_proto_common::protobuf::MessageField::none(),
            minigun: ::steam_vent_proto_common::protobuf::MessageField::none(),
            pistol: ::steam_vent_proto_common::protobuf::MessageField::none(),
            revolver: ::steam_vent_proto_common::protobuf::MessageField::none(),
            rocketlauncher: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scattergun: ::steam_vent_proto_common::protobuf::MessageField::none(),
            shotgun: ::steam_vent_proto_common::protobuf::MessageField::none(),
            smg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            sniperrifle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            stickybomb_launcher: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ubersaw: ::steam_vent_proto_common::protobuf::MessageField::none(),
            wrench: ::steam_vent_proto_common::protobuf::MessageField::none(),
            amputator: ::steam_vent_proto_common::protobuf::MessageField::none(),
            atom_launcher: ::steam_vent_proto_common::protobuf::MessageField::none(),
            back_scratcher: ::steam_vent_proto_common::protobuf::MessageField::none(),
            battleaxe: ::steam_vent_proto_common::protobuf::MessageField::none(),
            bazaar_sniper: ::steam_vent_proto_common::protobuf::MessageField::none(),
            blackbox: ::steam_vent_proto_common::protobuf::MessageField::none(),
            claidheamohmor: ::steam_vent_proto_common::protobuf::MessageField::none(),
            crusaders_crossbow: ::steam_vent_proto_common::protobuf::MessageField::none(),
            degreaser: ::steam_vent_proto_common::protobuf::MessageField::none(),
            demo_cannon: ::steam_vent_proto_common::protobuf::MessageField::none(),
            demo_sultan_sword: ::steam_vent_proto_common::protobuf::MessageField::none(),
            detonator: ::steam_vent_proto_common::protobuf::MessageField::none(),
            gatling_gun: ::steam_vent_proto_common::protobuf::MessageField::none(),
            holymackerel: ::steam_vent_proto_common::protobuf::MessageField::none(),
            jag: ::steam_vent_proto_common::protobuf::MessageField::none(),
            lochnload: ::steam_vent_proto_common::protobuf::MessageField::none(),
            powerjack: ::steam_vent_proto_common::protobuf::MessageField::none(),
            quadball: ::steam_vent_proto_common::protobuf::MessageField::none(),
            reserve_shooter: ::steam_vent_proto_common::protobuf::MessageField::none(),
            riding_crop: ::steam_vent_proto_common::protobuf::MessageField::none(),
            russian_riot: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scimitar: ::steam_vent_proto_common::protobuf::MessageField::none(),
            scorch_shot: ::steam_vent_proto_common::protobuf::MessageField::none(),
            shortstop: ::steam_vent_proto_common::protobuf::MessageField::none(),
            soda_popper: ::steam_vent_proto_common::protobuf::MessageField::none(),
            tele_shotgun: ::steam_vent_proto_common::protobuf::MessageField::none(),
            tomislav: ::steam_vent_proto_common::protobuf::MessageField::none(),
            trenchgun: ::steam_vent_proto_common::protobuf::MessageField::none(),
            winger_pistol: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPaintKit_Definition`
pub mod cmsg_paint_kit_definition {
    // @@protoc_insertion_point(message:CMsgPaintKit_Definition.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.item_definition_template)
        pub item_definition_template: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgProtoDefID>,
        // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.data)
        pub data: ::steam_vent_proto_common::protobuf::MessageField<item::ItemData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPaintKit_Definition.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            if self.item_definition_template.is_none() {
                return false;
            }
            for v in &self.item_definition_template {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.data {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_definition_template)?;
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_definition_template.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_definition_template.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.data.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_definition_template.clear();
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_definition_template: ::steam_vent_proto_common::protobuf::MessageField::none(),
                data: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Item`
    pub mod item {
        // @@protoc_insertion_point(message:CMsgPaintKit_Definition.Item.ItemData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ItemData {
            // message fields
            // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.ItemData.can_apply_paintkit)
            pub can_apply_paintkit: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.ItemData.material_override)
            pub material_override: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgPaintKit_Definition.Item.ItemData.variable)
            pub variable: ::std::vec::Vec<super::super::CMsgVarField>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgPaintKit_Definition.Item.ItemData.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ItemData {
            fn default() -> &'a ItemData {
                <ItemData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl ItemData {
            pub fn new() -> ItemData {
                ::std::default::Default::default()
            }

            // optional bool can_apply_paintkit = 2;

            pub fn can_apply_paintkit(&self) -> bool {
                self.can_apply_paintkit.unwrap_or(true)
            }

            pub fn clear_can_apply_paintkit(&mut self) {
                self.can_apply_paintkit = ::std::option::Option::None;
            }

            pub fn has_can_apply_paintkit(&self) -> bool {
                self.can_apply_paintkit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_can_apply_paintkit(&mut self, v: bool) {
                self.can_apply_paintkit = ::std::option::Option::Some(v);
            }

            // optional string material_override = 3;

            pub fn material_override(&self) -> &str {
                match self.material_override.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_material_override(&mut self) {
                self.material_override = ::std::option::Option::None;
            }

            pub fn has_material_override(&self) -> bool {
                self.material_override.is_some()
            }

            // Param is passed by value, moved
            pub fn set_material_override(&mut self, v: ::std::string::String) {
                self.material_override = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_material_override(&mut self) -> &mut ::std::string::String {
                if self.material_override.is_none() {
                    self.material_override = ::std::option::Option::Some(::std::string::String::new());
                }
                self.material_override.as_mut().unwrap()
            }

            // Take field
            pub fn take_material_override(&mut self) -> ::std::string::String {
                self.material_override.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for ItemData {
            const NAME: &'static str = "ItemData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        16 => {
                            self.can_apply_paintkit = ::std::option::Option::Some(is.read_bool()?);
                        },
                        26 => {
                            self.material_override = ::std::option::Option::Some(is.read_string()?);
                        },
                        34 => {
                            self.variable.push(is.read_message()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.can_apply_paintkit {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.material_override.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
                }
                for value in &self.variable {
                    let len = value.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.can_apply_paintkit {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.material_override.as_ref() {
                    os.write_string(3, v)?;
                }
                for v in &self.variable {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ItemData {
                ItemData::new()
            }

            fn clear(&mut self) {
                self.can_apply_paintkit = ::std::option::Option::None;
                self.material_override = ::std::option::Option::None;
                self.variable.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ItemData {
                static instance: ItemData = ItemData {
                    can_apply_paintkit: ::std::option::Option::None,
                    material_override: ::std::option::Option::None,
                    variable: ::std::vec::Vec::new(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuestTheme)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestTheme {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestTheme.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.notification_res)
    pub notification_res: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.quest_item_res)
    pub quest_item_res: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.in_game_tracker_res)
    pub in_game_tracker_res: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.give_sounds)
    pub give_sounds: ::std::vec::Vec<cmsg_quest_theme::WeightedStringSet>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.complete_sounds)
    pub complete_sounds: ::std::vec::Vec<cmsg_quest_theme::WeightedStringSet>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.fully_complete_sounds)
    pub fully_complete_sounds: ::std::vec::Vec<cmsg_quest_theme::WeightedStringSet>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.reward_sound)
    pub reward_sound: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.discard_sound)
    pub discard_sound: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgQuestTheme.reveal_sound)
    pub reveal_sound: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestTheme.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestTheme {
    fn default() -> &'a CMsgQuestTheme {
        <CMsgQuestTheme as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestTheme {
    pub fn new() -> CMsgQuestTheme {
        ::std::default::Default::default()
    }

    // optional string notification_res = 2;

    pub fn notification_res(&self) -> &str {
        match self.notification_res.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_res(&mut self) {
        self.notification_res = ::std::option::Option::None;
    }

    pub fn has_notification_res(&self) -> bool {
        self.notification_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_res(&mut self, v: ::std::string::String) {
        self.notification_res = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_res(&mut self) -> &mut ::std::string::String {
        if self.notification_res.is_none() {
            self.notification_res = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_res(&mut self) -> ::std::string::String {
        self.notification_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string quest_item_res = 3;

    pub fn quest_item_res(&self) -> &str {
        match self.quest_item_res.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_quest_item_res(&mut self) {
        self.quest_item_res = ::std::option::Option::None;
    }

    pub fn has_quest_item_res(&self) -> bool {
        self.quest_item_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_item_res(&mut self, v: ::std::string::String) {
        self.quest_item_res = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quest_item_res(&mut self) -> &mut ::std::string::String {
        if self.quest_item_res.is_none() {
            self.quest_item_res = ::std::option::Option::Some(::std::string::String::new());
        }
        self.quest_item_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_quest_item_res(&mut self) -> ::std::string::String {
        self.quest_item_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string in_game_tracker_res = 4;

    pub fn in_game_tracker_res(&self) -> &str {
        match self.in_game_tracker_res.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_in_game_tracker_res(&mut self) {
        self.in_game_tracker_res = ::std::option::Option::None;
    }

    pub fn has_in_game_tracker_res(&self) -> bool {
        self.in_game_tracker_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_tracker_res(&mut self, v: ::std::string::String) {
        self.in_game_tracker_res = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_in_game_tracker_res(&mut self) -> &mut ::std::string::String {
        if self.in_game_tracker_res.is_none() {
            self.in_game_tracker_res = ::std::option::Option::Some(::std::string::String::new());
        }
        self.in_game_tracker_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_in_game_tracker_res(&mut self) -> ::std::string::String {
        self.in_game_tracker_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_sound = 8;

    pub fn reward_sound(&self) -> &str {
        match self.reward_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reward_sound(&mut self) {
        self.reward_sound = ::std::option::Option::None;
    }

    pub fn has_reward_sound(&self) -> bool {
        self.reward_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_sound(&mut self, v: ::std::string::String) {
        self.reward_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_sound(&mut self) -> &mut ::std::string::String {
        if self.reward_sound.is_none() {
            self.reward_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reward_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_sound(&mut self) -> ::std::string::String {
        self.reward_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string discard_sound = 9;

    pub fn discard_sound(&self) -> &str {
        match self.discard_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_discard_sound(&mut self) {
        self.discard_sound = ::std::option::Option::None;
    }

    pub fn has_discard_sound(&self) -> bool {
        self.discard_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discard_sound(&mut self, v: ::std::string::String) {
        self.discard_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discard_sound(&mut self) -> &mut ::std::string::String {
        if self.discard_sound.is_none() {
            self.discard_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.discard_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_discard_sound(&mut self) -> ::std::string::String {
        self.discard_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reveal_sound = 10;

    pub fn reveal_sound(&self) -> &str {
        match self.reveal_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reveal_sound(&mut self) {
        self.reveal_sound = ::std::option::Option::None;
    }

    pub fn has_reveal_sound(&self) -> bool {
        self.reveal_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reveal_sound(&mut self, v: ::std::string::String) {
        self.reveal_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reveal_sound(&mut self) -> &mut ::std::string::String {
        if self.reveal_sound.is_none() {
            self.reveal_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reveal_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_reveal_sound(&mut self) -> ::std::string::String {
        self.reveal_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestTheme {
    const NAME: &'static str = "CMsgQuestTheme";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.give_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.complete_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fully_complete_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.notification_res = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.quest_item_res = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.in_game_tracker_res = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.give_sounds.push(is.read_message()?);
                },
                50 => {
                    self.complete_sounds.push(is.read_message()?);
                },
                58 => {
                    self.fully_complete_sounds.push(is.read_message()?);
                },
                66 => {
                    self.reward_sound = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.discard_sound = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.reveal_sound = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.notification_res.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.quest_item_res.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.in_game_tracker_res.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        for value in &self.give_sounds {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.complete_sounds {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fully_complete_sounds {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.reward_sound.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.discard_sound.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.reveal_sound.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.notification_res.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.quest_item_res.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.in_game_tracker_res.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.give_sounds {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.complete_sounds {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.fully_complete_sounds {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.reward_sound.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.discard_sound.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.reveal_sound.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestTheme {
        CMsgQuestTheme::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.notification_res = ::std::option::Option::None;
        self.quest_item_res = ::std::option::Option::None;
        self.in_game_tracker_res = ::std::option::Option::None;
        self.give_sounds.clear();
        self.complete_sounds.clear();
        self.fully_complete_sounds.clear();
        self.reward_sound = ::std::option::Option::None;
        self.discard_sound = ::std::option::Option::None;
        self.reveal_sound = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestTheme {
        static instance: CMsgQuestTheme = CMsgQuestTheme {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            notification_res: ::std::option::Option::None,
            quest_item_res: ::std::option::Option::None,
            in_game_tracker_res: ::std::option::Option::None,
            give_sounds: ::std::vec::Vec::new(),
            complete_sounds: ::std::vec::Vec::new(),
            fully_complete_sounds: ::std::vec::Vec::new(),
            reward_sound: ::std::option::Option::None,
            discard_sound: ::std::option::Option::None,
            reveal_sound: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgQuestTheme`
pub mod cmsg_quest_theme {
    // @@protoc_insertion_point(message:CMsgQuestTheme.WeightedString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WeightedString {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestTheme.WeightedString.string)
        pub string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgQuestTheme.WeightedString.weight)
        pub weight: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestTheme.WeightedString.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WeightedString {
        fn default() -> &'a WeightedString {
            <WeightedString as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WeightedString {
        pub fn new() -> WeightedString {
            ::std::default::Default::default()
        }

        // optional string string = 1;

        pub fn string(&self) -> &str {
            match self.string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string(&mut self) {
            self.string = ::std::option::Option::None;
        }

        pub fn has_string(&self) -> bool {
            self.string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string(&mut self, v: ::std::string::String) {
            self.string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string(&mut self) -> &mut ::std::string::String {
            if self.string.is_none() {
                self.string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string.as_mut().unwrap()
        }

        // Take field
        pub fn take_string(&mut self) -> ::std::string::String {
            self.string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 weight = 2;

        pub fn weight(&self) -> u32 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: u32) {
            self.weight = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WeightedString {
        const NAME: &'static str = "WeightedString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.string = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.weight = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.string.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.weight {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.string.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.weight {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WeightedString {
            WeightedString::new()
        }

        fn clear(&mut self) {
            self.string = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WeightedString {
            static instance: WeightedString = WeightedString {
                string: ::std::option::Option::None,
                weight: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgQuestTheme.WeightedStringSet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WeightedStringSet {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuestTheme.WeightedStringSet.weighted_strings)
        pub weighted_strings: ::std::vec::Vec<WeightedString>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuestTheme.WeightedStringSet.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WeightedStringSet {
        fn default() -> &'a WeightedStringSet {
            <WeightedStringSet as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WeightedStringSet {
        pub fn new() -> WeightedStringSet {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WeightedStringSet {
        const NAME: &'static str = "WeightedStringSet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.weighted_strings.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.weighted_strings {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.weighted_strings {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WeightedStringSet {
            WeightedStringSet::new()
        }

        fn clear(&mut self) {
            self.weighted_strings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WeightedStringSet {
            static instance: WeightedStringSet = WeightedStringSet {
                weighted_strings: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeCondition_NodeState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeCondition_NodeState {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_NodeState.bonus_objectives_required)
    pub bonus_objectives_required: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_NodeState.target_node_defid)
    pub target_node_defid: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefID>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeCondition_NodeState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition_NodeState {
    fn default() -> &'a CMsgQuestMapNodeCondition_NodeState {
        <CMsgQuestMapNodeCondition_NodeState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition_NodeState {
    pub fn new() -> CMsgQuestMapNodeCondition_NodeState {
        ::std::default::Default::default()
    }

    // optional uint32 bonus_objectives_required = 1;

    pub fn bonus_objectives_required(&self) -> u32 {
        self.bonus_objectives_required.unwrap_or(0u32)
    }

    pub fn clear_bonus_objectives_required(&mut self) {
        self.bonus_objectives_required = ::std::option::Option::None;
    }

    pub fn has_bonus_objectives_required(&self) -> bool {
        self.bonus_objectives_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_objectives_required(&mut self, v: u32) {
        self.bonus_objectives_required = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestMapNodeCondition_NodeState {
    const NAME: &'static str = "CMsgQuestMapNodeCondition_NodeState";

    fn is_initialized(&self) -> bool {
        if self.target_node_defid.is_none() {
            return false;
        }
        for v in &self.target_node_defid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bonus_objectives_required = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.target_node_defid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bonus_objectives_required {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_node_defid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.bonus_objectives_required {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_node_defid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeCondition_NodeState {
        CMsgQuestMapNodeCondition_NodeState::new()
    }

    fn clear(&mut self) {
        self.bonus_objectives_required = ::std::option::Option::None;
        self.target_node_defid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition_NodeState {
        static instance: CMsgQuestMapNodeCondition_NodeState = CMsgQuestMapNodeCondition_NodeState {
            bonus_objectives_required: ::std::option::Option::None,
            target_node_defid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeCondition_Logic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeCondition_Logic {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_Logic.operation)
    pub operation: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<LogicalOperation>>,
    // @@protoc_insertion_point(field:CMsgQuestMapNodeCondition_Logic.sub_conditions)
    pub sub_conditions: ::std::vec::Vec<CMsgQuestMapNodeCondition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeCondition_Logic.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition_Logic {
    fn default() -> &'a CMsgQuestMapNodeCondition_Logic {
        <CMsgQuestMapNodeCondition_Logic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition_Logic {
    pub fn new() -> CMsgQuestMapNodeCondition_Logic {
        ::std::default::Default::default()
    }

    // required .LogicalOperation operation = 1;

    pub fn operation(&self) -> LogicalOperation {
        match self.operation {
            Some(e) => e.enum_value_or(LogicalOperation::AND),
            None => LogicalOperation::AND,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: LogicalOperation) {
        self.operation = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestMapNodeCondition_Logic {
    const NAME: &'static str = "CMsgQuestMapNodeCondition_Logic";

    fn is_initialized(&self) -> bool {
        if self.operation.is_none() {
            return false;
        }
        for v in &self.sub_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.sub_conditions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.sub_conditions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.sub_conditions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeCondition_Logic {
        CMsgQuestMapNodeCondition_Logic::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.sub_conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition_Logic {
        static instance: CMsgQuestMapNodeCondition_Logic = CMsgQuestMapNodeCondition_Logic {
            operation: ::std::option::Option::None,
            sub_conditions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQuestMapNodeCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestMapNodeCondition {
    // message oneof groups
    pub operation: ::std::option::Option<cmsg_quest_map_node_condition::Operation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestMapNodeCondition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition {
    fn default() -> &'a CMsgQuestMapNodeCondition {
        <CMsgQuestMapNodeCondition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition {
    pub fn new() -> CMsgQuestMapNodeCondition {
        ::std::default::Default::default()
    }

    // optional .CMsgQuestMapNodeCondition_NodeState node_state = 1;

    pub fn node_state(&self) -> &CMsgQuestMapNodeCondition_NodeState {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(ref v)) => v,
            _ => <CMsgQuestMapNodeCondition_NodeState as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_node_state(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_node_state(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_node_state(&mut self, v: CMsgQuestMapNodeCondition_NodeState) {
        self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(v))
    }

    // Mutable pointer to the field.
    pub fn mut_node_state(&mut self) -> &mut CMsgQuestMapNodeCondition_NodeState {
        if let ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(CMsgQuestMapNodeCondition_NodeState::new()));
        }
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_node_state(&mut self) -> CMsgQuestMapNodeCondition_NodeState {
        if self.has_node_state() {
            match self.operation.take() {
                ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeCondition_NodeState::new()
        }
    }

    // optional .CMsgQuestMapNodeCondition_Logic logical = 2;

    pub fn logical(&self) -> &CMsgQuestMapNodeCondition_Logic {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(ref v)) => v,
            _ => <CMsgQuestMapNodeCondition_Logic as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_logical(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_logical(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logical(&mut self, v: CMsgQuestMapNodeCondition_Logic) {
        self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logical(&mut self) -> &mut CMsgQuestMapNodeCondition_Logic {
        if let ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(CMsgQuestMapNodeCondition_Logic::new()));
        }
        match self.operation {
            ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logical(&mut self) -> CMsgQuestMapNodeCondition_Logic {
        if self.has_logical() {
            match self.operation.take() {
                ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeCondition_Logic::new()
        }
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestMapNodeCondition {
    const NAME: &'static str = "CMsgQuestMapNodeCondition";

    fn is_initialized(&self) -> bool {
        if let Some(cmsg_quest_map_node_condition::Operation::NodeState(ref v)) = self.operation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(cmsg_quest_map_node_condition::Operation::Logical(ref v)) = self.operation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::NodeState(is.read_message()?));
                },
                18 => {
                    self.operation = ::std::option::Option::Some(cmsg_quest_map_node_condition::Operation::Logical(is.read_message()?));
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &cmsg_quest_map_node_condition::Operation::NodeState(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_quest_map_node_condition::Operation::Logical(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &cmsg_quest_map_node_condition::Operation::NodeState(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cmsg_quest_map_node_condition::Operation::Logical(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestMapNodeCondition {
        CMsgQuestMapNodeCondition::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition {
        static instance: CMsgQuestMapNodeCondition = CMsgQuestMapNodeCondition {
            operation: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgQuestMapNodeCondition`
pub mod cmsg_quest_map_node_condition {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgQuestMapNodeCondition.operation)
    pub enum Operation {
        // @@protoc_insertion_point(oneof_field:CMsgQuestMapNodeCondition.node_state)
        NodeState(super::CMsgQuestMapNodeCondition_NodeState),
        // @@protoc_insertion_point(oneof_field:CMsgQuestMapNodeCondition.logical)
        Logical(super::CMsgQuestMapNodeCondition_Logic),
    }

    impl ::steam_vent_proto_common::protobuf::Oneof for Operation {
    }

    impl Operation {
    }
}

// @@protoc_insertion_point(message:CMsgHeaderOnly)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeaderOnly {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeaderOnly.header)
    pub header: ::steam_vent_proto_common::protobuf::MessageField<CMsgProtoDefHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeaderOnly.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeaderOnly {
    fn default() -> &'a CMsgHeaderOnly {
        <CMsgHeaderOnly as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeaderOnly {
    pub fn new() -> CMsgHeaderOnly {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeaderOnly {
    const NAME: &'static str = "CMsgHeaderOnly";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeaderOnly {
        CMsgHeaderOnly::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeaderOnly {
        static instance: CMsgHeaderOnly = CMsgHeaderOnly {
            header: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LogicalOperation)
pub enum LogicalOperation {
    // @@protoc_insertion_point(enum_value:LogicalOperation.AND)
    AND = 0,
    // @@protoc_insertion_point(enum_value:LogicalOperation.OR)
    OR = 1,
    // @@protoc_insertion_point(enum_value:LogicalOperation.NOT)
    NOT = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for LogicalOperation {
    const NAME: &'static str = "LogicalOperation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogicalOperation> {
        match value {
            0 => ::std::option::Option::Some(LogicalOperation::AND),
            1 => ::std::option::Option::Some(LogicalOperation::OR),
            2 => ::std::option::Option::Some(LogicalOperation::NOT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LogicalOperation> {
        match str {
            "AND" => ::std::option::Option::Some(LogicalOperation::AND),
            "OR" => ::std::option::Option::Some(LogicalOperation::OR),
            "NOT" => ::std::option::Option::Some(LogicalOperation::NOT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LogicalOperation] = &[
        LogicalOperation::AND,
        LogicalOperation::OR,
        LogicalOperation::NOT,
    ];
}

impl ::std::default::Default for LogicalOperation {
    fn default() -> Self {
        LogicalOperation::AND
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EValueDefinitionSource)
pub enum EValueDefinitionSource {
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.REFERENCE_DEFINES)
    REFERENCE_DEFINES = 0,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.PARENT_DEFINES)
    PARENT_DEFINES = 1,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.THIS_DEFINES)
    THIS_DEFINES = 2,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.VARIABLE_DEFINES)
    VARIABLE_DEFINES = 3,
    // @@protoc_insertion_point(enum_value:EValueDefinitionSource.NOT_DEFINED)
    NOT_DEFINED = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EValueDefinitionSource {
    const NAME: &'static str = "EValueDefinitionSource";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EValueDefinitionSource> {
        match value {
            0 => ::std::option::Option::Some(EValueDefinitionSource::REFERENCE_DEFINES),
            1 => ::std::option::Option::Some(EValueDefinitionSource::PARENT_DEFINES),
            2 => ::std::option::Option::Some(EValueDefinitionSource::THIS_DEFINES),
            3 => ::std::option::Option::Some(EValueDefinitionSource::VARIABLE_DEFINES),
            4 => ::std::option::Option::Some(EValueDefinitionSource::NOT_DEFINED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EValueDefinitionSource> {
        match str {
            "REFERENCE_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::REFERENCE_DEFINES),
            "PARENT_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::PARENT_DEFINES),
            "THIS_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::THIS_DEFINES),
            "VARIABLE_DEFINES" => ::std::option::Option::Some(EValueDefinitionSource::VARIABLE_DEFINES),
            "NOT_DEFINED" => ::std::option::Option::Some(EValueDefinitionSource::NOT_DEFINED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EValueDefinitionSource] = &[
        EValueDefinitionSource::REFERENCE_DEFINES,
        EValueDefinitionSource::PARENT_DEFINES,
        EValueDefinitionSource::THIS_DEFINES,
        EValueDefinitionSource::VARIABLE_DEFINES,
        EValueDefinitionSource::NOT_DEFINED,
    ];
}

impl ::std::default::Default for EValueDefinitionSource {
    fn default() -> Self {
        EValueDefinitionSource::REFERENCE_DEFINES
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoDefTypes)
pub enum ProtoDefTypes {
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_NODE)
    DEF_TYPE_QUEST_MAP_NODE = 0,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_THEME)
    DEF_TYPE_QUEST_THEME = 2,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_REGION)
    DEF_TYPE_QUEST_MAP_REGION = 3,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST)
    DEF_TYPE_QUEST = 4,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_OBJECTIVE)
    DEF_TYPE_QUEST_OBJECTIVE = 5,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_VARIABLES)
    DEF_TYPE_PAINTKIT_VARIABLES = 6,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_OPERATION)
    DEF_TYPE_PAINTKIT_OPERATION = 7,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_ITEM_DEFINITION)
    DEF_TYPE_PAINTKIT_ITEM_DEFINITION = 8,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_PAINTKIT_DEFINITION)
    DEF_TYPE_PAINTKIT_DEFINITION = 9,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_HEADER_ONLY)
    DEF_TYPE_HEADER_ONLY = 10,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_STORE_ITEM)
    DEF_TYPE_QUEST_MAP_STORE_ITEM = 11,
    // @@protoc_insertion_point(enum_value:ProtoDefTypes.DEF_TYPE_QUEST_MAP_STAR_TYPE)
    DEF_TYPE_QUEST_MAP_STAR_TYPE = 12,
}

impl ::steam_vent_proto_common::protobuf::Enum for ProtoDefTypes {
    const NAME: &'static str = "ProtoDefTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoDefTypes> {
        match value {
            0 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE),
            2 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_THEME),
            3 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION),
            4 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST),
            5 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE),
            6 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES),
            7 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION),
            8 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION),
            9 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION),
            10 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_HEADER_ONLY),
            11 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM),
            12 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoDefTypes> {
        match str {
            "DEF_TYPE_QUEST_MAP_NODE" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE),
            "DEF_TYPE_QUEST_THEME" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_THEME),
            "DEF_TYPE_QUEST_MAP_REGION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION),
            "DEF_TYPE_QUEST" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST),
            "DEF_TYPE_QUEST_OBJECTIVE" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE),
            "DEF_TYPE_PAINTKIT_VARIABLES" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES),
            "DEF_TYPE_PAINTKIT_OPERATION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION),
            "DEF_TYPE_PAINTKIT_ITEM_DEFINITION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION),
            "DEF_TYPE_PAINTKIT_DEFINITION" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION),
            "DEF_TYPE_HEADER_ONLY" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_HEADER_ONLY),
            "DEF_TYPE_QUEST_MAP_STORE_ITEM" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM),
            "DEF_TYPE_QUEST_MAP_STAR_TYPE" => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoDefTypes] = &[
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE,
        ProtoDefTypes::DEF_TYPE_QUEST_THEME,
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION,
        ProtoDefTypes::DEF_TYPE_QUEST,
        ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION,
        ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION,
        ProtoDefTypes::DEF_TYPE_HEADER_ONLY,
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM,
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE,
    ];
}

impl ::std::default::Default for ProtoDefTypes {
    fn default() -> Self {
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EQuestPoints)
pub enum EQuestPoints {
    // @@protoc_insertion_point(enum_value:EQuestPoints.QUEST_POINTS_NOVICE)
    QUEST_POINTS_NOVICE = 0,
    // @@protoc_insertion_point(enum_value:EQuestPoints.QUEST_POINTS_ADVANCED)
    QUEST_POINTS_ADVANCED = 1,
    // @@protoc_insertion_point(enum_value:EQuestPoints.QUEST_POINTS_EXPERT)
    QUEST_POINTS_EXPERT = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EQuestPoints {
    const NAME: &'static str = "EQuestPoints";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EQuestPoints> {
        match value {
            0 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_NOVICE),
            1 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_ADVANCED),
            2 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_EXPERT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EQuestPoints> {
        match str {
            "QUEST_POINTS_NOVICE" => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_NOVICE),
            "QUEST_POINTS_ADVANCED" => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_ADVANCED),
            "QUEST_POINTS_EXPERT" => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_EXPERT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EQuestPoints] = &[
        EQuestPoints::QUEST_POINTS_NOVICE,
        EQuestPoints::QUEST_POINTS_ADVANCED,
        EQuestPoints::QUEST_POINTS_EXPERT,
    ];
}

impl ::std::default::Default for EQuestPoints {
    fn default() -> Self {
        EQuestPoints::QUEST_POINTS_NOVICE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EVarFieldType)
pub enum EVarFieldType {
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_INVALID)
    VAR_TYPE_INVALID = 1,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_FLOAT)
    VAR_TYPE_FLOAT = 2,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_DOUBLE)
    VAR_TYPE_DOUBLE = 3,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_UINT32)
    VAR_TYPE_UINT32 = 4,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_UINT64)
    VAR_TYPE_UINT64 = 5,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_SINT32)
    VAR_TYPE_SINT32 = 6,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_SINT64)
    VAR_TYPE_SINT64 = 7,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_BOOL)
    VAR_TYPE_BOOL = 8,
    // @@protoc_insertion_point(enum_value:EVarFieldType.VAR_TYPE_STRING)
    VAR_TYPE_STRING = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for EVarFieldType {
    const NAME: &'static str = "EVarFieldType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVarFieldType> {
        match value {
            1 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_INVALID),
            2 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_FLOAT),
            3 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_DOUBLE),
            4 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT32),
            5 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT64),
            6 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT32),
            7 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT64),
            8 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_BOOL),
            9 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_STRING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EVarFieldType> {
        match str {
            "VAR_TYPE_INVALID" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_INVALID),
            "VAR_TYPE_FLOAT" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_FLOAT),
            "VAR_TYPE_DOUBLE" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_DOUBLE),
            "VAR_TYPE_UINT32" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT32),
            "VAR_TYPE_UINT64" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT64),
            "VAR_TYPE_SINT32" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT32),
            "VAR_TYPE_SINT64" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT64),
            "VAR_TYPE_BOOL" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_BOOL),
            "VAR_TYPE_STRING" => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_STRING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EVarFieldType] = &[
        EVarFieldType::VAR_TYPE_INVALID,
        EVarFieldType::VAR_TYPE_FLOAT,
        EVarFieldType::VAR_TYPE_DOUBLE,
        EVarFieldType::VAR_TYPE_UINT32,
        EVarFieldType::VAR_TYPE_UINT64,
        EVarFieldType::VAR_TYPE_SINT32,
        EVarFieldType::VAR_TYPE_SINT64,
        EVarFieldType::VAR_TYPE_BOOL,
        EVarFieldType::VAR_TYPE_STRING,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EVarFieldType {
    fn default() -> Self {
        EVarFieldType::VAR_TYPE_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ENodeCashReward)
pub enum ENodeCashReward {
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_NONE)
    CASH_REWARD_NONE = 1,
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_SMALL)
    CASH_REWARD_SMALL = 2,
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_MEDIUM)
    CASH_REWARD_MEDIUM = 3,
    // @@protoc_insertion_point(enum_value:ENodeCashReward.CASH_REWARD_LARGE)
    CASH_REWARD_LARGE = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ENodeCashReward {
    const NAME: &'static str = "ENodeCashReward";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENodeCashReward> {
        match value {
            1 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_NONE),
            2 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_SMALL),
            3 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_MEDIUM),
            4 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_LARGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ENodeCashReward> {
        match str {
            "CASH_REWARD_NONE" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_NONE),
            "CASH_REWARD_SMALL" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_SMALL),
            "CASH_REWARD_MEDIUM" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_MEDIUM),
            "CASH_REWARD_LARGE" => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_LARGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ENodeCashReward] = &[
        ENodeCashReward::CASH_REWARD_NONE,
        ENodeCashReward::CASH_REWARD_SMALL,
        ENodeCashReward::CASH_REWARD_MEDIUM,
        ENodeCashReward::CASH_REWARD_LARGE,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ENodeCashReward {
    fn default() -> Self {
        ENodeCashReward::CASH_REWARD_NONE
    }
}


// Extension generation with lite runtime is not supported


const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

impl ::steam_vent_proto_common::RpcMessage for CMsgFieldID {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUniversalFieldID {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgVariableDefinition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProtoDefHeader {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgValidTypes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProtoDefID {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestObjectiveDef {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestDef {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestMapStoreItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestMapRegionDef {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgVarField {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestMapStarType {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestMapNodeDef {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Variables {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Operation_TextureStage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Operation_CombineStage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Operation_SelectStage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Operation_Sticker {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Operation_StickerStage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_OperationStage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_OperationNode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Operation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_ItemDefinition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPaintKit_Definition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestTheme {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestMapNodeCondition_NodeState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestMapNodeCondition_Logic {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestMapNodeCondition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeaderOnly {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
